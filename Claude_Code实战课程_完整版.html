
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Claude Code 实战课程</title>
        <style>
            @page {
                size: A4;
                margin: 2cm;
            }

            @media print {
                body {
                    font-size: 11pt;
                }
                
                h1 {
                    page-break-after: avoid;
                }
                
                h2, h3, h4 {
                    page-break-after: avoid;
                }
                
                pre, blockquote {
                    page-break-inside: avoid;
                }
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", sans-serif;
                font-size: 11pt;
                line-height: 1.8;
                color: #333;
                max-width: 900px;
                margin: 0 auto;
                padding: 40px 20px;
                background-color: #fff;
            }

            h1 {
                font-size: 32px;
                font-weight: bold;
                color: #2c3e50;
                margin-top: 50px;
                margin-bottom: 25px;
                border-bottom: 3px solid #3498db;
                padding-bottom: 15px;
            }

            h2 {
                font-size: 24px;
                font-weight: bold;
                color: #34495e;
                margin-top: 40px;
                margin-bottom: 20px;
                border-bottom: 2px solid #ecf0f1;
                padding-bottom: 10px;
            }

            h3 {
                font-size: 20px;
                font-weight: bold;
                color: #555;
                margin-top: 30px;
                margin-bottom: 15px;
            }

            h4 {
                font-size: 16px;
                font-weight: bold;
                color: #666;
                margin-top: 25px;
                margin-bottom: 12px;
            }

            p {
                margin-bottom: 12px;
                text-align: justify;
                line-height: 1.8;
            }

            blockquote {
                margin: 20px 0;
                padding: 15px 25px;
                background-color: #f8f9fa;
                border-left: 5px solid #3498db;
                color: #555;
                font-style: italic;
            }

            code {
                font-family: "Monaco", "Menlo", "Consolas", "Courier New", monospace;
                background-color: #f4f4f4;
                padding: 3px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                color: #e74c3c;
            }

            pre {
                background-color: #2d2d2d;
                color: #f8f8f2;
                padding: 20px;
                border-radius: 8px;
                overflow-x: auto;
                margin: 20px 0;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }

            pre code {
                background-color: transparent;
                padding: 0;
                color: #f8f8f2;
                font-size: 0.9em;
            }

            ul, ol {
                margin: 12px 0;
                padding-left: 40px;
            }

            li {
                margin-bottom: 8px;
                line-height: 1.6;
            }

            a {
                color: #3498db;
                text-decoration: none;
                border-bottom: 1px dotted #3498db;
                transition: all 0.2s ease;
            }

            a:hover {
                color: #2980b9;
                border-bottom-style: solid;
            }

            img {
                max-width: 100%;
                height: auto;
                display: block;
                margin: 25px auto;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }

            hr {
                border: none;
                border-top: 2px solid #ecf0f1;
                margin: 40px 0;
            }

            strong {
                color: #2c3e50;
                font-weight: 600;
            }

            em {
                font-style: italic;
                color: #555;
            }

            table {
                border-collapse: collapse;
                width: 100%;
                margin: 20px 0;
                font-size: 10pt;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }

            th, td {
                border: 1px solid #ddd;
                padding: 12px;
                text-align: left;
            }

            th {
                background-color: #3498db;
                color: white;
                font-weight: bold;
            }

            tr:nth-child(even) {
                background-color: #f8f9fa;
            }

            tr:hover {
                background-color: #e9ecef;
            }
        </style>
    </head>
    <body>
        <h1 id="claude-code-实战课程中文翻译">Claude Code 实战课程（中文翻译）</h1>

<blockquote>
  <p><strong>课程说明</strong>：本文档由自动化脚本抓取生成</p>
</blockquote>

<blockquote>
  <p><strong>原课程链接</strong>：https://anthropic.skilljar.com/claude-code-in-action/303233</p>
</blockquote>

<blockquote>
  <p><strong>官方网站</strong>：https://cholf5.com/claude-code-in-action/index.html</p>
</blockquote>

<hr />

<h2 id="课程目录">课程目录</h2>

<ol start="01">
<li><a href="#章节-01">引言</a></li>
<li><a href="#章节-02">什么是编码助手？</a></li>
<li><a href="#章节-03">Claude Code 实战</a></li>
<li><a href="#章节-04">Claude Code 安装与配置</a></li>
<li><a href="#章节-05">项目准备</a></li>
<li><a href="#章节-06">添加上下文</a></li>
<li><a href="#章节-07">进行修改</a></li>
<li><a href="#章节-08">课程满意度调查</a></li>
<li><a href="#章节-09">控制上下文</a></li>
<li><a href="#章节-10">自定义命令</a></li>
<li><a href="#章节-11">Claude Code 的 MCP 服务器</a></li>
<li><a href="#章节-12">GitHub 集成</a></li>
<li><a href="#章节-13">认识 Hooks</a></li>
<li><a href="#章节-14">定义 Hooks</a></li>
<li><a href="#章节-15">实现一个 Hook</a></li>
<li><a href="#章节-16">Hooks 常见坑点</a></li>
<li><a href="#章节-17">实用的 Hooks</a></li>
<li><a href="#章节-18">另一个实用 Hook</a></li>
<li><a href="#章节-19">Claude Code SDK</a></li>
<li><a href="#章节-20">Claude Code 测验</a></li>
<li><a href="#章节-21">总结与下一步</a></li>
</ol>

<hr />

<p><a id="章节-1"></a></p>

<h1 id="引言">引言</h1>

<p>本节为课程引言视频。</p>

<p>当前页面不包含文字讲义，请在原课程页面观看视频内容。</p>

<hr />

<p><a id="章节-2"></a></p>

<h1 id="什么是编码助手">什么是编码助手？</h1>

<p>编码助手不仅仅是写代码的工具——它是一个使用语言模型来处理复杂编程任务的系统。了解它们在幕后
            如何运作，能帮助你理解什么才是真正强大的编码伙伴。</p>

<h2 id="编码助手如何工作">编码助手如何工作</h2>

<p>当你给编码助手一个任务（例如根据报错修复 Bug），它会按类似人类开发者的方式来推进：</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1750967940%2F002_-_What_is_a_Coding_Assistant%3F_02.1750967940100.png" alt="编码助手的工作流程" /></p>

<ul>
<li><strong>收集上下文</strong>：理解错误指向什么、哪些文件受影响、哪些文件相关</li>
<li><strong>制定计划</strong>：决定如何解决问题，例如修改代码并运行测试验证</li>
<li><strong>采取行动</strong>：真正去修改文件、运行命令并完成修复</li>
</ul>

<p>关键洞见在于：第一步和最后一步都需要与外部世界交互——读文件、查文档、运行命令、编辑代码等。</p>

<h2 id="工具使用的挑战">工具使用的挑战</h2>

<p>语言模型本身只能处理文本、输出文本，无法真正读取文件或运行命令。如果你直接让一个独立语言模型去
            读文件，它会告诉你自己没有这个能力。</p>

<p>那编码助手如何解决？它们使用一种巧妙的系统，叫作“工具使用”。</p>

<h2 id="工具使用如何运作">工具使用如何运作</h2>

<p>当你向编码助手发送请求时，它会自动在消息中加上一些指令，教模型如何请求动作。比如它可能加上：
            “如果你想读文件，请回复 ‘ReadFile: 文件名’”。</p>

<p>完整流程如下：</p>

<ul>
<li>你提问：“main.go 文件里写了什么代码？”</li>
<li>编码助手为你的请求添加工具指令</li>
<li>语言模型回应：“ReadFile: main.go”</li>
<li>编码助手读取真实文件内容并回传给模型</li>
<li>语言模型基于文件内容给出最终答案</li>
</ul>

<p>这套机制让语言模型“看起来”能够读文件、写代码、运行命令——实际上它只是生成了格式化的文本响应。</p>

<h2 id="为什么-claude-的工具使用很关键">为什么 Claude 的工具使用很关键</h2>

<p>不是所有语言模型都擅长使用工具。Claude 系列模型（Opus、Sonnet、Haiku）在理解工具、调用工具方面
            尤其强。</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1750967942%2F002_-_What_is_a_Coding_Assistant%3F_14.1750967942536.png" alt="Claude 工具使用优势" /></p>

<p>强工具使用带来的好处包括：</p>

<h2 id="强工具使用的收益">强工具使用的收益</h2>

<ul>
<li><strong>更难的任务也能完成</strong>：Claude 能组合多种工具，甚至使用从未见过的新工具</li>
<li><strong>平台可扩展</strong>：你可以轻松为 Claude Code 增加新工具，Claude 会自适应你的流程</li>
<li><strong>更好的安全性</strong>：无需索引代码库即可导航，避免将整个代码库发送到外部服务器</li>
</ul>

<h2 id="要点回顾">要点回顾</h2>

<p>理解编码助手的关键在于：</p>

<ul>
<li>编码助手通过语言模型完成任务</li>
<li>语言模型需要工具才能处理真实世界的编程问题</li>
<li>不同模型的工具使用能力差异很大</li>
<li>Claude 的工具使用能力提升了安全性、可定制性与长期可用性</li>
</ul>

<p>正是这种工具使用能力，将一个只会生成文本的模型，转变成能读文件、理解代码库并实际修改项目的强大
            编码助手。</p>

<hr />

<p><a id="章节-3"></a></p>

<h1 id="claude-code-实战">Claude Code 实战</h1>

<p>Claude Code 内置了一整套开发工具，涵盖读取文件、编写代码、运行命令、管理目录等常见任务。真正让
            Claude Code 强大的是它能智能地组合这些工具，处理复杂的多步骤问题。</p>

<p>本节主要通过视频演示这些能力的实际使用方式。</p>

<hr />

<p><a id="章节-4"></a></p>

<h1 id="claude-code-安装与配置">Claude Code 安装与配置</h1>

<p>准备开始在本地安装 Claude Code！</p>

<p>完整的安装说明请参考：
            https://code.claude.com/docs/en/quickstart</p>

<p>简要步骤如下：</p>

<ul>
<li>安装 Claude Code</li>
</ul>

<p>macOS（Homebrew）：brew install --cask claude-code
macOS / Linux / WSL：curl -fsSL https://claude.ai/install.sh | bash</p>

<pre><code>              Windows CMD：
              curl -fsSL https://claude.ai/install.cmd -o install.cmd &amp;&amp; install.cmd &amp;&amp; del install.cmd
</code></pre>

<p>- 安装完成后，在终端运行 claude。首次运行会提示你进行认证。</p>

<p>如果你使用 AWS Bedrock 或 Google Cloud Vertex，还需要额外配置：</p>

<ul>
<li>AWS Bedrock 说明：
https://code.claude.com/docs/en/amazon-bedrock</li>
<li>Google Cloud Vertex 说明：
https://code.claude.com/docs/en/google-vertex-ai</li>
</ul>

<hr />

<p><a id="章节-5"></a></p>

<h1 id="项目准备">项目准备</h1>

<p>有一个可以操作的项目，会让你在 Claude Code 中练习时更有意思。</p>

<p>我准备了一个小项目供你探索，它就是前面视频里演示的 UI 生成应用。注意：你不一定需要运行这个项目，如果你愿意，也可以用自己的代码库跟随课程。</p>

<h2 id="准备步骤">准备步骤</h2>

<p>该项目需要一些基础设置：</p>

<ul>
<li>确保本地安装了 Node.js。安装说明：
https://nodejs.org/en/download</li>
<li>下载本节附带的 uigen.zip 并解压</li>
<li>在项目目录运行 npm run setup，安装依赖并初始化本地 SQLite 数据库</li>
<li><p><strong>可选：</strong>该项目使用 Anthropic API 调用 Claude 生成 UI 组件。
          如果你想完整体验应用，需要提供 API Key（不提供也能生成静态假代码）。</p>

<pre><code>          在
          https://console.anthropic.com/
          获取 API Key
</code></pre></li>
</ul>

<p>将 API Key 写入 .env 文件
- 运行 npm run dev 启动项目</p>

<hr />

<p><a id="章节-6"></a></p>

<h1 id="添加上下文">添加上下文</h1>

<p>在用 Claude 处理编程项目时，上下文管理非常关键。你的项目可能有几十甚至上百个文件，但 Claude
            只需要与任务相关的部分。过多无关上下文反而会降低 Claude 的表现，因此学会引导它定位关键文件与文档非常重要。</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1750967940%2F004_-_Adding_Context_02.1750967940092.png" alt="上下文管理示意" /></p>

<h2 id="init-命令">/init 命令</h2>

<p>当你在新项目里第一次启动 Claude 时，运行 /init 命令。它会分析整个代码库并理解：</p>

<ul>
<li>项目目标与架构</li>
<li>关键命令与核心文件</li>
<li>代码风格与模式</li>
</ul>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1750967941%2F004_-_Adding_Context_05.1750967940882.png" alt="init 输出" /></p>

<p>分析完成后，Claude 会生成一份摘要并写入 CLAUDE.md。当 Claude 询问是否允许写入时，
            你可以按 Enter 逐次确认，或按 Shift+Tab 让 Claude 在本次会话中自由写文件。</p>

<h2 id="claudemd-文件">CLAUDE.md 文件</h2>

<p>CLAUDE.md 有两个主要作用：</p>

<ul>
<li>引导 Claude 理解你的代码库：重要命令、架构、代码风格</li>
<li>允许你给 Claude 添加特定或自定义指令</li>
</ul>

<p>该文件会自动包含在每一次请求中，相当于项目级的持久系统提示词。</p>

<h2 id="claudemd-的位置">CLAUDE.md 的位置</h2>

<p>Claude 识别以下三处常见位置的 CLAUDE.md：</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1750967941%2F004_-_Adding_Context_09.1750967941793.png" alt="CLAUDE.md 位置" /></p>

<ul>
<li><strong>CLAUDE.md</strong>：由 /init 生成，提交到仓库，与团队共享</li>
<li><strong>CLAUDE.local.md</strong>：个人专用，不与团队共享</li>
<li><strong>~/.claude/CLAUDE.md</strong>：全局文件，适用于本机所有项目</li>
</ul>

<h2 id="添加自定义指令">添加自定义指令</h2>

<p>你可以在 CLAUDE.md 中添加指令来调整 Claude 的行为。</p>

<p>使用 # 命令进入“记忆模式”，例如：</p>

<pre><code># Use comments sparingly. Only comment complex code.
</code></pre>

<p>Claude 会自动将这条指令合并进 CLAUDE.md。</p>

<h2 id="使用-提及文件">使用 @ 提及文件</h2>

<p>当你希望 Claude 查看某个文件时，可以用 @ 加上路径。这样会自动把该文件内容加入请求。</p>

<p>例如：</p>

<pre><code>How does the auth system work? @auth
</code></pre>

<p>Claude 会列出相关文件供你选择，然后把选中的文件加入对话。</p>

<h2 id="在-claudemd-中引用文件">在 CLAUDE.md 中引用文件</h2>

<p>你也可以在 CLAUDE.md 里用 @ 直接引用文件。</p>

<p>比如数据库 schema 文件：</p>

<pre><code>The database schema is defined in the @prisma/schema.prisma file. Reference it anytime you need to understand the structure of data stored in the database.
</code></pre>

<p>这样一来，每次请求都会自动包含该文件内容，Claude 就不需要反复搜索与读取。</p>

<hr />

<p><a id="章节-7"></a></p>

<h1 id="进行修改">进行修改</h1>

<p>在开发环境中使用 Claude 时，你经常需要对现有项目进行修改。本节介绍了一些实用技巧：包括用截图进行
            精准沟通，以及利用 Claude 的高级推理能力提升修改质量。</p>

<h2 id="用截图进行精准沟通">用截图进行精准沟通</h2>

<p>截图是与 Claude 沟通 UI 修改需求最有效的方式之一。想修改界面某个细节时，截图能让 Claude 准确理解
            你指的具体区域。</p>

<p>将截图粘贴到 Claude 中，请使用 Ctrl+V（macOS 不是 Cmd+V）。粘贴后，
            你就可以让 Claude 针对这部分进行修改。</p>

<h2 id="规划模式planning-mode">规划模式（Planning Mode）</h2>

<p>当任务比较复杂、需要在代码库中大量探索时，可以启用规划模式。它会让 Claude 先深入浏览项目，再提出
            实施方案。</p>

<p>按 Shift + Tab 两次即可启用（若已开启自动接受编辑，按一次即可）。在该模式中，Claude 会：</p>

<ul>
<li>阅读更多项目文件</li>
<li>给出详细的实施计划</li>
<li>明确说明将要做的具体操作</li>
<li>在执行前等待你的批准</li>
</ul>

<p>这样你可以先审阅计划，如果遗漏重要点或方向不对，可以及时引导。</p>

<h2 id="思考模式thinking-modes">思考模式（Thinking Modes）</h2>

<p>Claude 提供多个“思考”模式，让它在复杂问题上投入更多推理资源：</p>

<ul>
<li>Think：基础推理</li>
<li>Think more：扩展推理</li>
<li>Think a lot：深入推理</li>
<li>Think longer：更长时间推理</li>
<li>Ultrathink：最高强度推理</li>
</ul>

<p>每个模式都会分配更多 token，用于更深层的分析与推理。</p>

<h2 id="何时用规划模式-vs-思考模式">何时用规划模式 vs 思考模式</h2>

<p>这两者针对不同类型的复杂度：</p>

<p>规划模式适合：</p>

<ul>
<li>需要广泛理解代码库的任务</li>
<li>多步骤实施</li>
<li>涉及多个文件或组件的改动</li>
</ul>

<p>思考模式适合：</p>

<ul>
<li>复杂逻辑问题</li>
<li>疑难 Bug 排查</li>
<li>算法或推理挑战</li>
</ul>

<p>如果一个任务既需要“广度”又需要“深度”，可以同时启用两种模式。但需要注意，它们都会消耗更多 token，
            因此会带来成本。</p>

<hr />

<p><a id="章节-8"></a></p>

<h1 id="课程满意度调查">课程满意度调查</h1>

<p>此页面为在线满意度调查，需要在原课程平台中填写。</p>

<p>静态版本无法展示交互问卷，请点击原文链接完成调查。</p>

<hr />

<p><a id="章节-9"></a></p>

<h1 id="控制上下文">控制上下文</h1>

<p>处理复杂任务时，你经常需要引导对话保持聚焦。下面这些技巧可以帮助你控制对话流，避免 Claude 走偏。</p>

<h2 id="用-esc-中断-claude">用 Esc 中断 Claude</h2>

<p>当 Claude 开始偏离方向或一次性处理过多任务时，你可以按 Esc 中断它的响应，随后重新明确目标。</p>

<p>例如你让 Claude 为多个函数写测试，它可能开始规划整套测试体系。此时按 Esc，中断后让它先写一个函数的测试。</p>

<h2 id="esc-记忆的组合">Esc + 记忆的组合</h2>

<p>Esc 的一个强大用途是修复重复性错误：</p>

<ul>
<li>按 Esc 停止当前回复</li>
<li>用 # 添加一条记忆（正确的做法）</li>
<li>继续对话，让 Claude 按新记忆执行</li>
</ul>

<p>这样可以避免 Claude 在未来对话中重复同样的错误。</p>

<h2 id="回退对话">回退对话</h2>

<p>长对话容易积累大量无关上下文。例如排错过程可能对下一任务无用。此时可以按 Esc 两次“回退对话”：</p>

<ul>
<li>保留有价值的上下文（例如对代码库的理解）</li>
<li>删除无用或干扰性的对话内容</li>
<li>让 Claude 专注于当前任务</li>
</ul>

<h2 id="上下文管理命令">上下文管理命令</h2>

<p>Claude 提供了几个专门管理上下文的命令：</p>

<h3 id="compact">/compact</h3>

<p>/compact 会总结整个对话并保留关键要点。适用于：</p>

<ul>
<li>Claude 已学习到项目的重要信息</li>
<li>你要继续相关任务但希望对话更短</li>
<li>对话变长但仍有价值信息需要保留</li>
</ul>

<h3 id="clear">/clear</h3>

<p>/clear 会清空对话上下文，适用于：</p>

<ul>
<li>切换到完全不相关的新任务</li>
<li>旧上下文可能干扰新任务</li>
<li>需要彻底重来</li>
</ul>

<h2 id="何时使用这些技巧">何时使用这些技巧</h2>

<p>这些控制技巧特别适用于：</p>

<ul>
<li>长对话导致上下文杂乱</li>
<li>任务切换时担心上下文干扰</li>
<li>Claude 重复犯错</li>
<li>复杂项目需要保持聚焦</li>
</ul>

<p>灵活使用 Esc、中断回退、/compact 与 /clear，可以让 Claude 在开发流程中保持高效
            与专注。这些不是小技巧，而是高质量 AI 开发会话的基础能力。</p>

<hr />

<p><a id="章节-10"></a></p>

<h1 id="自定义命令">自定义命令</h1>

<p>Claude Code 内置了一批以斜杠开头的命令，你也可以创建自己的命令，把常见流程自动化。</p>

<h2 id="创建自定义命令">创建自定义命令</h2>

<p>在项目中准备以下目录结构：</p>

<ul>
<li>找到项目中的 .claude 目录</li>
<li>在其中创建 commands 目录</li>
<li>创建一个以命令名命名的 Markdown 文件（如 audit.md）</li>
</ul>

<p>文件名就是命令名，因此 audit.md 会生成 /audit 命令。</p>

<h2 id="示例审计依赖的命令">示例：审计依赖的命令</h2>

<p>一个实用的命令是检查依赖安全问题：</p>

<ul>
<li>运行 npm audit 找出漏洞</li>
<li>运行 npm audit fix 自动修复</li>
<li>运行测试验证修复不破坏功能</li>
</ul>

<p>创建命令文件后，需要重启 Claude Code 才能识别新命令。</p>

<h2 id="带参数的命令">带参数的命令</h2>

<p>自定义命令可以使用 $ARGUMENTS 占位符接收参数，从而更灵活。</p>

<p>例如 write_tests.md：</p>

<pre><code>Write comprehensive tests for: $ARGUMENTS

Testing conventions:
* Use Vitests with React Testing Library
* Place test files in a __tests__ directory in the same folder as the source file
* Name test files as [filename].test.ts(x)
* Use @/ prefix for imports

Coverage:
* Test happy paths
* Test edge cases
* Test error states
</code></pre>

<p>调用方式：</p>

<p>/write_tests the use-auth.ts file in the hooks directory</p>

<p>参数可以是任意文字说明，不一定是文件路径。</p>

<h2 id="关键收益">关键收益</h2>

<ul>
<li><strong>自动化</strong>：把重复流程变成一个命令</li>
<li><strong>一致性</strong>：确保每次执行遵循相同步骤</li>
<li><strong>上下文</strong>：为 Claude 提供固定的项目约定</li>
<li><strong>灵活性</strong>：通过参数适配不同场景</li>
</ul>

<p>自定义命令非常适合项目内的固定流程，例如测试、部署、代码生成等。</p>

<hr />

<p><a id="章节-11"></a></p>

<h1 id="claude-code-的-mcp-服务器">Claude Code 的 MCP 服务器</h1>

<p>你可以通过 MCP（Model Context Protocol）服务器扩展 Claude Code 的能力。MCP 服务器可以在本地或远程运行，
            为 Claude 提供原本没有的新工具与新能力。</p>

<p>最常用的 MCP 服务器之一是 Playwright，它能让 Claude 控制浏览器，为 Web 开发流程带来巨大提升。</p>

<h2 id="安装-playwright-mcp-服务器">安装 Playwright MCP 服务器</h2>

<p>在终端运行以下命令（不要在 Claude Code 里运行）：</p>

<pre><code>claude mcp add playwright npx @playwright/mcp@latest
</code></pre>

<p>该命令会：</p>

<ul>
<li>把 MCP 服务器命名为 playwright</li>
<li>指定本地启动服务器的命令</li>
</ul>

<h2 id="权限管理">权限管理</h2>

<p>默认情况下 Claude 每次使用 MCP 工具都会请求权限。如果你不想频繁确认，可以在设置中预先允许：</p>

<pre><code>{
  "permissions": {
    "allow": ["mcp__playwright"],
    "deny": []
  }
}
</code></pre>

<p>注意 mcp__playwright 中有双下划线。这样 Claude 便可直接使用 Playwright 工具。</p>

<h2 id="实战示例提升组件生成质量">实战示例：提升组件生成质量</h2>

<p>Playwright 可以让 Claude 自动化以下流程：</p>

<ul>
<li>打开浏览器并进入你的应用</li>
<li>生成测试组件</li>
<li>分析视觉样式与代码质量</li>
<li>更新生成提示词</li>
<li>再次测试新提示词</li>
</ul>

<p>例如：</p>

<blockquote>
  <p>“访问 localhost:3000，生成一个基础组件，检查样式，然后更新
              @src/lib/prompts/generation.tsx 里的提示词，让后续组件更好。”</p>
</blockquote>

<p>Claude 会用浏览器工具观察真实视觉结果，再改写提示词，让生成的设计更有创意与差异化。</p>

<h2 id="收益与效果">收益与效果</h2>

<p>实践中，这种流程能显著提升生成质量，例如：</p>

<ul>
<li>从“紫蓝渐变 + 标准 Tailwind 结构”升级为更丰富的配色</li>
<li>暖色夕阳渐变（橙 → 粉 → 紫）</li>
<li>海洋深度主题（青绿 → 翡翠 → 青蓝）</li>
<li>非对称布局与重叠元素</li>
<li>更具创造性的留白与结构</li>
</ul>

<p>核心优势是：Claude 能看到真实视觉输出，而不是只盯着代码。</p>

<h2 id="探索更多-mcp-服务器">探索更多 MCP 服务器</h2>

<p>Playwright 只是其中一个例子。MCP 生态还包括：</p>

<ul>
<li>数据库交互</li>
<li>API 测试与监控</li>
<li>文件系统操作</li>
<li>云服务集成</li>
<li>开发工具自动化</li>
</ul>

<p>选择符合你需求的 MCP 服务器，可以让 Claude 从“代码助手”升级为“全流程开发伙伴”。</p>

<hr />

<p><a id="章节-12"></a></p>

<h1 id="github-集成">GitHub 集成</h1>

<p>Claude Code 提供官方 GitHub 集成，让 Claude 在 GitHub Actions 中运行。主要有两个流程：在 Issue/PR 中
            @Claude，以及自动 PR Review。</p>

<h2 id="安装与配置">安装与配置</h2>

<p>在 Claude 中运行 /install-github-app，它会引导你完成：</p>

<ul>
<li>安装 Claude Code GitHub App</li>
<li>添加 API Key</li>
<li>自动生成包含工作流文件的 PR</li>
</ul>

<p>合并该 PR 后，.github/workflows 中会出现两个 Actions。</p>

<h2 id="默认的-github-actions">默认的 GitHub Actions</h2>

<h3 id="mention-action">Mention Action</h3>

<p>在 Issue 或 PR 中使用 @claude，Claude 将：</p>

<ul>
<li>分析任务并给出计划</li>
<li>以完整权限执行任务</li>
<li>在 Issue/PR 中回复结果</li>
</ul>

<h3 id="pull-request-action">Pull Request Action</h3>

<p>每次创建 PR 时，Claude 会自动：</p>

<ul>
<li>审查改动</li>
<li>分析影响范围</li>
<li>发布详细评审报告</li>
</ul>

<h2 id="自定义工作流">自定义工作流</h2>

<p>合并初始 PR 后，你可以按项目需要调整工作流。</p>

<h3 id="添加项目准备步骤">添加项目准备步骤</h3>

<pre><code>- name: Project Setup
  run: |
    npm run setup
    npm run dev:daemon
</code></pre>

<h3 id="添加自定义指令-2">添加自定义指令</h3>

<pre><code>custom_instructions: |
  The project is already set up with all dependencies installed.
  The server is already running at localhost:3000. Logs from it
  are being written to logs.txt. If needed, you can query the
  db with the 'sqlite3' cli. If needed, use the mcp__playwright
  set of tools to launch a browser and interact with the app.
</code></pre>

<h3 id="mcp-服务器配置">MCP 服务器配置</h3>

<pre><code>mcp_config: |
  {
    "mcpServers": {
      "playwright": {
        "command": "npx",
        "args": [
          "@playwright/mcp@latest",
          "--allowed-origins",
          "localhost:3000;cdn.tailwindcss.com;esm.sh"
        ]
      }
    }
  }
</code></pre>

<h2 id="工具权限">工具权限</h2>

<p>在 GitHub Actions 中必须明确列出允许的工具（尤其是 MCP 工具）：</p>

<pre><code>allowed_tools: "Bash(npm:*),Bash(sqlite3:*),mcp__playwright__browser_snapshot,mcp__playwright__browser_click,..."

</code></pre>

<p>不同于本地环境，Actions 中没有快捷许可，必须逐项列出。</p>

<h2 id="最佳实践">最佳实践</h2>

<ul>
<li>从默认工作流开始，逐步定制</li>
<li>用自定义指令补充项目上下文</li>
<li>使用 MCP 时务必写清工具权限</li>
<li>先用简单任务验证工作流，再升级复杂任务</li>
</ul>

<p>GitHub 集成让 Claude 从“开发助手”升级为团队中的自动化成员，可直接在 GitHub 流程里完成任务与评审。</p>

<hr />

<p><a id="章节-13"></a></p>

<h1 id="认识-hooks">认识 Hooks</h1>

<p>Hooks 允许你在 Claude 使用工具前后运行自定义命令。它非常适合做自动化，比如在编辑后自动格式化代码、
            运行测试，或阻止访问特定文件。</p>

<h2 id="hooks-如何工作">Hooks 如何工作</h2>

<p>在常规流程中，Claude 接收你的问题，决定使用工具，然后 Claude Code 执行工具并把结果返回给模型。
            Hooks 会插入到这个流程中，让你在工具执行前或后运行自己的逻辑。</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618158%2F010_-_Introducing_Hooks_06.1752618158162.png" alt="Hooks 工作流程" /></p>

<p>Hooks 分为两类：</p>

<ul>
<li><strong>PreToolUse</strong>：在工具执行前触发</li>
<li><strong>PostToolUse</strong>：在工具执行后触发</li>
</ul>

<h2 id="hooks-配置位置">Hooks 配置位置</h2>

<p>Hooks 写在 Claude 的设置文件中，可放在：</p>

<ul>
<li><strong>全局</strong>：~/.claude/settings.json（影响所有项目）</li>
<li><strong>项目级</strong>：.claude/settings.json（团队共享）</li>
<li><strong>项目级（不提交）</strong>：.claude/settings.local.json（个人配置）</li>
</ul>

<p>也可以在 Claude Code 内使用 /hooks 命令进行设置。</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618158%2F010_-_Introducing_Hooks_07.1752618158600.png" alt="Hooks 配置入口" /></p>

<p>配置结构大致如下：</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618159%2F010_-_Introducing_Hooks_10.1752618159645.png" alt="Hooks 配置结构" /></p>

<h2 id="pretooluse-示例">PreToolUse 示例</h2>

<pre><code>"PreToolUse": [
  {
    "matcher": "Read",
    "hooks": [
      {
        "type": "command",
        "command": "node /home/hooks/read_hook.ts"
      }
    ]
  }
]
</code></pre>

<p>该配置会在执行 Read 工具前运行指定命令，你可以：</p>

<ul>
<li>允许工具正常执行</li>
<li>阻止操作，并向 Claude 返回错误信息</li>
</ul>

<h2 id="posttooluse-示例">PostToolUse 示例</h2>

<pre><code>"PostToolUse": [
  {
    "matcher": "Write|Edit|MultiEdit",
    "hooks": [
      {
        "type": "command",
        "command": "node /home/hooks/edit_hook.ts"
      }
    ]
  }
]
</code></pre>

<p>PostToolUse 无法阻止工具执行，但可以：</p>

<ul>
<li>在编辑后自动运行格式化或测试</li>
<li>把额外反馈返回给 Claude</li>
</ul>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618160%2F010_-_Introducing_Hooks_15.1752618160073.png" alt="PostToolUse 反馈" /></p>

<h2 id="常见应用场景">常见应用场景</h2>

<ul>
<li><strong>代码格式化</strong>：编辑后自动格式化</li>
<li><strong>自动测试</strong>：文件变更后运行测试</li>
<li><strong>访问控制</strong>：阻止读写敏感文件</li>
<li><strong>代码质量</strong>：跑 linter/类型检查并反馈</li>
<li><strong>日志记录</strong>：追踪 Claude 访问的文件</li>
<li><strong>规则校验</strong>：强制命名或编码规范</li>
</ul>

<p>Hooks 能把你的工具和流程整合进 Claude Code。PreToolUse 给你控制权，PostToolUse 让你增强 Claude 的结果。</p>

<hr />

<p><a id="章节-14"></a></p>

<h1 id="定义-hooks">定义 Hooks</h1>

<p>Hooks 让你在工具调用前后拦截并控制 Claude 的行为，从而对开发环境拥有更细粒度的掌控。</p>

<h2 id="构建一个-hook-的步骤">构建一个 Hook 的步骤</h2>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618153%2F011_-_Defining_Hooks_05.1752618152864.png" alt="Hook 构建步骤" /></p>

<ul>
<li><strong>选择 PreToolUse 或 PostToolUse</strong>：前者可阻止工具执行，后者只能在执行后处理</li>
<li><strong>确定要监控的工具类型</strong>：明确哪些工具触发 Hook</li>
<li><strong>编写接收工具调用的命令</strong>：通过标准输入获取 JSON 数据</li>
<li><strong>必要时向 Claude 反馈</strong>：用退出码控制允许/阻止</li>
</ul>

<h2 id="可用工具">可用工具</h2>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618153%2F011_-_Defining_Hooks_07.1752618153492.png" alt="内置工具列表" /></p>

<p>可用工具会随着 MCP 服务器变化，因此可直接让 Claude 列出当前工具列表以确认。</p>

<h2 id="工具调用的数据结构">工具调用的数据结构</h2>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618154%2F011_-_Defining_Hooks_11.1752618154320.png" alt="工具调用数据结构" /></p>

<pre><code>{
  "session_id": "2d6a1e4d-6...",
  "transcript_path": "/Users/sg/...",
  "hook_event_name": "PreToolUse",
  "tool_name": "Read",
  "tool_input": {
    "file_path": "/code/queries/.env"
  }
}
</code></pre>

<p>Hook 命令读取该 JSON，并决定是否允许当前工具调用。</p>

<h2 id="退出码与控制逻辑">退出码与控制逻辑</h2>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618154%2F011_-_Defining_Hooks_16.1752618154725.png" alt="退出码说明" /></p>

<ul>
<li><strong>退出码 0</strong>：允许工具正常执行</li>
<li><strong>退出码 2</strong>：阻止工具执行（仅 PreToolUse 有效）</li>
</ul>

<p>如果你在 PreToolUse 中返回 2，写到标准错误的内容会被 Claude 当作反馈信息。</p>

<h2 id="常见示例">常见示例</h2>

<p>最常见的用途是阻止 Claude 读取敏感文件，例如 .env。因为 Read 和 Grep 都可能访问文件内容，
            你需要同时监控这两个工具，并检测是否指向敏感路径。</p>

<p>这样既能保护文件系统，又能清晰告诉 Claude 为什么被拦截。</p>

<hr />

<p><a id="章节-15"></a></p>

<h1 id="实现一个-hook">实现一个 Hook</h1>

<p>我们来构建一个 Hook，防止 Claude 读取敏感文件（例如 .env）。这是一个保护环境变量的典型场景。</p>

<h2 id="配置-hook">配置 Hook</h2>

<p>在 .claude/settings.local.json 中添加 PreToolUse Hook，用于在工具执行前拦截。</p>

<p>配置的关键要素包括：</p>

<ul>
<li><strong>matcher</strong>：匹配触发的工具</li>
<li><strong>command</strong>：运行的脚本</li>
</ul>

<p>示例：</p>

<pre><code>"matcher": "Read|Grep"
</code></pre>

<p>管道符 | 表示“或”，因此 Read 或 Grep 都会触发。</p>

<pre><code>"command": "node ./hooks/read_hook.js"
</code></pre>

<h2 id="理解工具调用数据">理解工具调用数据</h2>

<p>Hook 通过标准输入接收 JSON，其中包含：</p>

<ul>
<li>会话 ID 与 transcript 路径</li>
<li>Hook 事件名（PreToolUse）</li>
<li>工具名（Read、Grep 等）</li>
<li>工具输入（文件路径等）</li>
</ul>

<p>你的脚本读取 JSON 后，决定允许或阻止。</p>

<h2 id="实现-hook-脚本">实现 Hook 脚本</h2>

<p>核心逻辑如下：</p>

<pre><code>async function main() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }

  const toolArgs = JSON.parse(Buffer.concat(chunks).toString());

  // Extract the file path Claude is trying to read
  const readPath =
    toolArgs.tool_input?.file_path || toolArgs.tool_input?.path || "";

  // Check if Claude is trying to read the .env file
  if (readPath.includes('.env')) {
    console.error("You cannot read the .env file");
    process.exit(2);
  }
}
</code></pre>

<p>当路径包含 .env 时，脚本写错误并以退出码 2 终止，Claude 会理解这是 Hook 的阻止。</p>

<h2 id="测试-hook">测试 Hook</h2>

<p>保存配置与脚本后，重启 Claude Code，再尝试让 Claude 读取 .env。</p>

<p>Hook 会拦截并返回错误信息，Claude 会解释操作被 Hook 阻止。同理，如果 Claude 用 Grep 搜索 .env，也会被阻止。</p>

<h2 id="收益">收益</h2>

<ul>
<li><strong>主动防护</strong>：在敏感数据被读取前阻止</li>
<li><strong>透明可解释</strong>：Claude 会收到清晰的阻止原因</li>
<li><strong>灵活匹配</strong>：可覆盖多个工具与路径</li>
<li><strong>可扩展</strong>：适用于任意敏感文件/目录</li>
</ul>

<p>你可以在此基础上扩展更多规则，实现更精细的访问控制。</p>

<hr />

<p><a id="章节-16"></a></p>

<h1 id="hooks-常见坑点">Hooks 常见坑点</h1>

<p>你可能注意到，在运行 npm run dev 后，.claude 目录里会出现两个
            settings.json 文件。下面解释原因。</p>

<p>Claude Code 文档对 Hook 安全有一些推荐：</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752683124%2FScreenshot+2025-07-16+at+10.25.07%E2%80%AFAM.1752683124012.png" alt="Hooks 安全建议" /></p>

<p>其中一条是：脚本尽量使用绝对路径，而不是相对路径。这样可以降低
            路径拦截 或
            二进制植入
            的风险。</p>

<p>但绝对路径也带来共享困难，因为你机器上的路径与其他人可能完全不同。</p>

<p>为了解决这个问题，项目提供了 settings.example.json。其中脚本路径使用
            $PWD 占位符。运行 npm run setup 时，会执行 scripts 目录中的
            init-claude.js：</p>

<ul>
<li>将 $PWD 替换为本机项目的绝对路径</li>
<li>复制 settings.example.json</li>
<li>重命名为 settings.local.json</li>
</ul>

<p>这样既能共享配置，又能满足使用绝对路径的安全建议。</p>

<hr />

<p><a id="章节-17"></a></p>

<h1 id="实用的-hooks">实用的 Hooks</h1>

<p>Claude Code 的 Hooks 能弥补 AI 协作中的常见问题，尤其在大型项目里效果明显。它们会在 Claude 修改代码时
            自动执行，提供即时反馈并阻止常见错误。</p>

<h2 id="typescript-类型检查-hook">TypeScript 类型检查 Hook</h2>

<p>Claude 修改函数签名时，经常忘记更新所有调用点。例如为 schema.ts 中函数添加
            verbose 参数后，main.ts 的调用还保持旧签名，导致类型错误。</p>

<p>解决办法是使用 PostToolUse Hook，在每次编辑后运行 TypeScript 编译器：</p>

<ul>
<li>运行 tsc --noEmit 做类型检查</li>
<li>收集错误</li>
<li>将错误反馈给 Claude</li>
<li>提示 Claude 修复相关文件</li>
</ul>

<p>对于其他强类型语言，也可以使用类似的类型检查流程；弱类型语言则可改用自动化测试。</p>

<h2 id="防止重复查询的-hook">防止重复查询的 Hook</h2>

<p>在有大量数据库查询的项目中，Claude 有时会重复造轮子。例如你要求它“增加一个超过三天未处理订单的 Slack
            提醒”，它可能重新写查询而不是复用 getPendingOrders()。</p>

<p>该 Hook 的思路是加入“二次审查”流程：</p>

<ul>
<li>当 Claude 修改 ./queries 目录下的文件时触发</li>
<li>程序化启动另一个 Claude Code 实例</li>
<li>让第二个实例检查是否已有相似查询</li>
<li>若发现重复，反馈给原 Claude</li>
<li>提示删除重复代码并复用现有实现</li>
</ul>

<h2 id="实现注意点">实现注意点</h2>

<p>TypeScript Hook 较轻量，速度快；查询重复 Hook 更消耗资源，因为它会启动额外 Claude 实例。</p>

<ul>
<li><strong>收益：</strong>减少重复代码，提升一致性</li>
<li><strong>成本：</strong>每次修改都要额外调用，耗时并消耗 API</li>
<li><strong>建议：</strong>只监控关键目录，避免过度开销</li>
</ul>

<p>这些 Hook 使用 Claude 的 TypeScript SDK，通过编程方式让一个 Claude 去审查另一个 Claude 的输出。</p>

<h2 id="可扩展思路">可扩展思路</h2>

<ul>
<li>用编译器或 linter 输出做即时反馈</li>
<li>用独立 AI 实例做自动代码审查</li>
<li>重点监控高价值目录</li>
<li>权衡自动化收益与性能成本</li>
</ul>

<p>关键是找出你流程中的痛点，并用 Hook 自动解决。</p>

<hr />

<p><a id="章节-18"></a></p>

<h1 id="另一个实用-hook">另一个实用 Hook</h1>

<p>除 PreToolUse 与 PostToolUse 外，还有更多 Hook 类型：</p>

<ul>
<li>Notification：Claude 请求工具权限或 60 秒空闲时触发</li>
<li>Stop：Claude 回复结束时触发</li>
<li>SubagentStop：子代理任务结束时触发</li>
<li>PreCompact：compact 操作前触发</li>
<li>UserPromptSubmit：用户提交提示词时触发</li>
<li>SessionStart：会话开始或恢复时触发</li>
<li>SessionEnd：会话结束时触发</li>
</ul>

<p>令人困惑的地方在于：</p>

<ul>
<li>不同 Hook 的标准输入结构完全不同</li>
<li>PreToolUse/PostToolUse 的输入还会随工具类型变化</li>
</ul>

<p>例如，下面是一个 PostToolUse（监听 TodoWrite）的输入：</p>

<pre><code>{
  "session_id": "9ecf22fa-edf8-4332-ae85-b6d5456eda64",
  "transcript_path": "&lt;path_to_transcript&gt;",
  "hook_event_name": "PostToolUse",
  "tool_name": "TodoWrite",
  "tool_input": {
    "todos": [{ "content": "write a readme", "status": "pending", "priority": "medium", "id": "1" }]
  },
  "tool_response": {
    "oldTodos": [],
    "newTodos": [{ "content": "write a readme", "status": "pending", "priority": "medium", "id": "1" }]
  }
}
</code></pre>

<p>而 Stop Hook 的输入是：</p>

<pre><code>{
  "session_id": "af9f50b6-f042-4773-b3e2-c3a4814765ce",
  "transcript_path": "&lt;path_to_transcript&gt;",
  "hook_event_name": "Stop",
  "stop_hook_active": false
}
</code></pre>

<p>可以看到，不同 Hook 的输入差异非常大，这使得编写 Hook 变得困难——你不一定知道该解析哪些字段。</p>

<p>建议做一个辅助 Hook 来记录输入：</p>

<pre><code>"PostToolUse": [ // Or "PreToolUse" or "Stop", etc
  {
    "matcher": "*",
    "hooks": [
      {
        "type": "command",
        "command": "jq . &gt; post-log.json"
      }
    ]
  },
]
</code></pre>

<p>该命令会把 Hook 输入写入 post-log.json，方便你观察真实结构，从而更容易编写稳定的 Hook。</p>

<hr />

<p><a id="章节-19"></a></p>

<h1 id="claude-code-sdk">Claude Code SDK</h1>

<p>Claude Code SDK 让你可以在应用或脚本中以编程方式调用 Claude Code。它提供 TypeScript、Python 以及 CLI
            方式，功能与终端中的 Claude Code 一致。</p>

<p><img src="https://everpath-course-content.s3-accelerate.amazonaws.com/instructor%2Fa46l9irobhg0f5webscixp0bs%2Fpublic%2F1752618201%2F014_-_The_Claude_Code_SDK_00.1752618201045.png" alt="Claude Code SDK" /></p>

<p>SDK 运行的就是你熟悉的 Claude Code，同样具备完整工具集，适用于自动化与系统集成。</p>

<h2 id="关键特性">关键特性</h2>

<ul>
<li>支持编程方式调用 Claude Code</li>
<li>功能与终端版本一致</li>
<li>继承同目录下 Claude Code 的设置</li>
<li>默认只读权限</li>
<li>适合嵌入更大的自动化流程</li>
</ul>

<h2 id="基础用法">基础用法</h2>

<p>以下是一个 TypeScript 示例，用于查找重复查询：</p>

<pre><code>import { query } from "@anthropic-ai/claude-code";

const prompt = "Look for duplicate queries in the ./src/queries dir";

for await (const message of query({
  prompt,
})) {
  console.log(JSON.stringify(message, null, 2));
}
</code></pre>

<p>运行后你会看到 Claude Code 与模型之间的完整消息流，最终消息即 Claude 的完整响应。</p>

<h2 id="权限与工具">权限与工具</h2>

<p>SDK 默认是只读模式，只能读取与检索文件，无法写入或编辑。如果需要写权限，可以在调用时传入
            allowedTools：</p>

<pre><code>for await (const message of query({
  prompt,
  options: {
    allowedTools: ["Edit"]
  }
})) {
  console.log(JSON.stringify(message, null, 2));
}
</code></pre>

<p>也可以在项目的 .claude 设置文件中进行全局授权。</p>

<h2 id="实用场景">实用场景</h2>

<ul>
<li>在 Git hooks 中自动评审改动</li>
<li>在构建脚本中分析和优化代码</li>
<li>辅助维护任务的工具命令</li>
<li>自动生成文档</li>
<li>CI/CD 中的代码质量检查</li>
</ul>

<p>SDK 让你把 AI 能力融入任意开发环节，是自动化与集成场景的强大基础设施。</p>

<hr />

<p><a id="章节-20"></a></p>

<h1 id="claude-code-测验">Claude Code 测验</h1>

<p>此页面为在线测验，需要在原课程平台中完成。</p>

<p>静态版本无法展示交互测验，请点击原文链接参与测试。</p>

<hr />

<p><a id="章节-21"></a></p>

<h1 id="总结与下一步">总结与下一步</h1>

<p>本节为课程总结视频。</p>

<p>当前页面不包含文字讲义，请在原课程页面观看视频内容。</p>

<hr />

    </body>
    </html>
    