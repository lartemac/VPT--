# Claude Code 中文教程

本教程从 https://claudecode.tangshuang.net 抓取

共 33 章，206 个小节

---

# 第 1 章

## 1 Claude Code是什么

**URL**: https://claudecode.tangshuang.net/course/1.1%20Claude%20Code%E6%98%AF%E4%BB%80%E4%B9%88

#### 1.1.1 Claude Code的定义#

Claude Code是由Anthropic公司推出的面向开发者的智能编码助手，它不仅仅是一个简单的代码生成工具，更是一个具备记忆、工具调用、自主规划和环境感知能力的"智能代理"（Agentic AI）系统。通过与本地开发环境（如VS Code）深度集成，Claude Code能够在不离开安全边界的前提下，深入理解代码库、解释复杂架构、生成可视化图表，并执行实际的代码修改任务。

区分Claude Code和Claude大模型。
Claude Code是一个工具软件，不能与Claude大模型划等号。虽然Claude Code的官方团队，在工具内默认使用Claude大模型，但是我们可以通过配置来使用非官方的大模型，例如使用国内的GLM等大模型。
这也展示了AI助手的灵活性和可扩展性，使得开发者能够根据自己的需求和场景，选择最适合的模型。
虽然目前市面上的编程模型中Cluade 4.5 Opus是最聪明最强的，但是因为太贵，实际上我们在实际开发中，更多的是使用国内的GLM等模型。

#### 1.1.2 Claude Code的发展背景#

在AI辅助编程领域，从早期的代码补全工具（如TabNine、GitHub Copilot）到具备简单对话能力的助手，再到如今的智能代理系统，技术发展经历了三个主要阶段：

True. 代码补全阶段：基于统计模型，提供简单的代码片段补全
True. 对话辅助阶段：结合大语言模型，能够理解自然语言指令并生成代码
True. 智能代理阶段：具备自主规划、工具调用、环境感知和记忆能力，能够完成复杂的开发任务

Claude Code正是处于第三个阶段的代表性产品，它的出现标志着AI编程助手从"被动响应"向"主动协作"的转变。

#### 1.1.3 Claude Code的核心定位#

Claude Code的核心定位是"开发者的智能协作伙伴"，它旨在：

- 增强开发者能力：通过AI辅助，提升开发效率和代码质量
- 简化复杂任务：将复杂的开发任务分解为可执行的子任务
- 提供深度洞察：基于对代码库的全面理解，提供架构级别的建议
- 确保安全可靠：在安全边界内运行，保护代码和数据隐私
- 支持团队协作：提供共享的知识和上下文，促进团队协作

#### 1.1.4 Claude Code的技术基础#

Claude Code构建在Anthropic公司的Claude大语言模型之上，结合了以下核心技术：

True. 大语言模型：基于Claude Opus 4和Sonnet 4双模型体系，具备强大的自然语言理解和生成能力
True. 工具调用系统：能够调用各种内置和外部工具，扩展AI的能力边界
True. 记忆系统：具备短期和长期记忆能力，能够记住上下文和历史交互
True. 自主规划算法：能够将复杂任务分解为可执行的子任务序列
True. 环境感知能力：能够感知和理解本地开发环境，包括代码库结构、文件内容等
True. 安全机制：基于最小权限原则，所有操作都在安全边界内执行

#### 1.1.5 Claude Code的主要组成部分#

Claude Code主要由以下几个核心组件组成：

#### 1.1.6 Claude Code与传统AI编程工具的本质区别#

与传统的AI编程工具相比，Claude Code具有以下本质区别：

True. 项目级理解：能够理解整个代码库的结构和关系，而不仅仅是单个文件
True. 自主规划能力：能够自主分解任务、制定计划并执行
True. 工具调用能力：能够调用各种工具扩展自身能力
True. 环境感知能力：能够感知和适应本地开发环境
True. 记忆能力：能够记住上下文和历史交互
True. 安全边界：在安全边界内运行，保护代码和数据隐私

#### 1.1.7 Claude Code的设计原则#

Claude Code的设计遵循以下核心原则：

True. 安全优先：所有操作都在安全边界内执行，保护用户代码和数据
True. 最小权限：工具调用和代码修改遵循最小权限原则，需要用户确认
True. 透明可信：所有操作都向用户透明，用户可以随时干预和控制
True. 增强协作：旨在增强开发者能力，而不是替代开发者
True. 持续学习：能够从交互中学习，不断提升自身能力
True. 开放生态：支持插件扩展，鼓励社区贡献

#### 1.1.8 Claude Code的应用前景#

随着AI技术的不断发展，Claude Code作为智能代理系统的代表，具有广阔的应用前景：

True. 提升开发效率：自动化重复性任务，让开发者专注于创造性工作
True. 降低开发门槛：帮助新手快速入门，降低编程学习曲线
True. 促进技术传播：通过代码解释和文档生成，促进技术知识的传播
True. 加速创新：帮助开发者快速验证想法，加速产品创新
True. 改变开发模式：推动从个体开发向人机协作开发模式的转变

Claude Code不仅仅是一个工具，更是AI辅助开发的未来方向，它将重新定义开发者与AI的协作关系，开启智能开发的新时代。

---

## 2 Claude Code的核心优势

**URL**: https://claudecode.tangshuang.net/course/1.2%20Claude%20Code%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF

#### 1.2.1 项目级代码理解能力#

Claude Code最显著的优势之一是其强大的项目级代码理解能力。与传统AI编程工具只能处理单个文件或有限上下文不同，Claude Code能够：

- 理解整个代码库：能够读取和理解整个项目的代码结构，包括文件依赖、模块关系和架构设计
- 建立代码图谱：自动构建代码之间的关联图谱，识别关键组件和核心逻辑
- 追踪代码演进：能够理解代码的历史变更和演进过程
- 识别架构模式：自动识别常见的架构模式和设计原则

这种项目级理解能力使得Claude Code能够提供更准确、更符合项目上下文的代码建议和修改。

#### 1.2.2 智能任务规划与执行#

Claude Code具备强大的自主规划和执行能力，能够将复杂的开发任务分解为可执行的子任务序列：

- 任务分解：将用户的自然语言需求分解为具体的开发任务
- 优先级排序：根据任务的依赖关系和重要性进行优先级排序
- 执行计划生成：生成详细的执行计划，包括需要修改的文件、使用的工具和执行顺序
- 自主执行：按照计划自主执行任务，包括代码生成、修改和测试
- 自适应调整：在执行过程中根据反馈和结果进行自适应调整

这种智能规划能力使得Claude Code能够处理复杂的开发任务，而不仅仅是简单的代码生成。

#### 1.2.3 强大的工具调用系统#

Claude Code拥有完善的工具调用系统，能够调用各种内置和外部工具：

- 内置工具：包括代码搜索、文件操作、测试运行、代码审查等
- 外部工具集成：支持集成Git、调试器、构建工具等开发环境工具
- 自定义工具扩展：通过插件系统支持自定义工具开发和集成
- 工具调用安全机制：所有工具调用都遵循最小权限原则，需要用户确认

工具调用系统极大地扩展了Claude Code的能力边界，使其能够完成更复杂的开发任务。

#### 1.2.4 先进的记忆系统#

Claude Code具备先进的记忆系统，能够：

- 短期记忆：记住当前对话的上下文和交互历史
- 长期记忆：存储和管理项目知识、架构设计和最佳实践
- 记忆压缩：自动压缩和优化记忆内容，提高记忆效率
- 记忆检索：根据需要快速检索相关记忆内容
- 团队共享记忆：支持团队成员之间共享记忆和知识

这种记忆系统使得Claude Code能够随着使用时间的推移，越来越熟悉项目和团队的工作方式，提供更加个性化和准确的帮助。

#### 1.2.5 深度集成的开发环境#

Claude Code与主流开发环境深度集成，提供无缝的开发体验：

- VS Code插件：提供功能完整的VS Code插件，与编辑器深度融合
- 命令行工具：支持通过命令行使用Claude Code的所有功能
- 本地环境感知：能够感知本地开发环境的配置和状态
- 实时反馈：提供实时的代码建议和反馈
- 无干扰设计：在不打断开发者工作流的前提下提供帮助

深度集成的开发环境使得Claude Code能够自然地融入开发者的日常工作中，提高开发效率而不增加额外的负担。

#### 1.2.6 严格的安全与隐私保护#

Claude Code在设计时就将安全和隐私保护放在首位：

- 安全边界：所有操作都在安全边界内执行，防止恶意代码执行
- 最小权限原则：工具调用和代码修改遵循最小权限原则
- 用户确认机制：重要操作需要用户确认，可配置自动执行
- 数据隐私保护：本地代码和数据不会被上传到云端，保护用户隐私
- 透明的操作日志：所有操作都有详细的日志记录，便于审计和追溯

这种严格的安全设计使得Claude Code能够在企业环境中安全使用，保护企业的知识产权和数据安全。

#### 1.2.7 支持多种编程语言和框架#

Claude Code支持多种主流编程语言和框架：

- 编程语言：Python、JavaScript/TypeScript、Java、C#、Go、Rust、PHP、Ruby等
- Web框架：React、Vue、Angular、Next.js、Django、Flask等
- 移动开发：React Native、Flutter、iOS、Android等
- 后端开发：Node.js、Spring、ASP.NET、Gin、Express等
- DevOps工具：Docker、Kubernetes、Terraform、Ansible等

这种广泛的语言和框架支持使得Claude Code能够适应各种开发场景和技术栈。

#### 1.2.8 持续学习与进化能力#

Claude Code具备持续学习和进化的能力：

- 从交互中学习：能够从与开发者的交互中学习，不断改进自身能力
- 从反馈中优化：根据开发者的反馈优化代码生成和建议质量
- 适应团队风格：能够适应不同团队的开发风格和编码规范
- 持续更新：定期更新模型和功能，引入最新的技术和最佳实践

这种持续学习能力使得Claude Code能够随着时间的推移不断提升自身能力，适应不断变化的开发环境和技术趋势。

#### 1.2.9 优秀的代码生成质量#

Claude Code生成的代码具有较高的质量和可维护性：

- 符合最佳实践：生成的代码遵循行业最佳实践和编码规范
- 可读性强：代码结构清晰，命名规范，注释完善
- 安全性高：生成的代码考虑了常见的安全问题和漏洞
- 性能优化：代码考虑了性能优化，避免常见的性能陷阱
- 测试覆盖：能够生成相应的测试用例，提高代码的测试覆盖率

这种高质量的代码生成能力使得Claude Code能够直接生成可用于生产环境的代码，减少开发者的修改工作量。

#### 1.2.10 强大的代码解释和文档生成能力#

Claude Code不仅能够生成代码，还具备强大的代码解释和文档生成能力：

- 代码解释：能够解释复杂的代码逻辑和算法，帮助开发者理解代码
- 架构文档生成：能够根据代码自动生成架构文档和系统设计图
- API文档生成：能够生成详细的API文档，包括参数说明和使用示例
- 技术文档更新：能够根据代码变更自动更新技术文档
- 注释生成和完善：能够为现有代码生成和完善注释

这种文档生成能力有助于提高项目的可维护性和知识传承，减少团队的文档工作量。

#### 1.2.11 跨平台和跨环境支持#

Claude Code支持多种平台和环境：

- 操作系统支持：Windows、macOS、Linux
- 开发环境支持：VS Code、JetBrains IDEs、命令行
- 云环境支持：AWS、Azure、Google Cloud、阿里云等
- 本地和远程开发：支持本地开发环境和远程开发环境

这种跨平台和跨环境支持使得Claude Code能够适应各种开发场景和工作方式。

#### 1.2.12 活跃的社区和开放的生态系统#

Claude Code拥有活跃的社区和开放的生态系统：

- 插件市场：提供丰富的插件扩展，支持自定义功能
- 开放API：提供开放的API，支持与其他工具和系统集成
- 社区贡献：鼓励社区贡献插件和工具
- 文档和教程：提供完善的文档和教程资源
- 开发者社区：活跃的开发者社区，提供技术支持和交流

这种开放的生态系统使得Claude Code能够不断扩展和完善，适应各种特殊的开发需求和场景。

#### 1.2.13 总结：Claude Code的优势矩阵#

将Claude Code的核心优势归纳为以下矩阵：

这种全面的优势矩阵使得Claude Code在AI编程助手领域具有显著的竞争力，能够为开发者提供全方位的智能辅助。

---

## 3 Claude Code与其他AI编程工具的对比

**URL**: https://claudecode.tangshuang.net/course/1.3%20Claude%20Code%E4%B8%8E%E5%85%B6%E4%BB%96AI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AF%B9%E6%AF%94

#### 1.3.1 对比概述#

在AI编程助手领域，目前有多种主流工具，包括GitHub Copilot、Cursor、ChatGPT Code Interpreter、Amazon CodeWhisperer等。Claude Code作为新兴的智能代理系统，与这些工具相比具有独特的优势和特点。本节将从多个维度对Claude Code与其他主流AI编程工具进行详细对比。

#### 1.3.2 与GitHub Copilot的对比#

GitHub Copilot是由GitHub和OpenAI合作开发的AI编程助手，是目前市场份额最大的AI编程工具之一。

#### 1.3.3 与Cursor的对比#

Cursor是基于VS Code的AI编程编辑器，内置了GPT-4模型，提供代码生成、解释和修改功能。

#### 1.3.4 与ChatGPT Code Interpreter的对比#

ChatGPT Code Interpreter是OpenAI推出的代码执行功能，允许ChatGPT编写和运行代码。

#### 1.3.5 与Amazon CodeWhisperer的对比#

Amazon CodeWhisperer是AWS推出的AI编程助手，专注于云开发和AWS服务集成。

#### 1.3.6 与TabNine的对比#

TabNine是最早的AI代码补全工具之一，基于深度学习模型提供代码补全服务。

#### 1.3.7 与OpenAI Codex的对比#

OpenAI Codex是OpenAI推出的基于云的软件工程代理，集成于ChatGPT平台，旨在为开发者提供更高效、安全的编程体验。

#### 1.3.8 对比总结#

通过以上对比，我们可以看出Claude Code在多个维度上具有明显优势，特别是在：

True. 项目级理解能力：能够理解整个代码库的结构和关系
True. 智能任务规划与执行：能够自主分解任务、制定计划并执行
True. 强大的工具调用系统：支持内置和外部工具集成
True. 先进的记忆系统：具备短期和长期记忆能力
True. 严格的安全机制：基于最小权限原则，保护用户代码和数据
True. 持续学习能力：能够从交互中学习，适应团队风格

这些优势使得Claude Code在处理复杂开发任务时表现更加出色，能够为开发者提供更全面、更智能的辅助。

#### 1.3.9 如何选择合适的AI编程工具#

在选择AI编程工具时，开发者应根据自己的需求和使用场景进行选择：

True. 如果您需要简单的代码补全：GitHub Copilot或TabNine可能是更好的选择
True. 如果您需要AI增强的编辑器：Cursor可能更适合您
True. 如果您主要进行云开发：Amazon CodeWhisperer可能更有优势
True. 如果您需要基于ChatGPT平台的集成：OpenAI Codex可能更适合您
True. 如果您需要处理复杂的开发任务：Claude Code是更好的选择
True. 如果您需要通用的AI助手：ChatGPT Code Interpreter可能更适合您

对于专业开发者来说，Claude Code的项目级理解、智能规划和工具调用能力使其在处理复杂开发任务时具有明显优势，能够显著提高开发效率和代码质量。

#### 1.3.10 Claude Code的独特价值主张#

Claude Code的独特价值主张在于：

- 从被动响应到主动协作：Claude Code不仅仅是一个被动的代码生成工具，更是一个主动的协作伙伴，能够理解需求、制定计划并执行任务
- 从代码级到架构级：Claude Code能够提供架构级别的建议和优化，而不仅仅是代码级别的补全
- 从单文件到整个项目：Claude Code能够理解整个代码库的结构和关系，提供更符合项目上下文的建议
- 从一次性到持续学习：Claude Code能够从交互中学习，随着使用时间的推移不断提升自身能力
- 从封闭到开放：Claude Code拥有开放的插件系统，支持社区贡献和自定义扩展

这些独特的价值主张使得Claude Code在AI编程助手领域具有广阔的发展前景，有望成为未来智能开发的核心工具之一。

---

## 4 Claude Code的应用场景

**URL**: https://claudecode.tangshuang.net/course/1.4%20Claude%20Code%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF

#### 1.4.1 应用场景概述#

Claude Code作为一款智能代理系统，具有广泛的应用场景，涵盖了软件开发的各个阶段和多个领域。本节将详细介绍Claude Code在不同场景下的应用，包括使用案例、最佳实践和预期效果。

#### 1.4.2 软件开发场景#

##### 需求分析与设计#

Claude Code能够帮助开发者进行需求分析和设计，将自然语言需求转化为结构化的设计文档和实现方案：

- 需求分解：将模糊的自然语言需求分解为具体的功能点和技术需求
- 架构设计：基于需求生成架构设计方案，包括技术选型、模块划分和交互设计
- API设计：生成详细的API设计文档，包括接口定义、参数说明和返回值格式
- 数据库设计：根据业务需求设计数据库 schema，包括表结构、关系和索引

```
bash复制用户：我需要开发一个在线电商平台，支持用户注册、商品管理、订单处理和支付功能。

Claude Code：

1. 需求分析：
   - 用户系统：注册、登录、个人信息管理
   - 商品系统：商品发布、分类、搜索、详情展示
   - 订单系统：购物车、订单创建、订单管理、物流跟踪
   - 支付系统：多种支付方式集成、支付状态管理
   - 管理后台：商品管理、订单管理、用户管理、数据分析

2. 技术选型建议：
   - 前端：React + TypeScript + Next.js
   - 后端：Node.js + Express + MongoDB
   - 支付：集成Stripe或PayPal API
   - 认证：JWT + OAuth2.0

3. 架构设计：
   - 微服务架构，将用户、商品、订单、支付拆分为独立服务
   - 使用API Gateway统一管理接口
   - 采用事件驱动架构处理异步任务
   - 实现CI/CD流水线自动化部署

4. 实现计划：
   - 第1周：搭建基础架构，实现用户系统
   - 第2周：实现商品系统和搜索功能
   - 第3周：实现订单系统和购物车
   - 第4周：集成支付系统
   - 第5周：开发管理后台
   - 第6周：测试和优化
```

```
用户：我需要开发一个在线电商平台，支持用户注册、商品管理、订单处理和支付功能。

Claude Code：

1. 需求分析：
   - 用户系统：注册、登录、个人信息管理
   - 商品系统：商品发布、分类、搜索、详情展示
   - 订单系统：购物车、订单创建、订单管理、物流跟踪
   - 支付系统：多种支付方式集成、支付状态管理
   - 管理后台：商品管理、订单管理、用户管理、数据分析

2. 技术选型建议：
   - 前端：React + TypeScript + Next.js
   - 后端：Node.js + Express + MongoDB
   - 支付：集成Stripe或PayPal API
   - 认证：JWT + OAuth2.0

3. 架构设计：
   - 微服务架构，将用户、商品、订单、支付拆分为独立服务
   - 使用API Gateway统一管理接口
   - 采用事件驱动架构处理异步任务
   - 实现CI/CD流水线自动化部署

4. 实现计划：
   - 第1周：搭建基础架构，实现用户系统
   - 第2周：实现商品系统和搜索功能
   - 第3周：实现订单系统和购物车
   - 第4周：集成支付系统
   - 第5周：开发管理后台
   - 第6周：测试和优化
```

##### 代码生成与实现#

Claude Code能够根据设计文档和需求生成高质量的代码，加速开发过程：

- 完整功能实现：根据需求生成完整的功能模块代码
- 跨文件代码生成：生成涉及多个文件的代码，保持一致性和完整性
- 设计模式应用：在生成代码中应用适当的设计模式和最佳实践
- 代码复用：识别和复用现有代码库中的组件和功能

```
bash复制用户：请帮我实现一个React组件，用于展示商品列表，支持分页、排序和筛选功能。
Claude Code：
1. 分析需求：
   - 商品列表展示
   - 分页功能
   - 排序功能（按价格、销量、上架时间）
   - 筛选功能（按分类、价格范围、品牌）

2. 生成组件代码：
```tsx
import React, { useState, useEffect } from 'react';
import { Product } from '../types';
import { Pagination, Select, Input, Button } from 'antd';

const { Option } = Select;
const { Search } = Input;

interface ProductListProps {
  initialProducts?: Product[];
  onProductClick?: (product: Product) => void;
}

const ProductList: React.FC<ProductListProps> = ({
  initialProducts = [],
  onProductClick
}) => {
  const [products, setProducts] = useState<Product[]>(initialProducts);
  const [filteredProducts, setFilteredProducts] = useState<Product[]>(initialProducts);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [sortBy, setSortBy] = useState('createdAt');
  const [sortOrder, setSortOrder] = useState('desc');
  const [filters, setFilters] = useState({
    category: '',
    minPrice: 0,
    maxPrice: Infinity,
    brand: '',
    search: ''
  });

  // Filter and sort products
  useEffect(() => {
    let result = [...products];

    // Apply filters
    if (filters.category) {
      result = result.filter(p => p.category === filters.category);
    }
    if (filters.brand) {
      result = result.filter(p => p.brand === filters.brand);
    }
    result = result.filter(p => p.price >= filters.minPrice && p.price <= filters.maxPrice);
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      result = result.filter(p =>
        p.name.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Apply sorting
    result.sort((a, b) => {
      const aValue = a[sortBy as keyof Product];
      const bValue = b[sortBy as keyof Product];

      if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
      return 0;
    });

    setFilteredProducts(result);
    setCurrentPage(1); // Reset to first page when filters change
  }, [products, filters, sortBy, sortOrder]);

  // Get current page products
  const indexOfLastProduct = currentPage * pageSize;
  const indexOfFirstProduct = indexOfLastProduct - pageSize;
  const currentProducts = filteredProducts.slice(indexOfFirstProduct, indexOfLastProduct);

  // Handle filter changes
  const handleFilterChange = (key: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [key]: value
    }));
  };

  // Get unique categories and brands for filters
  const categories = [...new Set(products.map(p => p.category))];
  const brands = [...new Set(products.map(p => p.brand))];

  return (
    <div className="product-list">
      {/* Filter section */}
      <div className="filter-section">
        <div className="filter-row">
          <Search
            placeholder="Search products"
            onChange={(e) => handleFilterChange('search', e.target.value)}
            style={{ width: 200, marginRight: 16 }}
          />
          <Select
            placeholder="Category"
            style={{ width: 150, marginRight: 16 }}
            onChange={(value) => handleFilterChange('category', value)}
          >
            <Option value="">All Categories</Option>
            {categories.map(category => (
              <Option key={category} value={category}>{category}</Option>
            ))}
          </Select>
          <Select
            placeholder="Brand"
            style={{ width: 150, marginRight: 16 }}
            onChange={(value) => handleFilterChange('brand', value)}
          >
            <Option value="">All Brands</Option>
            {brands.map(brand => (
              <Option key={brand} value={brand}>{brand}</Option>
            ))}
          </Select>
          <Input
            placeholder="Min Price"
            type="number"
            style={{ width: 100, marginRight: 8 }}
            onChange={(e) => handleFilterChange('minPrice', parseFloat(e.target.value) || 0)}
          />
          <span style={{ marginRight: 8 }}>-</span>
          <Input
            placeholder="Max Price"
            type="number"
            style={{ width: 100, marginRight: 16 }}
            onChange={(e) => handleFilterChange('maxPrice', parseFloat(e.target.value) || Infinity)}
          />
        </div>

        {/* Sort section */}
        <div className="sort-section" style={{ marginTop: 16 }}>
          <span style={{ marginRight: 8 }}>Sort by:</span>
          <Select
            style={{ width: 150, marginRight: 16 }}
```

```
用户：请帮我实现一个React组件，用于展示商品列表，支持分页、排序和筛选功能。
Claude Code：
1. 分析需求：
   - 商品列表展示
   - 分页功能
   - 排序功能（按价格、销量、上架时间）
   - 筛选功能（按分类、价格范围、品牌）

2. 生成组件代码：
```tsx
import React, { useState, useEffect } from 'react';
import { Product } from '../types';
import { Pagination, Select, Input, Button } from 'antd';

const { Option } = Select;
const { Search } = Input;

interface ProductListProps {
  initialProducts?: Product[];
  onProductClick?: (product: Product) => void;
}

const ProductList: React.FC<ProductListProps> = ({
  initialProducts = [],
  onProductClick
}) => {
  const [products, setProducts] = useState<Product[]>(initialProducts);
  const [filteredProducts, setFilteredProducts] = useState<Product[]>(initialProducts);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [sortBy, setSortBy] = useState('createdAt');
  const [sortOrder, setSortOrder] = useState('desc');
  const [filters, setFilters] = useState({
    category: '',
    minPrice: 0,
    maxPrice: Infinity,
    brand: '',
    search: ''
  });

  // Filter and sort products
  useEffect(() => {
    let result = [...products];

    // Apply filters
    if (filters.category) {
      result = result.filter(p => p.category === filters.category);
    }
    if (filters.brand) {
      result = result.filter(p => p.brand === filters.brand);
    }
    result = result.filter(p => p.price >= filters.minPrice && p.price <= filters.maxPrice);
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      result = result.filter(p =>
        p.name.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Apply sorting
    result.sort((a, b) => {
      const aValue = a[sortBy as keyof Product];
      const bValue = b[sortBy as keyof Product];

      if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
      return 0;
    });

    setFilteredProducts(result);
    setCurrentPage(1); // Reset to first page when filters change
  }, [products, filters, sortBy, sortOrder]);

  // Get current page products
  const indexOfLastProduct = currentPage * pageSize;
  const indexOfFirstProduct = indexOfLastProduct - pageSize;
  const currentProducts = filteredProducts.slice(indexOfFirstProduct, indexOfLastProduct);

  // Handle filter changes
  const handleFilterChange = (key: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [key]: value
    }));
  };

  // Get unique categories and brands for filters
  const categories = [...new Set(products.map(p => p.category))];
  const brands = [...new Set(products.map(p => p.brand))];

  return (
    <div className="product-list">
      {/* Filter section */}
      <div className="filter-section">
        <div className="filter-row">
          <Search
            placeholder="Search products"
            onChange={(e) => handleFilterChange('search', e.target.value)}
            style={{ width: 200, marginRight: 16 }}
          />
          <Select
            placeholder="Category"
            style={{ width: 150, marginRight: 16 }}
            onChange={(value) => handleFilterChange('category', value)}
          >
            <Option value="">All Categories</Option>
            {categories.map(category => (
              <Option key={category} value={category}>{category}</Option>
            ))}
          </Select>
          <Select
            placeholder="Brand"
            style={{ width: 150, marginRight: 16 }}
            onChange={(value) => handleFilterChange('brand', value)}
          >
            <Option value="">All Brands</Option>
            {brands.map(brand => (
              <Option key={brand} value={brand}>{brand}</Option>
            ))}
          </Select>
          <Input
            placeholder="Min Price"
            type="number"
            style={{ width: 100, marginRight: 8 }}
            onChange={(e) => handleFilterChange('minPrice', parseFloat(e.target.value) || 0)}
          />
          <span style={{ marginRight: 8 }}>-</span>
          <Input
            placeholder="Max Price"
            type="number"
            style={{ width: 100, marginRight: 16 }}
            onChange={(e) => handleFilterChange('maxPrice', parseFloat(e.target.value) || Infinity)}
          />
        </div>

        {/* Sort section */}
        <div className="sort-section" style={{ marginTop: 16 }}>
          <span style={{ marginRight: 8 }}>Sort by:</span>
          <Select
            style={{ width: 150, marginRight: 16 }}
```

```
bash复制        value={sortBy}
        onChange={setSortBy}
      >
        <Option value="createdAt">Created At</Option>
        <Option value="price">Price</Option>
        <Option value="sales">Sales</Option>
      </Select>
      <Select
        style={{ width: 100 }}
        value={sortOrder}
        onChange={setSortOrder}
      >
        <Option value="asc">Ascending</Option>
        <Option value="desc">Descending</Option>
      </Select>
    </div>
  </div>

  {/* Product grid */}
  <div className="product-grid" style={{ marginTop: 24, display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 16 }}>
    {currentProducts.map(product => (
      <div
        key={product.id}
        className="product-card"
        style={{ border: '1px solid #e8e8e8', borderRadius: 4, padding: 16, cursor: 'pointer' }}
        onClick={() => onProductClick && onProductClick(product)}
      >
        <img
          src={product.imageUrl}
          alt={product.name}
          style={{ width: '100%', height: 200, objectFit: 'cover', marginBottom: 12 }}
        />
        <h3 style={{ margin: '0 0 8px 0', fontSize: 16 }}>{product.name}</h3>
        <p style={{ margin: '0 0 12px 0', fontSize: 14, color: '#666', height: 48, overflow: 'hidden' }}>{product.description}</p>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontSize: 18, fontWeight: 'bold', color: '#ff4d4f' }}>${product.price.toFixed(2)}</span>
          <span style={{ fontSize: 12, color: '#999' }}>Sales: {product.sales}</span>
        </div>
      </div>
    ))}
  </div>

  {/* Pagination */}
  <div className="pagination" style={{ marginTop: 24, textAlign: 'center' }}>
    <Pagination
      current={currentPage}
      pageSize={pageSize}
      total={filteredProducts.length}
      onChange={setCurrentPage}
      pageSizeOptions={['10', '20', '50', '100']}
      showSizeChanger
      onShowSizeChange={(current, size) => setPageSize(size)}
    />
  </div>
</div>
```

```
value={sortBy}
        onChange={setSortBy}
      >
        <Option value="createdAt">Created At</Option>
        <Option value="price">Price</Option>
        <Option value="sales">Sales</Option>
      </Select>
      <Select
        style={{ width: 100 }}
        value={sortOrder}
        onChange={setSortOrder}
      >
        <Option value="asc">Ascending</Option>
        <Option value="desc">Descending</Option>
      </Select>
    </div>
  </div>

  {/* Product grid */}
  <div className="product-grid" style={{ marginTop: 24, display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 16 }}>
    {currentProducts.map(product => (
      <div
        key={product.id}
        className="product-card"
        style={{ border: '1px solid #e8e8e8', borderRadius: 4, padding: 16, cursor: 'pointer' }}
        onClick={() => onProductClick && onProductClick(product)}
      >
        <img
          src={product.imageUrl}
          alt={product.name}
          style={{ width: '100%', height: 200, objectFit: 'cover', marginBottom: 12 }}
        />
        <h3 style={{ margin: '0 0 8px 0', fontSize: 16 }}>{product.name}</h3>
        <p style={{ margin: '0 0 12px 0', fontSize: 14, color: '#666', height: 48, overflow: 'hidden' }}>{product.description}</p>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontSize: 18, fontWeight: 'bold', color: '#ff4d4f' }}>${product.price.toFixed(2)}</span>
          <span style={{ fontSize: 12, color: '#999' }}>Sales: {product.sales}</span>
        </div>
      </div>
    ))}
  </div>

  {/* Pagination */}
  <div className="pagination" style={{ marginTop: 24, textAlign: 'center' }}>
    <Pagination
      current={currentPage}
      pageSize={pageSize}
      total={filteredProducts.length}
      onChange={setCurrentPage}
      pageSizeOptions={['10', '20', '50', '100']}
      showSizeChanger
      onShowSizeChange={(current, size) => setPageSize(size)}
    />
  </div>
</div>
```

export default ProductList;

```
bash复制### 代码重构与优化

Claude Code能够帮助开发者重构和优化现有代码，提高代码质量和性能：

- **代码重构**：识别和重构坏味道代码，如重复代码、过长函数、过大类等
- **性能优化**：分析代码性能瓶颈，提供优化建议和实现方案
- **架构优化**：识别架构问题，提供架构重构建议
- **技术栈升级**：帮助将代码从旧技术栈升级到新技术栈

**使用案例**：
```

```
### 代码重构与优化

Claude Code能够帮助开发者重构和优化现有代码，提高代码质量和性能：

- **代码重构**：识别和重构坏味道代码，如重复代码、过长函数、过大类等
- **性能优化**：分析代码性能瓶颈，提供优化建议和实现方案
- **架构优化**：识别架构问题，提供架构重构建议
- **技术栈升级**：帮助将代码从旧技术栈升级到新技术栈

**使用案例**：
```

用户：请帮我重构这段代码，提高其性能和可维护性：

function calculateTotalPrice(items) {
let total = 0;
for (let i = 0; i < items.length; i++) {
if (items[i].price && items[i].quantity) {
total += items[i].price * items[i].quantity;
}
}
return total;
}

function calculateDiscount(total, discountPercent) {
if (discountPercent > 0 && discountPercent <= 100) {
return total * (1 - discountPercent / 100);
}
return total;
}

function calculateTax(amount, taxRate) {
if (taxRate > 0 && taxRate <= 100) {
return amount * (taxRate / 100);
}
return 0;
}

function calculateFinalPrice(items, discountPercent, taxRate) {
const subtotal = calculateTotalPrice(items);
const discounted = calculateDiscount(subtotal, discountPercent);
const tax = calculateTax(discounted, taxRate);
return discounted + tax;
}

Claude Code：

True. 代码分析：

函数职责明确，符合单一职责原则
缺少类型检查和错误处理
可以使用更现代的JavaScript特性
可以封装为一个价格计算类，提高可维护性和扩展性
True. 函数职责明确，符合单一职责原则
True. 缺少类型检查和错误处理
True. 可以使用更现代的JavaScript特性
True. 可以封装为一个价格计算类，提高可维护性和扩展性
True. 重构后的代码：

- 函数职责明确，符合单一职责原则
- 缺少类型检查和错误处理
- 可以使用更现代的JavaScript特性
- 可以封装为一个价格计算类，提高可维护性和扩展性

重构后的代码：

```
javascript复制class PriceCalculator {
  /**
   * 计算商品总价
   * @param {Array<{price: number, quantity: number}>} items - 商品列表
   * @returns {number} 商品总价
   */
  static calculateSubtotal(items) {
    if (!Array.isArray(items)) {
      throw new Error('Items must be an array');
    }

    return items.reduce((total, item) => {
      // 确保价格和数量是有效的数字
      const price = typeof item.price === 'number' && item.price > 0 ? item.price : 0;
      const quantity = typeof item.quantity === 'number' && item.quantity > 0 ? item.quantity : 0;

      return total + (price * quantity);
    }, 0);
  }

  /**
   * 计算折扣后的价格
   * @param {number} amount - 原始金额
   * @param {number} discountPercent - 折扣百分比 (0-100)
   * @returns {number} 折扣后的金额
   */
  static applyDiscount(amount, discountPercent) {
    // 验证输入
    if (typeof amount !== 'number' || amount < 0) {
      throw new Error('Amount must be a non-negative number');
    }

    if (typeof discountPercent !== 'number') {
      throw new Error('Discount percent must be a number');
    }

    // 限制折扣百分比在0-100之间
    const validDiscount = Math.max(0, Math.min(100, discountPercent));

    return amount * (1 - validDiscount / 100);
  }

  /**
   * 计算税费
   * @param {number} amount - 计税金额
   * @param {number} taxRate - 税率百分比 (0-100)
   * @returns {number} 税费金额
   */
  static calculateTax(amount, taxRate) {
    // 验证输入
    if (typeof amount !== 'number' || amount < 0) {
      throw new Error('Amount must be a non-negative number');
    }

    if (typeof taxRate !== 'number') {
      throw new Error('Tax rate must be a number');
    }

    // 限制税率在0-100之间
    const validTaxRate = Math.max(0, Math.min(100, taxRate));

    return amount * (validTaxRate / 100);
  }

  /**
   * 计算最终价格
   * @param {Array<{price: number, quantity: number}>} items - 商品列表
   * @param {number} discountPercent - 折扣百分比 (0-100)
   * @param {number} taxRate - 税率百分比 (0-100)
   * @returns {Object} 包含各项价格明细的对象
   */
  static calculateFinalPrice(items, discountPercent = 0, taxRate = 0) {
    const subtotal = this.calculateSubtotal(items);
    const discountedAmount = this.applyDiscount(subtotal, discountPercent);
    const tax = this.calculateTax(discountedAmount, taxRate);
    const finalPrice = discountedAmount + tax;

    return {
      subtotal: Number(subtotal.toFixed(2)),
      discount: Number((subtotal - discountedAmount).toFixed(2)),
      tax: Number(tax.toFixed(2)),
      finalPrice: Number(finalPrice.toFixed(2))
    };
  }
}

// 使用示例
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 },
  { price: 29.99, quantity: 3 }
];

try {
  const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
  console.log('Price breakdown:', result);
  // Output: { subtotal: 139.94, discount: 13.99, tax: 10.69, finalPrice: 136.64 }
} catch (error) {
  console.error('Error calculating price:', error.message);
}
```

```
class PriceCalculator {
  /**
   * 计算商品总价
   * @param {Array<{price: number, quantity: number}>} items - 商品列表
   * @returns {number} 商品总价
   */
  static calculateSubtotal(items) {
    if (!Array.isArray(items)) {
      throw new Error('Items must be an array');
    }

    return items.reduce((total, item) => {
      // 确保价格和数量是有效的数字
      const price = typeof item.price === 'number' && item.price > 0 ? item.price : 0;
      const quantity = typeof item.quantity === 'number' && item.quantity > 0 ? item.quantity : 0;

      return total + (price * quantity);
    }, 0);
  }

  /**
   * 计算折扣后的价格
   * @param {number} amount - 原始金额
   * @param {number} discountPercent - 折扣百分比 (0-100)
   * @returns {number} 折扣后的金额
   */
  static applyDiscount(amount, discountPercent) {
    // 验证输入
    if (typeof amount !== 'number' || amount < 0) {
      throw new Error('Amount must be a non-negative number');
    }

    if (typeof discountPercent !== 'number') {
      throw new Error('Discount percent must be a number');
    }

    // 限制折扣百分比在0-100之间
    const validDiscount = Math.max(0, Math.min(100, discountPercent));

    return amount * (1 - validDiscount / 100);
  }

  /**
   * 计算税费
   * @param {number} amount - 计税金额
   * @param {number} taxRate - 税率百分比 (0-100)
   * @returns {number} 税费金额
   */
  static calculateTax(amount, taxRate) {
    // 验证输入
    if (typeof amount !== 'number' || amount < 0) {
      throw new Error('Amount must be a non-negative number');
    }

    if (typeof taxRate !== 'number') {
      throw new Error('Tax rate must be a number');
    }

    // 限制税率在0-100之间
    const validTaxRate = Math.max(0, Math.min(100, taxRate));

    return amount * (validTaxRate / 100);
  }

  /**
   * 计算最终价格
   * @param {Array<{price: number, quantity: number}>} items - 商品列表
   * @param {number} discountPercent - 折扣百分比 (0-100)
   * @param {number} taxRate - 税率百分比 (0-100)
   * @returns {Object} 包含各项价格明细的对象
   */
  static calculateFinalPrice(items, discountPercent = 0, taxRate = 0) {
    const subtotal = this.calculateSubtotal(items);
    const discountedAmount = this.applyDiscount(subtotal, discountPercent);
    const tax = this.calculateTax(discountedAmount, taxRate);
    const finalPrice = discountedAmount + tax;

    return {
      subtotal: Number(subtotal.toFixed(2)),
      discount: Number((subtotal - discountedAmount).toFixed(2)),
      tax: Number(tax.toFixed(2)),
      finalPrice: Number(finalPrice.toFixed(2))
    };
  }
}

// 使用示例
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 },
  { price: 29.99, quantity: 3 }
];

try {
  const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
  console.log('Price breakdown:', result);
  // Output: { subtotal: 139.94, discount: 13.99, tax: 10.69, finalPrice: 136.64 }
} catch (error) {
  console.error('Error calculating price:', error.message);
}
```

True. 重构改进点：

封装为PriceCalculator类，提高可维护性和扩展性
添加了详细的JSDoc注释，提高代码可读性
添加了输入验证，提高代码健壮性
使用reduce方法替代for循环，更简洁高效
拆分了计算逻辑，每个方法只负责一个功能
返回完整的价格明细，方便调用者使用
添加了错误处理，提高代码可靠性
使用toFixed方法格式化结果，避免浮点数精度问题
True. 封装为PriceCalculator类，提高可维护性和扩展性
True. 添加了详细的JSDoc注释，提高代码可读性
True. 添加了输入验证，提高代码健壮性
True. 使用reduce方法替代for循环，更简洁高效
True. 拆分了计算逻辑，每个方法只负责一个功能
True. 返回完整的价格明细，方便调用者使用
True. 添加了错误处理，提高代码可靠性
True. 使用toFixed方法格式化结果，避免浮点数精度问题

- 封装为PriceCalculator类，提高可维护性和扩展性
- 添加了详细的JSDoc注释，提高代码可读性
- 添加了输入验证，提高代码健壮性
- 使用reduce方法替代for循环，更简洁高效
- 拆分了计算逻辑，每个方法只负责一个功能
- 返回完整的价格明细，方便调用者使用
- 添加了错误处理，提高代码可靠性
- 使用toFixed方法格式化结果，避免浮点数精度问题

```
bash复制## 1.4.3 自动化测试场景

Claude Code能够帮助开发者生成和运行测试用例，提高测试覆盖率和代码质量：

- **测试用例生成**：根据代码自动生成单元测试、集成测试和端到端测试用例
- **测试数据生成**：生成各种测试数据，包括边界情况和异常情况
- **测试执行**：运行测试用例并分析测试结果
- **测试报告生成**：生成详细的测试报告，包括覆盖率分析和失败原因

**使用案例**：
```

```
## 1.4.3 自动化测试场景

Claude Code能够帮助开发者生成和运行测试用例，提高测试覆盖率和代码质量：

- **测试用例生成**：根据代码自动生成单元测试、集成测试和端到端测试用例
- **测试数据生成**：生成各种测试数据，包括边界情况和异常情况
- **测试执行**：运行测试用例并分析测试结果
- **测试报告生成**：生成详细的测试报告，包括覆盖率分析和失败原因

**使用案例**：
```

用户：请帮我为刚才重构的PriceCalculator类生成单元测试用例。
Claude Code：

True. 测试策略：

测试正常情况
测试边界情况
测试异常情况
测试各种组合情况
True. 测试正常情况
True. 测试边界情况
True. 测试异常情况
True. 测试各种组合情况
True. 生成的测试用例（使用Jest框架）：

- 测试正常情况
- 测试边界情况
- 测试异常情况
- 测试各种组合情况

生成的测试用例（使用Jest框架）：

```
javascript复制const PriceCalculator = require('./PriceCalculator');

describe('PriceCalculator', () => {
  describe('calculateSubtotal', () => {
    test('should return 0 for empty array', () => {
      expect(PriceCalculator.calculateSubtotal([])).toBe(0);
    });

    test('should return 0 for array with invalid items', () => {
      expect(PriceCalculator.calculateSubtotal([{ price: 'invalid', quantity: 'invalid' }])).toBe(0);
    });

    test('should calculate correct subtotal for valid items', () => {
      const items = [
        { price: 10, quantity: 2 },
        { price: 20, quantity: 3 }
      ];
      expect(PriceCalculator.calculateSubtotal(items)).toBe(80); // (10*2) + (20*3) = 20 + 60 = 80
    });

    test('should handle items with zero price or quantity', () => {
      const items = [
        { price: 10, quantity: 0 },
        { price: 0, quantity: 5 },
        { price: 20, quantity: 2 }
      ];
      expect(PriceCalculator.calculateSubtotal(items)).toBe(40); // Only, third item contributes
    });

    test('should throw error for non-array input', () => {
      expect(() => PriceCalculator.calculateSubtotal('invalid')).toThrow('Items must be an array');
    });
  });

  describe('applyDiscount', () => {
    test('should return original amount for 0% discount', () => {
      expect(PriceCalculator.applyDiscount(100, 0)).toBe(100);
    });

    test('should return 0 for 100% discount', () => {
      expect(PriceCalculator.applyDiscount(100, 100)).toBe(0);
    });

    test('should calculate correct discount for valid percentage', () => {
      expect(PriceCalculator.applyDiscount(100, 20)).toBe(80); // 100 - 20% = 80
    });

    test('should cap discount at 100%', () => {
      expect(PriceCalculator.applyDiscount(100, 150)).toBe(0); // Discount cannot exceed 100%
    });

    test('should floor discount at 0%', () => {
      expect(PriceCalculator.applyDiscount(100, -50)).toBe(100); // Discount cannot be negative
    });

    test('should throw error for negative amount', () => {
      expect(() => PriceCalculator.applyDiscount(-100, 20)).toThrow('Amount must be a non-negative number');
    });

    test('should throw error for non-number discount', () => {
      expect(() => PriceCalculator.applyDiscount(100, 'invalid')).toThrow('Discount percent must be a number');
    });
  });

  describe('calculateTax', () => {
    test('should return 0 for 0% tax rate', () => {
      expect(PriceCalculator.calculateTax(100, 0)).toBe(0);
    });

    test('should calculate correct tax for valid rate', () => {
      expect(PriceCalculator.calculateTax(100, 8.25)).toBe(8.25); // 8.25% of 100 is 8.25
    });

    test('should cap tax rate at 100%', () => {
      expect(PriceCalculator.calculateTax(100, 150)).toBe(100); // Tax rate cannot exceed 100%
    });

    test('should floor tax rate at 0%', () => {
      expect(PriceCalculator.calculateTax(100, -50)).toBe(0); // Tax rate cannot be negative
    });

    test('should throw error for negative amount', () => {
      expect(() => PriceCalculator.calculateTax(-100, 8.25)).toThrow('Amount must be a non-negative number');
    });

    test('should throw error for non-number tax rate', () => {
      expect(() => PriceCalculator.calculateTax(100, 'invalid')).toThrow('Tax rate must be a number');
    });
  });

  describe('calculateFinalPrice', () => {
    test('should return correct price breakdown for valid input', () => {
      const items = [
        { price: 19.99, quantity: 2 },
        { price: 9.99, quantity: 1 }
      ];
      const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);

      expect(result).toEqual({
        subtotal: 49.97,
        discount: 4.997, // 10% of 49.97
        tax: 3.648, // 8.25% of (49.97 - 4.997)
        finalPrice: 48.621 // (49.97 - 4.997) + 3.648
      });
    });

    test('should use default values when discount and tax rate are not provided', () => {
      const items = [{ price: 100, quantity: 1 }];
      const result = PriceCalculator.calculateFinalPrice(items);

      expect(result).toEqual({
        subtotal: 100,
        discount: 0,
        tax: 0,
        finalPrice: 100
      });
    });

    test('should handle empty items array', () => {
      const result = PriceCalculator.calculateFinalPrice([], 10, 8.25);

      expect(result).toEqual({
        subtotal: 0,
        discount: 0,
        tax: 0,
        finalPrice: 0
      });
    });

    test('should throw error for invalid items', () => {
      expect(() => PriceCalculator.calculateFinalPrice('invalid', 10, 8.25)).toThrow('Items must be an array');
    });
  });
});
~~~
## 1.4.4 数据分析场景

### 数据处理与分析

Claude Code能够帮助开发者处理和分析数据，提取有价值的信息：

- **数据清洗**：识别和处理数据中的缺失值、异常值和重复值
- **数据转换**：将数据从一种格式转换为另一种格式
- **数据分析**：进行统计分析、趋势分析和关联分析
- **数据可视化**：生成各种图表和可视化报告

**使用案例**：
~~~
用户：我有一个包含销售数据的CSV文件，请帮我分析销售趋势并生成可视化报告。
Claude Code：

1. 分析需求：
   - 读取CSV文件
   - 分析销售趋势（按时间、地区、产品类别）
   - 生成可视化图表
   - 输出分析报告

2. 实现代码：
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

# 读取数据
df = pd.read_csv('sales_data.csv')

# 数据清洗
df['date'] = pd.to_datetime(df['date'])
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['quarter'] = df['date'].dt.quarter

# 销售趋势分析
def analyze_sales_trends(df):
    # 按时间分析
    monthly_sales = df.groupby(['year', 'month'])['revenue'].sum().reset_index()
    monthly_sales['date'] = pd.to_datetime(
        monthly_sales['year'].astype(str) + '-' + monthly_sales['month'].astype(str) + '-01'
    )

    # 按地区分析
    regional_sales = df.groupby('region')['revenue'].sum().sort_values(ascending=False)

    # 按产品类别分析
    category_sales = df.groupby('category')['revenue'].sum().sort_values(ascending=False)

    return monthly_sales, regional_sales, category_sales

# 生成可视化
def create_visualizations(df, monthly_sales, regional_sales, category_sales):
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))

    # 1. 月度销售趋势
    axes[0, 0].plot(monthly_sales['date'], monthly_sales['revenue'], marker='o')
    axes[0, 0].set_title('Monthly Sales Trend')
    axes[0, 0].set_xlabel('Date')
    axes[0, 0].set_ylabel('Revenue')
    axes[0, 0].grid(True)
    axes[0, 0].tick_params(axis='x', rotation=45)

    # 2. 地区销售分布
    regional_sales.plot(kind='bar', ax=axes[0, 1], color='skyblue')
    axes[0, 1].set_title('Sales by Region')
    axes[0, 1].set_xlabel('Region')
    axes[0, 1].set_ylabel('Revenue')
    axes[0, 1].tick_params(axis='x', rotation=45)

    # 3. 产品类别销售
    category_sales.plot(kind='bar', ax=axes[1, 0], color='lightcoral')
    axes[1, 0].set_title('Sales by Category')
    axes[1, 0].set_xlabel('Category')
    axes[1, 0].set_ylabel('Revenue')
    axes[1, 0].tick_params(axis='x', rotation=45)

    # 4. 销售热力图（按季度和地区）
    pivot_table = df.pivot_table(
        values='revenue',
        index='quarter',
        columns='region',
        aggfunc='sum'
    )
    sns.heatmap(pivot_table, annot=True, fmt='.0f', cmap='YlOrRd', ax=axes[1, 1])
    axes[1, 1].set_title('Sales Heatmap (Quarter vs Region)')

    plt.tight_layout()
    plt.savefig('sales_analysis_report.png', dpi=300, bbox_inches='tight')
    plt.show()

# 执行分析
monthly_sales, regional_sales, category_sales = analyze_sales_trends(df)
create_visualizations(df, monthly_sales, regional_sales, category_sales)

# 生成文本报告
def generate_report(df, monthly_sales, regional_sales, category_sales):
    report = f"""
    销售数据分析报告
    =================

    数据概览：
    - 总销售额: ${df['revenue'].sum():,.2f}
    - 总订单数: {len(df):,}
    - 平均订单金额: ${df['revenue'].mean():,.2f}
    - 数据时间范围: {df['date'].min()} 至 {df['date'].max()}

    地区销售排名：
    """

    for i, (region, revenue) in enumerate(regional_sales.items(), 1):
        report += f"{i}. {region}: ${revenue:,.2f}\n"

    report += "\n产品类别销售排名：\n"
    for i, (category, revenue) in enumerate(category_sales.items(), 1):
        report += f"{i}. {category}: ${revenue:,.2f}\n"

    return report

report = generate_report(df, monthly_sales, regional_sales, category_sales)
print(report)

# 保存报告
with open('sales_analysis_report.txt', 'w', encoding='utf-8') as f:
    f.write(report)
~~~
## 1.4.5 文档编写场景

Claude Code能够帮助开发者编写各种技术文档：

- **API文档**：根据代码自动生成API文档
- **用户手册**：编写用户使用手册和教程
- **技术博客**：生成技术博客文章和教程
- **代码注释**：为代码添加和完善注释

**使用案例**：
~~~
用户：请帮我为刚才的PriceCalculator类生成完整的API文档。
Claude Code：

生成的API文档：

# PriceCalculator API 文档

## 概述

PriceCalculator 是一个用于计算商品价格的工具类，支持商品总价计算、折扣应用、税费计算和最终价格计算。

## 方法

### calculateSubtotal(items)

计算商品列表的总价。

**参数：**
- `items` (Array<{price: number, quantity: number}>): 商品列表，每个商品包含价格和数量

**返回值：**
- `number`: 商品总价

**异常：**
- `Error`: 当输入不是数组时抛出

**示例：**
```javascript
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 }
];
const subtotal = PriceCalculator.calculateSubtotal(items);
// 返回: 49.97
```

```
const PriceCalculator = require('./PriceCalculator');

describe('PriceCalculator', () => {
  describe('calculateSubtotal', () => {
    test('should return 0 for empty array', () => {
      expect(PriceCalculator.calculateSubtotal([])).toBe(0);
    });

    test('should return 0 for array with invalid items', () => {
      expect(PriceCalculator.calculateSubtotal([{ price: 'invalid', quantity: 'invalid' }])).toBe(0);
    });

    test('should calculate correct subtotal for valid items', () => {
      const items = [
        { price: 10, quantity: 2 },
        { price: 20, quantity: 3 }
      ];
      expect(PriceCalculator.calculateSubtotal(items)).toBe(80); // (10*2) + (20*3) = 20 + 60 = 80
    });

    test('should handle items with zero price or quantity', () => {
      const items = [
        { price: 10, quantity: 0 },
        { price: 0, quantity: 5 },
        { price: 20, quantity: 2 }
      ];
      expect(PriceCalculator.calculateSubtotal(items)).toBe(40); // Only, third item contributes
    });

    test('should throw error for non-array input', () => {
      expect(() => PriceCalculator.calculateSubtotal('invalid')).toThrow('Items must be an array');
    });
  });

  describe('applyDiscount', () => {
    test('should return original amount for 0% discount', () => {
      expect(PriceCalculator.applyDiscount(100, 0)).toBe(100);
    });

    test('should return 0 for 100% discount', () => {
      expect(PriceCalculator.applyDiscount(100, 100)).toBe(0);
    });

    test('should calculate correct discount for valid percentage', () => {
      expect(PriceCalculator.applyDiscount(100, 20)).toBe(80); // 100 - 20% = 80
    });

    test('should cap discount at 100%', () => {
      expect(PriceCalculator.applyDiscount(100, 150)).toBe(0); // Discount cannot exceed 100%
    });

    test('should floor discount at 0%', () => {
      expect(PriceCalculator.applyDiscount(100, -50)).toBe(100); // Discount cannot be negative
    });

    test('should throw error for negative amount', () => {
      expect(() => PriceCalculator.applyDiscount(-100, 20)).toThrow('Amount must be a non-negative number');
    });

    test('should throw error for non-number discount', () => {
      expect(() => PriceCalculator.applyDiscount(100, 'invalid')).toThrow('Discount percent must be a number');
    });
  });

  describe('calculateTax', () => {
    test('should return 0 for 0% tax rate', () => {
      expect(PriceCalculator.calculateTax(100, 0)).toBe(0);
    });

    test('should calculate correct tax for valid rate', () => {
      expect(PriceCalculator.calculateTax(100, 8.25)).toBe(8.25); // 8.25% of 100 is 8.25
    });

    test('should cap tax rate at 100%', () => {
      expect(PriceCalculator.calculateTax(100, 150)).toBe(100); // Tax rate cannot exceed 100%
    });

    test('should floor tax rate at 0%', () => {
      expect(PriceCalculator.calculateTax(100, -50)).toBe(0); // Tax rate cannot be negative
    });

    test('should throw error for negative amount', () => {
      expect(() => PriceCalculator.calculateTax(-100, 8.25)).toThrow('Amount must be a non-negative number');
    });

    test('should throw error for non-number tax rate', () => {
      expect(() => PriceCalculator.calculateTax(100, 'invalid')).toThrow('Tax rate must be a number');
    });
  });

  describe('calculateFinalPrice', () => {
    test('should return correct price breakdown for valid input', () => {
      const items = [
        { price: 19.99, quantity: 2 },
        { price: 9.99, quantity: 1 }
      ];
      const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);

      expect(result).toEqual({
        subtotal: 49.97,
        discount: 4.997, // 10% of 49.97
        tax: 3.648, // 8.25% of (49.97 - 4.997)
        finalPrice: 48.621 // (49.97 - 4.997) + 3.648
      });
    });

    test('should use default values when discount and tax rate are not provided', () => {
      const items = [{ price: 100, quantity: 1 }];
      const result = PriceCalculator.calculateFinalPrice(items);

      expect(result).toEqual({
        subtotal: 100,
        discount: 0,
        tax: 0,
        finalPrice: 100
      });
    });

    test('should handle empty items array', () => {
      const result = PriceCalculator.calculateFinalPrice([], 10, 8.25);

      expect(result).toEqual({
        subtotal: 0,
        discount: 0,
        tax: 0,
        finalPrice: 0
      });
    });

    test('should throw error for invalid items', () => {
      expect(() => PriceCalculator.calculateFinalPrice('invalid', 10, 8.25)).toThrow('Items must be an array');
    });
  });
});
~~~
## 1.4.4 数据分析场景

### 数据处理与分析

Claude Code能够帮助开发者处理和分析数据，提取有价值的信息：

- **数据清洗**：识别和处理数据中的缺失值、异常值和重复值
- **数据转换**：将数据从一种格式转换为另一种格式
- **数据分析**：进行统计分析、趋势分析和关联分析
- **数据可视化**：生成各种图表和可视化报告

**使用案例**：
~~~
用户：我有一个包含销售数据的CSV文件，请帮我分析销售趋势并生成可视化报告。
Claude Code：

1. 分析需求：
   - 读取CSV文件
   - 分析销售趋势（按时间、地区、产品类别）
   - 生成可视化图表
   - 输出分析报告

2. 实现代码：
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

# 读取数据
df = pd.read_csv('sales_data.csv')

# 数据清洗
df['date'] = pd.to_datetime(df['date'])
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['quarter'] = df['date'].dt.quarter

# 销售趋势分析
def analyze_sales_trends(df):
    # 按时间分析
    monthly_sales = df.groupby(['year', 'month'])['revenue'].sum().reset_index()
    monthly_sales['date'] = pd.to_datetime(
        monthly_sales['year'].astype(str) + '-' + monthly_sales['month'].astype(str) + '-01'
    )

    # 按地区分析
    regional_sales = df.groupby('region')['revenue'].sum().sort_values(ascending=False)

    # 按产品类别分析
    category_sales = df.groupby('category')['revenue'].sum().sort_values(ascending=False)

    return monthly_sales, regional_sales, category_sales

# 生成可视化
def create_visualizations(df, monthly_sales, regional_sales, category_sales):
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))

    # 1. 月度销售趋势
    axes[0, 0].plot(monthly_sales['date'], monthly_sales['revenue'], marker='o')
    axes[0, 0].set_title('Monthly Sales Trend')
    axes[0, 0].set_xlabel('Date')
    axes[0, 0].set_ylabel('Revenue')
    axes[0, 0].grid(True)
    axes[0, 0].tick_params(axis='x', rotation=45)

    # 2. 地区销售分布
    regional_sales.plot(kind='bar', ax=axes[0, 1], color='skyblue')
    axes[0, 1].set_title('Sales by Region')
    axes[0, 1].set_xlabel('Region')
    axes[0, 1].set_ylabel('Revenue')
    axes[0, 1].tick_params(axis='x', rotation=45)

    # 3. 产品类别销售
    category_sales.plot(kind='bar', ax=axes[1, 0], color='lightcoral')
    axes[1, 0].set_title('Sales by Category')
    axes[1, 0].set_xlabel('Category')
    axes[1, 0].set_ylabel('Revenue')
    axes[1, 0].tick_params(axis='x', rotation=45)

    # 4. 销售热力图（按季度和地区）
    pivot_table = df.pivot_table(
        values='revenue',
        index='quarter',
        columns='region',
        aggfunc='sum'
    )
    sns.heatmap(pivot_table, annot=True, fmt='.0f', cmap='YlOrRd', ax=axes[1, 1])
    axes[1, 1].set_title('Sales Heatmap (Quarter vs Region)')

    plt.tight_layout()
    plt.savefig('sales_analysis_report.png', dpi=300, bbox_inches='tight')
    plt.show()

# 执行分析
monthly_sales, regional_sales, category_sales = analyze_sales_trends(df)
create_visualizations(df, monthly_sales, regional_sales, category_sales)

# 生成文本报告
def generate_report(df, monthly_sales, regional_sales, category_sales):
    report = f"""
    销售数据分析报告
    =================

    数据概览：
    - 总销售额: ${df['revenue'].sum():,.2f}
    - 总订单数: {len(df):,}
    - 平均订单金额: ${df['revenue'].mean():,.2f}
    - 数据时间范围: {df['date'].min()} 至 {df['date'].max()}

    地区销售排名：
    """

    for i, (region, revenue) in enumerate(regional_sales.items(), 1):
        report += f"{i}. {region}: ${revenue:,.2f}\n"

    report += "\n产品类别销售排名：\n"
    for i, (category, revenue) in enumerate(category_sales.items(), 1):
        report += f"{i}. {category}: ${revenue:,.2f}\n"

    return report

report = generate_report(df, monthly_sales, regional_sales, category_sales)
print(report)

# 保存报告
with open('sales_analysis_report.txt', 'w', encoding='utf-8') as f:
    f.write(report)
~~~
## 1.4.5 文档编写场景

Claude Code能够帮助开发者编写各种技术文档：

- **API文档**：根据代码自动生成API文档
- **用户手册**：编写用户使用手册和教程
- **技术博客**：生成技术博客文章和教程
- **代码注释**：为代码添加和完善注释

**使用案例**：
~~~
用户：请帮我为刚才的PriceCalculator类生成完整的API文档。
Claude Code：

生成的API文档：

# PriceCalculator API 文档

## 概述

PriceCalculator 是一个用于计算商品价格的工具类，支持商品总价计算、折扣应用、税费计算和最终价格计算。

## 方法

### calculateSubtotal(items)

计算商品列表的总价。

**参数：**
- `items` (Array<{price: number, quantity: number}>): 商品列表，每个商品包含价格和数量

**返回值：**
- `number`: 商品总价

**异常：**
- `Error`: 当输入不是数组时抛出

**示例：**
```javascript
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 }
];
const subtotal = PriceCalculator.calculateSubtotal(items);
// 返回: 49.97
```

##### applyDiscount(amount, discountPercent)#

计算折扣后的金额。

- amount (number): 原始金额
- discountPercent (number): 折扣百分比，范围 0-100

```
amount
```

```
discountPercent
```

- number: 折扣后的金额

```
number
```

- Error: 当金额为负数或折扣百分比不是数字时抛出

```
Error
```

```
javascript复制const discounted = PriceCalculator.applyDiscount(100, 20);
// 返回: 80
```

```
const discounted = PriceCalculator.applyDiscount(100, 20);
// 返回: 80
```

##### calculateTax(amount, taxRate)#

- amount (number): 计税金额
- taxRate (number): 税率百分比，范围 0-100

```
amount
```

```
taxRate
```

- number: 税费金额

```
number
```

- Error: 当金额为负数或税率不是数字时抛出

```
Error
```

```
javascript复制const tax = PriceCalculator.calculateTax(100, 8.25);
// 返回: 8.25
```

```
const tax = PriceCalculator.calculateTax(100, 8.25);
// 返回: 8.25
```

##### calculateFinalPrice(items, discountPercent, taxRate)#

计算最终价格，包含所有明细。

- items (Array<{price: number, quantity: number}>): 商品列表
- discountPercent (number, 可选): 折扣百分比，默认为 0
- taxRate (number, 可选): 税率百分比，默认为 0

```
items
```

```
discountPercent
```

```
taxRate
```

- Object: 包含价格明细的对象

subtotal (number): 商品总价
discount (number): 折扣金额
tax (number): 税费金额
finalPrice (number): 最终价格
- subtotal (number): 商品总价
- discount (number): 折扣金额
- tax (number): 税费金额
- finalPrice (number): 最终价格

```
Object
```

- subtotal (number): 商品总价
- discount (number): 折扣金额
- tax (number): 税费金额
- finalPrice (number): 最终价格

```
subtotal
```

```
discount
```

```
tax
```

```
finalPrice
```

- Error: 当商品列表不是数组时抛出

```
Error
```

```
javascript复制const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 }
];
const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
// 返回: { subtotal: 49.97, discount: 4.997, tax: 3.648, finalPrice: 48.621 }
```

```
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 }
];
const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
// 返回: { subtotal: 49.97, discount: 4.997, tax: 3.648, finalPrice: 48.621 }
```

#### 使用示例#

```
javascript复制const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 },
  { price: 29.99, quantity: 3 }
];

try {
  const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
  console.log('Price breakdown:', result);
} catch (error) {
  console.error('Error calculating price:', error.message);
}
```

```
const items = [
  { price: 19.99, quantity: 2 },
  { price: 9.99, quantity: 1 },
  { price: 29.99, quantity: 3 }
];

try {
  const result = PriceCalculator.calculateFinalPrice(items, 10, 8.25);
  console.log('Price breakdown:', result);
} catch (error) {
  console.error('Error calculating price:', error.message);
}
```

#### 注意事项#

True. 所有金额值都会被格式化为两位小数
True. 折扣百分比和税率会被限制在 0-100 的范围内
True. 无效的价格或数量会被视为 0
True. 所有方法都是静态方法，不需要实例化类

```
bash复制## 1.4.6 学习与教学场景

Claude Code可以作为学习和教学的有力工具：

- **代码解释**：解释复杂代码的逻辑和工作原理
- **概念讲解**：讲解编程概念、设计模式和最佳实践
- **练习生成**：生成编程练习题和答案
- **学习路径规划**：为学习者制定个性化的学习路径

**使用案例**：
```

```
## 1.4.6 学习与教学场景

Claude Code可以作为学习和教学的有力工具：

- **代码解释**：解释复杂代码的逻辑和工作原理
- **概念讲解**：讲解编程概念、设计模式和最佳实践
- **练习生成**：生成编程练习题和答案
- **学习路径规划**：为学习者制定个性化的学习路径

**使用案例**：
```

用户：请帮我解释一下React中的useEffect钩子是如何工作的。
Claude Code：
useEffect 是 React 中最重要的 Hooks 之一，它让你能够在函数组件中执行副作用操作。

#### 基本概念#

副作用（Side Effect）是指函数外部可观察到的操作，例如：

- 数据获取（API调用）
- 订阅事件
- 手动修改 DOM
- 设置定时器
- 记录日志

#### useEffect 的工作原理#

##### 1. 基本语法#

```
javascript复制useEffect(() => {
  // 副作用代码
  return () => {
    // 清理函数（可选）
  };
}, [依赖项数组]);
```

```
useEffect(() => {
  // 副作用代码
  return () => {
    // 清理函数（可选）
  };
}, [依赖项数组]);
```

##### 2. 执行时机#

useEffect 在以下时机执行：

- 组件首次渲染后
- 依赖项数组中的值发生变化后

##### 3. 依赖项数组的作用#

依赖项数组控制 useEffect 的执行频率：

```
javascript复制// 每次渲染后都执行
useEffect(() => {
  console.log('每次渲染都执行');
});

// 只在首次渲染后执行一次
useEffect(() => {
  console.log('只执行一次');
}, []);

// 当 count 变化时执行
useEffect(() => {
  console.log('count 变化了:', count);
}, [count]);

// 当 count 或 name 变化时执行
useEffect(() => {
  console.log('count 或 name 变化了');
}, [count, name]);
```

```
// 每次渲染后都执行
useEffect(() => {
  console.log('每次渲染都执行');
});

// 只在首次渲染后执行一次
useEffect(() => {
  console.log('只执行一次');
}, []);

// 当 count 变化时执行
useEffect(() => {
  console.log('count 变化了:', count);
}, [count]);

// 当 count 或 name 变化时执行
useEffect(() => {
  console.log('count 或 name 变化了');
}, [count, name]);
```

##### 4. 清理函数#

清理函数在以下时机执行：

- 组件卸载时
- 下一次 useEffect 执行之前

```
javascript复制useEffect(() => {
  const timer = setInterval(() => {
    console.log('定时器执行');
  }, 1000);

  // 返回清理函数
  return () => {
    clearInterval(timer);
    console.log('清理定时器');
  };
}, []);
```

```
useEffect(() => {
  const timer = setInterval(() => {
    console.log('定时器执行');
  }, 1000);

  // 返回清理函数
  return () => {
    clearInterval(timer);
    console.log('清理定时器');
  };
}, []);
```

#### 实际应用示例#

##### 1. 数据获取#

```
javascript复制useEffect(() => {
  const fetchData = async () => {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    setData(data);
  };

  fetchData();
}, []); // 空依赖数组，只执行一次
```

```
useEffect(() => {
  const fetchData = async () => {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    setData(data);
  };

  fetchData();
}, []); // 空依赖数组，只执行一次
```

##### 2. 监听窗口大小变化#

```
javascript复制useEffect(() => {
  const handleResize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

```
useEffect(() => {
  const handleResize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

##### 3. 表单验证#

```
javascript复制useEffect(() => {
  if (email && password) {
    setIsValid(validateEmail(email) && password.length >= 8);
  } else {
    setIsValid(false);
  }
}, [email, password]);
```

```
useEffect(() => {
  if (email && password) {
    setIsValid(validateEmail(email) && password.length >= 8);
  } else {
    setIsValid(false);
  }
}, [email, password]);
```

#### 常见陷阱#

##### 1. 遗漏依赖项#

```
javascript复制// 错误：遗漏了依赖项
useEffect(() => {
  console.log(count);
}, []); // 应该包含 [count]

// 正确
useEffect(() => {
  console.log(count);
}, [count]);
```

```
// 错误：遗漏了依赖项
useEffect(() => {
  console.log(count);
}, []); // 应该包含 [count]

// 正确
useEffect(() => {
  console.log(count);
}, [count]);
```

##### 2. 无限循环#

```
javascript复制// 错误：在 useEffect 中修改依赖项
useEffect(() => {
  setCount(count + 1); // 这会导致无限循环
}, [count]);
```

```
// 错误：在 useEffect 中修改依赖项
useEffect(() => {
  setCount(count + 1); // 这会导致无限循环
}, [count]);
```

##### 3. 过度使用清理函数#

```
javascript复制// 不必要：没有副作用不需要清理
useEffect(() => {
  const result = calculateSomething();
  return () => {
    // 不需要清理
  };
}, []);
```

```
// 不必要：没有副作用不需要清理
useEffect(() => {
  const result = calculateSomething();
  return () => {
    // 不需要清理
  };
}, []);
```

#### 最佳实践#

True. 明确依赖项：始终在依赖项数组中列出所有使用的变量
True. 合理使用清理函数：只在需要时使用清理函数
True. 拆分 useEffect：将不同的副作用拆分到不同的 useEffect 中
True. 避免过度优化：不要为了性能而过度拆分 useEffect

#### 总结#

useEffect 是处理副作用的强大工具，理解它的工作原理和最佳实践对于编写高质量的 React 应用至关重要。通过合理使用 useEffect，你可以：

- 管理组件的生命周期
- 处理异步操作
- 响应状态变化
- 清理资源

记住：useEffect 的核心是"响应式"——它响应依赖项的变化，并在适当的时候执行副作用。

---

# 第 2 章

## 1 系统要求与环境准备

**URL**: https://claudecode.tangshuang.net/course/2.1%20%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87

#### 2.1.1 系统要求#

在安装Claude Code之前，确保你的系统满足以下要求：

##### 2.1.1.1 操作系统#

- Windows: Windows 10 或更高版本，64位
- macOS: macOS 10.15 (Catalina) 或更高版本
- Linux: Ubuntu 18.04 或更高版本，或其他兼容的Linux发行版

##### 2.1.1.2 硬件要求#

- CPU: 至少4核处理器
- 内存: 至少8GB RAM（推荐16GB或更高）
- 磁盘空间: 至少1GB可用空间
- 网络: 稳定的互联网连接（用于授权验证和功能更新）

##### 2.1.1.3 软件要求#

- Node.js: 版本16.0或更高（用于命令行工具）
- npm: 版本8.0或更高（Node.js包管理器）
- Git: 版本2.0或更高（用于代码管理和插件安装）

#### 2.1.2 环境准备#

##### 2.1.2.1 安装Node.js和npm#

Claude Code的命令行工具依赖Node.js和npm，因此需要先确保它们已正确安装。

###### 检查Node.js和npm版本

打开终端或命令提示符，运行以下命令检查Node.js和npm版本：

```
bash复制# 检查Node.js版本
node --version
```

```
# 检查Node.js版本
node --version
```

### 检查npm版本

npm --version

```
bash复制
如果输出显示Node.js版本≥16.0和npm版本≥8.0，则可以跳过安装步骤。
#### 安装Node.js
如果没有安装Node.js或版本不符合要求，可以通过以下方式安装：
##### 方式一：使用官方安装包
1. 访问Node.js官方网站：https://nodejs.org/
2. 下载适合你操作系统的LTS（长期支持）版本
3. 运行安装程序，按照提示完成安装
4. 安装完成后，重新打开终端，验证Node.js和npm版本
##### 方式二：使用Node版本管理器（推荐）
使用Node版本管理器可以方便地管理多个Node.js版本，推荐使用nvm（Node Version Manager）：
**对于macOS和Linux：**
```bash
# 安装nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash
# 或使用wget
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash

# 安装完成后，重新打开终端，安装Node.js LTS版本
nvm install --lts

# 验证安装
node --version
npm --version

nvm install lts
nvm use lts
# 验证安装
node --version
npm --version
```

```
如果输出显示Node.js版本≥16.0和npm版本≥8.0，则可以跳过安装步骤。
#### 安装Node.js
如果没有安装Node.js或版本不符合要求，可以通过以下方式安装：
##### 方式一：使用官方安装包
1. 访问Node.js官方网站：https://nodejs.org/
2. 下载适合你操作系统的LTS（长期支持）版本
3. 运行安装程序，按照提示完成安装
4. 安装完成后，重新打开终端，验证Node.js和npm版本
##### 方式二：使用Node版本管理器（推荐）
使用Node版本管理器可以方便地管理多个Node.js版本，推荐使用nvm（Node Version Manager）：
**对于macOS和Linux：**
```bash
# 安装nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash
# 或使用wget
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash

# 安装完成后，重新打开终端，安装Node.js LTS版本
nvm install --lts

# 验证安装
node --version
npm --version

nvm install lts
nvm use lts
# 验证安装
node --version
npm --version
```

##### 2.1.2.2 安装Git#

Claude Code使用Git进行代码管理和插件安装，因此需要确保Git已正确安装。

###### 检查Git版本

打开终端或命令提示符，运行以下命令检查Git版本：

```
bash复制git --version
```

```
git --version
```

如果输出显示Git版本≥2.0，则可以跳过安装步骤。

###### 安装Git

对于macOS：

macOS系统可能已预装Git，你可以通过以下方式更新到最新版本：

```
bash复制# 使用Homebrew安装（推荐）
brew install git
# 或使用Xcode Command Line Tools
xcode-select --install
```

```
# 使用Homebrew安装（推荐）
brew install git
# 或使用Xcode Command Line Tools
xcode-select --install
```

对于Windows：

True. 访问Git官方网站：https://git-scm.com/
True. 下载适合Windows的Git安装程序
True. 运行安装程序，按照提示完成安装（建议使用默认配置）
对于Linux：
使用包管理器安装Git：

```
bash复制# Ubuntu/Debian
sudo apt-get update
sudo apt-get install git

# CentOS/RHEL
sudo yum install git

# Fedora
sudo dnf install git
```

```
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install git

# CentOS/RHEL
sudo yum install git

# Fedora
sudo dnf install git
```

##### 2.1.2.3 配置Git#

安装Git后，需要配置用户名和电子邮件，这些信息将用于代码提交：

```
bash复制git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

```
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

#### 2.1.3 环境验证#

完成上述安装后，运行以下命令验证环境是否准备就绪：

```
bash复制# 验证Node.js版本
node --version

# 验证npm版本
npm --version

# 验证Git版本
git --version
```

```
# 验证Node.js版本
node --version

# 验证npm版本
npm --version

# 验证Git版本
git --version
```

如果所有命令都能正常输出且版本符合要求，则说明环境准备就绪，可以开始安装Claude Code了。

#### 2.1.4 常见问题与解决方案#

##### 2.1.4.1 Node.js安装失败#

问题：运行node --version时显示"command not found"

```
node --version
```

- 检查安装过程是否有错误
- 确保Node.js的安装路径已添加到系统环境变量中
- 重新启动终端或命令提示符
- 尝试使用Node版本管理器重新安装

##### 2.1.4.2 npm安装包失败#

问题：使用npm安装包时显示网络错误或权限错误

- 检查网络连接
- 尝试使用npm镜像（如淘宝镜像）：npm config set registry https://registry.npmmirror.com
- 对于权限错误，尝试使用sudo（Linux/macOS）或以管理员身份运行命令提示符（Windows）
- 检查npm配置：npm config list

```
npm config set registry https://registry.npmmirror.com
```

```
sudo
```

```
npm config list
```

##### 2.1.4.3 Git配置错误#

问题：Git提交时显示用户名或电子邮件未配置

- 确保已正确配置Git用户名和电子邮件
- 检查配置：git config --list
- 如果全局配置不起作用，尝试在项目目录中进行本地配置

```
git config --list
```

#### 2.1.5 高级环境配置#

##### 2.1.5.1 使用yarn或pnpm替代npm#

如果你更喜欢使用yarn或pnpm作为包管理器，Claude Code也支持它们：

安装yarn：

```
bash复制npm install -g yarn
```

```
npm install -g yarn
```

安装pnpm：

```
bash复制npm install -g pnpm
```

```
npm install -g pnpm
```

##### 2.1.5.2 配置npm镜像#

为了提高npm包的下载速度，可以配置npm镜像：

```
bash复制# 使用淘宝镜像
npm config set registry https://registry.npmmirror.com
# 或使用npm官方镜像
npm config set registry https://registry.npmjs.org/
```

```
# 使用淘宝镜像
npm config set registry https://registry.npmmirror.com
# 或使用npm官方镜像
npm config set registry https://registry.npmjs.org/
```

##### 2.1.5.3 配置HTTP代理#

如果你的网络环境需要使用HTTP代理，可以配置npm和Git的代理设置：
配置npm代理：

```
bash复制# 设置HTTP代理
npm config set proxy http://proxy.example.com:8080
npm config set https-proxy http://proxy.example.com:8080

# 取消代理设置
npm config delete proxy
npm config delete https-proxy
```

```
# 设置HTTP代理
npm config set proxy http://proxy.example.com:8080
npm config set https-proxy http://proxy.example.com:8080

# 取消代理设置
npm config delete proxy
npm config delete https-proxy
```

配置Git代理：

```
bash复制# 设置HTTP代理
git config --global http.proxy http://proxy.example.com:8080
git config --global https.proxy http://proxy.example.com:8080
# 取消代理设置
git config --global --unset http.proxy
git config --global --unset https.proxy
```

```
# 设置HTTP代理
git config --global http.proxy http://proxy.example.com:8080
git config --global https.proxy http://proxy.example.com:8080
# 取消代理设置
git config --global --unset http.proxy
git config --global --unset https.proxy
```

---

## 2 VS Code插件安装

**URL**: https://claudecode.tangshuang.net/course/2.2%20VS%20Code%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85

VS Code，以及基于VS Code开发的其他编辑器，例如Cursor, Trae, Kiro等，都可以安装此插件。比如下方截图中，我就是用Kiro安装Claude Code插件的。

#### 2.2.1 安装VS Code#

Claude Code提供了VS Code插件，因此在安装Claude Code插件之前，需要先确保已安装VS Code。

##### 2.2.1.1 检查VS Code是否已安装#

打开终端或命令提示符，运行以下命令检查VS Code是否已安装：

```
bash复制# 检查VS Code版本
code --version
```

```
# 检查VS Code版本
code --version
```

如果输出显示VS Code版本信息，则说明VS Code已安装，可以跳过安装步骤。

##### 2.2.1.2 安装VS Code#

如果没有安装VS Code，可以通过以下方式安装：

###### 方式一：使用官方安装包

True. 访问VS Code官方网站：https://code.visualstudio.com/
True. 下载适合你操作系统的安装包
True. 运行安装程序，按照提示完成安装

###### 方式二：使用包管理器（推荐）

对于macOS：

```
bash复制# 使用Homebrew安装
brew install --cask visual-studio-code
```

```
# 使用Homebrew安装
brew install --cask visual-studio-code
```

对于Linux：

```
bash复制# Ubuntu/Debian
wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > packages.microsoft.gpg
sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/
sudo sh -c 'echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main" > /etc/apt/sources.list.d/vscode.list'
rm -f packages.microsoft.gpg
sudo apt update
sudo apt install code
# Fedora
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" > /etc/yum.repos.d/vscode.repo'
sudo dnf install code
```

```
# Ubuntu/Debian
wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > packages.microsoft.gpg
sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/
sudo sh -c 'echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main" > /etc/apt/sources.list.d/vscode.list'
rm -f packages.microsoft.gpg
sudo apt update
sudo apt install code
# Fedora
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" > /etc/yum.repos.d/vscode.repo'
sudo dnf install code
```

#### 2.2.2 安装Claude Code插件#

安装完VS Code后，现在可以安装Claude Code插件了。

##### 2.2.2.1 从VS Code市场安装（推荐）#

True. 打开VS Code
True. 点击左侧边栏的扩展图标（或使用快捷键Ctrl+Shift+X/Cmd+Shift+X）
True. 在搜索框中输入Claude Code
True. 在搜索结果中找到Claude Code插件，点击安装按钮
True. 安装完成后，插件会自动启用

```
Ctrl+Shift+X
```

```
Cmd+Shift+X
```

```
Claude Code
```

##### 2.2.2.2 手动安装插件#

如果无法从VS Code市场安装插件，可以使用以下方式手动安装：

True. 访问Claude Code插件的GitHub仓库或官方网站，下载最新的VSIX文件
True. 打开VS Code
True. 点击左侧边栏的扩展图标（或使用快捷键Ctrl+Shift+X/Cmd+Shift+X）
True. 点击扩展面板右上角的更多操作按钮（三个点）
True. 选择从VSIX安装
True. 选择下载的VSIX文件，点击安装
True. 安装完成后，重新加载VS Code以启用插件

```
Ctrl+Shift+X
```

```
Cmd+Shift+X
```

##### 2.2.2.3 验证插件安装#

安装完成后，可以通过以下方式验证插件是否成功安装：

True. 打开VS Code
True. 点击左侧边栏的Claude Code图标（如果已添加到边栏）
True. 或者，使用快捷键Ctrl+Shift+P/Cmd+Shift+P打开命令面板
True. 输入Claude Code，如果看到相关命令，则说明插件已成功安装

```
Ctrl+Shift+P
```

```
Cmd+Shift+P
```

```
Claude Code
```

##### 2.2.2.4 插件更新#

Claude Code插件会定期更新，提供新功能和修复bug。可以通过以下方式更新插件：

True. 打开VS Code
True. 点击左侧边栏的扩展图标（或使用快捷键Ctrl+Shift+X/Cmd+Shift+X）
True. 点击扩展面板右上角的更多操作按钮（三个点）
True. 选择检查更新
True. 如果有更新可用，点击更新按钮即可更新插件

```
Ctrl+Shift+X
```

```
Cmd+Shift+X
```

或者，在扩展面板中找到Claude Code插件，如果有更新可用，会显示更新按钮。

---

## 3 命令行工具安装

**URL**: https://claudecode.tangshuang.net/course/2.3%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85

#### 2.3.1 概述#

Claude Code提供了命令行工具，允许开发者在终端或命令提示符中使用Claude Code的功能。命令行工具特别适合那些更喜欢使用终端进行开发的开发者，或者需要在CI/CD流水线中集成Claude Code的场景。

#### 2.3.2 安装命令行工具#

##### 2.3.2.1 使用npm安装（推荐）#

Claude Code的命令行工具可以通过npm全局安装：

```
bash复制npm install -g claude-code
```

```
npm install -g claude-code
```

##### 2.3.2.2 使用yarn安装#

如果你使用yarn作为包管理器，可以使用以下命令安装：

```
bash复制yarn global add claude-code
```

```
yarn global add claude-code
```

##### 2.3.2.3 使用pnpm安装#

如果你使用pnpm作为包管理器，可以使用以下命令安装：

```
bash复制pnpm add -g claude-code
```

```
pnpm add -g claude-code
```

#### 2.3.3 验证安装#

安装完成后，可以通过以下命令验证Claude Code命令行工具是否已正确安装：

```
bash复制# 检查Claude Code版本
claude --version

# 或使用缩写
cl --version
```

```
# 检查Claude Code版本
claude --version

# 或使用缩写
cl --version
```

如果输出显示Claude Code的版本信息，则说明命令行工具已正确安装。

#### 2.3.4 配置命令行工具#

安装完成后，需要进行一些基本配置才能使用Claude Code命令行工具。

##### 2.3.4.1 登录Claude账户#

在使用命令行工具之前，需要先登录Claude账户：

```
bash复制# 登录Claude账户
claude login
# 或使用缩写
cl login
```

```
# 登录Claude账户
claude login
# 或使用缩写
cl login
```

执行上述命令后，会打开默认浏览器，跳转到Claude Code的登录页面。输入你的Claude账户凭据进行登录，登录成功后，浏览器会显示"授权成功"的提示，命令行工具会自动完成授权。

##### 2.3.4.2 配置默认模型#

可以通过以下命令配置默认使用的Claude模型：

```
bash复制# 配置默认模型为Opus 4
claude config set model claude-4-opus

# 或配置为Sonnet 4
claude config set model claude-4-sonnet
```

```
# 配置默认模型为Opus 4
claude config set model claude-4-opus

# 或配置为Sonnet 4
claude config set model claude-4-sonnet
```

##### 2.3.4.3 查看配置#

可以通过以下命令查看当前的配置：

```
bash复制# 查看所有配置
claude config list
# 查看特定配置项
claude config get model
```

```
# 查看所有配置
claude config list
# 查看特定配置项
claude config get model
```

#### 2.3.5 基本命令使用#

##### 2.3.5.1 帮助命令#

可以使用以下命令查看Claude Code命令行工具的帮助信息：

```
bash复制# 查看所有命令
claude help

# 查看特定命令的帮助
claude help chat

### 2.3.5.2 聊天命令

可以使用`chat`命令与Claude Code进行对话：

# 启动交互式聊天
claude chat
# 或使用缩写
cl chat
```

```
# 查看所有命令
claude help

# 查看特定命令的帮助
claude help chat

### 2.3.5.2 聊天命令

可以使用`chat`命令与Claude Code进行对话：

# 启动交互式聊天
claude chat
# 或使用缩写
cl chat
```

##### 2.3.5.3 代码生成命令#

可以使用code命令生成代码：

```
code
```

```
bash复制# 生成一个简单的Python函数
claude code "write a Python function to calculate Fibonacci numbers"
```

```
# 生成一个简单的Python函数
claude code "write a Python function to calculate Fibonacci numbers"
```

##### 2.3.5.4 代码解释命令#

可以使用explain命令解释代码：

```
explain
```

```
bash复制# 解释一个Python函数
claude explain "def fib(n): return 1 if n <= 1 else fib(n-1) + fib(n-2)"
```

```
# 解释一个Python函数
claude explain "def fib(n): return 1 if n <= 1 else fib(n-1) + fib(n-2)"
```

##### 2.3.5.5 代码执行命令#

可以使用run命令执行生成的代码：

```
run
```

```
bash复制# 执行一个Python函数
claude run "def fib(n): return 1 if n <= 1 else fib(n-1) + fib(n-2)"
```

```
# 执行一个Python函数
claude run "def fib(n): return 1 if n <= 1 else fib(n-1) + fib(n-2)"
```

#### 2.3.6 命令行工具的高级配置#

##### 2.3.6.1 配置输出格式#

可以配置命令行工具的输出格式：

```
bash复制# 配置输出格式为JSON
claude config set output-format json

# 配置输出格式为文本（默认）
claude config set output-format text

### 2.3.6.2 配置超时时间

可以配置命令行工具的超时时间：

# 配置超时时间为60秒
claude config set timeout 60
```

```
# 配置输出格式为JSON
claude config set output-format json

# 配置输出格式为文本（默认）
claude config set output-format text

### 2.3.6.2 配置超时时间

可以配置命令行工具的超时时间：

# 配置超时时间为60秒
claude config set timeout 60
```

##### 2.3.6.3 配置代理#

如果你的网络环境需要使用代理，可以配置命令行工具的代理：

```
bash复制# 配置HTTP代理
claude config set proxy http://proxy.example.com:8080

# 取消代理配置
claude config unset proxy
```

```
# 配置HTTP代理
claude config set proxy http://proxy.example.com:8080

# 取消代理配置
claude config unset proxy
```

#### 2.3.7 常见问题与解决方案#

##### 2.3.7.1 命令未找到#

问题：运行claude命令时显示"command not found"

```
claude
```

- 确保已正确安装Claude Code命令行工具
- 检查npm全局安装路径是否已添加到系统环境变量中
- 对于macOS和Linux，可以将以下行添加到~/.bashrc或~/.zshrc文件中：
bash
export PATH="$HOME/.npm/bin:$PATH"

对于Windows，确保%USERPROFILE%\AppData\Roaming\npm已添加到系统环境变量中
- 对于Windows，确保%USERPROFILE%\AppData\Roaming\npm已添加到系统环境变量中

```
~/.bashrc
```

```
~/.zshrc
```

- 对于Windows，确保%USERPROFILE%\AppData\Roaming\npm已添加到系统环境变量中

```
%USERPROFILE%\AppData\Roaming\npm
```

##### 2.3.7.2 登录失败#

问题：执行claude login命令后，浏览器打开但无法登录

```
claude login
```

- 检查网络连接
- 确保你使用的是正确的Claude账户凭据
- 检查浏览器是否阻止了弹出窗口
- 尝试清除浏览器缓存和Cookie
- 尝试使用不同的浏览器进行授权

##### 2.3.7.3 命令执行失败#

问题：执行Claude Code命令时显示"API request failed"

- 检查网络连接
- 确保已正确登录Claude账户
- 检查配置的模型是否可用
- 尝试增加超时时间
- 检查是否有防火墙或代理设置阻止了API请求

#### 2.3.8 命令行工具更新#

可以通过以下命令更新Claude Code命令行工具：

```
bash复制# 使用npm更新
npm update -g claude-code
# 使用yarn更新
yarn global upgrade claude-code
# 使用pnpm更新
pnpm update -g claude-code
```

```
# 使用npm更新
npm update -g claude-code
# 使用yarn更新
yarn global upgrade claude-code
# 使用pnpm更新
pnpm update -g claude-code
```

#### 2.3.9 卸载命令行工具#

如果需要卸载Claude Code命令行工具，可以使用以下命令：

```
bash复制# 使用npm卸载
npm uninstall -g claude-code

# 使用yarn卸载
yarn global remove claude-code

# 使用pnpm卸载
pnpm remove -g claude-code
```

```
# 使用npm卸载
npm uninstall -g claude-code

# 使用yarn卸载
yarn global remove claude-code

# 使用pnpm卸载
pnpm remove -g claude-code
```

#### 2.3.10 命令行工具的使用场景#

Claude Code命令行工具适合以下场景：

True. 终端爱好者：喜欢在终端中进行开发的开发者
True. CI/CD流水线：在持续集成/持续部署流水线中集成Claude Code
True. 脚本编写：编写自动化脚本时使用Claude Code生成代码
True. 批量处理：批量处理代码文件或生成多个代码片段
True. 远程服务器：在远程服务器上使用Claude Code（无图形界面环境）

#### 2.3.11 总结#

Claude Code命令行工具提供了一种在终端中使用Claude Code功能的方式，适合终端爱好者和需要在CI/CD流水线中集成Claude Code的场景。通过本小节的指导，你应该已经成功安装并配置了Claude Code命令行工具，可以开始使用它来辅助你的开发工作了。

接下来，我们将介绍如何注册Claude账户和进行授权，这是使用Claude Code的必要步骤。

---

## 4 账户注册与授权

**URL**: https://claudecode.tangshuang.net/course/2.4%20%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%8E%88%E6%9D%83

#### 2.4.1 注册Claude账户#

在使用Claude Code之前，需要先注册一个Claude账户。Claude账户是使用Claude Code的必要条件，它用于身份验证和授权。

##### 2.4.1.1 注册步骤#

True. 访问Claude官方网站：https://www.anthropic.com/claude
True. 点击页面右上角的"Sign Up"或"注册"按钮
True. 选择注册方式：

使用电子邮件注册
使用Google账户注册
使用Microsoft账户注册
True. 使用电子邮件注册
True. 使用Google账户注册
True. 使用Microsoft账户注册
True. 如果选择电子邮件注册，需要输入以下信息：

电子邮件地址
密码（至少8个字符，包含字母、数字和特殊字符）
确认密码
勾选同意服务条款和隐私政策
True. 电子邮件地址
True. 密码（至少8个字符，包含字母、数字和特殊字符）
True. 确认密码
True. 勾选同意服务条款和隐私政策
True. 点击"Sign Up"或"注册"按钮
True. 查收邮箱中的验证邮件，点击验证链接完成注册

- 使用电子邮件注册
- 使用Google账户注册
- 使用Microsoft账户注册

- 电子邮件地址
- 密码（至少8个字符，包含字母、数字和特殊字符）
- 确认密码
- 勾选同意服务条款和隐私政策

##### 2.4.1.2 账户类型#

Claude提供了多种账户类型：

True. 免费账户：提供基本的Claude功能，有一定的使用限额
True. Pro账户：付费账户，提供更多的使用额度和高级功能
True. 企业账户：适合团队和企业使用，提供团队管理、高级安全功能和定制服务

##### 2.4.1.3 注册注意事项#

- 确保使用真实有效的电子邮件地址，用于接收验证邮件和重要通知
- 选择强密码，并定期更换密码，确保账户安全
- 阅读并理解Claude的服务条款和隐私政策
- 免费账户可能有使用限额，超出限额后需要升级到付费账户

#### 2.4.2 登录Claude账户#

注册完成后，可以通过以下方式登录Claude账户：

##### 2.4.2.1 在VS Code插件中登录#

True. 打开VS Code
True. 点击左侧边栏的Claude Code图标
True. 在欢迎界面中，点击"登录"按钮
True. 会打开默认浏览器，跳转到Claude Code的登录页面
True. 输入你的Claude账户凭据进行登录
True. 登录成功后，浏览器会显示"授权成功"的提示
True. 返回VS Code，Claude Code插件会自动完成授权

##### 2.4.2.2 在命令行工具中登录#

True. 打开终端或命令提示符
True. 执行以下命令：
bash复制claude login
True. 会打开默认浏览器，跳转到Claude Code的登录页面
True. 输入你的Claude账户凭据进行登录
True. 登录成功后，浏览器会显示"授权成功"的提示
True. 返回终端，命令行工具会自动完成授权

```
bash复制claude login
```

```
claude login
```

##### 2.4.2.3 在Web界面中登录#

True. 访问Claude官方网站：https://www.anthropic.com/claude
True. 点击页面右上角的"Sign In"或"登录"按钮
True. 输入你的Claude账户凭据进行登录
True. 登录成功后，会跳转到Claude的Web界面

#### 2.4.3 授权管理#

##### 2.4.3.1 查看授权设备#

可以通过Claude的Web界面查看已授权的设备：

True. 登录Claude Web界面
True. 点击右上角的用户头像
True. 选择"Settings"或"设置"
True. 选择"Authorized Devices"或"授权设备"
True. 可以查看所有已授权的设备列表

##### 2.4.3.2 撤销设备授权#

如果需要撤销某个设备的授权，可以通过以下步骤：

True. 登录Claude Web界面
True. 进入"授权设备"页面
True. 找到需要撤销授权的设备
True. 点击"Revoke"或"撤销"按钮
True. 确认撤销授权

撤销授权后，该设备将无法再使用Claude Code，需要重新登录才能使用。

##### 2.4.3.3 授权范围#

Claude Code的授权范围包括：

- 访问你的Claude账户信息
- 访问和使用Claude模型
- 在你的开发环境中执行代码
- 读取和修改你的代码文件（需要用户确认）
- 调用外部工具（需要用户确认）

#### 2.4.4 多设备同步#

Claude Code支持多设备同步，你可以在多个设备上使用同一个Claude账户，它们之间会自动同步配置和上下文。

##### 2.4.4.1 同步内容#

- 账户设置
- 默认模型配置
- 最近的对话历史
- 常用命令和快捷键
- 插件安装状态

##### 2.4.4.2 同步机制#

Claude Code使用安全的加密机制进行数据同步，确保你的数据安全。同步过程是自动进行的，不需要手动操作。

#### 2.4.5 常见问题与解决方案#

##### 2.4.5.1 注册失败#

问题：注册Claude账户时显示"注册失败"或"电子邮件已被使用"

- 检查网络连接
- 确保使用的电子邮件地址未被注册过
- 尝试使用不同的注册方式
- 检查密码是否符合要求
- 检查是否勾选了同意服务条款和隐私政策

##### 2.4.5.2 登录失败#

问题：登录Claude账户时显示"登录失败"或"用户名或密码错误"

- 检查网络连接
- 确保输入的用户名和密码正确
- 尝试重置密码
- 检查是否开启了两步验证，如果开启，需要输入验证码
- 检查账户是否被锁定

##### 2.4.5.3 授权失败#

问题：在VS Code插件或命令行工具中授权时显示"授权失败"

- 检查网络连接
- 确保浏览器未阻止弹出窗口
- 尝试使用不同的浏览器进行授权
- 清除浏览器缓存和Cookie
- 确保账户未被限制或封禁

##### 2.4.5.4 忘记密码#

问题：忘记了Claude账户密码

- 在登录页面点击"Forgot Password"或"忘记密码"链接
- 输入注册时使用的电子邮件地址
- 查收邮箱中的密码重置邮件
- 点击重置链接，设置新密码

#### 2.4.6 账户安全建议#

为了保护你的Claude账户安全，建议采取以下措施：

True. 使用强密码：选择包含字母、数字和特殊字符的强密码，避免使用容易猜测的密码
True. 启用两步验证：在账户设置中启用两步验证，增加账户安全性
True. 定期更换密码：定期更换密码，避免使用同一个密码过长时间
True. 不要共享账户：不要与他人共享你的Claude账户，确保账户仅你自己使用
True. 谨慎授权设备：仅在可信的设备上授权使用Claude Code
True. 定期检查授权设备：定期检查已授权的设备列表，撤销不再使用的设备授权
True. 注意钓鱼邮件：不要点击来自未知发件人的邮件中的链接，特别是要求输入账户信息的链接
True. 使用安全的网络连接：避免在公共WiFi等不安全的网络环境中使用Claude Code

#### 2.4.7 企业账户管理#

对于企业账户，Claude提供了以下管理功能：

- 团队管理：添加和管理团队成员
- 权限管理：为不同的团队成员设置不同的权限
- 使用统计：查看团队成员的使用情况和统计数据
- 高级安全功能：包括单点登录（SSO）、审计日志等
- 定制服务：根据企业需求提供定制服务和支持

#### 2.4.8 总结#

账户注册与授权是使用Claude Code的必要步骤，它确保了你的身份验证和授权。通过本小节的指导，你应该已经了解了如何注册Claude账户、如何在VS Code插件和命令行工具中登录和授权，以及如何管理账户安全。

在使用Claude Code时，务必注意账户安全，采取必要的安全措施，保护你的账户和数据安全。

---

## 5 基本配置选项

**URL**: https://claudecode.tangshuang.net/course/2.5%20%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9

#### 2.5.1 概述#

Claude Code提供了多种配置选项，允许用户根据自己的需求和偏好进行定制。这些配置选项可以通过VS Code的设置界面或命令行工具进行配置。本节将介绍Claude Code的基本配置选项，帮助你根据自己的需求进行定制。

#### 2.5.2 VS Code插件配置#

在VS Code中，可以通过文件 首选项 设置（或使用快捷键 Ctrl+, / Cmd+,）来配置Claude Code插件。在设置搜索框中输入 "Claude Code" 即可查看所有配置选项。

```
Ctrl+,
```

```
Cmd+,
```

##### 2.5.2.1 模型配置#

- Model

功能：选择要使用的Claude模型
选项：

claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型


默认值：claude-4-sonnet
建议：根据任务复杂度选择合适的模型
- 功能：选择要使用的Claude模型
- 选项：

claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型
- claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
- claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型
- 默认值：claude-4-sonnet
- 建议：根据任务复杂度选择合适的模型
- Temperature

功能：控制生成文本的随机性
范围：0到1之间
默认值：0.7
建议：

对于需要精确结果的任务，设置较低值（如0.2-0.4）
对于需要创意结果的任务，设置较高值（如0.6-0.9）
- 功能：控制生成文本的随机性
- 范围：0到1之间
- 默认值：0.7
- 建议：

对于需要精确结果的任务，设置较低值（如0.2-0.4）
对于需要创意结果的任务，设置较高值（如0.6-0.9）
- 对于需要精确结果的任务，设置较低值（如0.2-0.4）
- 对于需要创意结果的任务，设置较高值（如0.6-0.9）
- Max Tokens

功能：控制单次生成的最大令牌数
范围：1到4096之间
默认值：1024
建议：根据任务需要设置，复杂任务可以设置较高值
- 功能：控制单次生成的最大令牌数
- 范围：1到4096之间
- 默认值：1024
- 建议：根据任务需要设置，复杂任务可以设置较高值

- 功能：选择要使用的Claude模型
- 选项：

claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型
- claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
- claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型
- 默认值：claude-4-sonnet
- 建议：根据任务复杂度选择合适的模型

- claude-4-opus：Claude 4 Opus，最强大的模型，适合复杂任务
- claude-4-sonnet：Claude 4 Sonnet，平衡性能和成本的模型

```
claude-4-opus
```

```
claude-4-sonnet
```

```
claude-4-sonnet
```

Temperature

- 功能：控制生成文本的随机性
- 范围：0到1之间
- 默认值：0.7
- 建议：

对于需要精确结果的任务，设置较低值（如0.2-0.4）
对于需要创意结果的任务，设置较高值（如0.6-0.9）
- 对于需要精确结果的任务，设置较低值（如0.2-0.4）
- 对于需要创意结果的任务，设置较高值（如0.6-0.9）

- 对于需要精确结果的任务，设置较低值（如0.2-0.4）
- 对于需要创意结果的任务，设置较高值（如0.6-0.9）

Max Tokens

- 功能：控制单次生成的最大令牌数
- 范围：1到4096之间
- 默认值：1024
- 建议：根据任务需要设置，复杂任务可以设置较高值

##### 2.5.2.2 编辑器配置#

- Auto-save

功能：是否自动保存生成的代码
选项：true / false
默认值：false
建议：根据个人习惯选择，自动保存可以减少手动操作
- 功能：是否自动保存生成的代码
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择，自动保存可以减少手动操作
- Show Welcome Page

功能：是否显示欢迎页面
选项：true / false
默认值：true
建议：新手可以保持开启，熟悉后可以关闭
- 功能：是否显示欢迎页面
- 选项：true / false
- 默认值：true
- 建议：新手可以保持开启，熟悉后可以关闭
- Show Line Numbers

功能：在生成的代码中是否显示行号
选项：true / false
默认值：false
建议：根据个人习惯选择
- 功能：在生成的代码中是否显示行号
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择

Auto-save

- 功能：是否自动保存生成的代码
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择，自动保存可以减少手动操作

```
true
```

```
false
```

```
false
```

Show Welcome Page

- 功能：是否显示欢迎页面
- 选项：true / false
- 默认值：true
- 建议：新手可以保持开启，熟悉后可以关闭

```
true
```

```
false
```

```
true
```

Show Line Numbers

- 功能：在生成的代码中是否显示行号
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择

```
true
```

```
false
```

```
false
```

##### 2.5.2.3 对话配置#

- Show Timestamps

功能：在对话历史中是否显示时间戳
选项：true / false
默认值：false
建议：需要记录对话时间时可以开启
- 功能：在对话历史中是否显示时间戳
- 选项：true / false
- 默认值：false
- 建议：需要记录对话时间时可以开启
- Clear Conversation on New File

功能：打开新文件时是否清除对话历史
选项：true / false
默认值：false
建议：根据个人习惯选择，保持开启可以保持对话上下文
- 功能：打开新文件时是否清除对话历史
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择，保持开启可以保持对话上下文
- Conversation History Limit

功能：限制对话历史的数量
范围：1到100之间
默认值：20
建议：根据需要设置，较多的历史记录可以提供更多上下文，但可能影响性能
- 功能：限制对话历史的数量
- 范围：1到100之间
- 默认值：20
- 建议：根据需要设置，较多的历史记录可以提供更多上下文，但可能影响性能

Show Timestamps

- 功能：在对话历史中是否显示时间戳
- 选项：true / false
- 默认值：false
- 建议：需要记录对话时间时可以开启

```
true
```

```
false
```

```
false
```

Clear Conversation on New File

- 功能：打开新文件时是否清除对话历史
- 选项：true / false
- 默认值：false
- 建议：根据个人习惯选择，保持开启可以保持对话上下文

```
true
```

```
false
```

```
false
```

Conversation History Limit

- 功能：限制对话历史的数量
- 范围：1到100之间
- 默认值：20
- 建议：根据需要设置，较多的历史记录可以提供更多上下文，但可能影响性能

#### 2.5.3 命令行工具配置#

在命令行工具中，可以使用 claude config 命令来配置Claude Code。

```
claude config
```

##### 2.5.3.1 常用配置命令#

- 设置配置项

```
bash复制claude config set <key<value>
```

```
claude config set <key<value>
```

- 获取配置项

```
bash复制claude config get <key>
```

```
claude config get <key>
```

- 列出所有配置项

```
bash复制claude config list
```

```
claude config list
```

- 删除配置项

```
bash复制claude config unset <key>
```

```
claude config unset <key>
```

##### 2.5.3.2 常用配置项#

- model

功能：设置默认使用的模型
选项：claude-4-opus、claude-4-sonnet
示例：
bash复制claude config set model claude-4-opus
- 功能：设置默认使用的模型
- 选项：claude-4-opus、claude-4-sonnet
- 示例：
bash复制claude config set model claude-4-opus
- temperature

功能：控制生成文本的随机性
范围：0到1之间
示例：
bash复制claude config set temperature 0.5
- 功能：控制生成文本的随机性
- 范围：0到1之间
- 示例：
bash复制claude config set temperature 0.5
- max-tokens

功能：控制单次生成的最大令牌数
范围：1到4096之间
示例：
bash复制claude config set max-tokens 2048
- 功能：控制单次生成的最大令牌数
- 范围：1到4096之间
- 示例：
bash复制claude config set max-tokens 2048
- output-format

功能：设置输出格式
选项：text、json
示例：
bash复制claude config set output-format json
- 功能：设置输出格式
- 选项：text、json
- 示例：
bash复制claude config set output-format json
- timeout

功能：设置命令执行的超时时间（秒）
范围：10到300之间
示例：
bash复制claude config set timeout 60
- 功能：设置命令执行的超时时间（秒）
- 范围：10到300之间
- 示例：
bash复制claude config set timeout 60
- auto-save

功能：是否自动保存生成的代码
选项：true / false
示例：
bash复制claude config set auto-save true
- 功能：是否自动保存生成的代码
- 选项：true / false
- 示例：
bash复制claude config set auto-save true

- 功能：设置默认使用的模型
- 选项：claude-4-opus、claude-4-sonnet
- 示例：
bash复制claude config set model claude-4-opus

```
claude-4-opus
```

```
claude-4-sonnet
```

```
bash复制claude config set model claude-4-opus
```

```
claude config set model claude-4-opus
```

temperature

- 功能：控制生成文本的随机性
- 范围：0到1之间
- 示例：
bash复制claude config set temperature 0.5

```
bash复制claude config set temperature 0.5
```

```
claude config set temperature 0.5
```

max-tokens

- 功能：控制单次生成的最大令牌数
- 范围：1到4096之间
- 示例：
bash复制claude config set max-tokens 2048

```
bash复制claude config set max-tokens 2048
```

```
claude config set max-tokens 2048
```

output-format

- 功能：设置输出格式
- 选项：text、json
- 示例：
bash复制claude config set output-format json

```
text
```

```
json
```

```
bash复制claude config set output-format json
```

```
claude config set output-format json
```

timeout

- 功能：设置命令执行的超时时间（秒）
- 范围：10到300之间
- 示例：
bash复制claude config set timeout 60

```
bash复制claude config set timeout 60
```

```
claude config set timeout 60
```

auto-save

- 功能：是否自动保存生成的代码
- 选项：true / false
- 示例：
bash复制claude config set auto-save true

```
true
```

```
false
```

```
bash复制claude config set auto-save true
```

```
claude config set auto-save true
```

#### 2.5.4 配置文件位置#

Claude Code的配置文件存储在以下位置：

- Windows：%USERPROFILE%\.claude-code\config.json
- macOS/Linux：~/.claude-code/config.json

```
%USERPROFILE%\.claude-code\config.json
```

```
~/.claude-code/config.json
```

配置文件采用JSON格式，可以直接编辑，但建议使用VS Code设置界面或命令行工具进行配置，以避免格式错误。

#### 2.5.5 配置同步#

Claude Code的配置会自动同步到云端，这意味着你在一个设备上的配置更改会自动同步到其他设备上。这种同步机制确保了在不同设备上使用Claude Code时具有一致的体验。

##### 2.5.5.1 同步内容#

- 模型配置
- 编辑器配置
- 对话配置
- 命令行工具配置

##### 2.5.5.2 同步机制#

配置同步使用安全的加密机制，确保你的配置信息安全。同步过程是自动进行的，不需要手动操作。

#### 2.5.6 恢复默认配置#

如果你需要恢复Claude Code的默认配置，可以通过以下方式：

##### 2.5.6.1 在VS Code中#

True. 打开VS Code设置
True. 搜索 "Claude Code"
True. 点击每个配置项旁边的重置按钮

##### 2.5.6.2 使用命令行工具#

```
bash复制# 删除配置文件
sudo rm -rf ~/.claude-code/config.json
# 或重新初始化配置
claude config reset
```

```
# 删除配置文件
sudo rm -rf ~/.claude-code/config.json
# 或重新初始化配置
claude config reset
```

---

## 6 连接本地开发环境

**URL**: https://claudecode.tangshuang.net/course/2.6%20%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83

#### 2.6.1 概述#

Claude Code需要连接到本地开发环境才能访问和修改代码文件。连接本地开发环境是使用Claude Code的重要步骤，它确保Claude Code能够在你的开发环境中正常工作。本节将介绍如何连接Claude Code到本地开发环境，包括权限设置、工作目录配置等。

#### 2.6.2 连接步骤#

##### 2.6.2.1 在VS Code中连接#

True. 打开VS Code
True. 打开你要工作的项目文件夹（文件 打开文件夹）
True. 点击左侧边栏的Claude Code图标
True. 如果是首次使用，Claude Code会提示你授予访问权限
True. 点击授权按钮，允许Claude Code访问你的项目文件夹
True. 授权成功后，Claude Code会显示项目的文件结构

##### 2.6.2.2 在命令行工具中连接#

True. 打开终端或命令提示符
True. 导航到你的项目目录
bash复制cd /path/to/your/project
True. 运行Claude Code命令
bash复制claude chat
True. 如果是首次使用，Claude Code会提示你授予访问权限
True. 输入y或yes，允许Claude Code访问当前目录
True. 授权成功后，Claude Code会显示项目的文件结构

```
bash复制cd /path/to/your/project
```

```
cd /path/to/your/project
```

```
bash复制claude chat
```

```
claude chat
```

```
y
```

```
yes
```

#### 2.6.3 权限设置#

Claude Code需要以下权限才能正常工作：

##### 2.6.3.1 文件系统权限#

- 读取权限：读取项目文件和目录结构
- 写入权限：修改和创建项目文件
- 执行权限：运行测试和构建命令

##### 2.6.3.2 权限管理#

True. 最小权限原则：Claude Code遵循最小权限原则，只请求必要的权限
True. 用户确认：所有可能修改文件的操作都需要用户确认
True. 权限撤销：可以随时撤销Claude Code的权限

##### 2.6.3.3 安全边界#

Claude Code在安全边界内运行，确保：

- 不会访问项目文件夹外的文件
- 不会执行危险的系统命令
- 所有操作都有详细的日志记录

#### 2.6.4 工作目录配置#

##### 2.6.4.1 设置默认工作目录#

可以配置Claude Code的默认工作目录，方便快速访问常用项目：

True. 在VS Code中：

打开VS Code设置
搜索 "Claude Code"
找到"Default Workspace"设置
输入你常用的项目目录路径
True. 打开VS Code设置
True. 搜索 "Claude Code"
True. 找到"Default Workspace"设置
True. 输入你常用的项目目录路径
True. 在命令行工具中：
bash复制claude config set default-workspace /path/to/your/project

在VS Code中：

- 打开VS Code设置
- 搜索 "Claude Code"
- 找到"Default Workspace"设置
- 输入你常用的项目目录路径

在命令行工具中：

```
bash复制claude config set default-workspace /path/to/your/project
```

```
claude config set default-workspace /path/to/your/project
```

##### 2.6.4.2 切换工作目录#

在命令行工具中，可以使用以下命令切换工作目录：

```
bash复制# 切换到指定目录
claude cd /path/to/your/project
# 列出当前目录内容
claude ls
```

```
# 切换到指定目录
claude cd /path/to/your/project
# 列出当前目录内容
claude ls
```

---

## 7 使用国内大模型

**URL**: https://claudecode.tangshuang.net/course/2.7%20%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E5%A4%A7%E6%A8%A1%E5%9E%8B

#### 2.7.1 概述#

随着国内大模型技术的快速发展，越来越多的国内大模型平台推出了Coding Plan，支持Claude Code的接入和使用。这些国内大模型通常具有更低的使用成本和更好的本地化支持，为用户提供了更多选择。本节将介绍如何在Claude Code中使用国内大模型，包括支持的平台和配置方法。

#### 2.7.2 支持的国内大模型#

目前，以下国内大模型平台支持Claude Code的接入和使用：

##### 2.7.2.1 GLM#

- Coding Plan：提供专门的编程模型GLM-4.6，据称能使用户仅用1/7的价格即享受到接近Claude Sonnet 4的代码能力
- 特点：支持多语言代码生成、代码审查、调试等功能，具有良好的中文理解能力
- 接入方式：通过API密钥接入，支持Claude Code的所有核心功能

##### 2.7.2.2 通义千问 (Qwen)#

- Coding Plan：提供Qwen3-Coder-Plus模型，专门针对编程场景优化
- 特点：支持代码生成、代码补全、代码解释等功能，在中文编程场景中表现优异
- 接入方式：通过百炼平台获取API密钥，支持Claude Code无缝对接

##### 2.7.2.3 DeepSeek#

- Coding Plan：提供DeepSeek V3模型，专注于代码生成和理解
- 特点：在代码生成速度和准确性方面表现出色，支持多种编程语言
- 接入方式：通过官方API平台获取密钥，支持Claude Code集成

##### 2.7.2.4 豆包 (Doubao)#

- Coding Plan：推出国内首个支持视觉理解能力的编程模型
- 特点：支持代码生成、代码审查、文档生成等功能，具有良好的用户体验
- 接入方式：通过字节跳动开放平台获取API密钥，支持Claude Code接入

##### 2.7.2.5 Kimi#

- Coding Plan：提供Kimi 2模型，支持代码生成和理解
- 特点：在长上下文代码理解方面表现出色，支持大型代码库分析
- 接入方式：通过官方平台获取API密钥，支持Claude Code集成

#### 2.7.3 配置方法#

##### 2.7.3.1 准备工作#

True. 注册并登录所选国内大模型平台的账号
True. 开通Coding Plan或编程模型服务
True. 获取API密钥和API端点信息
True. 确保已安装最新版本的Claude Code

##### 2.7.3.2 在VS Code中配置#

True. 打开VS Code
True. 点击左侧边栏的Claude Code图标
True. 点击右上角的设置按钮（齿轮图标）
True. 选择模型设置
True. 选择自定义模型
True. 输入以下信息：

模型名称：自定义名称（如"GLM-4.6"）
API端点：国内大模型平台提供的API地址
API密钥：你的API密钥
模型类型：选择适合的模型类型
True. 模型名称：自定义名称（如"GLM-4.6"）
True. API端点：国内大模型平台提供的API地址
True. API密钥：你的API密钥
True. 模型类型：选择适合的模型类型
True. 点击保存按钮

- 模型名称：自定义名称（如"GLM-4.6"）
- API端点：国内大模型平台提供的API地址
- API密钥：你的API密钥
- 模型类型：选择适合的模型类型

##### 2.7.3.3 在命令行中配置#

True. 打开终端或命令提示符
True. 运行以下命令配置自定义模型：
bash复制claude config set custom-model "{\n  \"name\": \"GLM-4.6\",\n  \"endpoint\": \"https://api.example.com/v1/chat/completions\",\n  \"api_key\": \"your-api-key-here\",\n  \"model_type\": \"code\"\n}"
True. 设置默认使用的模型：
bash复制claude config set model custom:GLM-4.6

```
bash复制claude config set custom-model "{\n  \"name\": \"GLM-4.6\",\n  \"endpoint\": \"https://api.example.com/v1/chat/completions\",\n  \"api_key\": \"your-api-key-here\",\n  \"model_type\": \"code\"\n}"
```

```
claude config set custom-model "{\n  \"name\": \"GLM-4.6\",\n  \"endpoint\": \"https://api.example.com/v1/chat/completions\",\n  \"api_key\": \"your-api-key-here\",\n  \"model_type\": \"code\"\n}"
```

```
bash复制claude config set model custom:GLM-4.6
```

```
claude config set model custom:GLM-4.6
```

##### 2.7.3.4 直接修改配置文件#

除了上述方法外，您还可以直接编辑Claude Code的配置文件来设置国内大模型。

###### 2.7.3.4.1 配置文件位置

Claude Code的配置文件位于用户目录下的.claude/settings.json文件中：

```
.claude/settings.json
```

- Windows: C:\Users\YourUsername\.claude\settings.json
- macOS/Linux: ~/.claude/settings.json

```
C:\Users\YourUsername\.claude\settings.json
```

```
~/.claude/settings.json
```

如果该文件不存在，可以手动创建。

###### 2.7.3.4.2 配置文件格式

使用文本编辑器打开settings.json文件，并添加以下配置：

```
settings.json
```

```
json复制{
  "env": {
    "ANTHROPIC_BASE_URL": "https://api.example.com/v1",
    "ANTHROPIC_AUTH_TOKEN": "your-api-key-here"
  },
  "model": "glm-4.6",
  "custom-model": {
    "name": "GLM-4.6",
    "endpoint": "https://api.example.com/v1/chat/completions",
    "api_key": "your-api-key-here",
    "model_type": "code"
  }
}
```

```
{
  "env": {
    "ANTHROPIC_BASE_URL": "https://api.example.com/v1",
    "ANTHROPIC_AUTH_TOKEN": "your-api-key-here"
  },
  "model": "glm-4.6",
  "custom-model": {
    "name": "GLM-4.6",
    "endpoint": "https://api.example.com/v1/chat/completions",
    "api_key": "your-api-key-here",
    "model_type": "code"
  }
}
```

###### 2.7.3.4.3 配置说明

- env.ANTHROPIC_BASE_URL: 国内大模型的API端点URL
- env.ANTHROPIC_AUTH_TOKEN: 您的API密钥
- model: 默认使用的模型名称
- custom-model: 自定义模型配置

name: 模型名称（自定义）
endpoint: API端点URL
api_key: API密钥
model_type: 模型类型（通常为"code"）
- name: 模型名称（自定义）
- endpoint: API端点URL
- api_key: API密钥
- model_type: 模型类型（通常为"code"）

- name: 模型名称（自定义）
- endpoint: API端点URL
- api_key: API密钥
- model_type: 模型类型（通常为"code"）

###### 2.7.3.4.4 示例：配置GLM

```
json复制{
  "env": {
    "ANTHROPIC_BASE_URL": "https://open.bigmodel.cn/api/paas/v4",
    "ANTHROPIC_AUTH_TOKEN": "your-glm-api-key"
  },
  "model": "glm-4.6",
  "custom-model": {
    "name": "GLM-4.6",
    "endpoint": "https://open.bigmodel.cn/api/paas/v4/chat/completions",
    "api_key": "your-glm-api-key",
    "model_type": "code"
  }
}
```

```
{
  "env": {
    "ANTHROPIC_BASE_URL": "https://open.bigmodel.cn/api/paas/v4",
    "ANTHROPIC_AUTH_TOKEN": "your-glm-api-key"
  },
  "model": "glm-4.6",
  "custom-model": {
    "name": "GLM-4.6",
    "endpoint": "https://open.bigmodel.cn/api/paas/v4/chat/completions",
    "api_key": "your-glm-api-key",
    "model_type": "code"
  }
}
```

保存配置文件后，重启Claude Code或VS Code插件使配置生效。

#### 2.7.4 注意事项#

True. API兼容性：确保所选国内大模型的API与Claude Code兼容
True. 成本控制：国内大模型通常提供更优惠的价格，但仍需注意使用量和成本控制
True. 功能差异：不同大模型在功能和性能上可能存在差异，建议根据实际需求选择
True. 数据隐私：使用国内大模型时，注意数据隐私和安全保护
True. 更新维护：定期关注国内大模型平台的更新和维护信息

---

## 8 使用CCR等中转工具

**URL**: https://claudecode.tangshuang.net/course/2.8%20%E4%BD%BF%E7%94%A8CCR%E7%AD%89%E4%B8%AD%E8%BD%AC%E5%B7%A5%E5%85%B7

#### 2.8.1 概述#

Claude Code默认需要直接连接到Anthropic的API服务器，但在某些情况下（如网络限制、访问速度慢等），用户可能需要使用中转工具来代理Claude Code的请求。CCR（ClaudeCodeRouter）是一种常用的中转工具，它可以将Claude Code的请求进行代理中转，帮助用户解决网络连接问题，提高访问速度，甚至实现一些高级功能。本节将介绍如何使用CCR等中转工具来优化Claude Code的使用体验。

#### 2.8.2 什么是ClaudeCodeRouter (CCR)#

##### 2.8.2.1 基本概念#

ClaudeCodeRouter（简称CCR）是一个开源的Claude Code请求转发工具，它可以：

- 代理Claude Code的API请求
- 优化网络连接，提高访问速度
- 支持多种大模型的统一接入
- 提供请求日志和监控功能
- 支持自定义路由规则和流量控制

##### 2.8.2.2 核心功能#

True. 请求代理：将Claude Code的API请求转发到目标服务器
True. 多模型支持：支持同时接入多个大模型API
True. 负载均衡：在多个API端点之间分配请求负载
True. 缓存机制：缓存常用请求的响应，提高性能
True. 安全控制：提供API密钥管理和访问控制

#### 2.8.3 安装ClaudeCodeRouter#

##### 2.8.3.1 系统要求#

- Node.js 18.0.0 或更高版本
- npm 或 pnpm 包管理器
- 足够的系统内存和存储空间

##### 2.8.3.2 安装步骤#

True. 安装Node.js：

访问Node.js官方网站（https://nodejs.org/）下载并安装最新版本的Node.js
安装完成后，打开终端验证安装：
bash复制node --version
npm --version
True. 访问Node.js官方网站（https://nodejs.org/）下载并安装最新版本的Node.js
True. 安装完成后，打开终端验证安装：
bash复制node --version
npm --version
True. 安装ClaudeCodeRouter：
bash复制npm install -g @musistudio/claude-code-router
或使用pnpm：
bash复制pnpm add -g @musistudio/claude-code-router
True. 验证安装：
bash复制ccr --version

安装Node.js：

- 访问Node.js官方网站（https://nodejs.org/）下载并安装最新版本的Node.js
- 安装完成后，打开终端验证安装：
bash复制node --version
npm --version

```
bash复制node --version
npm --version
```

```
node --version
npm --version
```

安装ClaudeCodeRouter：

```
bash复制npm install -g @musistudio/claude-code-router
```

```
npm install -g @musistudio/claude-code-router
```

或使用pnpm：

```
bash复制pnpm add -g @musistudio/claude-code-router
```

```
pnpm add -g @musistudio/claude-code-router
```

```
bash复制ccr --version
```

```
ccr --version
```

#### 2.8.4 配置ClaudeCodeRouter#

##### 2.8.4.1 创建配置文件#

True. 创建配置目录：
bash复制mkdir -p ~/.claude-code-router
True. 创建配置文件：
bash复制touch ~/.claude-code-router/config.json
True. 编辑配置文件：
json复制{
  "port": 3000,
  "logLevel": "info",
  "endpoints": [
    {
      "name": "anthropic",
      "type": "anthropic",
      "apiKey": "your-anthropic-api-key",
      "baseUrl": "https://api.anthropic.com/v1"
    },
    {
      "name": "glm",
      "type": "custom",
      "apiKey": "your-glm-api-key",
      "baseUrl": "https://api.glm.example.com/v1",
      "headers": {
        "Content-Type": "application/json"
      }
    }
  ],
  "defaultEndpoint": "anthropic",
  "cache": {
    "enabled": true,
    "ttl": 3600
  }
}

创建配置目录：

```
bash复制mkdir -p ~/.claude-code-router
```

```
mkdir -p ~/.claude-code-router
```

创建配置文件：

```
bash复制touch ~/.claude-code-router/config.json
```

```
touch ~/.claude-code-router/config.json
```

编辑配置文件：

```
json复制{
  "port": 3000,
  "logLevel": "info",
  "endpoints": [
    {
      "name": "anthropic",
      "type": "anthropic",
      "apiKey": "your-anthropic-api-key",
      "baseUrl": "https://api.anthropic.com/v1"
    },
    {
      "name": "glm",
      "type": "custom",
      "apiKey": "your-glm-api-key",
      "baseUrl": "https://api.glm.example.com/v1",
      "headers": {
        "Content-Type": "application/json"
      }
    }
  ],
  "defaultEndpoint": "anthropic",
  "cache": {
    "enabled": true,
    "ttl": 3600
  }
}
```

```
{
  "port": 3000,
  "logLevel": "info",
  "endpoints": [
    {
      "name": "anthropic",
      "type": "anthropic",
      "apiKey": "your-anthropic-api-key",
      "baseUrl": "https://api.anthropic.com/v1"
    },
    {
      "name": "glm",
      "type": "custom",
      "apiKey": "your-glm-api-key",
      "baseUrl": "https://api.glm.example.com/v1",
      "headers": {
        "Content-Type": "application/json"
      }
    }
  ],
  "defaultEndpoint": "anthropic",
  "cache": {
    "enabled": true,
    "ttl": 3600
  }
}
```

##### 2.8.4.2 配置参数说明#

- port：CCR服务器监听的端口
- logLevel：日志级别（debug、info、warn、error）
- endpoints：配置的API端点列表

name：端点名称
type：端点类型（anthropic、custom等）
apiKey：API密钥
baseUrl：API基础URL
headers：自定义请求头
- name：端点名称
- type：端点类型（anthropic、custom等）
- apiKey：API密钥
- baseUrl：API基础URL
- headers：自定义请求头
- defaultEndpoint：默认使用的端点
- cache：缓存配置

enabled：是否启用缓存
ttl：缓存过期时间（秒）
- enabled：是否启用缓存
- ttl：缓存过期时间（秒）

- name：端点名称
- type：端点类型（anthropic、custom等）
- apiKey：API密钥
- baseUrl：API基础URL
- headers：自定义请求头

- enabled：是否启用缓存
- ttl：缓存过期时间（秒）

#### 2.8.5 启动ClaudeCodeRouter#

##### 2.8.5.1 基本启动命令#

```
bash复制ccr start
```

```
ccr start
```

##### 2.8.5.2 自定义启动参数#

```
bash复制# 指定配置文件
ccr start --config ~/my-ccr-config.json

# 指定端口
ccr start --port 4000

# 启用调试模式
ccr start --debug
```

```
# 指定配置文件
ccr start --config ~/my-ccr-config.json

# 指定端口
ccr start --port 4000

# 启用调试模式
ccr start --debug
```

##### 2.8.5.3 后台运行#

在Linux/macOS系统上，可以使用nohup或systemd来后台运行CCR：

```
bash复制nohup ccr start > ~/.claude-code-router/ccr.log 2>&1 &
```

```
nohup ccr start > ~/.claude-code-router/ccr.log 2>&1 &
```

#### 2.8.6 配置Claude Code使用中转服务#

##### 2.8.6.1 在VS Code中配置#

True. 打开VS Code
True. 点击左侧边栏的Claude Code图标
True. 点击右上角的设置按钮（齿轮图标）
True. 选择高级设置
True. 在API端点字段中输入：
bash复制http://localhost:3000/v1
True. 在API密钥字段中输入：
bash复制ccr:your-anthropic-api-key
True. 点击保存按钮

```
bash复制http://localhost:3000/v1
```

```
http://localhost:3000/v1
```

```
bash复制ccr:your-anthropic-api-key
```

```
ccr:your-anthropic-api-key
```

##### 2.8.6.2 在命令行中配置#

True. 打开终端或命令提示符
True. 运行以下命令配置API端点：
bash复制claude config set api-endpoint http://localhost:3000/v1
True. 配置API密钥：
bash复制claude config set api-key "ccr:your-anthropic-api-key"

```
bash复制claude config set api-endpoint http://localhost:3000/v1
```

```
claude config set api-endpoint http://localhost:3000/v1
```

```
bash复制claude config set api-key "ccr:your-anthropic-api-key"
```

```
claude config set api-key "ccr:your-anthropic-api-key"
```

#### 2.8.7 其他常用中转工具#

##### 2.8.7.1 AnyRouter#

- 特点：功能强大的API路由和转发工具
- 优势：支持多种API协议，提供丰富的路由规则
- 使用方式：下载并部署AnyRouter，配置路由规则

##### 2.8.7.2 Cloudflare Workers#

- 特点：基于Cloudflare边缘网络的无服务器函数
- 优势：全球边缘节点，低延迟访问
- 使用方式：编写并部署Cloudflare Worker脚本

#### 2.8.8 注意事项#

True. 网络安全：使用中转工具时，注意保护API密钥和敏感数据
True. 性能影响：中转工具可能会对请求响应时间产生一定影响
True. 可靠性：自行部署的中转服务需要考虑高可用性和故障恢复
True. 合规性：确保使用中转工具符合相关法律法规和服务条款
True. 成本控制：使用第三方中转服务时，注意了解相关费用和使用限制
True. 更新维护：定期更新中转工具和配置，确保安全性和稳定性

---

# 第 3 章

## 1 界面介绍与导航

**URL**: https://claudecode.tangshuang.net/course/3.1%20%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AF%BC%E8%88%AA

#### 3.1.1 概述#

Claude Code提供了直观的界面，方便开发者进行代码开发和协作。熟悉界面布局和导航方式是使用Claude Code的基础，它可以帮助你快速找到所需功能，提高工作效率。本节将详细介绍Claude Code的界面组成和导航方法。

#### 3.1.2 VS Code插件界面#

##### 3.1.2.1 活动栏#

VS Code的活动栏位于左侧，包含各种功能图标。Claude Code的图标通常位于活动栏的底部或中部，图标是一个带有Claude标志的蓝色图标。

点击Claude Code图标，会打开Claude Code的侧边栏，显示主要功能区域。

##### 3.1.2.2 侧边栏#

Claude Code的侧边栏包含以下主要区域：

True. 欢迎区：首次使用时显示欢迎信息和快速开始指南
True. 对话区：显示与Claude Code的对话历史
True. 文件区：显示项目的文件结构
True. 命令区：提供常用命令的快捷访问
True. 设置区：提供快速设置选项

##### 3.1.2.3 编辑器区#

编辑器区是VS Code的主要工作区域，用于编辑代码文件。Claude Code会在编辑器区中生成和修改代码。

##### 3.1.2.4 状态栏#

状态栏位于VS Code的底部，显示当前的编辑状态、分支信息、语言模式等。Claude Code会在状态栏中显示当前的连接状态和模型信息。

##### 3.1.2.5 面板区#

面板区位于编辑器区的底部，用于显示输出、终端、调试控制台等。Claude Code会在面板区中显示执行结果和日志信息。

#### 3.1.3 命令行工具界面#

##### 3.1.3.1 交互式界面#

Claude Code命令行工具提供了交互式界面，类似于终端中的聊天界面。在交互式界面中，可以直接输入命令和消息与Claude Code进行交互。

##### 3.1.3.2 命令提示符#

命令行工具的命令提示符通常显示为：

claude>

在命令提示符后输入命令或消息，按Enter键执行。

##### 3.1.3.3 输出格式#

命令行工具的输出格式通常为：

```
bash复制[Claude] 这是Claude Code的响应内容
```

```
[Claude] 这是Claude Code的响应内容
```

#### 3.1.4 导航方法#

##### 3.1.4.1 在VS Code中导航#

True. 活动栏导航：点击活动栏中的Claude Code图标，打开或关闭侧边栏
True. 侧边栏导航：在侧边栏中点击不同的选项卡，切换功能区域
True. 文件导航：在文件区中浏览和打开项目文件
True. 命令导航：使用快捷键或命令面板访问Claude Code命令

##### 3.1.4.2 快捷键#

Claude Code提供了以下常用快捷键：

```
Ctrl+Shift+C
```

```
Cmd+Shift+C
```

```
Ctrl+Shift+P
```

```
Cmd+Shift+P
```

```
Ctrl+Enter
```

```
Cmd+Enter
```

```
Esc
```

##### 3.1.4.3 命令面板#

可以使用VS Code的命令面板访问Claude Code的所有命令：

True. 按下Ctrl+Shift+P / Cmd+Shift+P打开命令面板
True. 输入"Claude Code"，会显示所有可用的Claude Code命令
True. 选择需要的命令，按Enter键执行

```
Ctrl+Shift+P
```

```
Cmd+Shift+P
```

#### 3.1.5 界面定制#

##### 3.1.5.1 调整侧边栏大小#

可以通过拖动侧边栏的边缘来调整其宽度，以适应你的工作习惯。

##### 3.1.5.2 隐藏/显示功能区#

可以在VS Code的设置中隐藏或显示Claude Code的某些功能区：

True. 打开VS Code设置
True. 搜索 "Claude Code"
True. 找到"UI"相关设置
True. 根据需要启用或禁用功能区

##### 3.1.5.3 自定义主题#

Claude Code会自动适应VS Code的主题设置。可以在VS Code的设置中修改主题：

True. 打开VS Code设置
True. 搜索 "Theme"
True. 选择你喜欢的主题

#### 3.1.6 常见问题与解决方案#

##### 3.1.6.1 侧边栏不显示#

问题：点击Claude Code图标后，侧边栏不显示

- 检查VS Code是否已更新到最新版本
- 检查Claude Code插件是否已更新到最新版本
- 尝试重新启动VS Code
- 尝试卸载并重新安装Claude Code插件

##### 3.1.6.2 界面显示异常#

问题：Claude Code界面显示异常，如按钮不显示、布局混乱等

- 检查VS Code是否已更新到最新版本
- 检查Claude Code插件是否已更新到最新版本
- 尝试清除VS Code的缓存
- 尝试切换到不同的主题

##### 3.1.6.3 快捷键冲突#

问题：Claude Code的快捷键与其他插件或VS Code内置功能冲突

- 打开VS Code的键盘快捷方式设置
- 搜索并修改冲突的快捷键
- 或在Claude Code设置中修改快捷键

#### 3.1.7 导航最佳实践#

True. 熟悉快捷键：记住常用快捷键可以提高导航效率
True. 自定义布局：根据工作习惯调整界面布局
True. 使用命令面板：命令面板是访问所有功能的便捷方式
True. 定期清理对话：定期清理对话历史，保持界面整洁
True. 使用快速访问：将常用功能添加到快速访问区域

#### 3.1.8 总结#

Claude Code的界面设计直观易用，通过熟悉界面布局和导航方法，可以提高使用Claude Code的效率。VS Code插件提供了丰富的可视化界面，而命令行工具提供了简洁的终端界面，开发者可以根据自己的偏好选择使用方式。

在使用Claude Code时，建议花一些时间熟悉界面布局和导航方法，这将有助于你更快地找到所需功能，提高工作效率。

---

## 2 基本对话交互

**URL**: https://claudecode.tangshuang.net/course/3.2%20%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%AF%9D%E4%BA%A4%E4%BA%92

#### 3.2.1 概述#

Claude Code的核心功能之一是与开发者进行自然语言对话，理解开发者的需求并提供相应的帮助。掌握基本的对话交互方式是使用Claude Code的基础，它可以帮助你更有效地与Claude Code进行沟通，获取所需的代码和建议。本节将详细介绍Claude Code的基本对话交互方式。

#### 3.2.2 启动对话#

##### 3.2.2.1 在VS Code中启动对话#

True. 打开VS Code
True. 点击左侧边栏的Claude Code图标
True. 在侧边栏中点击"新对话"按钮
True. 在输入框中输入你的问题或需求
True. 按下Ctrl+Enter / Cmd+Enter发送消息

```
Ctrl+Enter
```

```
Cmd+Enter
```

##### 3.2.2.2 在命令行工具中启动对话#

True. 打开终端或命令提示符
True. 运行以下命令启动交互式对话：
bash复制claude chat
True. 在命令提示符后输入你的问题或需求
True. 按下Enter键发送消息

```
bash复制claude chat
```

```
claude chat
```

#### 3.2.3 对话格式#

##### 3.2.3.1 自然语言输入#

Claude Code支持自然语言输入，你可以直接用中文或英文描述你的需求，例如：

- "帮我写一个Python函数来计算斐波那契数列"
- "解释这段JavaScript代码的工作原理"
- "修复这个React组件中的错误"

##### 3.2.3.2 代码块输入#

你可以使用代码块格式输入代码，例如：

```
python复制def fib(n):
```

```
def fib(n):
```

```
bash复制return 1 if n <= 1 else fib(n-1) + fib(n-2)
```

```
return 1 if n <= 1 else fib(n-1) + fib(n-2)
```

```
bash复制### 3.2.3.3 混合输入
你可以混合使用自然语言和代码块，例如：

~~~bash
帮我优化这段Python函数，提高它的性能：

```python
def fib(n):
    return 1 if n <= 1 else fib(n-1) + fib(n-2)
```

```
### 3.2.3.3 混合输入
你可以混合使用自然语言和代码块，例如：

~~~bash
帮我优化这段Python函数，提高它的性能：

```python
def fib(n):
    return 1 if n <= 1 else fib(n-1) + fib(n-2)
```

```
bash复制
## 3.2.4 对话技巧
### 3.2.4.1 清晰明确的需求
当与Claude Code交互时，尽量提供清晰明确的需求，这有助于Claude Code更好地理解你的意图，提供更准确的响应。
**不好的示例**：
```bash
帮我写一个函数。
```
**好的示例**：
```bash
帮我写一个Python函数，接收一个整数n作为参数，返回前n个斐波那契数的列表，使用迭代方式实现，提高性能。
```
### 3.2.4.2 提供上下文信息
提供足够的上下文信息可以帮助Claude Code更好地理解你的需求，特别是在处理复杂问题时。
**示例**：
```bash
我正在开发一个React应用，使用TypeScript和Next.js框架。我需要实现一个用户登录组件，包含用户名、密码输入框和登录按钮，以及表单验证功能。请帮我实现这个组件。
```
### 3.2.4.3 逐步细化需求

对于复杂的需求，可以采用逐步细化的方式，先提出大致需求，然后根据Claude Code的响应进一步细化。
**示例**：
```bash
我正在开发一个React应用，使用TypeScript和Next.js框架。我需要实现一个用户登录组件，包含用户名、密码输入框和登录按钮，以及表单验证功能。请帮我实现这个组件。
```
### 3.2.4.4 使用具体示例
使用具体示例可以帮助Claude Code更好地理解你的需求，例如：
**示例**：
```bash
帮我实现一个函数，将日期格式从"YYYY-MM-DD"转换为"DD/MM/YYYY"，例如：

输入："2023-12-25"
输出："25/12/2023"

```
## 3.2.5 对话历史管理

### 3.2.5.1 查看对话历史

在VS Code插件中，对话历史显示在侧边栏的对话区中，你可以通过滚动查看完整的对话历史。

在命令行工具中，对话历史直接显示在终端中，你可以通过终端的滚动功能查看。

### 3.2.5.2 清除对话历史

1. **在VS Code中**：
 - 在侧边栏中点击"清除对话"按钮
 - 或使用快捷键`Ctrl+Shift+L` / `Cmd+Shift+L`

2. **在命令行工具中**：
 - 输入`clear`命令清除当前对话
 - 或退出并重新启动交互式对话

### 3.2.5.3 保存对话历史

在VS Code插件中，对话历史会自动保存，你可以在下次打开VS Code时继续之前的对话。

在命令行工具中，对话历史不会自动保存，如果你需要保存对话历史，可以使用终端的复制功能或重定向输出到文件：

```bash
claude chat conversation.log
```
## 3.2.6 对话响应类型
Claude Code的响应主要包括以下类型：
### 3.2.6.1 代码响应
当你请求Claude Code生成或修改代码时，它会返回代码块形式的响应：

```python
def fib(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]

    fib_list = [0, 1]
    for i in range(2, n):
        next_fib = fib_list[i-1] + fib_list[i-2]
        fib_list.append(next_fib)

    return fib_list
```

### 3.2.6.2 解释响应

当你请求Claude Code解释代码或概念时，它会返回详细的解释：

这段代码实现了一个迭代版本的斐波那契数列生成函数。它的工作原理如下：
1. 首先处理边界情况：
    - 如果n <= 0，返回空列表
    - 如果n == 1，返回[0]
    - 如果n == 2，返回[0, 1]
2. 对于n 2的情况：
    - 初始化一个包含前两个斐波那契数的列表[0, 1]
    - 使用for循环从索引2开始，计算后续的斐波那契数
    - 每个新的斐波那契数是前两个数的和
    - 将计算出的新数添加到列表中
    - 循环结束后返回完整的斐波那契数列列表
3. 性能分析：
    - 时间复杂度：O(n)，因为只需要遍历一次
    - 空间复杂度：O(n)，需要存储生成的斐波那契数列
    - 相比递归实现，迭代实现避免了重复计算，性能更好

### 3.2.6.3 问题响应
当你请求Claude Code回答问题时，它会返回详细的回答：
```bash
React中的useState钩子用于在函数组件中添加状态管理。它的基本用法是：

const [state, setState] = useState(initialState);

- state：当前状态值
- setState：更新状态的函数
- initialState：初始状态值

useState钩子的特点：
1. 每次调用setState都会触发组件重新渲染
2. setState是异步的，React会批量处理状态更新
3. 可以使用函数式更新来获取最新状态
4. 可以使用多个useState钩子来管理多个状态
```
## 3.2.7 对话命令

Claude Code支持一些特殊命令，可以在对话中使用：

### 3.2.7.1 帮助命令

输入`/help`或`/h`查看可用命令列表：
```bash
可用命令：
/help, /h - 显示帮助信息
/new - 开始新对话
/clear - 清除当前对话
/model - 切换模型
/config - 查看或修改配置
/exit - 退出对话（仅命令行）
```
### 3.2.7.2 模型切换命令
输入`/model`切换使用的模型：
```bash
当前模型：claude-4-sonnet
可用模型：

请选择模型（输入数字）：

```
### 3.2.7.3 配置命令

输入`/config`查看或修改配置：
```bash
当前配置：
model: claude-4-sonnet
temperature: 0.7
max-tokens: 1024
可用配置项：
1. model
2. temperature
3. max-tokens
请选择要修改的配置项（输入数字）：
```
```

```
## 3.2.4 对话技巧
### 3.2.4.1 清晰明确的需求
当与Claude Code交互时，尽量提供清晰明确的需求，这有助于Claude Code更好地理解你的意图，提供更准确的响应。
**不好的示例**：
```bash
帮我写一个函数。
```
**好的示例**：
```bash
帮我写一个Python函数，接收一个整数n作为参数，返回前n个斐波那契数的列表，使用迭代方式实现，提高性能。
```
### 3.2.4.2 提供上下文信息
提供足够的上下文信息可以帮助Claude Code更好地理解你的需求，特别是在处理复杂问题时。
**示例**：
```bash
我正在开发一个React应用，使用TypeScript和Next.js框架。我需要实现一个用户登录组件，包含用户名、密码输入框和登录按钮，以及表单验证功能。请帮我实现这个组件。
```
### 3.2.4.3 逐步细化需求

对于复杂的需求，可以采用逐步细化的方式，先提出大致需求，然后根据Claude Code的响应进一步细化。
**示例**：
```bash
我正在开发一个React应用，使用TypeScript和Next.js框架。我需要实现一个用户登录组件，包含用户名、密码输入框和登录按钮，以及表单验证功能。请帮我实现这个组件。
```
### 3.2.4.4 使用具体示例
使用具体示例可以帮助Claude Code更好地理解你的需求，例如：
**示例**：
```bash
帮我实现一个函数，将日期格式从"YYYY-MM-DD"转换为"DD/MM/YYYY"，例如：

输入："2023-12-25"
输出："25/12/2023"

```
## 3.2.5 对话历史管理

### 3.2.5.1 查看对话历史

在VS Code插件中，对话历史显示在侧边栏的对话区中，你可以通过滚动查看完整的对话历史。

在命令行工具中，对话历史直接显示在终端中，你可以通过终端的滚动功能查看。

### 3.2.5.2 清除对话历史

1. **在VS Code中**：
 - 在侧边栏中点击"清除对话"按钮
 - 或使用快捷键`Ctrl+Shift+L` / `Cmd+Shift+L`

2. **在命令行工具中**：
 - 输入`clear`命令清除当前对话
 - 或退出并重新启动交互式对话

### 3.2.5.3 保存对话历史

在VS Code插件中，对话历史会自动保存，你可以在下次打开VS Code时继续之前的对话。

在命令行工具中，对话历史不会自动保存，如果你需要保存对话历史，可以使用终端的复制功能或重定向输出到文件：

```bash
claude chat conversation.log
```
## 3.2.6 对话响应类型
Claude Code的响应主要包括以下类型：
### 3.2.6.1 代码响应
当你请求Claude Code生成或修改代码时，它会返回代码块形式的响应：

```python
def fib(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]

    fib_list = [0, 1]
    for i in range(2, n):
        next_fib = fib_list[i-1] + fib_list[i-2]
        fib_list.append(next_fib)

    return fib_list
```

### 3.2.6.2 解释响应

当你请求Claude Code解释代码或概念时，它会返回详细的解释：

这段代码实现了一个迭代版本的斐波那契数列生成函数。它的工作原理如下：
1. 首先处理边界情况：
    - 如果n <= 0，返回空列表
    - 如果n == 1，返回[0]
    - 如果n == 2，返回[0, 1]
2. 对于n 2的情况：
    - 初始化一个包含前两个斐波那契数的列表[0, 1]
    - 使用for循环从索引2开始，计算后续的斐波那契数
    - 每个新的斐波那契数是前两个数的和
    - 将计算出的新数添加到列表中
    - 循环结束后返回完整的斐波那契数列列表
3. 性能分析：
    - 时间复杂度：O(n)，因为只需要遍历一次
    - 空间复杂度：O(n)，需要存储生成的斐波那契数列
    - 相比递归实现，迭代实现避免了重复计算，性能更好

### 3.2.6.3 问题响应
当你请求Claude Code回答问题时，它会返回详细的回答：
```bash
React中的useState钩子用于在函数组件中添加状态管理。它的基本用法是：

const [state, setState] = useState(initialState);

- state：当前状态值
- setState：更新状态的函数
- initialState：初始状态值

useState钩子的特点：
1. 每次调用setState都会触发组件重新渲染
2. setState是异步的，React会批量处理状态更新
3. 可以使用函数式更新来获取最新状态
4. 可以使用多个useState钩子来管理多个状态
```
## 3.2.7 对话命令

Claude Code支持一些特殊命令，可以在对话中使用：

### 3.2.7.1 帮助命令

输入`/help`或`/h`查看可用命令列表：
```bash
可用命令：
/help, /h - 显示帮助信息
/new - 开始新对话
/clear - 清除当前对话
/model - 切换模型
/config - 查看或修改配置
/exit - 退出对话（仅命令行）
```
### 3.2.7.2 模型切换命令
输入`/model`切换使用的模型：
```bash
当前模型：claude-4-sonnet
可用模型：

请选择模型（输入数字）：

```
### 3.2.7.3 配置命令

输入`/config`查看或修改配置：
```bash
当前配置：
model: claude-4-sonnet
temperature: 0.7
max-tokens: 1024
可用配置项：
1. model
2. temperature
3. max-tokens
请选择要修改的配置项（输入数字）：
```
```

---

## 3 基础代码生成

**URL**: https://claudecode.tangshuang.net/course/3.3%20%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90

#### 3.3.1 概述#

Claude Code最核心的功能之一是代码生成，它可以根据自然语言描述生成各种编程语言的代码。掌握基础代码生成功能是使用Claude Code的关键，它可以帮助你快速生成代码骨架、常用功能模块和完整的程序。本节将详细介绍Claude Code的基础代码生成功能和使用方法。

#### 3.3.2 简单代码生成#

##### 3.3.2.1 生成函数#

你可以要求Claude Code生成单个函数，例如：

输入：
帮我写一个Python函数来计算阶乘

```
python复制def factorial(n):
    """
    计算给定整数的阶乘

    参数:
    n: int - 要计算阶乘的整数

    返回:
    int - 阶乘结果

    示例:
```

```
def factorial(n):
    """
    计算给定整数的阶乘

    参数:
    n: int - 要计算阶乘的整数

    返回:
    int - 阶乘结果

    示例:
```

```
bash复制>>factorial(5)
120
>>factorial(0)
1
"""
if n < 0:
    raise ValueError("阶乘不能为负数")
elif n == 0 or n == 1:
    return 1
else:
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```

```
>>factorial(5)
120
>>factorial(0)
1
"""
if n < 0:
    raise ValueError("阶乘不能为负数")
elif n == 0 or n == 1:
    return 1
else:
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```

```
bash复制
### 3.3.2.2 生成类

你可以要求Claude Code生成完整的类，例如：

**输入**：
```bash
帮我写一个Java类，表示学生信息，包含姓名、年龄、学号、成绩等属性，以及相应的getter和setter方法
```

```
### 3.3.2.2 生成类

你可以要求Claude Code生成完整的类，例如：

**输入**：
```bash
帮我写一个Java类，表示学生信息，包含姓名、年龄、学号、成绩等属性，以及相应的getter和setter方法
```

```
java复制public class Student {
    // 成员变量
    private String name;
    private int age;
    private String studentId;
    private double score;

    // 默认构造方法
    public Student() {
    }

    // 带参数的构造方法
    public Student(String name, int age, String studentId, double score) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
        this.score = score;
    }

    // getter和setter方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getStudentId() {
        return studentId;
    }

    public void setStudentId(String studentId) {
        this.studentId = studentId;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    // toString方法，用于打印学生信息
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", studentId='" + studentId + '\'' +
                ", score=" + score +
                '}';
    }

    // equals方法，用于比较两个学生对象是否相等
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && Double.compare(student.score, score) == 0 && Objects.equals(name, student.name) && Objects.equals(studentId, student.studentId);
    }

    // hashCode方法
    @Override
    public int hashCode() {
        return Objects.hash(name, age, studentId, score);
    }
}
```

```
public class Student {
    // 成员变量
    private String name;
    private int age;
    private String studentId;
    private double score;

    // 默认构造方法
    public Student() {
    }

    // 带参数的构造方法
    public Student(String name, int age, String studentId, double score) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
        this.score = score;
    }

    // getter和setter方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getStudentId() {
        return studentId;
    }

    public void setStudentId(String studentId) {
        this.studentId = studentId;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    // toString方法，用于打印学生信息
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", studentId='" + studentId + '\'' +
                ", score=" + score +
                '}';
    }

    // equals方法，用于比较两个学生对象是否相等
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && Double.compare(student.score, score) == 0 && Objects.equals(name, student.name) && Objects.equals(studentId, student.studentId);
    }

    // hashCode方法
    @Override
    public int hashCode() {
        return Objects.hash(name, age, studentId, score);
    }
}
```

##### 3.3.2.3 生成完整程序#

你可以要求Claude Code生成完整的程序，例如：

```
bash复制帮我写一个C++程序，实现一个简单的计算器，支持加减乘除四种运算
```

```
帮我写一个C++程序，实现一个简单的计算器，支持加减乘除四种运算
```

```
cpp复制#include <iostream>
#include <string>
#include <stdexcept>

using namespace std;

// 计算器类
class Calculator {
public:
    // 加法
    double add(double a, double b) {
        return a + b;
    }

    // 减法
    double subtract(double a, double b) {
        return a - b;
    }

    // 乘法
    double multiply(double a, double b) {
        return a * b;
    }

    // 除法
    double divide(double a, double b) {
        if (b == 0) {
            throw runtime_error("除数不能为零");
        }
        return a / b;
    }
};

int main() {
    Calculator calc;
    char operation;
    double num1, num2;

    cout << "简单计算器\n";
    cout << "支持的运算：+、-、*、/\n";
    cout << "输入格式：数字 运算符 数字\n";
    cout << "例如：1 + 2\n";
    cout << "输入 'exit' 退出程序\n\n";

    while (true) {
        string input;
        cout << "请输入：";
        getline(cin, input);

        // 检查是否退出
        if (input == "exit") {
            cout << "程序已退出\n";
            break;
        }

        try {
            // 解析输入
            size_t op_pos = input.find_first_of("+-*/");
            if (op_pos == string::npos) {
                cout << "无效的输入格式\n";
                continue;
            }

            operation = input[op_pos];
            num1 = stod(input.substr(0, op_pos));
            num2 = stod(input.substr(op_pos + 1));

            // 执行运算
            double result;
            switch (operation) {
                case '+':
                    result = calc.add(num1, num2);
                    break;
                case '-':
                    result = calc.subtract(num1, num2);
                    break;
                case '*':
                    result = calc.multiply(num1, num2);
                    break;
                case '/':
                    result = calc.divide(num1, num2);
                    break;
                default:
                    cout << "无效的运算符\n";
                    continue;
            }

            // 输出结果
            cout << "结果：" << result << "\n";
        } catch (const invalid_argument& e) {
            cout << "无效的数字输入\n";
        } catch (const out_of_range& e) {
            cout << "数字超出范围\n";
        } catch (const runtime_error& e) {
            cout << e.what() << "\n";
        } catch (...) {
            cout << "发生未知错误\n";
        }

        cout << "\n";
    }

    return 0;
}
```

```
#include <iostream>
#include <string>
#include <stdexcept>

using namespace std;

// 计算器类
class Calculator {
public:
    // 加法
    double add(double a, double b) {
        return a + b;
    }

    // 减法
    double subtract(double a, double b) {
        return a - b;
    }

    // 乘法
    double multiply(double a, double b) {
        return a * b;
    }

    // 除法
    double divide(double a, double b) {
        if (b == 0) {
            throw runtime_error("除数不能为零");
        }
        return a / b;
    }
};

int main() {
    Calculator calc;
    char operation;
    double num1, num2;

    cout << "简单计算器\n";
    cout << "支持的运算：+、-、*、/\n";
    cout << "输入格式：数字 运算符 数字\n";
    cout << "例如：1 + 2\n";
    cout << "输入 'exit' 退出程序\n\n";

    while (true) {
        string input;
        cout << "请输入：";
        getline(cin, input);

        // 检查是否退出
        if (input == "exit") {
            cout << "程序已退出\n";
            break;
        }

        try {
            // 解析输入
            size_t op_pos = input.find_first_of("+-*/");
            if (op_pos == string::npos) {
                cout << "无效的输入格式\n";
                continue;
            }

            operation = input[op_pos];
            num1 = stod(input.substr(0, op_pos));
            num2 = stod(input.substr(op_pos + 1));

            // 执行运算
            double result;
            switch (operation) {
                case '+':
                    result = calc.add(num1, num2);
                    break;
                case '-':
                    result = calc.subtract(num1, num2);
                    break;
                case '*':
                    result = calc.multiply(num1, num2);
                    break;
                case '/':
                    result = calc.divide(num1, num2);
                    break;
                default:
                    cout << "无效的运算符\n";
                    continue;
            }

            // 输出结果
            cout << "结果：" << result << "\n";
        } catch (const invalid_argument& e) {
            cout << "无效的数字输入\n";
        } catch (const out_of_range& e) {
            cout << "数字超出范围\n";
        } catch (const runtime_error& e) {
            cout << e.what() << "\n";
        } catch (...) {
            cout << "发生未知错误\n";
        }

        cout << "\n";
    }

    return 0;
}
```

#### 3.3.3 生成特定框架代码#

##### 3.3.3.1 Web框架代码#

Claude Code熟悉各种Web框架，可以生成相应的代码，例如：

输入：
帮我写一个Node.js Express路由，实现用户注册功能，包括验证和错误处理

```
javascript复制const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const bcrypt = require('bcryptjs');
const User = require('../models/User');

// 用户注册路由
router.post('/register',
    // 验证规则
    [
        body('username')
            .notEmpty().withMessage('用户名不能为空')
            .isLength({ min: 3, max: 20 }).withMessage('用户名长度必须在3-20个字符之间')
            .matches(/^[a-zA-Z0-9_]+$/).withMessage('用户名只能包含字母、数字和下划线'),
        body('email')
            .notEmpty().withMessage('邮箱不能为空')
            .isEmail().withMessage('请输入有效的邮箱地址'),
        body('password')
            .notEmpty().withMessage('密码不能为空')
            .isLength({ min: 6 }).withMessage('密码长度不能少于6个字符')
            .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{6,}$/).withMessage('密码必须包含至少一个大写字母、一个小写字母和一个数字'),
        body('confirmPassword')
            .notEmpty().withMessage('确认密码不能为空')
            .custom((value, { req }) ={
                if (value !== req.body.password) {
                    throw new Error('两次密码输入不一致');
                }
                return true;
            })
    ],
    async (req, res) ={
        // 检查验证结果
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        try {
            // 检查用户名是否已存在
            let user = await User.findOne({ username: req.body.username });
            if (user) {
                return res.status(400).json({ errors: [{ msg: '该用户名已存在' }] });
            }

            // 检查邮箱是否已存在
            user = await User.findOne({ email: req.body.email });
            if (user) {
                return res.status(400).json({ errors: [{ msg: '该邮箱已被注册' }] });
            }

            // 创建新用户
            user = new User({
                username: req.body.username,
                email: req.body.email,
                password: req.body.password
            });

            // 加密密码
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(user.password, salt);

            // 保存用户到数据库
            await user.save();

            // 返回成功响应
            res.status(201).json({
                msg: '注册成功',
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email
                }
            });
        } catch (err) {
            console.error(err.message);
            res.status(500).send('服务器错误');
        }
    }
);

module.exports = router;
```

```
const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const bcrypt = require('bcryptjs');
const User = require('../models/User');

// 用户注册路由
router.post('/register',
    // 验证规则
    [
        body('username')
            .notEmpty().withMessage('用户名不能为空')
            .isLength({ min: 3, max: 20 }).withMessage('用户名长度必须在3-20个字符之间')
            .matches(/^[a-zA-Z0-9_]+$/).withMessage('用户名只能包含字母、数字和下划线'),
        body('email')
            .notEmpty().withMessage('邮箱不能为空')
            .isEmail().withMessage('请输入有效的邮箱地址'),
        body('password')
            .notEmpty().withMessage('密码不能为空')
            .isLength({ min: 6 }).withMessage('密码长度不能少于6个字符')
            .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{6,}$/).withMessage('密码必须包含至少一个大写字母、一个小写字母和一个数字'),
        body('confirmPassword')
            .notEmpty().withMessage('确认密码不能为空')
            .custom((value, { req }) ={
                if (value !== req.body.password) {
                    throw new Error('两次密码输入不一致');
                }
                return true;
            })
    ],
    async (req, res) ={
        // 检查验证结果
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        try {
            // 检查用户名是否已存在
            let user = await User.findOne({ username: req.body.username });
            if (user) {
                return res.status(400).json({ errors: [{ msg: '该用户名已存在' }] });
            }

            // 检查邮箱是否已存在
            user = await User.findOne({ email: req.body.email });
            if (user) {
                return res.status(400).json({ errors: [{ msg: '该邮箱已被注册' }] });
            }

            // 创建新用户
            user = new User({
                username: req.body.username,
                email: req.body.email,
                password: req.body.password
            });

            // 加密密码
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(user.password, salt);

            // 保存用户到数据库
            await user.save();

            // 返回成功响应
            res.status(201).json({
                msg: '注册成功',
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email
                }
            });
        } catch (err) {
            console.error(err.message);
            res.status(500).send('服务器错误');
        }
    }
);

module.exports = router;
```

##### 3.3.3.2 前端框架代码#

Claude Code也可以生成前端框架代码，例如：

```
bash复制帮我写一个React组件，实现一个待办事项列表，支持添加、删除和标记完成功能
```

```
帮我写一个React组件，实现一个待办事项列表，支持添加、删除和标记完成功能
```

```
javascript复制import React, { useState } from 'react';

const TodoList = () ={
    // 状态管理
    const [todos, setTodos] = useState([]);
    const [inputText, setInputText] = useState('');

    // 生成唯一ID
    const generateId = () ={
        return Math.random().toString(36).substr(2, 9);
    };

    // 添加待办事项
    const handleAddTodo = (e) ={
        e.preventDefault();
        if (inputText.trim() === '') return;

        const newTodo = {
            id: generateId(),
            text: inputText,
            completed: false
        };

        setTodos([...todos, newTodo]);
        setInputText('');
    };

    // 删除待办事项
    const handleDeleteTodo = (id) ={
        setTodos(todos.filter(todo =todo.id !== id));
    };

    // 切换待办事项完成状态
    const handleToggleComplete = (id) ={
        setTodos(todos.map(todo ={
            if (todo.id === id) {
                return { ...todo, completed: !todo.completed };
            }
            return todo;
        }));
    };

    return (
        <div className="todo-list-container">
            <h1>待办事项列表</h1>

            {/* 添加待办事项表单 */}
            <form onSubmit={handleAddTodo} className="todo-form">
                <input
                    type="text"
                    placeholder="添加新的待办事项..."
                    value={inputText}
                    onChange={(e) =setInputText(e.target.value)}
                    className="todo-input"
                />
                <button type="submit" className="add-button">
                    添加
                </button>
            </form>

            {/* 待办事项列表 */}
            <ul className="todo-items">
                {todos.length === 0 ? (
                    <li className="no-todos">暂无待办事项</li>
                ) : (
                    todos.map(todo =(
                        <li
                            key={todo.id}
                            className={`todo-item ${todo.completed ? 'completed' : ''}`}
                        >
                            <div className="todo-content">
                                <input
                                    type="checkbox"
                                    checked={todo.completed}
                                    onChange={() =handleToggleComplete(todo.id)}
                                    className="todo-checkbox"
                                />
                                <span className="todo-text">{todo.text}</span>
                            </div>
                            <button
                                onClick={() =handleDeleteTodo(todo.id)}
                                className="delete-button"
                            >
                                删除
                            </button>
                        </li>
                    ))
                )}
            </ul>
        </div>
    );
};

export default TodoList;
```

```
import React, { useState } from 'react';

const TodoList = () ={
    // 状态管理
    const [todos, setTodos] = useState([]);
    const [inputText, setInputText] = useState('');

    // 生成唯一ID
    const generateId = () ={
        return Math.random().toString(36).substr(2, 9);
    };

    // 添加待办事项
    const handleAddTodo = (e) ={
        e.preventDefault();
        if (inputText.trim() === '') return;

        const newTodo = {
            id: generateId(),
            text: inputText,
            completed: false
        };

        setTodos([...todos, newTodo]);
        setInputText('');
    };

    // 删除待办事项
    const handleDeleteTodo = (id) ={
        setTodos(todos.filter(todo =todo.id !== id));
    };

    // 切换待办事项完成状态
    const handleToggleComplete = (id) ={
        setTodos(todos.map(todo ={
            if (todo.id === id) {
                return { ...todo, completed: !todo.completed };
            }
            return todo;
        }));
    };

    return (
        <div className="todo-list-container">
            <h1>待办事项列表</h1>

            {/* 添加待办事项表单 */}
            <form onSubmit={handleAddTodo} className="todo-form">
                <input
                    type="text"
                    placeholder="添加新的待办事项..."
                    value={inputText}
                    onChange={(e) =setInputText(e.target.value)}
                    className="todo-input"
                />
                <button type="submit" className="add-button">
                    添加
                </button>
            </form>

            {/* 待办事项列表 */}
            <ul className="todo-items">
                {todos.length === 0 ? (
                    <li className="no-todos">暂无待办事项</li>
                ) : (
                    todos.map(todo =(
                        <li
                            key={todo.id}
                            className={`todo-item ${todo.completed ? 'completed' : ''}`}
                        >
                            <div className="todo-content">
                                <input
                                    type="checkbox"
                                    checked={todo.completed}
                                    onChange={() =handleToggleComplete(todo.id)}
                                    className="todo-checkbox"
                                />
                                <span className="todo-text">{todo.text}</span>
                            </div>
                            <button
                                onClick={() =handleDeleteTodo(todo.id)}
                                className="delete-button"
                            >
                                删除
                            </button>
                        </li>
                    ))
                )}
            </ul>
        </div>
    );
};

export default TodoList;
```

#### 3.3.4 生成配置文件#

Claude Code可以生成各种配置文件，例如：

```
bash复制帮我写一个package.json文件，用于一个React项目，包含常用的依赖和脚本
```

```
帮我写一个package.json文件，用于一个React项目，包含常用的依赖和脚本
```

```
json复制{
  "name": "my-react-app",
  "version": "1.0.0",
  "description": "A React application",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.16.0",
    "axios": "^1.5.0",
    "styled-components": "^6.0.8"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-router-dom": "^5.3.3",
    "@types/styled-components": "^5.1.26",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "eslint": "^8.49.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "keywords": ["react", "javascript", "typescript"],
  "author": "Your Name",
  "license": "MIT",
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

```
{
  "name": "my-react-app",
  "version": "1.0.0",
  "description": "A React application",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.16.0",
    "axios": "^1.5.0",
    "styled-components": "^6.0.8"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-router-dom": "^5.3.3",
    "@types/styled-components": "^5.1.26",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "eslint": "^8.49.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "keywords": ["react", "javascript", "typescript"],
  "author": "Your Name",
  "license": "MIT",
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

#### 3.3.5 生成测试代码#

Claude Code可以生成各种测试代码，例如：

```
bash复制帮我写一个Jest测试用例，测试前面生成的阶乘函数
```

```
帮我写一个Jest测试用例，测试前面生成的阶乘函数
```

```
javascript复制// 导入阶乘函数
const factorial = require('./factorial');

describe('阶乘函数测试', () ={
    // 测试基本情况
    test('0的阶乘应该返回1', () ={
        expect(factorial(0)).toBe(1);
    });

    test('1的阶乘应该返回1', () ={
        expect(factorial(1)).toBe(1);
    });

    // 测试普通正整数
    test('5的阶乘应该返回120', () ={
        expect(factorial(5)).toBe(120);
    });

    test('10的阶乘应该返回3628800', () ={
        expect(factorial(10)).toBe(3628800);
    });

    // 测试较大的数
    test('15的阶乘应该返回1307674368000', () ={
        expect(factorial(15)).toBe(1307674368000);
    });

    // 测试异常情况
    test('负数的阶乘应该抛出错误', () ={
        expect(() =factorial(-1)).toThrow();
        expect(() =factorial(-5)).toThrow();
        expect(() =factorial(-10)).toThrow();
    });

    // 测试非整数输入
    test('非整数输入应该抛出错误', () ={
        expect(() =factorial(1.5)).toThrow();
        expect(() =factorial('5')).toThrow();
        expect(() =factorial(null)).toThrow();
        expect(() =factorial(undefined)).toThrow();
    });
});
```

```
// 导入阶乘函数
const factorial = require('./factorial');

describe('阶乘函数测试', () ={
    // 测试基本情况
    test('0的阶乘应该返回1', () ={
        expect(factorial(0)).toBe(1);
    });

    test('1的阶乘应该返回1', () ={
        expect(factorial(1)).toBe(1);
    });

    // 测试普通正整数
    test('5的阶乘应该返回120', () ={
        expect(factorial(5)).toBe(120);
    });

    test('10的阶乘应该返回3628800', () ={
        expect(factorial(10)).toBe(3628800);
    });

    // 测试较大的数
    test('15的阶乘应该返回1307674368000', () ={
        expect(factorial(15)).toBe(1307674368000);
    });

    // 测试异常情况
    test('负数的阶乘应该抛出错误', () ={
        expect(() =factorial(-1)).toThrow();
        expect(() =factorial(-5)).toThrow();
        expect(() =factorial(-10)).toThrow();
    });

    // 测试非整数输入
    test('非整数输入应该抛出错误', () ={
        expect(() =factorial(1.5)).toThrow();
        expect(() =factorial('5')).toThrow();
        expect(() =factorial(null)).toThrow();
        expect(() =factorial(undefined)).toThrow();
    });
});
```

#### 3.3.6 代码生成技巧#

##### 3.3.6.1 提供明确的需求#

在要求Claude Code生成代码时，提供明确的需求可以获得更准确的结果，例如：

不好的示例：

```
bash复制帮我写一个登录功能
```

```
帮我写一个登录功能
```

```
bash复制帮我写一个使用React和TypeScript的登录组件，包含用户名和密码输入框，以及登录按钮。需要实现表单验证，包括用户名不能为空，密码长度至少6个字符。使用Axios发送POST请求到/api/login接口，处理成功和失败的情况，并显示相应的提示信息。
```

```
帮我写一个使用React和TypeScript的登录组件，包含用户名和密码输入框，以及登录按钮。需要实现表单验证，包括用户名不能为空，密码长度至少6个字符。使用Axios发送POST请求到/api/login接口，处理成功和失败的情况，并显示相应的提示信息。
```

##### 3.3.6.2 指定编程语言和版本#

明确指定编程语言和版本可以获得更符合需求的代码，例如：

```
bash复制帮我写一个Python 3.10版本的异步HTTP客户端，使用aiohttp库
```

```
帮我写一个Python 3.10版本的异步HTTP客户端，使用aiohttp库
```

##### 3.3.6.3 指定框架和库#

如果需要使用特定的框架或库，应该明确指定，例如：

```
bash复制帮我写一个使用Vue 3和Pinia的计数器组件，包含增加、减少和重置功能
```

```
帮我写一个使用Vue 3和Pinia的计数器组件，包含增加、减少和重置功能
```

##### 3.3.6.4 提供示例数据#

提供示例数据可以帮助Claude Code更好地理解需求，例如：

```
bash复制帮我写一个JavaScript函数，将以下JSON数据转换为HTML表格：
{
    "users": [
        { "name": "张三", "age": 25, "city": "北京" },
        { "name": "李四", "age": 30, "city": "上海" },
        { "name": "王五", "age": 35, "city": "广州" }
    ]
}
```

```
帮我写一个JavaScript函数，将以下JSON数据转换为HTML表格：
{
    "users": [
        { "name": "张三", "age": 25, "city": "北京" },
        { "name": "李四", "age": 30, "city": "上海" },
        { "name": "王五", "age": 35, "city": "广州" }
    ]
}
```

##### 3.3.6.5 使用逐步细化的方法#

对于复杂的需求，可以使用逐步细化的方法，例如：

```
bash复制1. 帮我写一个用户管理系统的后端API
2. 使用Node.js和Express框架
3. 数据库使用MongoDB
4. 实现用户注册、登录、获取用户列表和删除用户功能
5. 注册时需要验证邮箱格式和密码强度
6. 登录时生成JWT令牌
7. 实现中间件来验证JWT令牌
```

```
1. 帮我写一个用户管理系统的后端API
2. 使用Node.js和Express框架
3. 数据库使用MongoDB
4. 实现用户注册、登录、获取用户列表和删除用户功能
5. 注册时需要验证邮箱格式和密码强度
6. 登录时生成JWT令牌
7. 实现中间件来验证JWT令牌
```

#### 3.3.7 常见问题与解决方案#

##### 3.3.7.1 生成的代码不符合需求#

问题：Claude Code生成的代码不符合预期需求

- 提供更明确的需求描述
- 指定具体的编程语言、框架和库
- 提供示例数据或示例代码
- 逐步细化需求

##### 3.3.7.2 生成的代码存在语法错误#

问题：Claude Code生成的代码存在语法错误

- 检查是否指定了正确的编程语言版本
- 提供更明确的需求描述
- 要求Claude Code修复语法错误

##### 3.3.7.3 生成的代码缺少必要的功能#

问题：Claude Code生成的代码缺少必要的功能

- 提供更详细的需求描述
- 明确列出所有需要的功能
- 要求Claude Code添加缺少的功能

##### 3.3.7.4 生成的代码过于复杂#

问题：Claude Code生成的代码过于复杂，超出了需求范围

- 提供更简洁的需求描述
- 明确要求生成简洁的代码
- 要求Claude Code简化代码

#### 3.3.8 代码生成最佳实践#

True. 明确需求：提供清晰、明确的需求描述
True. 指定技术栈：明确指定编程语言、框架和库
True. 提供示例：提供示例数据或示例代码
True. 逐步细化：对于复杂需求，采用逐步细化的方式
True. 验证结果：生成代码后，仔细验证是否符合需求
True. 反馈修正：如果代码不符合需求，及时反馈并修正
True. 学习借鉴：学习Claude Code生成的代码，提高自己的编程能力
True. 结合实际：根据实际情况修改生成的代码，使其更适合项目需求

#### 3.3.9 总结#

Claude Code的基础代码生成功能非常强大，可以生成各种编程语言、框架和库的代码，包括简单函数、完整类、整个程序、配置文件和测试代码等。掌握基础代码生成功能可以大大提高开发效率，减少重复劳动。

在使用Claude Code生成代码时，建议提供明确的需求描述，指定具体的技术栈，提供示例数据或示例代码，并采用逐步细化的方式处理复杂需求。这些技巧可以帮助你获得更符合预期的代码。

同时，生成代码后，应该仔细验证代码是否符合需求，是否存在语法错误或逻辑问题，并根据实际情况进行修改。Claude Code生成的代码可以作为基础，在此基础上进行调整和优化，使其更适合项目的实际需求。

---

## 4 基础代码理解

**URL**: https://claudecode.tangshuang.net/course/3.4%20%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3

#### 3.4.1 概述#

Claude Code 具备强大的代码理解能力，能够深入分析并解释各种编程语言的代码。无论是简单的单行代码还是复杂的大型项目，Claude Code 都能帮助你快速理解其功能、工作原理和潜在问题。通过代码理解功能，你可以：

- 学习新的编程技术和最佳实践
- 快速上手他人编写的代码
- 排查代码中的逻辑错误和性能瓶颈
- 理解复杂算法和数据结构的实现

#### 3.4.2 代码解释#

##### 3.4.2.1 解释单行或简单代码#

对于单行或简单代码片段，Claude Code 能够提供清晰、简洁的解释，帮助你理解代码的基本功能和语法特性。

示例：React useState 钩子

```
bash复制解释这段 JavaScript 代码的意思：const [count, setCount] = useState(0);
```

```
解释这段 JavaScript 代码的意思：const [count, setCount] = useState(0);
```

```
bash复制这段代码是 React Hooks 中 useState 钩子的典型用法，用于在函数组件中管理状态。

具体解释如下：
- `const`: 声明常量的关键字
- `[count, setCount]`: 数组解构赋值，从 useState 返回的数组中提取两个值
- `useState(0)`: 调用 useState 钩子，传入初始状态值 0
- `count`: 存储当前状态值的变量
- `setCount`: 用于更新状态的函数

当调用 `setCount(newValue)` 时，React 会重新渲染组件，并将 `count` 更新为 `newValue`。

useState 钩子的特点：
1. 每次调用都会返回一对新的状态变量和更新函数
2. 状态更新是异步的，可能会被合并
3. 初始值只会在组件首次渲染时生效
4. 可以传递函数作为初始值，用于计算复杂的初始状态
```

```
这段代码是 React Hooks 中 useState 钩子的典型用法，用于在函数组件中管理状态。

具体解释如下：
- `const`: 声明常量的关键字
- `[count, setCount]`: 数组解构赋值，从 useState 返回的数组中提取两个值
- `useState(0)`: 调用 useState 钩子，传入初始状态值 0
- `count`: 存储当前状态值的变量
- `setCount`: 用于更新状态的函数

当调用 `setCount(newValue)` 时，React 会重新渲染组件，并将 `count` 更新为 `newValue`。

useState 钩子的特点：
1. 每次调用都会返回一对新的状态变量和更新函数
2. 状态更新是异步的，可能会被合并
3. 初始值只会在组件首次渲染时生效
4. 可以传递函数作为初始值，用于计算复杂的初始状态
```

##### 3.4.2.2 解释复杂代码块#

对于包含复杂逻辑的代码块，Claude Code 能够深入分析其工作原理、算法复杂度和潜在问题。

示例：快速排序算法

```
bash复制解释这段 Python 代码的工作原理：
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

```
解释这段 Python 代码的工作原理：
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

```
bash复制这段代码实现了快速排序（Quicksort）算法，这是一种高效的分治排序算法。

### 工作原理

1. **基线条件**：如果输入数组的长度小于等于 1，直接返回该数组（已经有序）

2. **选择基准元素**：选择数组中间位置的元素作为基准（pivot）

3. **分区操作**：将数组分为三个部分：
   - `left`: 所有小于基准的元素
   - `middle`: 所有等于基准的元素
   - `right`: 所有大于基准的元素

4. **递归排序**：对 `left` 和 `right` 两个子数组递归调用 quicksort 函数

5. **合并结果**：将排序后的 `left`、`middle` 和 `right` 合并，返回最终的有序数组

### 算法分析

- **时间复杂度**：平均 O(n log n)，最坏情况 O(n²)（当数组已经有序时）
- **空间复杂度**：O(log n)（递归调用栈的深度）
- **稳定性**：不稳定排序（相等元素的相对位置可能改变）

### 优缺点

**优点**：
- 平均情况下性能优异
- 原地排序版本空间复杂度低
- 适用于各种数据类型

**缺点**：
- 最坏情况下性能较差
- 递归实现可能导致栈溢出（对于非常大的数组）

### 优化建议

1. **随机选择基准**：避免在有序数组上出现最坏情况
2. **三数取中**：选择首、中、尾三个元素的中位数作为基准
3. **迭代实现**：避免递归栈溢出
4. **小数组优化**：对于小数组使用插入排序等简单算法
```

```
这段代码实现了快速排序（Quicksort）算法，这是一种高效的分治排序算法。

### 工作原理

1. **基线条件**：如果输入数组的长度小于等于 1，直接返回该数组（已经有序）

2. **选择基准元素**：选择数组中间位置的元素作为基准（pivot）

3. **分区操作**：将数组分为三个部分：
   - `left`: 所有小于基准的元素
   - `middle`: 所有等于基准的元素
   - `right`: 所有大于基准的元素

4. **递归排序**：对 `left` 和 `right` 两个子数组递归调用 quicksort 函数

5. **合并结果**：将排序后的 `left`、`middle` 和 `right` 合并，返回最终的有序数组

### 算法分析

- **时间复杂度**：平均 O(n log n)，最坏情况 O(n²)（当数组已经有序时）
- **空间复杂度**：O(log n)（递归调用栈的深度）
- **稳定性**：不稳定排序（相等元素的相对位置可能改变）

### 优缺点

**优点**：
- 平均情况下性能优异
- 原地排序版本空间复杂度低
- 适用于各种数据类型

**缺点**：
- 最坏情况下性能较差
- 递归实现可能导致栈溢出（对于非常大的数组）

### 优化建议

1. **随机选择基准**：避免在有序数组上出现最坏情况
2. **三数取中**：选择首、中、尾三个元素的中位数作为基准
3. **迭代实现**：避免递归栈溢出
4. **小数组优化**：对于小数组使用插入排序等简单算法
```

#### 3.4.3 代码审查#

Claude Code 可以帮助你审查代码，发现潜在的问题并提供改进建议。常见的审查内容包括：

##### 3.4.3.1 代码质量审查#

示例：代码质量审查

```
bash复制审查这段 Python 代码的质量：
def calculate_total(prices):
    total = 0
    for i in range(len(prices)):
        total += prices[i]
```

```
审查这段 Python 代码的质量：
def calculate_total(prices):
    total = 0
    for i in range(len(prices)):
        total += prices[i]
```

```
bash复制return total
```

```
return total
```

```
bash复制
**输出**：
~~~
### 代码质量分析

这段代码实现了计算价格总和的功能，整体结构清晰，但存在一些可以改进的地方：

#### 优点
- 功能明确，实现简单
- 代码风格一致，易于阅读

#### 改进建议

1. **使用更简洁的循环方式**：
   ```python
   def calculate_total(prices):
       total = 0
       for price in prices:
           total += price
       return total
```

```
**输出**：
~~~
### 代码质量分析

这段代码实现了计算价格总和的功能，整体结构清晰，但存在一些可以改进的地方：

#### 优点
- 功能明确，实现简单
- 代码风格一致，易于阅读

#### 改进建议

1. **使用更简洁的循环方式**：
   ```python
   def calculate_total(prices):
       total = 0
       for price in prices:
           total += price
       return total
```

True. 使用内置函数 sum()：
python复制def calculate_total(prices):
    return sum(prices)
True. 添加类型注解：
python复制from typing import List

def calculate_total(prices: List[float]) -> float:
    return sum(prices)
True. 添加文档字符串：
python复制from typing import List

def calculate_total(prices: List[float]) -> float:
    """
    计算价格列表的总和

    参数:
    prices: 包含价格的列表

    返回:
    价格总和
    """
    return sum(prices)

使用内置函数 sum()：

```
python复制def calculate_total(prices):
    return sum(prices)
```

```
def calculate_total(prices):
    return sum(prices)
```

添加类型注解：

```
python复制from typing import List

def calculate_total(prices: List[float]) -> float:
    return sum(prices)
```

```
from typing import List

def calculate_total(prices: List[float]) -> float:
    return sum(prices)
```

添加文档字符串：

```
python复制from typing import List

def calculate_total(prices: List[float]) -> float:
    """
    计算价格列表的总和

    参数:
    prices: 包含价格的列表

    返回:
    价格总和
    """
    return sum(prices)
```

```
from typing import List

def calculate_total(prices: List[float]) -> float:
    """
    计算价格列表的总和

    参数:
    prices: 包含价格的列表

    返回:
    价格总和
    """
    return sum(prices)
```

```
bash复制
### 3.4.3.2 性能审查

**示例：性能审查**

**输入**：
```
审查这段 JavaScript 代码的性能：
function find_duplicates(arr) {
    const duplicates = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
                duplicates.push(arr[i]);
            }
        }
    }
    return duplicates;
}
```

**输出**：
```

```
### 3.4.3.2 性能审查

**示例：性能审查**

**输入**：
```
审查这段 JavaScript 代码的性能：
function find_duplicates(arr) {
    const duplicates = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
                duplicates.push(arr[i]);
            }
        }
    }
    return duplicates;
}
```

**输出**：
```

##### 性能分析#

这段代码用于查找数组中的重复元素，但存在明显的性能问题：

###### 问题分析

True. 时间复杂度：O(n²)，因为使用了嵌套循环
True. 空间复杂度：O(n)，用于存储重复元素
True. 额外开销：每次调用 duplicates.includes(arr[i]) 都会遍历整个 duplicates 数组

```
duplicates.includes(arr[i])
```

###### 优化建议

True. 使用 Set 数据结构：
javascript复制function find_duplicates(arr) {
    const seen = new Set();
    const duplicates = new Set();

    for (const item of arr) {
        if (seen.has(item)) {
            duplicates.add(item);
        } else {
            seen.add(item);
        }
    }

    return Array.from(duplicates);
}
True. 使用对象记录出现次数：
javascript复制function find_duplicates(arr) {
    const counts = {};
    const duplicates = [];

    for (const item of arr) {
        counts[item] = (counts[item] || 0) + 1;
    }

    for (const item in counts) {
        if (counts[item] > 1) {
            duplicates.push(item);
        }
    }

    return duplicates;
}

使用 Set 数据结构：

```
javascript复制function find_duplicates(arr) {
    const seen = new Set();
    const duplicates = new Set();

    for (const item of arr) {
        if (seen.has(item)) {
            duplicates.add(item);
        } else {
            seen.add(item);
        }
    }

    return Array.from(duplicates);
}
```

```
function find_duplicates(arr) {
    const seen = new Set();
    const duplicates = new Set();

    for (const item of arr) {
        if (seen.has(item)) {
            duplicates.add(item);
        } else {
            seen.add(item);
        }
    }

    return Array.from(duplicates);
}
```

使用对象记录出现次数：

```
javascript复制function find_duplicates(arr) {
    const counts = {};
    const duplicates = [];

    for (const item of arr) {
        counts[item] = (counts[item] || 0) + 1;
    }

    for (const item in counts) {
        if (counts[item] > 1) {
            duplicates.push(item);
        }
    }

    return duplicates;
}
```

```
function find_duplicates(arr) {
    const counts = {};
    const duplicates = [];

    for (const item of arr) {
        counts[item] = (counts[item] || 0) + 1;
    }

    for (const item in counts) {
        if (counts[item] > 1) {
            duplicates.push(item);
        }
    }

    return duplicates;
}
```

###### 性能对比

- 原实现：O(n²) 时间复杂度
- 优化后：O(n) 时间复杂度

对于包含 10,000 个元素的数组，优化后的实现将比原实现快约 100 倍。

```
bash复制
## 3.4.4 代码调试

Claude Code 可以帮助你调试代码，发现潜在的错误并提供修复建议。

### 3.4.4.1 错误排查

**示例：错误排查**

**输入**：
```
这段 Python 代码有什么问题？
def divide(a, b):
    return a / b

result = divide(5, 0)
print(result)
```

**输出**：
```

```
## 3.4.4 代码调试

Claude Code 可以帮助你调试代码，发现潜在的错误并提供修复建议。

### 3.4.4.1 错误排查

**示例：错误排查**

**输入**：
```
这段 Python 代码有什么问题？
def divide(a, b):
    return a / b

result = divide(5, 0)
print(result)
```

**输出**：
```

##### 问题分析#

这段代码会引发 ZeroDivisionError 异常，因为在 Python 中不能将一个数除以零。

##### 错误详情#

当执行 divide(5, 0) 时，Python 会抛出以下异常：

```
divide(5, 0)
```

```
bash复制ZeroDivisionError: division by zero
```

```
ZeroDivisionError: division by zero
```

##### 修复建议#

True. 添加参数验证：
python复制def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b
True. 添加异常处理：
python复制def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return None
True. 返回错误信息：
python复制def divide(a, b):
    if b == 0:
        return None, "除数不能为零"
    return a / b, None

添加参数验证：

```
python复制def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b
```

```
def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b
```

添加异常处理：

```
python复制def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return None
```

```
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return None
```

返回错误信息：

```
python复制def divide(a, b):
    if b == 0:
        return None, "除数不能为零"
    return a / b, None
```

```
def divide(a, b):
    if b == 0:
        return None, "除数不能为零"
    return a / b, None
```

```
bash复制
### 3.4.4.2 逻辑错误排查

**示例：逻辑错误排查**

**输入**：
```
这段 JavaScript 代码有什么逻辑错误？
function calculate_discount(price, discount) {
    return price - discount;
}

const original_price = 100;
const discount = 0.2;
const final_price = calculate_discount(original_price, discount);
console.log(`最终价格: ${final_price}`);
```

**输出**：
```

```
### 3.4.4.2 逻辑错误排查

**示例：逻辑错误排查**

**输入**：
```
这段 JavaScript 代码有什么逻辑错误？
function calculate_discount(price, discount) {
    return price - discount;
}

const original_price = 100;
const discount = 0.2;
const final_price = calculate_discount(original_price, discount);
console.log(`最终价格: ${final_price}`);
```

**输出**：
```

##### 逻辑错误分析#

这段代码的逻辑错误在于折扣计算方式不正确。当前实现是直接从价格中减去折扣值，而不是按折扣比例计算。

##### 错误详情#

当 original_price 为 100，discount 为 0.2 时，预期的折扣应该是 20%（即 20 元），最终价格应该是 80 元。但当前实现会返回 99.8 元（100 - 0.2）。

```
original_price
```

```
discount
```

##### 修复建议#

True. 按比例计算折扣：
javascript复制function calculate_discount(price, discount) {
    return price * (1 - discount);
}
True. 添加参数验证：
javascript复制function calculate_discount(price, discount) {
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}
True. 添加文档字符串：
javascript复制function calculate_discount(price, discount) {
    """
    计算折扣后的价格

    参数:
    price: 原价
    discount: 折扣比例（0 到 1 之间）

    返回:
    折扣后的价格
    """
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}

按比例计算折扣：

```
javascript复制function calculate_discount(price, discount) {
    return price * (1 - discount);
}
```

```
function calculate_discount(price, discount) {
    return price * (1 - discount);
}
```

添加参数验证：

```
javascript复制function calculate_discount(price, discount) {
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}
```

```
function calculate_discount(price, discount) {
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}
```

添加文档字符串：

```
javascript复制function calculate_discount(price, discount) {
    """
    计算折扣后的价格

    参数:
    price: 原价
    discount: 折扣比例（0 到 1 之间）

    返回:
    折扣后的价格
    """
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}
```

```
function calculate_discount(price, discount) {
    """
    计算折扣后的价格

    参数:
    price: 原价
    discount: 折扣比例（0 到 1 之间）

    返回:
    折扣后的价格
    """
    if (discount < 0 || discount > 1) {
        throw new Error("折扣必须在 0 到 1 之间");
    }
    return price * (1 - discount);
}
```

```
bash复制
## 3.4.5 最佳实践

### 3.4.5.1 提供足够的上下文

在请求代码理解时，提供足够的上下文信息有助于 Claude Code 做出更准确的分析。例如：
- 说明代码的用途和业务背景
- 提供相关的依赖和环境信息
- 说明代码的预期行为

### 3.4.5.2 分步骤理解复杂代码

对于非常复杂的代码，建议分步骤进行理解：
1. 先理解整体结构和主要功能
2. 再深入分析关键函数和算法
3. 最后关注细节和边界情况

### 3.4.5.3 结合实际运行结果

如果代码运行结果不符合预期，将实际结果和预期结果一起提供给 Claude Code，有助于更快地定位问题。

### 3.4.5.4 验证理解结果

在获得 Claude Code 的解释后，建议通过以下方式验证：
- 运行代码观察实际行为
- 查阅官方文档确认语法和特性
- 与其他开发者讨论理解结果

通过以上实践，你将能够充分发挥 Claude Code 在代码理解方面的能力，快速掌握复杂代码并提升编程技能。
```

```
## 3.4.5 最佳实践

### 3.4.5.1 提供足够的上下文

在请求代码理解时，提供足够的上下文信息有助于 Claude Code 做出更准确的分析。例如：
- 说明代码的用途和业务背景
- 提供相关的依赖和环境信息
- 说明代码的预期行为

### 3.4.5.2 分步骤理解复杂代码

对于非常复杂的代码，建议分步骤进行理解：
1. 先理解整体结构和主要功能
2. 再深入分析关键函数和算法
3. 最后关注细节和边界情况

### 3.4.5.3 结合实际运行结果

如果代码运行结果不符合预期，将实际结果和预期结果一起提供给 Claude Code，有助于更快地定位问题。

### 3.4.5.4 验证理解结果

在获得 Claude Code 的解释后，建议通过以下方式验证：
- 运行代码观察实际行为
- 查阅官方文档确认语法和特性
- 与其他开发者讨论理解结果

通过以上实践，你将能够充分发挥 Claude Code 在代码理解方面的能力，快速掌握复杂代码并提升编程技能。
```

---

## 5 代码修改与优化

**URL**: https://claudecode.tangshuang.net/course/3.5%20%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B8%8E%E4%BC%98%E5%8C%96

#### 3.5.1 概述#

Claude Code 不仅能够从零开始生成高质量代码，更擅长对现有代码进行智能修改与深度优化。通过代码修改功能，你可以快速实现函数重命名、参数调整、结构重构等需求；而优化功能则能帮助你提升代码性能、增强可读性、修复潜在问题。掌握这些能力，将显著提升你的开发效率和代码质量。

#### 3.5.2 代码修改#

##### 3.5.2.1 修改简单代码#

对于基础代码修改任务，Claude Code 能够精准识别并完成变更。常见场景包括函数重命名、变量名调整、简单逻辑修改等。

示例：函数重命名

```
bash复制修改这段 JavaScript 代码，将函数名从 add 改为 sum：
function add(a, b) {
    return a + b;
}
```

```
修改这段 JavaScript 代码，将函数名从 add 改为 sum：
function add(a, b) {
    return a + b;
}
```

```
javascript复制function sum(a, b) {
    return a + b;
}
```

```
function sum(a, b) {
    return a + b;
}
```

##### 3.5.2.2 修改复杂代码#

对于包含复杂逻辑的代码，Claude Code 能够理解上下文并进行深度修改。常见场景包括添加类型注解、重构条件分支、优化错误处理等。

示例：添加类型注解

```
bash复制修改这段 Python 代码，添加类型注解：
def calculate_area(shape, **kwargs):
    if shape == "circle":
        return 3.14159 * kwargs["radius"] ** 2
    elif shape == "rectangle":
        return kwargs["width"] * kwargs["height"]
    elif shape == "triangle":
        return 0.5 * kwargs["base"] * kwargs["height"]
    else:
        raise ValueError(f"Unknown shape: {shape}")
```

```
修改这段 Python 代码，添加类型注解：
def calculate_area(shape, **kwargs):
    if shape == "circle":
        return 3.14159 * kwargs["radius"] ** 2
    elif shape == "rectangle":
        return kwargs["width"] * kwargs["height"]
    elif shape == "triangle":
        return 0.5 * kwargs["base"] * kwargs["height"]
    else:
        raise ValueError(f"Unknown shape: {shape}")
```

```
python复制from typing import Dict, Union, Any

def calculate_area(shape: str, **kwargs: Dict[str, Union[int, float]]) -> Union[float, int]:
    """
    计算不同形状的面积

    参数:
    shape: str - 形状类型，可以是 "circle", "rectangle", 或 "triangle"
    **kwargs: Dict[str, Union[int, float]] - 形状的参数
        - 对于圆形: 需要 "radius" 参数
        - 对于矩形: 需要 "width" 和 "height" 参数
        - 对于三角形: 需要 "base" 和 "height" 参数

    返回:
    Union[float, int] - 计算出的面积

    异常:
    ValueError - 当形状类型未知时抛出
    """
    if shape == "circle":
        if "radius" not in kwargs:
            raise ValueError("Circle requires 'radius' parameter")
        return 3.14159 * kwargs["radius"] ** 2
    elif shape == "rectangle":
        if "width" not in kwargs or "height" not in kwargs:
            raise ValueError("Rectangle requires 'width' and 'height' parameters")
        return kwargs["width"] * kwargs["height"]
    elif shape == "triangle":
        if "base" not in kwargs or "height" not in kwargs:
            raise ValueError("Triangle requires 'base' and 'height' parameters")
        return 0.5 * kwargs["base"] * kwargs["height"]
    else:
        raise ValueError(f"Unknown shape: {shape}")
```

```
from typing import Dict, Union, Any

def calculate_area(shape: str, **kwargs: Dict[str, Union[int, float]]) -> Union[float, int]:
    """
    计算不同形状的面积

    参数:
    shape: str - 形状类型，可以是 "circle", "rectangle", 或 "triangle"
    **kwargs: Dict[str, Union[int, float]] - 形状的参数
        - 对于圆形: 需要 "radius" 参数
        - 对于矩形: 需要 "width" 和 "height" 参数
        - 对于三角形: 需要 "base" 和 "height" 参数

    返回:
    Union[float, int] - 计算出的面积

    异常:
    ValueError - 当形状类型未知时抛出
    """
    if shape == "circle":
        if "radius" not in kwargs:
            raise ValueError("Circle requires 'radius' parameter")
        return 3.14159 * kwargs["radius"] ** 2
    elif shape == "rectangle":
        if "width" not in kwargs or "height" not in kwargs:
            raise ValueError("Rectangle requires 'width' and 'height' parameters")
        return kwargs["width"] * kwargs["height"]
    elif shape == "triangle":
        if "base" not in kwargs or "height" not in kwargs:
            raise ValueError("Triangle requires 'base' and 'height' parameters")
        return 0.5 * kwargs["base"] * kwargs["height"]
    else:
        raise ValueError(f"Unknown shape: {shape}")
```

##### 3.5.2.3 修改代码结构#

Claude Code 能够理解代码的整体结构，并进行大规模重构。常见场景包括回调函数转 Promise、类结构调整、模块化拆分等。

示例：回调函数转 Promise

```
bash复制重构这段 JavaScript 代码，将回调函数改为 Promise：
function fetchData(url, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => {
        if (xhr.status === 200) {
            callback(null, JSON.parse(xhr.responseText));
        } else {
            callback(new Error(`Request failed with status ${xhr.status}`));
        }
    };
    xhr.onerror = () => {
        callback(new Error('Network error'));
    };
    xhr.send();
}
```

```
重构这段 JavaScript 代码，将回调函数改为 Promise：
function fetchData(url, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => {
        if (xhr.status === 200) {
            callback(null, JSON.parse(xhr.responseText));
        } else {
            callback(new Error(`Request failed with status ${xhr.status}`));
        }
    };
    xhr.onerror = () => {
        callback(new Error('Network error'));
    };
    xhr.send();
}
```

```
javascript复制function fetchData(url) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.onload = () => {
            if (xhr.status === 200) {
                try {
                    const data = JSON.parse(xhr.responseText);
                    resolve(data);
                } catch (error) {
                    reject(new Error(`Failed to parse JSON: ${error.message}`));
                }
            } else {
                reject(new Error(`Request failed with status ${xhr.status}`));
            }
        };
        xhr.onerror = () => {
            reject(new Error('Network error'));
        };
        xhr.send();
    });
}
```

```
function fetchData(url) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.onload = () => {
            if (xhr.status === 200) {
                try {
                    const data = JSON.parse(xhr.responseText);
                    resolve(data);
                } catch (error) {
                    reject(new Error(`Failed to parse JSON: ${error.message}`));
                }
            } else {
                reject(new Error(`Request failed with status ${xhr.status}`));
            }
        };
        xhr.onerror = () => {
            reject(new Error('Network error'));
        };
        xhr.send();
    });
}
```

#### 3.5.3 代码优化#

##### 3.5.3.1 性能优化#

Claude Code 能够识别性能瓶颈并提供优化建议。常见场景包括循环优化、内存泄漏修复、算法复杂度降低等。

示例：循环优化

```
bash复制优化这段 Python 代码的性能：
def find_duplicates(lst):
    duplicates = []
    for i in range(len(lst)):
        for j in range(i + 1, len(lst)):
            if lst[i] == lst[j] and lst[i] not in duplicates:
                duplicates.append(lst[i])
    return duplicates
```

```
优化这段 Python 代码的性能：
def find_duplicates(lst):
    duplicates = []
    for i in range(len(lst)):
        for j in range(i + 1, len(lst)):
            if lst[i] == lst[j] and lst[i] not in duplicates:
                duplicates.append(lst[i])
    return duplicates
```

```
python复制def find_duplicates(lst):
    seen = set()
    duplicates = set()
    for item in lst:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)
    return list(duplicates)
```

```
def find_duplicates(lst):
    seen = set()
    duplicates = set()
    for item in lst:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)
    return list(duplicates)
```

##### 3.5.3.2 可读性优化#

良好的代码可读性是团队协作和长期维护的基础。Claude Code 能够优化代码结构、添加注释、统一命名规范，提升代码的可理解性。

示例：提升代码可读性

```
bash复制优化这段代码的可读性：
def calc(a,b,c):
    if a>b:
        return a*c
    else:
        return b/c
```

```
优化这段代码的可读性：
def calc(a,b,c):
    if a>b:
        return a*c
    else:
        return b/c
```

```
python复制def calculate_result(value_a: float, value_b: float, multiplier: float) -> float:
    """
    根据输入值计算结果

    如果 value_a 大于 value_b，返回 value_a 乘以 multiplier
    否则返回 value_b 除以 multiplier

    参数:
    value_a: 第一个比较值
    value_b: 第二个比较值
    multiplier: 乘法因子

    返回:
    计算结果
    """
    if value_a > value_b:
        return value_a * multiplier
    else:
        return value_b / multiplier
```

```
def calculate_result(value_a: float, value_b: float, multiplier: float) -> float:
    """
    根据输入值计算结果

    如果 value_a 大于 value_b，返回 value_a 乘以 multiplier
    否则返回 value_b 除以 multiplier

    参数:
    value_a: 第一个比较值
    value_b: 第二个比较值
    multiplier: 乘法因子

    返回:
    计算结果
    """
    if value_a > value_b:
        return value_a * multiplier
    else:
        return value_b / multiplier
```

##### 3.5.3.3 安全性优化#

Claude Code 能够识别常见的安全漏洞并提供修复方案。常见场景包括 SQL 注入防护、XSS 攻击防范、输入验证增强等。

示例：SQL 注入防护

```
bash复制修复这段 Python 代码的 SQL 注入漏洞：
def get_user(username):
    cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")
    return cursor.fetchone()
```

```
修复这段 Python 代码的 SQL 注入漏洞：
def get_user(username):
    cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")
    return cursor.fetchone()
```

```
python复制def get_user(username):
    cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
    return cursor.fetchone()
```

```
def get_user(username):
    cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
    return cursor.fetchone()
```

#### 3.5.4 最佳实践#

##### 3.5.4.1 明确修改范围#

在请求代码修改时，尽可能明确修改范围和目标。例如：

- ✅ "将函数名从 fetchData 改为 getUserData，并保持功能不变"
- ❌ "修改这段代码"

```
fetchData
```

```
getUserData
```

##### 3.5.4.2 提供上下文#

对于复杂代码修改，提供足够的上下文信息有助于 Claude Code 做出更准确的修改。例如：

- "这段代码用于处理用户登录，需要添加验证码验证步骤"
- "这个函数的性能瓶颈在于循环嵌套，需要优化时间复杂度"

##### 3.5.4.3 分阶段修改#

对于大规模代码变更，建议分阶段进行：

True. 先完成核心功能修改
True. 再进行性能优化
True. 最后添加文档和测试

##### 3.5.4.4 验证修改结果#

在接受 Claude Code 的修改建议后，务必进行验证：

- 运行测试用例确保功能正常
- 检查代码风格一致性
- 确认性能提升效果

通过以上实践，你将能够充分发挥 Claude Code 在代码修改与优化方面的能力，显著提升开发效率和代码质量。

---

## 6 基础代码协作

**URL**: https://claudecode.tangshuang.net/course/3.6%20%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%8D%8F%E4%BD%9C

#### 3.6.1 概述#

Claude Code不仅可以帮助个人开发者提高效率，还可以促进团队成员之间的代码协作。掌握基础代码协作功能可以帮助团队成员更好地理解和贡献代码，提高团队的整体开发效率。本节将详细介绍Claude Code的基础代码协作功能和使用方法。

#### 3.6.2 代码共享#

##### 3.6.2.1 生成代码链接#

Claude Code可以生成代码的共享链接，方便团队成员之间分享代码，例如：

输入：
帮我生成这段代码的共享链接：
function fibonacci(n) {
if (n <= 1) {
return n;
}
return fibonacci(n - 1) + fibonacci(n - 2);
}

输出：
我可以帮你生成这段代码的共享链接。在Claude Code中，你可以通过以下步骤生成代码链接：

- 选中要分享的代码
- 右键点击，选择"Claude Code: 分享代码"
- 在弹出的对话框中，选择分享范围（公开或私有）
- 点击"生成链接"按钮
- 复制生成的链接并分享给团队成员

```
bash复制claude share --code "function fibonacci(n) { if (n <= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }"
```

```
claude share --code "function fibonacci(n) { if (n <= 1) { return n; } return fibonacci(n - 1) + fibonacci(n - 2); }"
```

生成的链接可以让团队成员直接查看代码，并可以在Claude Code中打开进行进一步的讨论和修改。

##### 3.6.2.2 导出代码片段#

Claude Code可以导出代码片段，方便团队成员在不同项目中复用，例如：

```
bash复制帮我导出这段代码片段，以便在其他项目中复用：
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
```

```
帮我导出这段代码片段，以便在其他项目中复用：
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
```

```
bash复制        func.apply(this, args);
    }, delay);
};
```

```
func.apply(this, args);
    }, delay);
};
```

```
bash复制**输出**：

我可以帮你导出这段防抖函数代码片段。在Claude Code中，你可以通过以下步骤导出代码片段：

1. 在VS Code插件中：
 - 选中要导出的代码
 - 右键点击，选择"Claude Code: 导出代码片段"
 - 在弹出的对话框中，填写代码片段的名称、描述和标签
 - 选择导出格式（JSON或YAML）
 - 点击"导出"按钮
 - 保存导出的文件

2. 在命令行工具中：
```bash
claude snippet export --name "debounce" --description "防抖函数" --tags "javascript,performance" --output debounce-snippet.json << 'EOF'
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}
EOF
```

```
**输出**：

我可以帮你导出这段防抖函数代码片段。在Claude Code中，你可以通过以下步骤导出代码片段：

1. 在VS Code插件中：
 - 选中要导出的代码
 - 右键点击，选择"Claude Code: 导出代码片段"
 - 在弹出的对话框中，填写代码片段的名称、描述和标签
 - 选择导出格式（JSON或YAML）
 - 点击"导出"按钮
 - 保存导出的文件

2. 在命令行工具中：
```bash
claude snippet export --name "debounce" --description "防抖函数" --tags "javascript,performance" --output debounce-snippet.json << 'EOF'
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}
EOF
```

导出的代码片段可以在其他项目中导入使用，或者分享给团队成员。

导入代码片段的方法：

True. 在VS Code插件中：

- 点击Claude Code图标，打开侧边栏
- 点击"代码片段"选项卡
- 点击"导入"按钮
- 选择要导入的代码片段文件
- 点击"导入"按钮

True. 在命令行工具中：

```
bash复制claude snippet import debounce-snippet.json
```

```
claude snippet import debounce-snippet.json
```

#### 3.6.3 代码评审辅助#

##### 3.6.3.1 生成代码评审意见#

Claude Code可以辅助进行代码评审，生成代码评审意见，例如：

输入：
帮我评审这段代码，给出改进建议：
function calculateTotal(items) {
let total = 0;
for (let i = 0; i < items.length; i++) {
total += items[i].price * items[i].quantity;
}
return total;
}

输出：
这段代码实现了计算商品总价的功能，整体结构清晰，但还有一些可以改进的地方：

- 使用Array.reduce()方法替代传统的for循环，使代码更简洁、更具函数式编程风格
- 添加类型注解，提高代码的可读性和可维护性
- 添加错误处理，处理空数组或无效数据的情况
- 添加JSDoc注释，说明函数的功能、参数和返回值

```
Array.reduce()
```

```
javascript复制/**
 * 计算商品总价
 * @param {Array<{price: number, quantity: number}>} items - 商品数组
 * @returns {number} - 商品总价
 */
function calculateTotal(items) {
    // 处理空数组情况
    if (!Array.isArray(items) || items.length === 0) {
        return 0;
    }

    // 使用reduce方法计算总价
    return items.reduce((total, item) => {
        // 处理无效数据情况
        const price = typeof item.price === 'number' ? item.price : 0;
        const quantity = typeof item.quantity === 'number' ? item.quantity : 0;
        return total + (price * quantity);
    }, 0);
}
```

```
/**
 * 计算商品总价
 * @param {Array<{price: number, quantity: number}>} items - 商品数组
 * @returns {number} - 商品总价
 */
function calculateTotal(items) {
    // 处理空数组情况
    if (!Array.isArray(items) || items.length === 0) {
        return 0;
    }

    // 使用reduce方法计算总价
    return items.reduce((total, item) => {
        // 处理无效数据情况
        const price = typeof item.price === 'number' ? item.price : 0;
        const quantity = typeof item.quantity === 'number' ? item.quantity : 0;
        return total + (price * quantity);
    }, 0);
}
```

True. 其他建议：

- 考虑添加单元测试，确保函数在各种情况下都能正常工作
- 考虑使用TypeScript，进一步提高代码的类型安全性
- 考虑将价格和数量的验证逻辑提取为单独的函数，提高代码的复用性

总体来说，这段代码的功能实现是正确的，但可以通过添加类型注解、错误处理和JSDoc注释，以及使用更现代的JavaScript语法来提高代码的可读性、可维护性和健壮性。

##### 3.6.3.2 检查代码质量#

Claude Code可以检查代码质量，提供改进建议，例如：

输入：
帮我检查这段Python代码的质量，给出改进建议：
def get_user_info(user_id):
import requests
r = requests.get(f"https://api.example.com/users/{user_id}")
if r.status_code == 200:
return r.json()
else:
return None

这段Python代码实现了从API获取用户信息的功能，但在代码质量方面还有一些可以改进的地方：

True. 代码结构问题：

- 导入语句应该放在文件顶部，而不是函数内部
- 缺乏错误处理，只检查了状态码，没有处理网络错误等异常情况
- 缺乏日志记录，不利于调试和监控
- 缺乏类型注解，降低了代码的可读性和可维护性
- 硬编码的API URL，不利于维护和测试

True. 性能问题：

- 每次调用函数都会创建一个新的HTTP请求，没有使用连接池
- 没有设置超时时间，可能导致请求无限期等待

True. 安全问题：

- 使用f-string拼接URL，存在安全风险
- 没有验证API响应的格式，可能导致解析错误

True. 优化后的代码：

```
python复制import requests
import logging
from typing import Dict, Optional, Any

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# API配置
API_BASE_URL = "https://api.example.com"
TIMEOUT = 5  # 超时时间，单位：秒

def get_user_info(user_id: int) -> Optional[Dict[str, Any]]:
    """
    从API获取用户信息

    Args:
        user_id: 用户ID

    Returns:
        Optional[Dict[str, Any]]: 用户信息字典，如果获取失败则返回None

    Raises:
        ValueError: 如果user_id无效
    """
    # 验证参数
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("user_id必须是正整数")

    url = f"{API_BASE_URL}/users/{user_id}"

    try:
        logger.info(f"获取用户信息，user_id: {user_id}")
        response = requests.get(url, timeout=TIMEOUT)
        response.raise_for_status()  # 抛出HTTP错误

        user_info = response.json()
        logger.info(f"成功获取用户信息，user_id: {user_id}")
        return user_info

    except requests.exceptions.RequestException as e:
        logger.error(f"获取用户信息失败，user_id: {user_id}, 错误: {str(e)}")
        return None
    except ValueError as e:
        logger.error(f"解析用户信息失败，user_id: {user_id}, 错误: {str(e)}")
        return None
```

```
import requests
import logging
from typing import Dict, Optional, Any

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# API配置
API_BASE_URL = "https://api.example.com"
TIMEOUT = 5  # 超时时间，单位：秒

def get_user_info(user_id: int) -> Optional[Dict[str, Any]]:
    """
    从API获取用户信息

    Args:
        user_id: 用户ID

    Returns:
        Optional[Dict[str, Any]]: 用户信息字典，如果获取失败则返回None

    Raises:
        ValueError: 如果user_id无效
    """
    # 验证参数
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("user_id必须是正整数")

    url = f"{API_BASE_URL}/users/{user_id}"

    try:
        logger.info(f"获取用户信息，user_id: {user_id}")
        response = requests.get(url, timeout=TIMEOUT)
        response.raise_for_status()  # 抛出HTTP错误

        user_info = response.json()
        logger.info(f"成功获取用户信息，user_id: {user_id}")
        return user_info

    except requests.exceptions.RequestException as e:
        logger.error(f"获取用户信息失败，user_id: {user_id}, 错误: {str(e)}")
        return None
    except ValueError as e:
        logger.error(f"解析用户信息失败，user_id: {user_id}, 错误: {str(e)}")
        return None
```

True. 其他建议：

- 考虑使用HTTP客户端库，如httpx，支持异步请求
- 考虑添加重试机制，提高API请求的可靠性
- 考虑使用环境变量存储API URL，提高配置的灵活性
- 考虑添加单元测试，使用mock模拟API响应

```
httpx
```

总体来说，这段代码的功能实现是正确的，但可以通过优化代码结构、添加错误处理和日志记录、使用类型注解以及改进API请求方式来提高代码的质量、可读性、可维护性和健壮性。

#### 3.6.4 代码协作技巧#

##### 3.6.4.1 明确协作目标#

在进行代码协作时，明确协作目标可以提高协作效率，例如：

我们需要协作开发一个用户管理系统的后端API，具体包括：

True. 用户注册功能
True. 用户登录功能
True. 获取用户列表功能
True. 获取用户详情功能
True. 更新用户信息功能
True. 删除用户功能

技术栈：Node.js + Express + MongoDB + JWT

请大家根据自己的专长选择模块进行开发，并在开发过程中使用Claude Code辅助编写代码和进行代码评审。

##### 3.6.4.2 使用统一的代码风格#

使用统一的代码风格可以提高代码的可读性和可维护性，例如：
我们的项目使用以下代码风格：

```
javascript复制// 函数名使用驼峰命名法
function calculateTotalPrice() { ... }

// 变量名使用驼峰命名法
let productList = [];

// 常量名使用大写蛇形命名法
const API_BASE_URL = "https://api.example.com";

// 代码缩进使用4个空格
if (condition) {
    // 代码块缩进
    doSomething();
}
```

```
// 函数名使用驼峰命名法
function calculateTotalPrice() { ... }

// 变量名使用驼峰命名法
let productList = [];

// 常量名使用大写蛇形命名法
const API_BASE_URL = "https://api.example.com";

// 代码缩进使用4个空格
if (condition) {
    // 代码块缩进
    doSomething();
}
```

请大家在开发过程中使用Claude Code辅助检查代码风格，确保代码符合项目要求。

##### 3.6.4.3 定期进行代码评审#

定期进行代码评审可以提高代码质量，发现潜在问题，例如：

我们将每周进行一次代码评审，具体安排如下：

True. 每周五下午2点开始
True. 每个开发者分享本周开发的代码
True. 其他开发者使用Claude Code辅助进行代码评审，给出改进建议
True. 记录评审结果和改进计划
请大家在评审前使用Claude Code检查自己的代码，确保代码质量符合要求。

##### 3.6.4.4 建立代码知识库#

建立代码知识库可以方便团队成员共享和复用代码，例如：

我们将建立一个代码知识库，用于共享和复用代码片段、工具函数和最佳实践。具体要求如下：

True. 使用Claude Code的代码片段功能管理代码片段
True. 每个代码片段需要包含名称、描述、标签和使用示例
True. 定期更新代码知识库，添加新的代码片段和最佳实践
True. 鼓励团队成员积极贡献和使用代码知识库

请大家在开发过程中使用Claude Code导出和导入代码片段，丰富我们的代码知识库。

#### 3.6.5 常见问题与解决方案#

##### 3.6.5.1 代码风格不一致#

问题：团队成员之间的代码风格不一致，导致代码可读性差，维护困难

- 制定统一的代码风格规范
- 使用Claude Code辅助检查代码风格
- 集成代码风格检查工具到CI/CD流程中
- 定期进行代码风格培训和评审

##### 3.6.5.2 代码质量参差不齐#

问题：团队成员之间的代码质量参差不齐，导致项目整体质量下降

- 制定统一的代码质量标准
- 使用Claude Code辅助进行代码评审和质量检查
- 建立代码质量奖励机制，鼓励高质量代码
- 定期进行代码质量培训和分享

##### 3.6.5.3 协作效率低下#

问题：团队成员之间的协作效率低下，导致项目进度缓慢

- 明确协作目标和分工
- 使用Claude Code辅助编写代码和进行代码评审
- 建立有效的沟通机制，及时解决协作中的问题
- 定期进行协作效率评估和改进

#### 3.6.6 代码协作最佳实践#

True. 明确目标：明确协作目标和分工，提高协作效率
True. 统一规范：制定统一的代码风格和质量标准
True. 定期评审：定期进行代码评审，提高代码质量
True. 建立知识库：建立代码知识库，方便共享和复用代码
True. 有效沟通：建立有效的沟通机制，及时解决协作中的问题
True. 使用工具：使用Claude Code等工具辅助编写代码和进行代码评审
True. 持续改进：定期评估协作效率和代码质量，持续改进
True. 鼓励贡献：鼓励团队成员积极贡献代码和分享经验

#### 3.6.7 总结#

Claude Code的基础代码协作功能可以帮助团队成员更好地理解和贡献代码，提高团队的整体开发效率。它支持代码共享、代码片段导出和导入、代码评审辅助以及代码质量检查等功能。

在进行代码协作时，建议明确协作目标，使用统一的代码风格，定期进行代码评审，建立代码知识库，并使用Claude Code等工具辅助编写代码和进行代码评审。这些技巧可以帮助团队提高协作效率，提高代码质量，加快项目进度。

同时，Claude Code的代码协作功能也可以作为学习工具，帮助团队成员学习最佳实践，提高编程能力，促进团队成员之间的知识共享和技术成长。通过协作开发和代码评审，团队成员可以互相学习，共同进步，提高团队的整体技术水平。

---

# 第 4 章

## 1 命令系统简介

**URL**: https://claudecode.tangshuang.net/course/4.1%20%E5%91%BD%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B

Claude Code 提供了一套功能强大、设计优雅的命令系统，是开发者与 AI 交互的核心方式。通过命令系统，您可以高效地控制 Claude Code 的行为、执行复杂任务、自动化工作流程，并深入探索其强大功能。

#### 命令系统概述#

Claude Code 的命令系统由三个核心组件构成，覆盖了从简单交互到复杂自动化的所有使用场景：

##### 1. CLI 命令（Command Line Interface）#

CLI 命令是直接在终端中执行的命令，适用于以下场景：

- 启动 Claude Code 交互式会话
- 执行一次性代码生成或分析任务
- 集成到脚本和自动化工作流中
- 批量处理文件或项目

```
bash复制# 启动交互式会话
claude
```

```
# 启动交互式会话
claude
```

### 执行一次性代码生成

claude -p "生成一个 Python 快速排序算法"

### 处理文件内容

cat main.py | claude -p "优化这段代码的性能"

```
bash复制
### 2. CLI 标志（Command Line Flags）

CLI 标志是与 CLI 命令配合使用的选项，用于自定义 Claude Code 的行为。通过标志，您可以：
- 配置模型参数（如温度、最大 tokens）
- 控制输出格式（如 JSON、Markdown）
- 管理会话状态（如恢复之前的对话）
- 配置安全权限（如跳过权限提示）

**示例**：
```bash
# 使用 GPT-4o 模型
claude --model gpt-4o

# 恢复之前的会话
claude --continue

# 以 JSON 格式输出
claude --output-format json -p "生成一个简单的 React 组件"
```

```
### 2. CLI 标志（Command Line Flags）

CLI 标志是与 CLI 命令配合使用的选项，用于自定义 Claude Code 的行为。通过标志，您可以：
- 配置模型参数（如温度、最大 tokens）
- 控制输出格式（如 JSON、Markdown）
- 管理会话状态（如恢复之前的对话）
- 配置安全权限（如跳过权限提示）

**示例**：
```bash
# 使用 GPT-4o 模型
claude --model gpt-4o

# 恢复之前的会话
claude --continue

# 以 JSON 格式输出
claude --output-format json -p "生成一个简单的 React 组件"
```

##### 3. 斜杠命令（Slash Commands）#

斜杠命令是在交互式会话中使用的特殊命令，以 / 开头。它们提供了一种快速执行常见操作的方式，而无需通过自然语言描述。

```
/
```

```
bash复制# 清除对话历史
/clear

# 配置 Claude Code
/config

# 启用 Vim 编辑器模式
/vim
```

```
# 清除对话历史
/clear

# 配置 Claude Code
/config

# 启用 Vim 编辑器模式
/vim
```

#### 命令系统的特点#

Claude Code 的命令系统经过精心设计，具有以下显著特点：

##### 1. 灵活性#

支持多种交互方式，您可以根据具体场景选择最合适的方式：

- 快速原型开发：使用交互式会话和斜杠命令
- 批量处理：使用 CLI 命令和脚本
- 集成到现有工作流：使用 CLI 标志和 API

##### 2. 可扩展性#

通过插件系统，您可以轻松扩展命令系统的功能：

- 开发自定义命令和工具
- 集成第三方服务和 API
- 创建领域特定的命令集

##### 3. 一致性#

命令系统遵循一致的设计原则：

- 命名规范：命令名称简洁明了，符合行业惯例
- 参数设计：参数格式统一，易于记忆和使用
- 错误处理：提供清晰的错误信息和修复建议

##### 4. 文档完善#

每个命令都配有详细的文档和示例：

- 内置帮助系统（/help 命令）
- 在线文档和教程
- 命令行帮助（claude --help）

```
/help
```

```
claude --help
```

#### 命令系统的重要性#

掌握 Claude Code 的命令系统是成为高效开发者的关键：

##### 1. 提高效率#

通过命令快速完成常见操作，减少重复性工作：

- 一键生成代码模板
- 快速重构代码结构
- 批量修改文件内容

##### 2. 自动化工作流#

将命令集成到脚本和自动化流程中：

- 持续集成/持续部署（CI/CD）
- 代码质量检查
- 文档自动生成

##### 3. 深入控制#

通过标志和选项精确控制 Claude Code 的行为：

- 调整模型参数以平衡质量和速度
- 配置安全策略保护敏感信息
- 自定义输出格式以适应不同需求

##### 4. 扩展功能#

通过插件和自定义命令扩展 Claude Code 的能力：

- 集成特定领域的工具和服务
- 创建团队专属的命令集
- 实现复杂的工作流自动化

#### 命令系统的学习路径#

为了帮助您快速掌握命令系统，我们建议按照以下路径学习：

True. 基础入门：先熟悉 CLI 命令和常用标志
True. 交互式会话：学习使用斜杠命令提高交互效率
True. 高级功能：探索插件系统和自定义命令开发
True. 自动化：将命令集成到脚本和工作流中

在接下来的章节中，我们将详细介绍命令系统的各个方面，包括命令分类、执行流程、帮助系统等。通过系统学习，您将能够充分发挥 Claude Code 的强大功能，显著提升开发效率和代码质量。

---

## 2 命令分类

**URL**: https://claudecode.tangshuang.net/course/4.2%20%E5%91%BD%E4%BB%A4%E5%88%86%E7%B1%BB

Claude Code 的命令按照功能和用途可以分为不同的类别。理解这些分类有助于您快速找到需要的命令，并更好地理解命令系统的整体结构。

#### 主要命令分类#

##### 1. CLI 命令#

CLI 命令是直接在命令行中执行的命令，用于启动 Claude Code、执行一次性任务等。主要包括：

- claude：启动交互式 REPL
- claude "query"：使用初始提示启动 REPL
- claude -p "query"：通过 SDK 查询，然后退出
- cat file | claude -p "query"：处理管道内容
- claude -c：继续最近的对话
- claude -r "<session-id>" "query"：按 ID 恢复会话

```
claude
```

```
claude "query"
```

```
claude -p "query"
```

```
cat file | claude -p "query"
```

```
claude -c
```

```
claude -r "<session-id>" "query"
```

##### 2. CLI 标志#

CLI 标志是与 CLI 命令一起使用的选项，用于自定义 Claude Code 的行为。主要包括：

- --print, -p：打印响应而不进入交互模式
- --verbose：启用详细日志记录
- --model：设置会话模型
- --continue：加载最近的对话
- --resume：恢复特定会话

```
--print
```

```
-p
```

```
--verbose
```

```
--model
```

```
--continue
```

```
--resume
```

##### 3. 斜杠命令#

斜杠命令是在交互式会话中使用的命令，以 / 开头。主要包括：

```
/
```

- /init：初始化命令
- /plugin：插件管理命令
- /config：配置 Claude Code
- /clear：清除命令历史
- /agents：管理子代理

```
/init
```

```
/plugin
```

```
/config
```

```
/clear
```

```
/agents
```

#### 按功能分类#

除了按类型分类，命令还可以按功能分类：

##### 会话管理类#

- 启动会话：claude
- 继续会话：claude -c、claude --continue
- 恢复会话：claude -r、claude --resume
- 清除历史：/clear

```
claude
```

```
claude -c
```

```
claude --continue
```

```
claude -r
```

```
claude --resume
```

```
/clear
```

##### 配置管理类#

- 系统配置：/config
- 模型配置：--model

```
/config
```

```
--model
```

##### 插件管理类#

- 插件管理：/plugin

```
/plugin
```

##### 工具和代理类#

- 子代理管理：/agents

```
/agents
```

#### 命令分类的意义#

理解命令分类可以帮助您：

True. 快速定位：根据需要的功能快速找到对应的命令
True. 系统学习：按照分类系统地学习命令，避免遗漏
True. 高效使用：根据不同的使用场景选择最合适的命令类型
True. 扩展开发：了解命令分类有助于开发插件和自定义命令

在接下来的章节中，我们将详细介绍各个命令的具体用法和示例。

---

## 3 命令执行流程

**URL**: https://claudecode.tangshuang.net/course/4.3%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B

了解 Claude Code 命令的执行流程可以帮助您更好地理解命令系统的工作原理，以及如何有效地使用各种命令。

#### CLI 命令执行流程#

当您在命令行中执行 Claude Code 命令时，系统会按照以下流程处理：

##### 1. 命令解析#

Claude Code 首先解析您输入的命令，识别以下内容：

- 主命令：如 claude
- 子命令：如 update、mcp 等
- 参数：如查询文本、文件路径等
- 标志：如 --print、--model 等

```
claude
```

```
update
```

```
mcp
```

```
--print
```

```
--model
```

##### 2. 参数验证#

解析完成后，系统会验证参数的有效性：

- 检查必需的参数是否提供
- 验证参数的格式是否正确
- 检查标志的组合是否有效
- 验证文件路径是否存在

##### 3. 配置加载#

系统会加载相关配置：

- 读取全局配置文件（用户范围）
- 读取项目配置文件（项目范围）
- 读取本地配置文件（本地范围）
- 应用命令行标志覆盖配置

##### 4. 会话初始化#

根据命令类型，系统会进行不同的初始化：

- 交互模式：初始化 REPL 环境，加载命令历史
- 打印模式：准备输出格式，处理输入数据
- 配置模式：加载配置界面或执行配置命令

##### 5. 执行命令#

系统执行具体的命令操作：

- 调用相应的命令处理器
- 执行命令逻辑
- 与外部工具或服务交互
- 处理命令结果

##### 6. 输出结果#

根据命令类型和标志，系统会输出结果：

- 交互模式：在 REPL 中显示结果
- 打印模式：按照指定的格式输出（text、json、stream-json）
- 配置模式：显示配置结果或确认信息

#### 斜杠命令执行流程#

当您在交互式会话中输入斜杠命令时，系统会按照以下流程处理：

##### 1. 命令识别#

系统识别以 / 开头的命令：

```
/
```

- 检查是否为有效的斜杠命令
- 识别命令名称和子命令
- 解析命令参数

##### 2. 命令验证#

验证命令的有效性：

- 检查命令是否存在
- 验证参数是否正确
- 检查权限是否满足

##### 3. 命令执行#

执行命令操作：

- 调用相应的命令处理器
- 执行命令逻辑
- 更新内部状态
- 与外部系统交互

##### 4. 结果反馈#

向用户反馈执行结果：

- 显示执行结果
- 提供错误信息（如果失败）
- 更新界面状态
- 记录命令历史

#### 命令执行中的错误处理#

在命令执行过程中，系统会处理各种错误情况：

##### 参数错误#

- 错误类型：缺少必需参数、参数格式错误、参数值无效
- 处理方式：显示错误信息，提示正确的用法
- 用户操作：根据提示修正命令后重新执行

##### 配置错误#

- 错误类型：配置文件不存在、配置格式错误、配置冲突
- 处理方式：显示配置错误详情，提供修复建议
- 用户操作：检查并修复配置文件

##### 权限错误#

- 错误类型：文件访问权限、网络访问权限、API 权限
- 处理方式：提示权限问题，提供解决方案
- 用户操作：调整权限或使用适当的认证

##### 网络错误#

- 错误类型：连接失败、超时、服务不可用
- 处理方式：显示网络错误信息，建议重试
- 用户操作：检查网络连接，稍后重试

#### 命令执行的性能考虑#

##### 1. 启动时间#

- CLI 命令的启动时间通常在几百毫秒到几秒之间
- 首次运行可能需要更长时间（加载依赖、初始化环境）
- 后续运行会更快（缓存、预热）

##### 2. 执行时间#

- 简单命令（如 --help）几乎立即完成
- 复杂命令（如代码生成、分析）可能需要几秒到几分钟
- 网络操作（如更新、下载）取决于网络速度

```
--help
```

##### 3. 资源使用#

- 内存使用：通常在几十到几百 MB
- CPU 使用：命令执行期间会有峰值
- 磁盘 I/O：读写配置文件、缓存文件

#### 优化命令执行#

为了提高命令执行效率，可以：

True. 使用缓存：系统会缓存常用数据，减少重复加载
True. 并行执行：某些操作可以并行执行，提高速度
True. 增量更新：只更新变化的部分，减少不必要的工作
True. 异步操作：网络操作等耗时操作异步执行，不阻塞主流程

#### 命令执行的最佳实践#

True. 使用正确的命令：根据需求选择最合适的命令类型
True. 提供完整参数：避免因缺少参数导致的重复执行
True. 检查错误信息：仔细阅读错误提示，快速定位问题
True. 利用命令历史：重复使用之前成功的命令
True. 使用帮助系统：不确定时使用 --help 或 /help 查看用法

```
--help
```

```
/help
```

理解命令执行流程可以帮助您更有效地使用 Claude Code，快速解决问题，并优化工作流程。

---

## 4 命令帮助系统

**URL**: https://claudecode.tangshuang.net/course/4.4%20%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E7%B3%BB%E7%BB%9F

Claude Code 提供了完善的帮助系统，帮助您快速查找和理解命令的用法。掌握帮助系统可以大大提高您使用 Claude Code 的效率。

#### 帮助系统的组成#

Claude Code 的帮助系统包括以下几个部分：

True. CLI 帮助：通过 --help 标志获取命令行帮助
True. 交互式帮助：通过 /help 斜杠命令获取交互式帮助
True. 命令自动完成：在输入命令时提供自动完成建议
True. 错误提示：在命令执行失败时提供有用的错误信息和建议

```
--help
```

```
/help
```

#### CLI 帮助#

##### 使用 --help 标志#

```
--help
```

大多数 CLI 命令和标志都支持 --help 标志，可以显示详细的帮助信息。

```
--help
```

###### 基本用法

claude --help

这会显示 Claude Code 主命令的帮助信息，包括所有可用的子命令和标志。

###### 子命令帮助

```
bash复制bash

claude update --help

这会显示 `update` 子命令的详细帮助信息。

#### 标志帮助

claude --help --model
```

```
bash

claude update --help

这会显示 `update` 子命令的详细帮助信息。

#### 标志帮助

claude --help --model
```

这会显示 --model 标志的详细说明。

```
--model
```

##### 帮助信息的内容#

帮助信息通常包含以下内容：

- 命令描述：命令或标志的简要说明
- 语法格式：命令的正确使用格式
- 参数说明：各个参数的含义和用法
- 使用示例：实际的使用示例
- 相关命令：相关的其他命令或标志
- 注意事项：使用时需要注意的事项

#### 交互式帮助#

##### 使用 /help 斜杠命令#

```
/help
```

在交互式会话中，输入 /help 可以显示可用的斜杠命令列表。

```
/help
```

###### 基本用法

```
bash复制/help
```

```
/help
```

这会显示所有可用的斜杠命令及其简要说明。

###### 命令详细帮助

某些斜杠命令也支持获取详细帮助：

```
bash复制/help plugin
```

```
/help plugin
```

这会显示 /plugin 命令的详细用法。

```
/plugin
```

##### 交互式帮助的特点#

交互式帮助具有以下特点：

- 实时更新：帮助信息会根据当前环境动态更新
- 上下文相关：显示与当前上下文相关的命令
- 分类显示：命令按照功能分类显示，便于查找
- 示例丰富：提供大量实际使用示例

#### 命令自动完成#

##### CLI 自动完成#

在命令行中，Claude Code 支持命令和参数的自动完成。

###### 使用方法

###### 自动完成的内容

- 命令名称
- 子命令名称
- 标志名称
- 文件路径
- 参数值

##### 交互式自动完成#

在交互式会话中，Claude Code 也支持自动完成。

###### 使用方法

###### 交互式自动完成的内容

- 斜杠命令
- 文件路径
- 命令参数
- 历史命令

#### 错误提示和建议#

##### 错误提示的内容#

当命令执行失败时，Claude Code 会提供详细的错误信息，包括：

- 错误类型：错误的类别（参数错误、权限错误、网络错误等）
- 错误详情：具体的错误描述
- 错误位置：错误发生的位置（文件名、行号等）
- 建议方案：修复错误的建议

##### 错误提示的示例#

```
bash复制$ claude --invalid-flag
Error: Unknown flag: --invalid-flag
Did you mean: --verbose?

$ claude -r "invalid-session-id"
Error: Session not found: invalid-session-id
Available sessions:
- abc123: "Review PR #123"
- def456: "Fix bug #456"
```

```
$ claude --invalid-flag
Error: Unknown flag: --invalid-flag
Did you mean: --verbose?

$ claude -r "invalid-session-id"
Error: Session not found: invalid-session-id
Available sessions:
- abc123: "Review PR #123"
- def456: "Fix bug #456"
```

---

## 5 命令版本管理

**URL**: https://claudecode.tangshuang.net/course/4.5%20%E5%91%BD%E4%BB%A4%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86

Claude Code 会定期更新，添加新功能、改进现有功能、修复 bug。了解命令版本管理可以帮助您保持 Claude Code 的最新状态，并了解版本之间的差异。

#### 版本信息#

##### 查看当前版本#

您可以通过以下方式查看当前安装的 Claude Code 版本：

###### CLI 命令

claude --version

###### 交互式命令

```
bash复制/version
```

```
/version
```

这会显示当前安装的 Claude Code 版本号。

##### 版本号格式#

Claude Code 使用语义化版本号格式：MAJOR.MINOR.PATCH

```
MAJOR.MINOR.PATCH
```

- MAJOR（主版本号）：重大更新，可能包含不兼容的 API 变更
- MINOR（次版本号）：新功能添加，向后兼容
- PATCH（修订号）：bug 修复和小改进，向后兼容

例如：2.1.3 表示主版本 2，次版本 1，修订号 3。

```
2.1.3
```

#### 更新 Claude Code#

##### 使用 claude update 命令#

```
claude update
```

Claude Code 提供了方便的更新命令，可以自动检查并安装最新版本。

###### 基本用法

```
bash复制claude update
```

```
claude update
```

这会执行以下操作：

True. 检查是否有新版本可用
True. 下载最新版本的安装包
True. 安装新版本
True. 清理旧版本的文件

###### 更新过程

更新过程通常包括以下步骤：

True. 检查更新：连接到更新服务器，检查最新版本
True. 下载更新：下载更新包（可能需要几分钟）
True. 验证更新：验证下载的更新包的完整性
True. 安装更新：安装新版本（可能需要管理员权限）
True. 清理：删除临时文件和旧版本
True. 确认：显示更新完成信息和新版本号

##### 更新选项#

###### 检查更新但不安装

某些情况下，您可能只想检查是否有更新，而不立即安装：

```
bash复制claude update --check-only
```

```
claude update --check-only
```

这会显示是否有新版本可用，但不会执行安装。

###### 指定版本

在某些情况下，您可能需要安装特定版本：

```
bash复制claude update --version 2.1.0
```

```
claude update --version 2.1.0
```

这会安装指定的版本，而不是最新版本。

###### 预览版本

如果您想尝试预览版本（可能包含新功能，但可能有 bug）：

```
bash复制claude update --preview
```

```
claude update --preview
```

这会安装最新的预览版本。

#### 版本兼容性#

##### 命令兼容性#

不同版本的 Claude Code 可能支持不同的命令和标志：

- 新增命令：新版本可能添加新的命令
- 废弃命令：旧命令在新版本中可能被废弃
- 删除命令：某些命令在新版本中可能被删除
- 命令变更：命令的语法或行为可能发生变化

##### 标志兼容性#

不同版本的 Claude Code 可能支持不同的标志：

- 新增标志：新版本可能添加新的标志
- 废弃标志：旧标志在新版本中可能被废弃
- 删除标志：某些标志在新版本中可能被删除
- 标志变更：标志的语法或行为可能发生变化

##### 配置兼容性#

不同版本的 Claude Code 可能使用不同的配置格式：

- 配置结构：配置文件的结构可能发生变化
- 配置选项：配置选项可能被添加、删除或重命名
- 默认值：配置选项的默认值可能发生变化
- 验证规则：配置验证规则可能变得更加严格

#### 版本迁移#

##### 升级到新版本#

当您升级到新版本时，可能需要进行一些迁移工作：

True. 阅读发布说明：了解新版本的变化和改进
True. 检查废弃警告：注意废弃的功能，准备迁移
True. 更新配置：根据新的配置格式更新配置文件
True. 测试功能：测试常用的功能，确保正常工作
True. 报告问题：如果发现问题，及时报告

##### 降级到旧版本#

如果新版本有问题，您可能需要降级到旧版本：

```
bash复制claude update --version 2.0.14
```

```
claude update --version 2.0.14
```

---

# 第 5 章

## 1 `claude` - 启动交互式 REPL

**URL**: https://claudecode.tangshuang.net/course/5.1%20%60claude%60%20-%20%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%20REPL

claude 是 Claude Code 的主命令，用于启动交互式 REPL（Read-Eval-Print Loop）环境。这是与 Claude Code 进行日常交互的最常用方式，提供了一个流畅的对话式编程体验。

```
claude
```

#### 命令语法#

```
bash复制claude [options] [prompt]
```

```
claude [options] [prompt]
```

#### 命令选项与参数#

##### 参数:#

```
prompt
```

##### 选项:#

```
--verbose
```

```
--verbose
```

```
-p, --print
```

```
--print
```

```
--output-format <format>
```

```
--output-format json
```

```
--dangerously-skip-permissions
```

```
--dangerously-skip-permissions
```

```
-c, --continue
```

```
--continue
```

```
-r, --resume [sessionId]
```

```
--resume session-id-123
```

```
--model <model>
```

```
--model claude-sonnet-4-5
```

```
-v, --version
```

```
--version
```

```
-h, --help
```

```
--help
```

##### 子命令:#

```
update
```

#### 功能描述#

启动 Claude Code 的交互式 REPL 环境后，您可以：

##### 核心功能#

- 自然语言对话：与 Claude 进行流畅的自然语言交互
- 代码生成：根据需求生成各种编程语言的代码
- 代码理解：解释现有代码的功能和工作原理
- 代码优化：改进代码质量、性能和可读性
- 问题排查：诊断代码中的错误和潜在问题

##### 高级功能#

- 工具调用：使用内置工具（如文件读写、搜索、执行命令）
- 会话管理：保存和恢复对话历史

#### 使用示例#

##### 基本用法#

```
bash复制claude
```

```
claude
```

这会启动 Claude Code 的交互式 REPL，您将看到类似以下的提示符：

```
bash复制Claude Code v1.0.0
Type '/help' for available commands.
>
```

```
Claude Code v1.0.0
Type '/help' for available commands.
>
```

现在您可以开始与 Claude 进行交互：

```
bash复制> 生成一个 Python 快速排序算法
```

```
> 生成一个 Python 快速排序算法
```

##### 使用初始提示启动#

```
bash复制claude "解释这个项目的架构"
```

```
claude "解释这个项目的架构"
```

这会使用指定的初始提示启动 REPL，Claude 会立即开始处理该提示并返回结果。这种方式适用于快速执行一次性任务。

##### 指定模型#

```
bash复制claude --model claude-sonnet-4-5
```

```
claude --model claude-sonnet-4-5
```

这会使用指定的模型启动 REPL。您可以根据需要选择不同的模型，平衡性能和质量。

##### 恢复之前的会话#

```
bash复制claude --continue
```

```
claude --continue
```

这会恢复最近的对话会话，让您可以继续之前的工作。您也可以使用 --resume 标志恢复特定会话：

```
--resume
```

```
bash复制claude --resume session-id-123
```

```
claude --resume session-id-123
```

#### 常用选项#

```
--model
```

```
--model claude-sonnet-4-5
```

```
--continue
```

```
--continue
```

```
--resume
```

```
--resume session-id
```

```
--verbose
```

```
--verbose
```

```
--help
```

```
--help
```

#### 最佳实践#

##### 1. 选择合适的模型#

根据任务复杂度选择合适的模型，平衡性能和质量。

##### 2. 保存会话#

定期保存重要的会话，以便后续恢复和参考。

#### 故障排除#

##### 问题：无法启动 REPL#

- 网络连接问题
- 许可证无效
- 依赖缺失

True. 检查网络连接
True. 验证许可证状态
True. 重新安装依赖

##### 问题：响应速度慢#

- 模型选择不当
- 网络延迟
- 系统资源不足

True. 尝试使用更快的模型
True. 检查网络连接
True. 关闭其他占用资源的程序

##### 问题：权限错误#

- 尝试执行敏感操作

True. 使用 --dangerously-skip-permissions 标志（谨慎使用）

```
--dangerously-skip-permissions
```

通过以上信息，您应该能够熟练使用 claude 命令启动和配置交互式 REPL 环境，享受高效的对话式编程体验。

```
claude
```

---

## 2 `claude "query"` - 使用初始提示启动 REPL

**URL**: https://claudecode.tangshuang.net/course/5.2%20%60claude%20%22query%22%60%20-%20%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E6%8F%90%E7%A4%BA%E5%90%AF%E5%8A%A8%20REPL

claude "query" 命令允许您使用初始提示启动 Claude Code 的交互式 REPL 环境。这在您希望 Claude 立即开始处理特定任务时非常有用。

```
claude "query"
```

#### 命令语法#

```
bash复制claude "query" [选项]
```

```
claude "query" [选项]
```

#### 功能描述#

使用初始提示启动 REPL，Claude 会立即开始处理您提供的查询。这比先启动 REPL 再输入查询更高效，特别适合：

- 快速开始特定任务
- 脚本和自动化

#### 使用示例#

##### 基本用法#

```
bash复制claude "解释这个项目"
```

```
claude "解释这个项目"
```

启动 REPL 并立即请求 Claude 解释当前项目。

##### 代码生成#

```
bash复制claude "创建一个 React 组件，用于显示用户列表"
```

```
claude "创建一个 React 组件，用于显示用户列表"
```

启动 REPL 并立即请求创建 React 组件。

##### 代码审查#

```
bash复制claude "审查 src/utils.js 文件中的代码"
```

```
claude "审查 src/utils.js 文件中的代码"
```

启动 REPL 并立即请求审查指定文件。

##### 结合其他选项#

```
bash复制claude --model claude-sonnet-4-5 "优化这个函数的性能"
```

```
claude --model claude-sonnet-4-5 "优化这个函数的性能"
```

使用指定的模型启动 REPL，并立即请求优化函数。

#### 初始提示的优势#

##### 1. 节省时间#

不需要先启动 REPL 再输入查询，一步完成启动和查询。

##### 2. 上下文设置#

初始查询可以设置对话的上下文，后续的交互会基于这个上下文。

##### 3. 自动化友好#

适合在脚本和自动化流程中使用，可以快速执行特定任务。

#### 常用场景#

##### 1. 快速任务#

```
bash复制claude "将这个 Python 函数转换为 JavaScript"
```

```
claude "将这个 Python 函数转换为 JavaScript"
```

快速完成代码转换任务。

##### 2. 日常开发#

```
bash复制claude "帮我写一个单元测试，测试这个函数"
```

```
claude "帮我写一个单元测试，测试这个函数"
```

在日常开发中快速请求帮助。

##### 3. 学习和探索#

```
bash复制claude "解释什么是闭包，并给出示例"
```

```
claude "解释什么是闭包，并给出示例"
```

快速学习和探索编程概念。

##### 4. 调试和问题解决#

```
bash复制claude "为什么这个函数返回 undefined？"
```

```
claude "为什么这个函数返回 undefined？"
```

快速获取调试帮助。

#### 注意事项#

True. 引号使用：如果查询包含空格或特殊字符，需要使用引号括起来
True. 查询长度：初始查询不宜过长，可以在 REPL 中继续补充
True. 上下文保持：初始查询会设置对话上下文，影响后续交互
True. 会话保存：使用初始提示启动的 REPL 会话也会被保存，可以后续恢复
True. 错误处理：如果初始查询有错误，REPL 仍会启动，您可以修正查询

#### 与其他命令的对比#

```
claude
```

```
claude "query"
```

```
claude -p "query"
```

```
claude -c
```

```
claude -r "id"
```

#### 最佳实践#

True. 明确查询：初始查询应该明确具体，避免模糊不清
True. 提供上下文：如果查询涉及特定文件或项目，提供足够的上下文
True. 分步进行：复杂任务可以分步进行，先设置初始查询，然后在 REPL 中逐步完善
True. 保存会话：重要的对话会话可以保存，方便后续恢复和参考

#### 相关命令#

- claude：启动交互式 REPL（无初始提示）
- claude -p "query"：通过 SDK 查询，然后退出

```
claude
```

```
claude -p "query"
```

---

## 3 `claude -p "query"` - 通过 SDK 查询，然后退出

**URL**: https://claudecode.tangshuang.net/course/5.3%20%60claude%20-p%20%22query%22%60%20-%20%E9%80%9A%E8%BF%87%20SDK%20%E6%9F%A5%E8%AF%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%80%E5%87%BA

claude -p "query" 命令允许您通过 SDK 执行查询，然后立即退出。这是非交互模式，适合脚本和自动化场景。

```
claude -p "query"
```

#### 命令语法#

```
bash复制claude -p "query" [选项]
```

```
claude -p "query" [选项]
```

#### 功能描述#

使用 -p（--print）标志，Claude Code 会：

```
-p
```

```
--print
```

True. 处理您提供的查询
True. 通过 SDK 执行查询
True. 打印响应结果
True. 立即退出，不进入交互模式

这是程序化使用 Claude Code 的主要方式，特别适合：

- 脚本和自动化
- CI/CD 流程
- 批处理任务
- 集成到其他工具

#### 使用示例#

##### 基本用法#

```
bash复制claude -p "解释这个函数"
```

```
claude -p "解释这个函数"
```

执行查询，打印结果，然后退出。

##### 代码生成#

```
bash复制claude -p "创建一个快速排序算法的 Python 实现"
```

```
claude -p "创建一个快速排序算法的 Python 实现"
```

生成快速排序算法代码，打印结果，然后退出。

##### 代码分析#

```
bash复制claude -p "分析这段代码的时间复杂度"
```

```
claude -p "分析这段代码的时间复杂度"
```

分析代码的时间复杂度，打印结果，然后退出。

##### 处理管道内容#

```
bash复制cat logs.txt | claude -p "解释这些日志"
```

```
cat logs.txt | claude -p "解释这些日志"
```

将日志文件内容通过管道传递给 Claude Code，请求解释，然后退出。

##### 结合输出格式#

```
bash复制claude -p "分析这个项目" --output-format json
```

```
claude -p "分析这个项目" --output-format json
```

以 JSON 格式输出分析结果，便于脚本解析。

#### 输出格式#

-p 标志支持多种输出格式，可以通过 --output-format 标志指定：

```
-p
```

```
--output-format
```

##### text 格式（默认）#

```
bash复制claude -p "查询内容"
```

```
claude -p "查询内容"
```

输出纯文本格式的响应。

##### json 格式#

```
bash复制claude -p "查询内容" --output-format json
```

```
claude -p "查询内容" --output-format json
```

输出 JSON 格式的响应，便于程序解析。

##### stream-json 格式#

```
bash复制claude -p "查询内容" --output-format stream-json
```

```
claude -p "查询内容" --output-format stream-json
```

输出流式 JSON，可以实时处理响应。

#### 使用场景#

##### 1. 脚本自动化#

```
bash复制#!/bin/bash

# 获取代码审查结果
result=$(claude -p "审查 src/main.js" --output-format json)
# 处理结果
echo "$result" | jq '.suggestions'
```

```
#!/bin/bash

# 获取代码审查结果
result=$(claude -p "审查 src/main.js" --output-format json)
# 处理结果
echo "$result" | jq '.suggestions'
```

在脚本中使用 Claude Code 进行代码审查。

##### 2. CI/CD 集成#

```
yaml复制# GitHub Actions 示例
- name: Code Review
  run: |
    review=$(claude -p "审查最近的代码变更" --output-format json)
    echo "$review" > review.json
```

```
# GitHub Actions 示例
- name: Code Review
  run: |
    review=$(claude -p "审查最近的代码变更" --output-format json)
    echo "$review" > review.json
```

在 CI/CD 流程中自动进行代码审查。

##### 3. 批处理#

```
sh复制for file in *.js; do
  claude -p "优化 $file" > "${file%.js}.optimized.js"
done
```

```
for file in *.js; do
  claude -p "优化 $file" > "${file%.js}.optimized.js"
done
```

批量处理多个文件。

#### 高级用法#

##### 跳过权限提示#

```
bash复制claude -p --dangerously-skip-permissions "任务"
```

```
claude -p --dangerously-skip-permissions "任务"
```

跳过权限提示（谨慎使用），完全自动化执行。

#### 注意事项#

True. 非交互模式：-p 标志不会进入交互模式，执行完查询后立即退出
True. 输出格式：建议使用 --output-format json 便于脚本解析
True. 错误处理：脚本中应该处理可能的错误和异常
True. API 限制：频繁调用可能触发 API 速率限制

```
-p
```

```
--output-format json
```

#### 与交互模式的对比#

#### 最佳实践#

True. 使用 JSON 输出：便于脚本解析和处理
True. 错误处理：在脚本中添加错误处理逻辑
True. 结果验证：验证返回的结果是否符合预期
True. 日志记录：记录查询和结果，便于调试和审计

#### 相关命令#

- claude：启动交互式 REPL
- claude "query"：使用初始提示启动 REPL
- claude -c：继续最近的对话
- --output-format：指定输出格式

```
claude
```

```
claude "query"
```

```
claude -c
```

```
--output-format
```

#### SDK 文档#

有关程序化使用 Claude Code 的更多详情，请参阅官方 SDK 文档。

---

## 4 `cat file | claude -p "query"` - 处理管道内容

**URL**: https://claudecode.tangshuang.net/course/5.4%20%60cat%20file%20%7C%20claude%20-p%20%22query%22%60%20-%20%E5%A4%84%E7%90%86%E7%AE%A1%E9%81%93%E5%86%85%E5%AE%B9

通过管道将文件内容传递给 Claude Code 进行处理，这是一种强大的工作流，允许您将其他命令的输出直接传递给 Claude Code。

#### 命令语法#

```
bash复制cat file | claude -p "query" [选项]
```

```
cat file | claude -p "query" [选项]
```

或使用其他命令的输出：

```
bash复制command | claude -p "query" [选项]
```

```
command | claude -p "query" [选项]
```

#### 功能描述#

通过管道（|）将左侧命令的输出传递给右侧的 claude -p 命令。这允许您：

```
|
```

```
claude -p
```

- 将文件内容传递给 Claude Code 处理
- 将其他命令的输出传递给 Claude Code
- 构建复杂的数据处理管道
- 实现自动化的工作流

#### 使用示例#

##### 基本用法#

```
bash复制cat logs.txt | claude -p "解释这些日志"
```

```
cat logs.txt | claude -p "解释这些日志"
```

将 logs.txt 文件的内容传递给 Claude Code，请求解释日志。

##### 代码分析#

```
bash复制cat main.js | claude -p "分析这段代码的质量"
```

```
cat main.js | claude -p "分析这段代码的质量"
```

将 main.js 的内容传递给 Claude Code，请求代码质量分析。

##### 错误日志分析#

```
bash复制cat error.log | claude -p "找出这些错误的原因"
```

```
cat error.log | claude -p "找出这些错误的原因"
```

将错误日志传递给 Claude Code，请求分析错误原因。

##### Git 输出处理#

```
bash复制git diff | claude -p "总结这些代码变更"
```

```
git diff | claude -p "总结这些代码变更"
```

将 git diff 的输出传递给 Claude Code，请求总结代码变更。

##### 结合其他命令#

```
bash复制grep "error" app.log | claude -p "分析这些错误模式"
```

```
grep "error" app.log | claude -p "分析这些错误模式"
```

先使用 grep 过滤错误日志，然后将结果传递给 Claude Code 分析。

##### 列出文件类型#

```
bash复制ls -la | claude -p "列出这些文件的类型"
```

```
ls -la | claude -p "列出这些文件的类型"
```

将 ls 命令的输出传递给 Claude Code，请求分析文件类型。

#### 管道的优势#

##### 1. 灵活性#

可以组合多个命令，构建复杂的数据处理流程。

##### 2. 自动化#

适合在脚本和自动化流程中使用，无需手动复制粘贴。

##### 3. 效率#

避免中间文件，直接在命令之间传递数据。

##### 4. 集成#

可以轻松集成到现有的 Unix/Linux 命令行工具链中。

#### 常用场景#

##### 1. 日志分析#

```
bash复制cat application.log | claude -p "分析这些日志，找出性能问题"
```

```
cat application.log | claude -p "分析这些日志，找出性能问题"
```

分析应用程序日志，找出性能问题。

##### 2. 代码审查#

```
bash复制git diff HEAD~1 | claude -p "审查这些代码变更"
```

```
git diff HEAD~1 | claude -p "审查这些代码变更"
```

审查最近的代码变更。

##### 3. 文档生成#

```
bash复制cat api.py | claude -p "为这个 API 生成文档"
```

```
cat api.py | claude -p "为这个 API 生成文档"
```

为 API 代码生成文档。

##### 4. 数据转换#

```
bash复制cat data.csv | claude -p "将 CSV 转换为 JSON" --output-format json
```

```
cat data.csv | claude -p "将 CSV 转换为 JSON" --output-format json
```

将 CSV 数据转换为 JSON 格式。

##### 5. 错误调试#

```
bash复制cat stacktrace.txt | claude -p "分析这个堆栈跟踪"
```

```
cat stacktrace.txt | claude -p "分析这个堆栈跟踪"
```

分析堆栈跟踪，帮助调试错误。

#### 高级用法#

##### 多重管道#

```
bash复制cat file.txt | grep "pattern" | claude -p "处理匹配的内容"
```

```
cat file.txt | grep "pattern" | claude -p "处理匹配的内容"
```

使用多个管道，先过滤再处理。

##### 结合重定向#

```
bash复制cat input.txt | claude -p "处理内容" > output.txt
```

```
cat input.txt | claude -p "处理内容" > output.txt
```

将处理结果重定向到文件。

##### 错误流处理#

```
bash复制command 2>&1 | claude -p "处理所有输出"
```

```
command 2>&1 | claude -p "处理所有输出"
```

将标准输出和错误输出都传递给 Claude Code。

##### 后台执行#

```
bash复制cat largefile.txt | claude -p "处理大文件" &
```

```
cat largefile.txt | claude -p "处理大文件" &
```

在后台处理大文件。

#### 注意事项#

True. 输出格式：确保传递给 Claude Code 的内容是合适的格式
True. 编码问题：注意文件的编码，避免乱码
True. 大小限制：大文件可能需要分批处理
True. 特殊字符：某些特殊字符可能需要转义
True. 错误处理：管道中的任何命令失败都会导致整个管道失败

#### 管道最佳实践#

True. 验证输出：先验证左侧命令的输出是否符合预期
True. 使用合适的格式：确保传递的内容格式正确
True. 处理错误：考虑管道中命令失败的情况
True. 性能考虑：大文件处理可能需要优化
True. 日志记录：记录管道的输入和输出，便于调试

#### 与其他方法的对比#

#### 相关命令#

- claude -p：通过 SDK 查询，然后退出
- cat：显示文件内容
- grep：搜索文本模式
- git diff：显示代码变更
- --input-format：指定输入格式

```
claude -p
```

```
cat
```

```
grep
```

```
git diff
```

```
--input-format
```

#### 实际应用示例#

##### CI/CD 代码审查#

```
sh复制#!/bin/bash
# 获取最近的代码变更
changes=$(git diff origin/main...HEAD)
# 通过管道传递给 Claude Code 进行审查
echo "$changes" | claude -p "审查这些代码变更" --output-format json > review.json
```

```
#!/bin/bash
# 获取最近的代码变更
changes=$(git diff origin/main...HEAD)
# 通过管道传递给 Claude Code 进行审查
echo "$changes" | claude -p "审查这些代码变更" --output-format json > review.json
```

##### 日志监控脚本#

```
sh复制#!/bin/bash
# 监控日志文件
tail -f app.log | while read line; do
echo "$line" | claude -p "分析这行日志"
done
```

```
#!/bin/bash
# 监控日志文件
tail -f app.log | while read line; do
echo "$line" | claude -p "分析这行日志"
done
```

##### 批量文档生成#

```
sh复制#!/bin/bash
# 为多个文件生成文档
for file in src/*.py; do
  cat "$file" | claude -p "为这个文件生成文档" > "docs/${file##*/}.md"
done
```

```
#!/bin/bash
# 为多个文件生成文档
for file in src/*.py; do
  cat "$file" | claude -p "为这个文件生成文档" > "docs/${file##*/}.md"
done
```

通过管道，您可以构建强大而灵活的工作流，将 Claude Code 无缝集成到您的开发和运维流程中。

---

## 5 `claude -c` - 继续最近的对话

**URL**: https://claudecode.tangshuang.net/course/5.5%20%60claude%20-c%60%20-%20%E7%BB%A7%E7%BB%AD%E6%9C%80%E8%BF%91%E7%9A%84%E5%AF%B9%E8%AF%9D

claude -c 命令允许您继续最近的对话会话。这在您意外关闭了 REPL 或想要继续之前的工作时非常有用。

```
claude -c
```

#### 命令语法#

```
bash复制claude -c [选项]
```

```
claude -c [选项]
```

#### 功能描述#

-c（--continue）标志会加载当前目录中最近的对话会话，并启动 REPL。这允许您：

```
-c
```

```
--continue
```

- 恢复意外中断的对话
- 继续之前的工作
- 保持对话上下文
- 避免重复之前的查询

#### 使用示例#

##### 基本用法#

```
bash复制claude -c
```

```
claude -c
```

加载最近的对话会话并启动 REPL。

##### 结合初始查询#

```
bash复制claude -c "继续优化这个函数"
```

```
claude -c "继续优化这个函数"
```

加载最近的对话，并立即继续优化函数的任务。

##### 指定模型#

```
bash复制claude -c --model claude-4-opus
```

```
claude -c --model claude-4-opus
```

使用指定的模型继续最近的对话。

##### 添加额外的工作目录#

```
bash复制claude -c --add-dir ../tests
```

```
claude -c --add-dir ../tests
```

加载最近的对话，并添加额外的工作目录。

#### 会话保存机制#

Claude Code 会自动保存对话会话，以便后续恢复：

##### 保存位置#

会话保存在以下位置：

- 本地会话：保存在项目目录的 .claude/sessions/ 子目录
- 用户会话：保存在用户主目录的 .claude/sessions/ 子目录

```
.claude/sessions/
```

```
.claude/sessions/
```

##### 会话命名#

会话通常以以下方式命名：

- 时间戳：包含会话创建或最后修改的时间
- 会话 ID：唯一的标识符，用于精确恢复
- 摘要：对话的简要描述（如果可用）

##### 会话内容#

保存的会话包含：

- 对话历史
- 上下文信息
- 工具调用记录
- 配置状态
- 文件访问记录

#### 使用场景#

##### 1. 意外中断#

```
bash复制# 意外关闭了 REPL
claude -c
```

```
# 意外关闭了 REPL
claude -c
```

恢复意外中断的对话。

##### 2. 跨天工作#

```
bash复制# 第二天继续前一天的工作
claude -c "继续昨天的任务"
```

```
# 第二天继续前一天的工作
claude -c "继续昨天的任务"
```

继续前一天未完成的工作。

##### 3. 切换任务#

```
bash复制# 完成一个任务后，开始另一个任务
claude -c "开始新任务"
```

```
# 完成一个任务后，开始另一个任务
claude -c "开始新任务"
```

切换到不同的任务，同时保持之前的上下文。

##### 4. 多项目工作#

```
bash复制# 在项目 A 中工作
cd /path/to/project-a
claude -c
# 切换到项目 B
cd /path/to/project-b
claude -c
```

```
# 在项目 A 中工作
cd /path/to/project-a
claude -c
# 切换到项目 B
cd /path/to/project-b
claude -c
```

在不同项目之间切换，每个项目保持独立的对话上下文。

#### 会话管理#

##### 查看可用会话#

虽然 claude -c 默认加载最近的会话，但您可以通过以下方式查看所有可用会话：

```
claude -c
```

True. 查看会话目录：

```
bash复制ls -la .claude/sessions/
```

```
ls -la .claude/sessions/
```

```
bash复制claude --resume
```

```
claude --resume
```

这会显示可用会话列表，让您选择要恢复的会话。

##### 清理旧会话#

定期清理旧会话可以释放磁盘空间：

```
bash复制# 删除超过 7 天的会话
find .claude/sessions/ -mtime +7 -delete
```

```
# 删除超过 7 天的会话
find .claude/sessions/ -mtime +7 -delete
```

#### 注意事项#

#### 与其他恢复命令的对比#

```
claude -c
```

```
claude --resume
```

```
claude -r "id"
```

#### 最佳实践#

##### 1. 结合版本控制#

```
bash复制# 在Git提交前保存会话
git add .
git commit -m "重构用户认证模块"
```

```
# 在Git提交前保存会话
git add .
git commit -m "重构用户认证模块"
```

将代码变更与会话状态同步记录。

##### 2. 清理策略#

```
bash复制# 删除超过 7 天的会话
find .claude/sessions/ -mtime +7 -delete
```

```
# 删除超过 7 天的会话
find .claude/sessions/ -mtime +7 -delete
```

定期清理旧会话，避免磁盘空间浪费。

#### 常见问题#

##### Q: 如何查看会话的详细信息？#

A: 可以查看会话目录中的文件，或使用 claude --resume 交互式选择会话。

```
claude --resume
```

##### Q: 恢复的会话与原会话完全一样吗？#

A: 基本一样，但某些临时状态可能无法完全恢复。

##### Q: 可以恢复其他目录的会话吗？#

A: 不可以，-c 只会加载当前目录中的会话。要恢复其他目录的会话，需要切换到该目录或使用 -r 命令。

```
-c
```

```
-r
```

##### Q: 会话会占用多少磁盘空间？#

A: 这取决于对话的长度和复杂度，通常在几 KB 到几 MB 之间。

#### 相关命令#

- claude：启动新的交互式 REPL
- claude --resume：交互式选择并恢复会话
- claude -r "id"：按 ID 恢复会话
- /clear：清除对话历史
- /exit：退出 REPL

```
claude
```

```
claude --resume
```

```
claude -r "id"
```

```
/clear
```

```
/exit
```

#### 实际应用示例#

##### 工作流恢复#

```
sh复制#!/bin/bash
# 检查是否有最近的会话
if [ -d .claude/sessions/ ]; then
# 恢复最近的会话
claude -c "继续之前的工作"
else
# 启动新的会话
claude "开始新任务"
fi
```

```
#!/bin/bash
# 检查是否有最近的会话
if [ -d .claude/sessions/ ]; then
# 恢复最近的会话
claude -c "继续之前的工作"
else
# 启动新的会话
claude "开始新任务"
fi
```

##### 多项目管理#

```
bash复制#!/bin/bash
# 项目列表
projects=("project-a" "project-b" "project-c")

# 选择项目
echo "选择项目："
select project in "${projects[@]}"; do
  cd "/path/to/$project"
  claude -c "在 $project 中工作"
  break
done
```

```
#!/bin/bash
# 项目列表
projects=("project-a" "project-b" "project-c")

# 选择项目
echo "选择项目："
select project in "${projects[@]}"; do
  cd "/path/to/$project"
  claude -c "在 $project 中工作"
  break
done
```

通过 claude -c，您可以无缝地继续之前的工作，提高工作效率，避免重复之前的查询和上下文设置。

```
claude -c
```

---

## 6 `claude -c -p "query"` - 通过 SDK 继续

**URL**: https://claudecode.tangshuang.net/course/5.6%20%60claude%20-c%20-p%20%22query%22%60%20-%20%E9%80%9A%E8%BF%87%20SDK%20%E7%BB%A7%E7%BB%AD

claude -c -p "query" 命令结合了会话恢复和打印模式，允许您在继续最近对话的同时执行一次性查询。

```
claude -c -p "query"
```

#### 命令语法#

```
bash复制claude -c -p "query" [选项]
```

```
claude -c -p "query" [选项]
```

#### 功能描述#

这个命令结合了两个功能：

True. -c（--continue）：加载最近的对话会话
True. -p（--print）：通过 SDK 执行查询，然后退出
这允许您：

```
-c
```

```
--continue
```

```
-p
```

```
--print
```

- 在之前对话的上下文中执行查询
- 获取查询结果而不进入交互模式
- 适合脚本和自动化场景
- 保持对话的连续性

#### 使用示例#

##### 基本用法#

```
bash复制claude -c -p "检查类型错误"
```

```
claude -c -p "检查类型错误"
```

```
bash复制加载最近的对话，执行类型检查查询，打印结果，然后退出。

### 代码审查
~~~bash
claude -c -p "审查最近的代码变更"
```

```
加载最近的对话，执行类型检查查询，打印结果，然后退出。

### 代码审查
~~~bash
claude -c -p "审查最近的代码变更"
```

在之前对话的上下文中审查最近的代码变更。

##### 测试结果分析#

```
bash复制claude -c -p "分析测试失败的原因"
```

```
claude -c -p "分析测试失败的原因"
```

在之前对话的上下文中分析测试失败的原因。

##### 结合输出格式#

```
bash复制claude -c -p "总结当前进度" --output-format json
```

```
claude -c -p "总结当前进度" --output-format json
```

以 JSON 格式输出进度总结，便于脚本解析。

##### 指定模型#

```
bash复制claude -c -p "优化性能" --model claude-4-opus
```

```
claude -c -p "优化性能" --model claude-4-opus
```

使用指定的模型在之前对话的上下文中优化性能。

#### 使用场景#

##### 1. CI/CD 集成#

```
bash复制# 在 CI/CD 流程中继续之前的对话
claude -c -p "运行测试并分析结果" --output-format json
```

```
# 在 CI/CD 流程中继续之前的对话
claude -c -p "运行测试并分析结果" --output-format json
```

在 CI/CD 中继续之前的对话，执行测试并分析结果。

##### 2. 定期检查#

```
bash复制# 定期检查项目状态
claude -c -p "检查代码质量" --output-format json
```

```
# 定期检查项目状态
claude -c -p "检查代码质量" --output-format json
```

在之前对话的上下文中定期检查代码质量。

##### 3. 自动化报告#

```
bash复制# 生成进度报告
claude -c -p "生成进度报告" --output-format json > report.json
```

```
# 生成进度报告
claude -c -p "生成进度报告" --output-format json > report.json
```

在之前对话的上下文中生成进度报告。

##### 4. 批量任务#

```
bash复制# 执行多个相关任务
claude -c -p "任务1" --output-format json > result1.json
claude -c -p "任务2" --output-format json > result2.json
claude -c -p "任务3" --output-format json > result3.json
```

```
# 执行多个相关任务
claude -c -p "任务1" --output-format json > result1.json
claude -c -p "任务2" --output-format json > result2.json
claude -c -p "任务3" --output-format json > result3.json
```

在相同的对话上下文中执行多个相关任务。

#### 上下文保持#

##### 对话历史#

-c 标志会加载完整的对话历史，包括：

```
-c
```

- 之前的查询和响应
- 代码生成和修改
- 文件访问记录
- 工具调用历史

##### 上下文影响#

查询会在之前对话的上下文中执行，这意味着：

- Claude 会记住之前的讨论
- 可以引用之前生成的代码
- 可以继续之前的话题
- 保持一致的风格和偏好

##### 上下文限制#

需要注意上下文的限制：

- 上下文长度：对话历史有长度限制，过长的历史可能被截断
- 上下文相关性：如果查询与之前对话不相关，上下文可能没有帮助
- 上下文更新：新的查询会更新对话上下文

#### 与其他命令的对比#

```
claude -c
```

```
claude -c -p
```

```
claude -p
```

```
claude -r "id" -p
```

#### 高级用法#

##### 结合多个选项#

```
bash复制claude -c -p "任务" --model opus --output-format json --verbose
```

```
claude -c -p "任务" --model opus --output-format json --verbose
```

使用多个选项精确控制执行。

##### 错误处理#

```
bash复制#!/bin/bash
# 执行查询并处理错误
result=$(claude -c -p "任务" --output-format json 2>&1)
if [ $? -ne 0 ]; then
  echo "错误: $result"
  exit 1
fi
echo "$result" | jq '.result'
```

```
#!/bin/bash
# 执行查询并处理错误
result=$(claude -c -p "任务" --output-format json 2>&1)
if [ $? -ne 0 ]; then
  echo "错误: $result"
  exit 1
fi
echo "$result" | jq '.result'
```

在脚本中处理可能的错误。

##### 超时控制#

```
bash复制# 设置超时
timeout 60 claude -c -p "长时间任务"
```

```
# 设置超时
timeout 60 claude -c -p "长时间任务"
```

为长时间运行的任务设置超时。

#### 注意事项#

True. 会话依赖：需要当前目录中有可用的会话
True. 上下文相关：查询应该与之前对话相关，以充分利用上下文
True. 输出格式：建议使用 --output-format json 便于脚本解析
True. 会话更新：查询会更新对话上下文，影响后续的 -c 调用
True. 资源使用：长时间运行的查询可能占用较多资源

```
--output-format json
```

```
-c
```

#### 最佳实践#

True. 上下文相关：确保查询与之前对话相关，充分利用上下文
True. 明确查询：查询应该明确具体，避免模糊不清
True. 输出格式：使用合适的输出格式，便于后续处理
True. 错误处理：在脚本中添加错误处理逻辑
True. 会话管理：定期清理不需要的会话，避免混淆

#### 常见问题#

##### Q: 查询会修改会话吗？#

A: 是的，查询会更新对话上下文，影响后续的 -c 调用。

```
-c
```

##### Q: 可以使用其他会话吗？#

A: 不可以，-c 只会加载最近的会话。要使用其他会话，请使用 -r 命令。

```
-c
```

```
-r
```

##### Q: 上下文会保留多久？#

A: 上下文会保留在会话文件中，直到会话被删除或覆盖。

##### Q: 查询失败会影响会话吗？#

A: 查询失败不会修改会话，但会记录错误信息。

#### 相关命令#

- claude -c：继续最近的对话（进入 REPL）
- claude -r "id" -p：按 ID 恢复会话并执行查询
- claude -p：执行独立查询
- --output-format：指定输出格式

```
claude -c
```

```
claude -r "id" -p
```

```
claude -p
```

```
--output-format
```

#### 实际应用示例#

##### 自动化工作流#

```
bash复制#!/bin/bash
# 每天自动检查项目状态
echo "=== 每日检查 ==="

# 检查代码质量
claude -c -p "检查代码质量" --output-format json > quality.json

# 检查测试状态
claude -c -p "检查测试状态" --output-format json > tests.json

# 生成报告
claude -c -p "生成每日报告" --output-format json > report.json

echo "检查完成"
```

```
#!/bin/bash
# 每天自动检查项目状态
echo "=== 每日检查 ==="

# 检查代码质量
claude -c -p "检查代码质量" --output-format json > quality.json

# 检查测试状态
claude -c -p "检查测试状态" --output-format json > tests.json

# 生成报告
claude -c -p "生成每日报告" --output-format json > report.json

echo "检查完成"
```

##### 持续集成#

```
yaml复制# GitHub Actions 示例
name: Daily Check
on:
  schedule:
  - cron: '0 9 * * *'
  jobs:
    check:
      runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v2
    - name: Check Code Quality
      run: |
        result=$(claude -c -p "检查代码质量" --output-format json)
        echo "$result" | jq '.issues' > issues.json
```

```
# GitHub Actions 示例
name: Daily Check
on:
  schedule:
  - cron: '0 9 * * *'
  jobs:
    check:
      runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v2
    - name: Check Code Quality
      run: |
        result=$(claude -c -p "检查代码质量" --output-format json)
        echo "$result" | jq '.issues' > issues.json
```

---

## 7 `claude -r "<session-id>" "query"` - 按 ID 恢复会话

**URL**: https://claudecode.tangshuang.net/course/5.7%20%60claude%20-r%20%22%3Csession-id%3E%22%20%22query%22%60%20-%20%E6%8C%89%20ID%20%E6%81%A2%E5%A4%8D%E4%BC%9A%E8%AF%9D

claude -r "<session-id>" "query" 命令允许您按会话 ID 恢复特定的对话会话，并在恢复的上下文中执行查询。

```
claude -r "<session-id>" "query"
```

#### 命令语法#

```
bash复制claude -r "<session-id>" "query" [选项]
```

```
claude -r "<session-id>" "query" [选项]
```

#### 功能描述#

-r（--resume）标志允许您：

```
-r
```

```
--resume
```

- 按会话 ID 精确恢复特定会话
- 在恢复的会话上下文中执行查询
- 保持对话的连续性和上下文
- 精确控制要恢复的会话

#### 使用示例#

##### 基本用法#

```
bash复制claude -r "abc123" "继续这个任务"
```

```
claude -r "abc123" "继续这个任务"
```

恢复 ID 为 "abc123" 的会话，并继续执行任务。

##### 代码审查#

```
bash复制claude -r "def456" "审查最新的代码变更"
```

```
claude -r "def456" "审查最新的代码变更"
```

恢复特定会话，并在该上下文中审查代码变更。

##### 项目分析#

```
bash复制claude -r "ghi789" "分析这个项目的性能"
```

```
claude -r "ghi789" "分析这个项目的性能"
```

恢复特定会话，并在该上下文中分析项目性能。

##### 结合其他选项#

```
bash复制claude -r "abc123" "完成任务" --model claude-4-opus
```

```
claude -r "abc123" "完成任务" --model claude-4-opus
```

恢复指定会话，使用特定模型完成任务。

```
bash复制claude -r "def456" "检查状态" --output-format json
```

```
claude -r "def456" "检查状态" --output-format json
```

恢复指定会话，以 JSON 格式输出状态检查结果。

#### 获取会话 ID#

##### 方法1：查看会话目录#

```
bash复制ls -la .claude/sessions/
```

```
ls -la .claude/sessions/
```

这会列出所有保存的会话，包括会话 ID。

##### 方法2：使用交互式恢复#

```
bash复制claude --resume
```

```
claude --resume
```

这会显示可用会话列表，包括会话 ID 和描述。

##### 方法3：查看会话文件#

会话文件名通常包含会话 ID：

```
bash复制ls -la .claude/sessions/ | grep session
```

```
ls -la .claude/sessions/ | grep session
```

这会显示所有包含会话 ID 的会话文件。

#### 会话 ID 格式#

会话 ID 通常是：

- 短字符串：如 "abc123"、"def456"
- 唯一标识：每个会话有唯一的 ID
- 可读性：某些情况下可能包含描述性信息

#### 使用场景#

##### 1. 精确恢复#

```
bash复制# 知道要恢复的会话 ID
claude -r "abc123" "继续工作"
```

```
# 知道要恢复的会话 ID
claude -r "abc123" "继续工作"
```

精确恢复指定的会话。

##### 2. 多会话管理#

```
bash复制# 在多个会话之间切换
claude -r "abc123" "任务1"
claude -r "def456" "任务2"
claude -r "ghi789" "任务3"
```

```
# 在多个会话之间切换
claude -r "abc123" "任务1"
claude -r "def456" "任务2"
claude -r "ghi789" "任务3"
```

在不同的会话之间切换工作。

##### 3. 协作恢复#

```
bash复制# 恢复团队成员分享的会话
claude -r "shared-session-id" "继续协作"
```

```
# 恢复团队成员分享的会话
claude -r "shared-session-id" "继续协作"
```

恢复共享的会话进行协作。

##### 4. 长期项目#

```
bash复制# 恢复长期项目的会话
claude -r "project-alpha-session" "继续项目 Alpha"
```

```
# 恢复长期项目的会话
claude -r "project-alpha-session" "继续项目 Alpha"
```

恢复长期项目的会话，保持项目上下文。

#### 会话选择策略#

##### 选择最近会话#

如果您不确定要恢复哪个会话，可以：

True. 查看会话列表
True. 按时间排序
True. 选择最近的会话

##### 选择相关会话#

根据当前任务选择最相关的会话：

- 查看会话描述
- 检查会话内容
- 选择最匹配的会话

##### 选择活跃会话#

优先选择最近活跃的会话：

- 查看最后修改时间
- 选择最近更新的会话
- 确保上下文是最新的

#### 注意事项#

True. 会话存在：确保指定的会话 ID 存在
True. 会话位置：-r 会从当前目录的会话目录查找会话
True. 上下文相关：查询应该与恢复的会话相关
True. 会话更新：新的查询会更新恢复的会话
True. ID 大小写：会话 ID 可能区分大小写

```
-r
```

#### 与其他恢复命令的对比#

```
claude -c
```

```
claude --resume
```

```
claude -r "id"
```

#### 最佳实践#

True. 记录会话 ID：重要的会话 ID 可以记录下来，便于后续恢复
True. 描述性会话：在会话中使用描述性的查询，便于识别
True. 定期清理：定期清理不需要的会话，避免混淆
True. 会话备份：重要的会话可以备份，防止意外丢失
True. 上下文保持：确保查询与恢复的会话相关，充分利用上下文

#### 常见问题#

##### Q: 如何知道要恢复哪个会话？#

A: 可以使用 claude --resume 查看所有可用会话，或查看会话目录。

```
claude --resume
```

##### Q: 会话 ID 会改变吗？#

A: 会话 ID 在会话创建时生成，通常不会改变。

##### Q: 可以恢复其他目录的会话吗？#

A: 不可以，-r 只会从当前目录的会话目录查找会话。

```
-r
```

##### Q: 恢复的会话会覆盖当前会话吗？#

A: 不会，恢复的会话和当前会话是独立的。

#### 相关命令#

- claude -c：继续最近的对话
- claude --resume：交互式选择并恢复会话
- claude -r "id"：按 ID 恢复会话（不执行查询）
- /clear：清除对话历史

```
claude -c
```

```
claude --resume
```

```
claude -r "id"
```

```
/clear
```

#### 实际应用示例#

##### 会话管理脚本#

```
bash复制#!/bin/bash
# 列出所有会话
echo "可用会话："
ls -la .claude/sessions/ | grep session

# 选择要恢复的会话
read -p "输入会话 ID: " session_id

# 恢复会话
claude -r "$session_id" "继续工作"
```

```
#!/bin/bash
# 列出所有会话
echo "可用会话："
ls -la .claude/sessions/ | grep session

# 选择要恢复的会话
read -p "输入会话 ID: " session_id

# 恢复会话
claude -r "$session_id" "继续工作"
```

恢复用户选择的会话。

##### 多项目工作流#

```
bash复制#!/bin/bash
# 项目会话映射
declare -A sessions
sessions[project-a]="abc123"
sessions[project-b]="def456"
sessions[project-c]="ghi789"
# 选择项目
echo "选择项目："
for project in "${!sessions[@]}"; do
echo "$project: ${sessions[$project]}"
done
read -p "输入项目名称: " project_name
# 恢复项目会话
claude -r "${sessions[$project_name]}" "在 $project_name 中工作"
```

```
#!/bin/bash
# 项目会话映射
declare -A sessions
sessions[project-a]="abc123"
sessions[project-b]="def456"
sessions[project-c]="ghi789"
# 选择项目
echo "选择项目："
for project in "${!sessions[@]}"; do
echo "$project: ${sessions[$project]}"
done
read -p "输入项目名称: " project_name
# 恢复项目会话
claude -r "${sessions[$project_name]}" "在 $project_name 中工作"
```

恢复用户选择的项目会话。

---

## 8 `claude update` - 更新到最新版本

**URL**: https://claudecode.tangshuang.net/course/5.8%20%60claude%20update%60%20-%20%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC

claude update 命令用于将 Claude Code 更新到最新版本，确保您始终使用最新的功能和改进。

```
claude update
```

#### 命令语法#

```
bash复制claude update [选项]
```

```
claude update [选项]
```

#### 功能描述#

claude update 命令会执行以下操作：

```
claude update
```

True. 检查当前安装的版本
True. 连接到更新服务器，检查是否有新版本
True. 下载最新版本的安装包
True. 验证下载的安装包
True. 安装新版本
True. 清理旧版本的文件
True. 显示更新完成信息

#### 使用示例#

##### 基本用法#

```
bash复制claude update
```

```
claude update
```

更新到最新版本。

#### 更新过程#

##### 1. 检查更新#

系统会检查是否有新版本可用：

- 比较当前版本和最新版本
- 显示可用的更新信息

##### 2. 下载更新#

如果检测到新版本，系统会下载更新包：

- 显示下载进度
- 保存到临时目录

##### 3. 安装更新#

下载完成后，系统会安装新版本：

- 安装新版本文件
- 更新配置文件（如需要）

##### 4. 确认#

最后，系统会显示更新完成信息：

- 显示新版本号
- 提供更新说明

#### 使用场景#

##### 1. 定期更新#

```
bash复制# 每周检查并更新
claude update
```

```
# 每周检查并更新
claude update
```

保持 Claude Code 最新状态。

##### 2. 通过 npm 更新#

```
bash复制# 使用 npm 更新
npm update -g @anthropic-ai/claude-code
```

```
# 使用 npm 更新
npm update -g @anthropic-ai/claude-code
```

通过 npm 包管理器更新。

#### 更新注意事项#

##### 1. 权限要求#

更新可能需要管理员权限：

- Linux/macOS：可能需要 sudo
- Windows：可能需要管理员权限

```
sudo
```

##### 2. 网络连接#

更新需要网络连接：

- 确保网络连接稳定
- 某些网络环境可能需要代理配置
- 下载可能需要几分钟

##### 3. 配置兼容性#

新版本可能需要配置更新：

- 某些配置选项可能被废弃
- 新的配置选项可能被添加
- 配置格式可能发生变化

##### 4. 插件兼容性#

更新后，插件可能需要更新：

- 某些插件可能不兼容新版本
- 插件 API 可能发生变化
- 需要更新插件到兼容版本

#### 更新最佳实践#

##### 1. 定期更新#

- 定期检查并更新 Claude Code
- 关注重要更新和安全补丁
- 在非生产环境先测试新版本

##### 2. 备份配置#

- 更新前备份配置文件
- 保存重要的会话和历史
- 记录自定义设置和插件

##### 3. 阅读发布说明#

- 更新前阅读发布说明
- 了解新功能和改进
- 注意废弃的功能和 breaking changes

##### 4. 测试更新#

- 在测试环境先更新
- 验证关键功能正常工作
- 确认没有性能问题

##### 5. 逐步推广#

- 不要立即在生产环境使用新版本
- 先在小范围试用
- 确认稳定后再全面推广

#### 故障排除#

##### 更新失败#

如果更新失败，可以尝试：

True. 检查网络连接
True. 使用 npm update -g @anthropic-ai/claude-code 手动更新
True. 使用 claude doctor 检查安装状态

```
npm update -g @anthropic-ai/claude-code
```

```
claude doctor
```

##### 权限问题#

如果遇到权限问题：

True. 使用 sudo（Linux/macOS）
True. 以管理员身份运行（Windows）
True. 检查文件和目录权限

```
sudo
```

#### 相关命令#

- claude --version：查看当前版本
- /version：在交互式会话中查看版本
- --check-only：只检查更新

```
claude --version
```

```
/version
```

```
--check-only
```

#### 更新日志#

Claude Code 的更新日志包含：

- 新功能列表
- 改进和优化
- bug 修复
- 废弃的功能
- 已知问题

您可以通过以下方式获取更新日志：

True. 官方文档：访问 Claude Code 官方文档
True. GitHub Releases：查看 GitHub 仓库的 Releases 页面
True. 更新通知：关注更新通知邮件或消息

通过定期更新 Claude Code，您可以确保使用最新的功能和改进，获得更好的使用体验。

---

## 9 `claude mcp` - 配置模型上下文协议 (MCP) 服务器

**URL**: https://claudecode.tangshuang.net/course/5.9%20%60claude%20mcp%60%20-%20%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE%20(MCP)%20%E6%9C%8D%E5%8A%A1%E5%99%A8

claude mcp 命令用于配置和管理模型上下文协议 (MCP) 服务器。MCP 是 Claude Code 连接外部工具和数据源的重要桥梁。

```
claude mcp
```

#### 命令语法#

```
bash复制claude mcp [选项]
```

```
claude mcp [选项]
```

#### 功能描述#

claude mcp 命令会打开 MCP 配置界面，允许您：

```
claude mcp
```

- 添加新的 MCP 服务器
- 管理现有的 MCP 服务器
- 配置 MCP 服务器参数
- 测试 MCP 服务器连接
- 查看 MCP 服务器状态

#### MCP 概述#

##### 什么是 MCP？#

模型上下文协议 (MCP) 是一个开放协议，允许 Claude Code：

- 连接到外部工具和服务
- 访问外部数据源
- 执行外部操作
- 扩展 Claude Code 的能力

##### MCP 的优势#

- 开放标准：基于开放协议，任何人都可以实现
- 灵活扩展：支持各种工具和服务集成
- 安全控制：提供细粒度的权限控制
- 易于使用：简单的配置和管理

#### 使用示例#

##### 基本用法#

```
bash复制claude mcp
```

```
claude mcp
```

打开 MCP 配置界面。

##### 添加 MCP 服务器#

```
bash复制claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx @modelcontextprotocol/server-airtable
```

```
claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx @modelcontextprotocol/server-airtable
```

添加 Airtable MCP 服务器。

##### 列出服务器#

```
bash复制claude mcp list
```

```
claude mcp list
```

列出所有配置的 MCP 服务器。

##### 删除服务器#

```
bash复制claude mcp remove airtable
```

```
claude mcp remove airtable
```

删除指定的 MCP 服务器。

#### MCP 配置选项#

##### 服务器配置#

MCP 服务器通过以下方式配置：

- 服务器名称
- 命令和参数
- 环境变量

```
bash复制claude mcp add <name> <command> [args...]
```

```
claude mcp add <name> <command> [args...]
```

##### 安装范围#

MCP 服务器可以在不同范围安装：

True. 本地范围：仅当前项目
True. 项目范围：项目及其子项目
True. 用户范围：所有项目

#### 使用场景#

##### 1. 数据库集成#

```
bash复制claude mcp add postgres -- npx @modelcontextprotocol/server-postgres --env POSTGRES_CONNECTION_STRING="postgresql://..."
```

```
claude mcp add postgres -- npx @modelcontextprotocol/server-postgres --env POSTGRES_CONNECTION_STRING="postgresql://..."
```

集成数据库访问能力。

##### 2. API 集成#

```
bash复制claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx @modelcontextprotocol/server-airtable
```

```
claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx @modelcontextprotocol/server-airtable
```

集成外部 API 服务。

##### 3. 文件系统访问#

```
bash复制claude mcp add filesystem -- npx @modelcontextprotocol/server-filesystem /path/to/directory
```

```
claude mcp add filesystem -- npx @modelcontextprotocol/server-filesystem /path/to/directory
```

扩展文件系统访问能力。

##### 4. 云服务集成#

```
bash复制claude mcp add browsercat -- npx -y @browsercatco/mcp-server --env BROWSERCAT_API_KEY=YOUR_KEY
```

```
claude mcp add browsercat -- npx -y @browsercatco/mcp-server --env BROWSERCAT_API_KEY=YOUR_KEY
```

集成云服务。

#### 注意事项#

True. 网络连接：远程 MCP 服务器需要稳定的网络连接
True. 认证配置：某些服务器需要配置认证信息
True. 权限控制：MCP 服务器可能需要特定的权限
True. 性能影响：过多的 MCP 服务器可能影响性能
True. 安全考虑：只信任和配置可信的 MCP 服务器

#### 相关命令#

- /mcp：在交互式会话中检查 MCP 服务器状态
- MCP 文档：详细的 MCP 配置和使用指南

```
/mcp
```

---

# 第 6 章

## 1 `--add-dir` - 添加额外的工作目录

**URL**: https://claudecode.tangshuang.net/course/6.1%20%60--add-dir%60%20-%20%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95

--add-dir 标志允许您添加额外的工作目录供 Claude Code 访问。这在您需要让 Claude Code 访问项目外的文件或目录时非常有用。

```
--add-dir
```

#### 标志语法#

```
bash复制claude --add-dir <path> [其他选项]
```

```
claude --add-dir <path> [其他选项]
```

#### 功能描述#

--add-dir 标志会：

```
--add-dir
```

True. 验证指定的路径是否存在为目录
True. 将该目录添加到 Claude Code 可访问的工作目录列表
True. 允许 Claude Code 读取和操作该目录中的文件

#### 使用示例#

##### 基本用法#

```
bash复制claude --add-dir ../apps
```

```
claude --add-dir ../apps
```

添加 ../apps 目录到工作目录。

```
../apps
```

##### 添加多个目录#

```
bash复制claude --add-dir ../apps ../lib
```

```
claude --add-dir ../apps ../lib
```

添加多个目录到工作目录。

##### 绝对路径#

```
bash复制claude --add-dir /absolute/path/to/directory
```

```
claude --add-dir /absolute/path/to/directory
```

使用绝对路径添加目录。

##### 结合其他标志#

```
bash复制claude --add-dir ../src --add-dir ../tests "分析整个项目"
```

```
claude --add-dir ../src --add-dir ../tests "分析整个项目"
```

添加多个目录并立即开始分析项目。

#### 使用场景#

##### 1. 多模块项目#

```
bash复制claude --add-dir ../frontend --add-dir ../backend
```

```
claude --add-dir ../frontend --add-dir ../backend
```

让 Claude Code 访问前端和后端模块。

##### 2. 共享库访问#

```
bash复制claude --add-dir ../shared-lib
```

```
claude --add-dir ../shared-lib
```

让 Claude Code 访问共享的库代码。

##### 3. 测试目录访问#

```
bash复制claude --add-dir ./tests
```

```
claude --add-dir ./tests
```

让 Claude Code 访问测试目录和文件。

##### 4. 配置文件访问#

```
bash复制claude --add-dir ../config
```

```
claude --add-dir ../config
```

让 Claude Code 访问配置文件。

#### 路径验证#

--add-dir 标志会验证每个路径：

```
--add-dir
```

- 存在性检查：确保路径存在
- 目录检查：确保路径是目录，不是文件
- 可访问性检查：确保路径可读可访问
如果验证失败，会显示错误信息。

#### 注意事项#

True. 路径存在：指定的路径必须存在，否则会报错
True. 目录类型：路径必须是目录，不能是文件
True. 权限要求：需要有读取该目录的权限
True. 相对路径：相对路径是相对于当前工作目录
True. 多个目录：可以多次使用 --add-dir 添加多个目录
True. 路径分隔符：在 Windows 系统中可以使用反斜杠 \ 或正斜杠 /

```
--add-dir
```

```
\
```

```
/
```

#### 最佳实践#

True. 使用相对路径：优先使用相对路径，提高可移植性
True. 明确添加：只添加实际需要的目录
True. 组织结构：保持项目结构清晰，便于添加目录
True. 权限管理：确保添加的目录有适当的权限
True. 文档记录：记录添加的目录及其用途

#### 常见问题#

##### Q: 可以添加文件吗？#

A: 不可以，--add-dir 只能添加目录。要访问特定文件，可以在对话中直接提及。

```
--add-dir
```

##### Q: 添加的目录会持久化吗？#

A: 不会，--add-dir 只对当前会话有效。要持久化，请在配置文件中设置。

```
--add-dir
```

##### Q: 可以添加网络路径吗？#

A: 不可以，--add-dir 只能添加本地文件系统路径。

```
--add-dir
```

##### Q: 添加目录的数量有限制吗？#

A: 理论上没有限制，但添加过多目录可能影响性能。

#### 相关标志#

- --model：设置会话模型
- --verbose：启用详细日志记录
- /help：显示可用命令列表

```
--model
```

```
--verbose
```

```
/help
```

#### 实际应用示例#

##### 多项目工作流#

```
shell复制#!/bin/bash
# 在多个项目目录中工作
projects=("project-a" "project-b" "project-c")

for project in "${projects[@]}"; do
  echo "在 $project 中工作"
  cd "/path/to/$project"
  claude --add-dir ../shared-lib "处理 $project"
done
```

```
#!/bin/bash
# 在多个项目目录中工作
projects=("project-a" "project-b" "project-c")

for project in "${projects[@]}"; do
  echo "在 $project 中工作"
  cd "/path/to/$project"
  claude --add-dir ../shared-lib "处理 $project"
done
```

##### 开发环境配置#

```
bash复制#!/bin/bash
# 配置开发环境
claude \
--add-dir ./src \
--add-dir ./tests \
--add-dir ./config \
--add-dir ../shared \
"配置开发环境"
```

```
#!/bin/bash
# 配置开发环境
claude \
--add-dir ./src \
--add-dir ./tests \
--add-dir ./config \
--add-dir ../shared \
"配置开发环境"
```

---

## 2 `--agents` - 动态定义自定义子代理

**URL**: https://claudecode.tangshuang.net/course/6.2%20%60--agents%60%20-%20%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E4%BB%A3%E7%90%86

--agents 标志允许您通过 JSON 动态定义自定义子代理，无需修改配置文件。这为临时或特定任务提供了灵活的代理配置方式。

```
--agents
```

#### 标志语法#

```
bash复制claude --agents '<json>' [其他选项]
```

```
claude --agents '<json>' [其他选项]
```

#### 功能描述#

--agents 标志接受定义一个或多个自定义子代理的 JSON 对象。每个子代理需要一个唯一的名称（作为键）和一个具有以下字段的定义对象：

```
--agents
```

```
description
```

```
prompt
```

```
tools
```

```
model
```

```
sonnet
```

```
opus
```

```
haiku
```

#### 使用示例#

##### 基本用法#

```
bash复制
claude --agents '{
  "reviewer": {
    "description": "Reviews code",
    "prompt": "You are a code reviewer"
  }
}'
```

```
claude --agents '{
  "reviewer": {
    "description": "Reviews code",
    "prompt": "You are a code reviewer"
  }
}'
```

定义一个简单的代码审查子代理。

##### 多个子代理#

```
bash复制
claude --agents '{
  "code-reviewer": {
    "description": "Expert code reviewer. Use proactively after code changes.",
    "prompt": "You are a senior code reviewer. Focus on code quality, security, and best practices.",
    "tools": ["Read", "Grep", "Glob", "Bash"],
    "model": "sonnet"
  },
  "debugger": {
    "description": "Debugging specialist for errors and test failures.",
    "prompt": "You are an expert debugger. Analyze errors, identify root causes, and provide fixes."
  }
}'
```

```
claude --agents '{
  "code-reviewer": {
    "description": "Expert code reviewer. Use proactively after code changes.",
    "prompt": "You are a senior code reviewer. Focus on code quality, security, and best practices.",
    "tools": ["Read", "Grep", "Glob", "Bash"],
    "model": "sonnet"
  },
  "debugger": {
    "description": "Debugging specialist for errors and test failures.",
    "prompt": "You are an expert debugger. Analyze errors, identify root causes, and provide fixes."
  }
}'
```

定义多个子代理，每个有不同的职责和配置。

##### 指定工具#

```
bash复制
claude --agents '{
  "tester": {
    "description": "Runs and analyzes tests",
    "prompt": "You are a testing expert. Run tests and analyze failures.",
    "tools": ["Bash", "Read", "Grep"]
  }
}'
```

```
claude --agents '{
  "tester": {
    "description": "Runs and analyzes tests",
    "prompt": "You are a testing expert. Run tests and analyze failures.",
    "tools": ["Bash", "Read", "Grep"]
  }
}'
```

定义一个只能使用特定工具的子代理。

##### 指定模型#

```
bash复制
claude --agents '{
  "analyzer": {
    "description": "Analyzes code structure",
    "prompt": "You are a code architecture expert.",
    "model": "opus"
  }
}'
```

```
claude --agents '{
  "analyzer": {
    "description": "Analyzes code structure",
    "prompt": "You are a code architecture expert.",
    "model": "opus"
  }
}'
```

定义一个使用特定模型的子代理。

#### 使用场景#

##### 1. 代码审查#

```
bash复制
claude --agents '{
  "reviewer": {
    "description": "Reviews code for quality and security",
    "prompt": "You are a security-focused code reviewer."
  }
}' "审查这段代码"
```

```
claude --agents '{
  "reviewer": {
    "description": "Reviews code for quality and security",
    "prompt": "You are a security-focused code reviewer."
  }
}' "审查这段代码"
```

使用专门的代码审查子代理。

##### 2. 调试#

```
bash复制
claude --agents '{
  "debugger": {
    "description": "Debugs errors and failures",
    "prompt": "You are an expert debugger."
  }
}' "调试这个错误"
```

```
claude --agents '{
  "debugger": {
    "description": "Debugs errors and failures",
    "prompt": "You are an expert debugger."
  }
}' "调试这个错误"
```

使用专门的调试子代理。

##### 3. 测试#

```
bash复制
claude --agents '{
  "tester": {
    "description": "Runs and analyzes tests",
    "prompt": "You are a testing expert."
  }
}' "运行测试并分析结果"
```

```
claude --agents '{
  "tester": {
    "description": "Runs and analyzes tests",
    "prompt": "You are a testing expert."
  }
}' "运行测试并分析结果"
```

使用专门的测试子代理。

##### 4. 文档生成#

```
bash复制
claude --agents '{
  "documenter": {
    "description": "Generates documentation",
    "prompt": "You are a technical writer."
  }
}' "为这个 API 生成文档"
```

```
claude --agents '{
  "documenter": {
    "description": "Generates documentation",
    "prompt": "You are a technical writer."
  }
}' "为这个 API 生成文档"
```

使用专门的文档生成子代理。

#### 子代理的优势#

##### 1. 专业化#

每个子代理可以专注于特定领域：

- 代码审查
- 调试
- 测试
- 文档生成

##### 2. 灵活性#

可以动态定义子代理，无需修改配置文件：

- 临时任务
- 特定项目
- 实验性功能

##### 3. 工具限制#

可以限制子代理使用的工具：

- 提高安全性
- 减少成本
- 优化性能

##### 4. 模型选择#

可以为每个子代理选择不同的模型：

- 使用更强大的模型处理复杂任务
- 使用更快的模型处理简单任务
- 优化成本和性能

#### 注意事项#

True. JSON 格式：确保 JSON 格式正确，使用单引号或转义双引号
True. 唯一名称：每个子代理必须有唯一的名称
True. 描述清晰：描述应该清晰明确，帮助 Claude 决定何时调用
True. 提示有效：系统提示应该清晰具体，指导子代理的行为
True. 工具兼容：指定的工具必须存在且可用
True. 模型有效：指定的模型必须受支持

#### 最佳实践#

True. 明确描述：子代理描述应该明确说明何时应该调用
True. 具体提示：系统提示应该具体指导子代理的行为和风格
True. 合理工具：只包含子代理实际需要的工具
True. 合适模型：根据任务复杂度选择合适的模型
True. 测试验证：定义子代理后，测试其行为是否符合预期
True. 文档记录：记录每个子代理的用途和配置

#### 与配置文件的对比#

```
--agents
```

#### 常见问题#

##### Q: 可以定义多少个子代理？#

A: 理论上没有限制，但过多的子代理可能影响性能和决策。

##### Q: 子代理可以嵌套吗？#

A: 不可以，子代理不能调用其他子代理。

##### Q: 子代理的提示可以多长？#

A: 提示长度有限制，建议保持简洁明确。

##### Q: 如何调试子代理？#

A: 使用 --verbose 标志可以查看子代理的调用和执行详情。

```
--verbose
```

#### 相关资源#

- 子代理文档：详细的子代理配置和使用指南
- --model：设置会话模型
- --verbose：启用详细日志记录

```
--model
```

```
--verbose
```

#### 实际应用示例#

##### 项目特定子代理#

```
bash复制#!/bin/bash
# 为项目定义特定的子代理
claude --agents '{
  "api-reviewer": {
    "description": "Reviews API endpoints for REST best practices",
    "prompt": "You are an API design expert. Focus on REST principles, error handling, and documentation."
  },
  "database-expert": {
    "description": "Optimizes database queries and schema",
    "prompt": "You are a database performance expert. Focus on query optimization and indexing."
  }
}' "审查这个 API 设计"
```

```
#!/bin/bash
# 为项目定义特定的子代理
claude --agents '{
  "api-reviewer": {
    "description": "Reviews API endpoints for REST best practices",
    "prompt": "You are an API design expert. Focus on REST principles, error handling, and documentation."
  },
  "database-expert": {
    "description": "Optimizes database queries and schema",
    "prompt": "You are a database performance expert. Focus on query optimization and indexing."
  }
}' "审查这个 API 设计"
```

##### 临时调试会话#

```
bash复制#!/bin/bash
# 创建临时调试会话
claude --agents '{
"debugger": {
"description": "Debugs the current issue",
"prompt": "You are a debugging specialist. Analyze the error, identify the root cause, and provide a fix.",
"model": "opus"
}
}' --verbose "调试这个生产问题"
```

```
#!/bin/bash
# 创建临时调试会话
claude --agents '{
"debugger": {
"description": "Debugs the current issue",
"prompt": "You are a debugging specialist. Analyze the error, identify the root cause, and provide a fix.",
"model": "opus"
}
}' --verbose "调试这个生产问题"
```

---

## 3 `--allowedTools` - 允许的工具列表

**URL**: https://claudecode.tangshuang.net/course/6.3%20%60--allowedTools%60%20-%20%E5%85%81%E8%AE%B8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8

--allowedTools 标志允许您指定应允许的工具列表，无需提示用户获得权限。这可以简化工作流程，减少权限提示的频率。

```
--allowedTools
```

#### 标志语法#

```
bash复制claude --allowedTools <tool1> <tool2> ... [其他选项]
```

```
claude --allowedTools <tool1> <tool2> ... [其他选项]
```

#### 功能描述#

--allowedTools 标志会：

```
--allowedTools
```

True. 指定允许的工具列表
True. 这些工具在使用时不会提示用户获得权限
True. 其他工具仍会按正常权限流程处理

#### 使用示例#

##### 基本用法#

```
bash复制
claude --allowedTools "Bash(git log:*)" "Bash(git diff:*)" "Read"
```

```
claude --allowedTools "Bash(git log:*)" "Bash(git diff:*)" "Read"
```

允许特定的 Bash 命令和 Read 工具。

##### 允许读取工具#

```
bash复制
claude --allowedTools "Read" "Grep" "Glob"
```

```
claude --allowedTools "Read" "Grep" "Glob"
```

允许文件读取和搜索工具。

##### 允许特定命令#

```
bash复制
claude --allowedTools "Bash(npm test:*)" "Bash(npm run build:*)"
```

```
claude --allowedTools "Bash(npm test:*)" "Bash(npm run build:*)"
```

允许特定的 npm 命令。

##### 结合其他标志#

```
bash复制
claude --allowedTools "Read" "Edit" --add-dir ./src
```

```
claude --allowedTools "Read" "Edit" --add-dir ./src
```

允许读取和编辑工具，并添加工作目录。

#### 工具格式#

工具的格式为：工具名称(模式)

```
工具名称(模式)
```

- 工具名称：如 Bash、Read、Edit 等
- 模式：可选，指定工具的使用模式或参数

```
Bash
```

```
Read
```

```
Edit
```

##### 常用工具#

```
Bash
```

```
Read
```

```
Edit
```

```
Grep
```

```
Glob
```

```
Write
```

#### 使用场景#

##### 1. 只读操作#

```
bash复制
claude --allowedTools "Read" "Grep" "Glob"
```

```
claude --allowedTools "Read" "Grep" "Glob"
```

只允许读取操作，避免意外修改。

##### 2. 安全命令#

```
bash复制
claude --allowedTools "Bash(git log:*)" "Bash(git diff:*)"
```

```
claude --allowedTools "Bash(git log:*)" "Bash(git diff:*)"
```

只允许安全的 git 只读命令。

##### 3. 测试命令#

```
bash复制
claude --allowedTools "Bash(npm test:*)" "Bash(python -m pytest:*)"
```

```
claude --allowedTools "Bash(npm test:*)" "Bash(python -m pytest:*)"
```

只允许测试相关命令。

##### 4. 构建命令#

```
bash复制
claude --allowedTools "Bash(npm run build:*)" "Bash(cmake --build:*)"
```

```
claude --allowedTools "Bash(npm run build:*)" "Bash(cmake --build:*)"
```

只允许构建相关命令。

#### 注意事项#

True. 权限覆盖：--allowedTools 会覆盖 settings.json 中的设置
True. 工具存在：指定的工具必须存在且可用
True. 模式匹配：工具模式应该准确，避免过于宽泛
True. 安全考虑：只允许真正需要的工具，避免安全风险
True. 权限提示：未在列表中的工具仍会提示用户获得权限

```
--allowedTools
```

#### 最佳实践#

True. 最小权限：只允许真正需要的工具，遵循最小权限原则
True. 明确模式：使用明确的工具模式，避免过于宽泛的匹配
True. 定期审查：定期审查允许的工具列表，移除不需要的
True. 文档记录：记录允许的工具及其原因
True. 测试验证：测试允许的工具是否按预期工作

#### 与 --disallowedTools 的对比#

```
--disallowedTools
```

```
--allowedTools
```

```
--disallowedTools
```

#### 常见问题#

##### Q: 可以同时使用 --allowedTools 和 --disallowedTools 吗？#

```
--allowedTools
```

```
--disallowedTools
```

A: 可以，--allowedTools 优先级更高，会覆盖 --disallowedTools。

```
--allowedTools
```

```
--disallowedTools
```

##### Q: 工具模式支持通配符吗？#

A: 是的，支持 * 通配符进行模式匹配。

```
*
```

##### Q: 如何知道可用的工具列表？#

A: 可以使用 /tool list 命令查看所有可用工具。

```
/tool list
```

##### Q: 允许的工具会持久化吗？#

A: 不会，--allowedTools 只对当前会话有效。要持久化，请在 settings.json 中设置。

```
--allowedTools
```

#### 相关标志#

- --disallowedTools：禁止的工具列表
- --dangerously-skip-permissions：跳过所有权限提示
- --permission-mode：指定权限模式

```
--disallowedTools
```

```
--dangerously-skip-permissions
```

```
--permission-mode
```

#### 实际应用示例#

##### CI/CD 环境#

```
bash复制
#!/bin/bash
# 在 CI/CD 中只允许安全操作
claude \
  --allowedTools \
    "Bash(git log:*)" \
    "Bash(git diff:*)" \
    "Read" \
    "Grep" \
  "审查代码变更"
```

```
#!/bin/bash
# 在 CI/CD 中只允许安全操作
claude \
  --allowedTools \
    "Bash(git log:*)" \
    "Bash(git diff:*)" \
    "Read" \
    "Grep" \
  "审查代码变更"
```

##### 只读分析#

```
bash复制
#!/bin/bash
# 只读分析，避免意外修改
claude \
  --allowedTools "Read" "Grep" "Glob" \
  "分析这个项目的结构"
```

```
#!/bin/bash
# 只读分析，避免意外修改
claude \
  --allowedTools "Read" "Grep" "Glob" \
  "分析这个项目的结构"
```

---

## 4 `--disallowedTools` - 禁止的工具列表

**URL**: https://claudecode.tangshuang.net/course/6.4%20%60--disallowedTools%60%20-%20%E7%A6%81%E6%AD%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8

--disallowedTools 标志允许您指定应禁止的工具列表，无需提示用户获得权限。这可以防止 Claude Code 执行危险或不需要的操作。

```
--disallowedTools
```

#### 标志语法#

```
bash复制claude --disallowedTools <tool1> <tool2> ... [其他选项]
```

```
claude --disallowedTools <tool1> <tool2> ... [其他选项]
```

#### 功能描述#

--disallowedTools 标志会：

```
--disallowedTools
```

True. 指定禁止的工具列表
True. 这些工具在使用时会被拒绝，无需提示用户
True. 其他工具仍可正常使用

#### 使用示例#

##### 基本用法#

```
bash复制claude --disallowedTools "Bash(rm:*)" "Bash(rmdir:*)"
```

```
claude --disallowedTools "Bash(rm:*)" "Bash(rmdir:*)"
```

禁止删除文件和目录的命令。

##### 禁止写入操作#

```
bash复制claude --disallowedTools "Edit" "Write"
```

```
claude --disallowedTools "Edit" "Write"
```

禁止文件写入和编辑操作。

##### 禁止危险命令#

```
bash复制claude --disallowedTools "Bash(rm:*)" "Bash(dd:*)" "Bash(mkfs:*)"
```

```
claude --disallowedTools "Bash(rm:*)" "Bash(dd:*)" "Bash(mkfs:*)"
```

禁止危险的系统命令。

##### 结合其他标志#

```
bash复制claude --disallowedTools "Bash(git push:*)" --add-dir ./src
```

```
claude --disallowedTools "Bash(git push:*)" --add-dir ./src
```

禁止 git push 操作，同时添加工作目录。

#### 使用场景#

##### 1. 保护重要文件#

```
bash复制claude --disallowedTools "Edit" "Write" "Bash(rm:*)"
```

```
claude --disallowedTools "Edit" "Write" "Bash(rm:*)"
```

防止意外修改或删除重要文件。

##### 2. 只读分析#

```
bash复制claude --disallowedTools "Edit" "Write" "Bash(*:*)"
```

```
claude --disallowedTools "Edit" "Write" "Bash(*:*)"
```

只允许读取操作，禁止任何修改。

##### 3. 禁止特定操作#

```
bash复制claude --disallowedTools "Bash(git push:*)" "Bash(git commit:*)"
```

```
claude --disallowedTools "Bash(git push:*)" "Bash(git commit:*)"
```

禁止 git 提交和推送操作。

##### 4. 安全环境#

```
bash复制claude --disallowedTools "Bash(sudo:*)" "Bash(chown:*)" "Bash(chmod:*)"
```

```
claude --disallowedTools "Bash(sudo:*)" "Bash(chown:*)" "Bash(chmod:*)"
```

禁止需要提升权限的操作。

---

## 5 `--print`, `-p` - 打印响应而不进入交互模式

**URL**: https://claudecode.tangshuang.net/course/6.5%20%60--print%60%2C%20%60-p%60%20-%20%E6%89%93%E5%8D%B0%E5%93%8D%E5%BA%94%E8%80%8C%E4%B8%8D%E8%BF%9B%E5%85%A5%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F

--print 或 -p 标志允许 Claude Code 打印响应而不进入交互模式。这是程序化使用 Claude Code 的主要方式。

```
--print
```

```
-p
```

#### 标志语法#

```
bash复制claude -p "query" [其他选项]
```

```
claude -p "query" [其他选项]
```

```
bash复制claude --print "query" [其他选项]
```

```
claude --print "query" [其他选项]
```

#### 功能描述#

-p（--print）标志会：

```
-p
```

```
--print
```

#### 使用示例#

##### 基本用法#

```
bash复制claude -p "解释这个函数"
```

```
claude -p "解释这个函数"
```

执行查询，打印结果，然后退出。

##### 代码生成#

```
bash复制claude -p "创建一个快速排序算法"
```

```
claude -p "创建一个快速排序算法"
```

生成快速排序算法代码，打印结果，然后退出。

##### 结合输出格式#

```
bash复制claude -p "分析这个项目" --output-format json
```

```
claude -p "分析这个项目" --output-format json
```

以 JSON 格式输出分析结果。

##### 处理管道内容#

```
bash复制cat logs.txt | claude -p "解释这些日志"
```

```
cat logs.txt | claude -p "解释这些日志"
```

将日志文件内容通过管道传递给 Claude Code，请求解释，然后退出。

#### 输出格式#

-p 标志支持多种输出格式：

```
-p
```

##### text 格式（默认）#

```
bash复制claude -p "查询内容"
```

```
claude -p "查询内容"
```

输出纯文本格式的响应。

##### json 格式#

```
bash复制claude -p "查询内容" --output-format json
```

```
claude -p "查询内容" --output-format json
```

输出 JSON 格式的响应，便于程序解析。

##### stream-json 格式#

```
bash复制claude -p "查询内容" --output-format stream-json
```

```
claude -p "查询内容" --output-format stream-json
```

输出流式 JSON，可以实时处理响应。

#### 使用场景#

##### 1. 脚本自动化#

```
bash复制#!/bin/bash
# 获取代码审查结果
result=$(claude -p "审查 src/main.js")
echo "$result"
```

```
#!/bin/bash
# 获取代码审查结果
result=$(claude -p "审查 src/main.js")
echo "$result"
```

在脚本中使用 Claude Code 进行代码审查。

##### 2. CI/CD 集成#

```
yaml复制# GitHub Actions 示例
- name: Code Review
  run: |
    review=$(claude -p "审查最近的代码变更")
    echo "$review"
```

```
# GitHub Actions 示例
- name: Code Review
  run: |
    review=$(claude -p "审查最近的代码变更")
    echo "$review"
```

在 CI/CD 流程中自动进行代码审查。

##### 3. 批处理#

```
bash复制for file in *.js; do
  claude -p "优化 $file" > "${file%.js}.optimized.js"
done
```

```
for file in *.js; do
  claude -p "优化 $file" > "${file%.js}.optimized.js"
done
```

批量处理多个文件。

##### 4. 数据处理#

```
bash复制cat data.json | claude -p "提取关键信息" --output-format json
```

```
cat data.json | claude -p "提取关键信息" --output-format json
```

处理 JSON 数据并提取关键信息。

#### 高级用法#

##### 包含部分流事件#

```
bash复制claude -p "复杂任务" --output-format stream-json --include-partial-messages
```

```
claude -p "复杂任务" --output-format stream-json --include-partial-messages
```

在输出中包含部分流事件，用于调试和实时处理。

##### 限制代理轮数#

```
bash复制claude -p --max-turns 3 "执行任务"
```

```
claude -p --max-turns 3 "执行任务"
```

限制非交互模式中的代理轮数，控制执行时间。

##### 指定权限提示工具#

```
bash复制claude -p --permission-prompt-tool mcp_auth_tool "需要权限的任务"
```

```
claude -p --permission-prompt-tool mcp_auth_tool "需要权限的任务"
```

指定 MCP 工具以在非交互模式中处理权限提示。

#### 注意事项#

True. 非交互模式：-p 标志不会进入交互模式，执行完查询后立即退出
True. 输出格式：建议使用 --output-format json 便于脚本解析
True. 错误处理：脚本中应该处理可能的错误和异常
True. 资源限制：长时间运行的任务可能需要调整超时设置
True. API 限制：频繁调用可能触发 API 速率限制

```
-p
```

```
--output-format json
```

#### 与交互模式的对比#

#### 最佳实践#

True. 使用 JSON 输出：便于脚本解析和处理
True. 错误处理：在脚本中添加错误处理逻辑
True. 超时设置：为长时间运行的任务设置合理的超时
True. 结果验证：验证返回的结果是否符合预期
True. 日志记录：记录查询和结果，便于调试和审计

#### 相关命令#

- claude：启动交互式 REPL
- claude "query"：使用初始提示启动 REPL
- --output-format：指定输出格式
- --input-format：指定输入格式

```
claude
```

```
claude "query"
```

```
--output-format
```

```
--input-format
```

#### SDK 文档#

有关程序化使用 Claude Code 的更多详情，请参阅 SDK 文档。

---

## 6 `--system-prompt` - 替换整个系统提示

**URL**: https://claudecode.tangshuang.net/course/6.6%20%60--system-prompt%60%20-%20%E6%9B%BF%E6%8D%A2%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA

--system-prompt 标志允许您用自定义文本替换整个系统提示。这为您提供了完全控制 Claude 行为的能力。

```
--system-prompt
```

#### 标志语法#

```
bash复制claude --system-prompt "<prompt>" [其他选项]
```

```
claude --system-prompt "<prompt>" [其他选项]
```

#### 功能描述#

--system-prompt 标志会：

```
--system-prompt
```

True. 用您提供的自定义文本替换整个默认系统提示
True. 完全控制 Claude 的行为和指令
True. 适用于交互模式和打印模式

#### 使用示例#

##### 基本用法#

```
bash复制
claude --system-prompt "You are a Python expert"
```

```
claude --system-prompt "You are a Python expert"
```

将 Claude 设置为 Python 专家。

##### 代码风格指定#

```
bash复制
claude --system-prompt "You only write type-annotated Python code"
```

```
claude --system-prompt "You only write type-annotated Python code"
```

指定只编写类型注解的 Python 代码。

##### 领域专家#

```
bash复制
claude --system-prompt "You are a machine learning expert specializing in PyTorch"
```

```
claude --system-prompt "You are a machine learning expert specializing in PyTorch"
```

将 Claude 设置为 PyTorch 机器学习专家。

##### 结合其他标志#

```
bash复制
claude --system-prompt "You are a security-focused code reviewer" --model opus
```

```
claude --system-prompt "You are a security-focused code reviewer" --model opus
```

使用指定的系统提示和模型。

#### 使用场景#

##### 1. 特定编程语言#

```
bash复制
claude --system-prompt "You are a Rust expert who follows the Rust API guidelines"
```

```
claude --system-prompt "You are a Rust expert who follows the Rust API guidelines"
```

专注于 Rust 编程。

##### 2. 特定框架#

```
bash复制
claude --system-prompt "You are a React expert who uses functional components and hooks"
```

```
claude --system-prompt "You are a React expert who uses functional components and hooks"
```

专注于 React 开发。

##### 3. 特定领域#

```
bash复制
claude --system-prompt "You are a DevOps expert specializing in Kubernetes"
```

```
claude --system-prompt "You are a DevOps expert specializing in Kubernetes"
```

专注于 DevOps 和 Kubernetes。

##### 4. 特定风格#

```
bash复制
claude --system-prompt "You write clean, well-documented code with comprehensive tests"
```

```
claude --system-prompt "You write clean, well-documented code with comprehensive tests"
```

强调代码质量和文档。

#### 系统提示的影响#

##### 完全替换#

--system-prompt 会完全替换默认系统提示，这意味着：

```
--system-prompt
```

- 删除所有默认 Claude Code 指令
- 为您提供一个空白的开始
- 完全由您控制 Claude 的行为

##### 适用模式#

--system-prompt 在以下模式中有效：

```
--system-prompt
```

- 交互模式：claude --system-prompt "..."
- 打印模式：claude -p --system-prompt "..."
- 继续模式：claude -c --system-prompt "..."

```
claude --system-prompt "..."
```

```
claude -p --system-prompt "..."
```

```
claude -c --system-prompt "..."
```

#### 注意事项#

True. 与 --system-prompt-file 互斥：不能同时使用两个标志
True. 完全替换：会删除所有默认指令，确保您的提示足够完整
True. 提示长度：系统提示有长度限制，保持简洁明确
True. 行为改变：会显著改变 Claude 的行为，确保这是您想要的
True. 测试验证：使用前测试自定义提示，确保行为符合预期

```
--system-prompt-file
```

#### 与其他系统提示标志的对比#

```
--system-prompt
```

```
--system-prompt-file
```

```
--append-system-prompt
```

#### 最佳实践#

True. 明确具体：系统提示应该明确具体，指导 Claude 的行为
True. 保持简洁：避免过长的提示，保持简洁明确
True. 测试验证：使用前测试自定义提示，确保行为符合预期
True. 文档记录：记录自定义提示及其用途
True. 版本控制：将重要的自定义提示放入版本控制

#### 常见问题#

##### Q: 可以在打印模式中使用吗？#

A: 是的，--system-prompt 在交互模式和打印模式中都有效。

```
--system-prompt
```

##### Q: 会影响会话历史吗？#

A: 不会，系统提示只影响 Claude 的行为，不影响会话历史。

##### Q: 可以动态更改吗？#

A: 不可以，系统提示在会话开始时设置，会话期间不能更改。

##### Q: 与 --append-system-prompt 有什么区别？#

```
--append-system-prompt
```

A: --system-prompt 完全替换默认提示，而 --append-system-prompt 附加到默认提示。

```
--system-prompt
```

```
--append-system-prompt
```

#### 相关标志#

- --system-prompt-file：从文件加载系统提示
- --append-system-prompt：附加到默认系统提示
- --model：设置会话模型

```
--system-prompt-file
```

```
--append-system-prompt
```

```
--model
```

#### 实际应用示例#

##### 项目特定提示#

```
bash复制
#!/bin/bash
# 为项目定义特定的系统提示
PROJECT_PROMPT="You are a developer working on the XYZ project. Follow our coding standards: use TypeScript, include JSDoc comments, and write unit tests for all functions."

claude --system-prompt "$PROJECT_PROMPT" "实现这个功能"
```

```
#!/bin/bash
# 为项目定义特定的系统提示
PROJECT_PROMPT="You are a developer working on the XYZ project. Follow our coding standards: use TypeScript, include JSDoc comments, and write unit tests for all functions."

claude --system-prompt "$PROJECT_PROMPT" "实现这个功能"
```

##### 团队标准提示#

```
bash复制
#!/bin/bash
# 使用团队标准的系统提示
TEAM_PROMPT=$(cat .claude/team-prompt.txt)
claude --system-prompt "$TEAM_PROMPT" "审查这个 PR"
```

```
#!/bin/bash
# 使用团队标准的系统提示
TEAM_PROMPT=$(cat .claude/team-prompt.txt)
claude --system-prompt "$TEAM_PROMPT" "审查这个 PR"
```

---

## 7 --system-prompt-file - 从文件加载系统提示

**URL**: https://claudecode.tangshuang.net/course/6.7%20--system-prompt-file%20-%20%E4%BB%8E%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA

#### 概述#

--system-prompt-file 标志允许您从文件中加载自定义的系统提示，而不是直接在命令行中输入。这对于复杂的系统提示、需要版本控制的提示，或者需要在不同项目间共享的提示特别有用。

```
--system-prompt-file
```

#### 基本语法#

```
bash复制claude --system-prompt-file <文件路径>
```

```
claude --system-prompt-file <文件路径>
```

#### 使用场景#

##### 1. 复杂系统提示#

当您的系统提示非常长或包含多个部分时，使用文件可以更好地组织内容：

```
bash复制
# 创建系统提示文件
cat > python-expert.txt << 'EOF'
你是一位资深的 Python 开发专家，具有以下专长：
- Python 3.8+ 的所有新特性
- 异步编程和并发
- 数据科学和机器学习
- Web 开发（Django, Flask, FastAPI）
- 性能优化和调试

在回答问题时，请：
EOF

# 使用文件加载系统提示
claude --system-prompt-file python-expert.txt
```

```
# 创建系统提示文件
cat > python-expert.txt << 'EOF'
你是一位资深的 Python 开发专家，具有以下专长：
- Python 3.8+ 的所有新特性
- 异步编程和并发
- 数据科学和机器学习
- Web 开发（Django, Flask, FastAPI）
- 性能优化和调试

在回答问题时，请：
EOF

# 使用文件加载系统提示
claude --system-prompt-file python-expert.txt
```

##### 2. 项目特定的系统提示#

为不同的项目创建专门的系统提示文件：

```
bash复制
# 项目 A 的系统提示
cat > project-a-prompt.txt << 'EOF'
你正在为 Project A 工作，这是一个金融科技应用。
技术栈：Python 3.9, Django 4.0, PostgreSQL, Redis
关键规则：
- 所有金融计算必须使用 decimal.Decimal
- 敏感数据必须加密存储
- 所有 API 端点需要认证
- 日志记录必须包含审计信息
EOF

# 项目 B 的系统提示
cat > project-b-prompt.txt << 'EOF'
你正在为 Project B 工作，这是一个电商平台。
技术栈：Node.js 18, Express, MongoDB, Elasticsearch
关键规则：
- 使用 TypeScript 进行类型安全
- 所有数据库操作使用事务
- 实现缓存策略
- 监控和追踪所有用户行为
EOF

# 根据项目使用不同的系统提示
cd project-a
claude --system-prompt-file project-a-prompt.txt
cd project-b
claude --system-prompt-file project-b-prompt.txt
```

```
# 项目 A 的系统提示
cat > project-a-prompt.txt << 'EOF'
你正在为 Project A 工作，这是一个金融科技应用。
技术栈：Python 3.9, Django 4.0, PostgreSQL, Redis
关键规则：
- 所有金融计算必须使用 decimal.Decimal
- 敏感数据必须加密存储
- 所有 API 端点需要认证
- 日志记录必须包含审计信息
EOF

# 项目 B 的系统提示
cat > project-b-prompt.txt << 'EOF'
你正在为 Project B 工作，这是一个电商平台。
技术栈：Node.js 18, Express, MongoDB, Elasticsearch
关键规则：
- 使用 TypeScript 进行类型安全
- 所有数据库操作使用事务
- 实现缓存策略
- 监控和追踪所有用户行为
EOF

# 根据项目使用不同的系统提示
cd project-a
claude --system-prompt-file project-a-prompt.txt
cd project-b
claude --system-prompt-file project-b-prompt.txt
```

##### 3. 版本控制系统提示#

将系统提示文件纳入版本控制，便于团队协作和历史追溯：

```
bash复制
# 项目结构
my-project/
├── prompts/
│   ├── system-prompt-v1.txt
│   ├── system-prompt-v2.txt
│   └── system-prompt.txt -> system-prompt-v2.txt
└── src/

# 使用当前版本的系统提示
claude --system-prompt-file prompts/system-prompt.txt
```

```
# 项目结构
my-project/
├── prompts/
│   ├── system-prompt-v1.txt
│   ├── system-prompt-v2.txt
│   └── system-prompt.txt -> system-prompt-v2.txt
└── src/

# 使用当前版本的系统提示
claude --system-prompt-file prompts/system-prompt.txt
```

##### 4. 多语言系统提示#

为不同语言创建专门的系统提示文件：

```
bash复制
# Python 专家提示
cat > python-expert.txt << 'EOF'
你是一位 Python 专家，精通：
- Python 3.8+ 的所有特性
- 常用框架：Django, Flask, FastAPI
- 数据科学：NumPy, Pandas, Matplotlib
- 机器学习：scikit-learn, TensorFlow, PyTorch
EOF

# JavaScript 专家提示
cat > javascript-expert.txt << 'EOF'
你是一位 JavaScript 专家，精通：
- ES6+ 的所有特性
- 前端框架：React, Vue, Angular
- 后端：Node.js, Express, NestJS
- 工具链：Webpack, Vite, ESLint
EOF

# 根据需要选择
claude --system-prompt-file python-expert.txt
claude --system-prompt-file javascript-expert.txt
```

```
# Python 专家提示
cat > python-expert.txt << 'EOF'
你是一位 Python 专家，精通：
- Python 3.8+ 的所有特性
- 常用框架：Django, Flask, FastAPI
- 数据科学：NumPy, Pandas, Matplotlib
- 机器学习：scikit-learn, TensorFlow, PyTorch
EOF

# JavaScript 专家提示
cat > javascript-expert.txt << 'EOF'
你是一位 JavaScript 专家，精通：
- ES6+ 的所有特性
- 前端框架：React, Vue, Angular
- 后端：Node.js, Express, NestJS
- 工具链：Webpack, Vite, ESLint
EOF

# 根据需要选择
claude --system-prompt-file python-expert.txt
claude --system-prompt-file javascript-expert.txt
```

#### 高级用法#

##### 1. 与其他标志组合使用#

```
bash复制
# 使用文件加载系统提示，并设置模型
claude --system-prompt-file security-reviewer.txt --model opus

# 使用文件加载系统提示，并限制工具
claude --system-prompt-file code-analyzer.txt --allowedTools "Read" "Grep"

# 使用文件加载系统提示，并指定输出格式
claude --system-prompt-file api-docs.txt --output-format json
```

```
# 使用文件加载系统提示，并设置模型
claude --system-prompt-file security-reviewer.txt --model opus

# 使用文件加载系统提示，并限制工具
claude --system-prompt-file code-analyzer.txt --allowedTools "Read" "Grep"

# 使用文件加载系统提示，并指定输出格式
claude --system-prompt-file api-docs.txt --output-format json
```

##### 2. 管道输入配合使用#

```
bash复制
# 从文件加载系统提示，并处理管道输入
cat code.py | claude --system-prompt-file code-reviewer.txt -p "审查这段代码"

# 从文件加载系统提示，并使用 SDK 查询
claude --system-prompt-file data-scientist.txt -p "分析这个数据集"
```

```
# 从文件加载系统提示，并处理管道输入
cat code.py | claude --system-prompt-file code-reviewer.txt -p "审查这段代码"

# 从文件加载系统提示，并使用 SDK 查询
claude --system-prompt-file data-scientist.txt -p "分析这个数据集"
```

##### 3. 环境变量指定文件路径#

```
bash复制
# 设置环境变量
export SYSTEM_PROMPT_FILE=~/.claude/prompts/default-prompt.txt

# 使用环境变量
claude --system-prompt-file "$SYSTEM_PROMPT_FILE"
```

```
# 设置环境变量
export SYSTEM_PROMPT_FILE=~/.claude/prompts/default-prompt.txt

# 使用环境变量
claude --system-prompt-file "$SYSTEM_PROMPT_FILE"
```

##### 4. 动态生成系统提示文件#

```
bash复制
# 根据当前目录动态生成系统提示
cat > dynamic-prompt.txt << EOF
你正在 $(basename $(pwd)) 项目中工作。
项目信息：
$(cat README.md 2>/dev/null | head -20)
技术栈：
$(cat package.json 2>/dev/null | grep -A 20 "dependencies" || cat requirements.txt 2>/dev/null || echo "未检测到依赖文件")
EOF

# 使用动态生成的系统提示
claude --system-prompt-file dynamic-prompt.txt
```

```
# 根据当前目录动态生成系统提示
cat > dynamic-prompt.txt << EOF
你正在 $(basename $(pwd)) 项目中工作。
项目信息：
$(cat README.md 2>/dev/null | head -20)
技术栈：
$(cat package.json 2>/dev/null | grep -A 20 "dependencies" || cat requirements.txt 2>/dev/null || echo "未检测到依赖文件")
EOF

# 使用动态生成的系统提示
claude --system-prompt-file dynamic-prompt.txt
```

#### 文件格式建议#

##### 1. 结构化提示#

```
text复制# 角色定义
你是一位 [角色名称]

# 专业领域
- 领域 1
- 领域 2
- 领域 3

# 工作原则

# 输出要求
- 要求 1
- 要求 2
- 要求 3

# 禁止事项
- 禁止 1
- 禁止 2

### 2. 包含示例的提示

你是一位代码审查专家。
审查标准：

输出格式：

## 审查结果
### 优点
- 优点 1
- 优点 2
### 问题
- 问题 1
- 问题 2
### 建议
- 建议 1
- 建议 2
示例：
[提供 1-2 个具体的审查示例]
```

```
# 角色定义
你是一位 [角色名称]

# 专业领域
- 领域 1
- 领域 2
- 领域 3

# 工作原则

# 输出要求
- 要求 1
- 要求 2
- 要求 3

# 禁止事项
- 禁止 1
- 禁止 2

### 2. 包含示例的提示

你是一位代码审查专家。
审查标准：

输出格式：

## 审查结果
### 优点
- 优点 1
- 优点 2
### 问题
- 问题 1
- 问题 2
### 建议
- 建议 1
- 建议 2
示例：
[提供 1-2 个具体的审查示例]
```

#### 最佳实践#

##### 1. 文件组织#

### 推荐的目录结构

```
text复制~/.claude/
├── prompts/
│   ├── general/
│   │   ├── code-assistant.txt
│   │   ├── code-reviewer.txt
│   │   └── debugger.txt
│   ├── languages/
│   │   ├── python-expert.txt
│   │   ├── javascript-expert.txt
│   │   └── go-expert.txt
│   └── domains/
│       ├── web-dev.txt
│       ├── data-science.txt
│       └── devops.txt
```

```
~/.claude/
├── prompts/
│   ├── general/
│   │   ├── code-assistant.txt
│   │   ├── code-reviewer.txt
│   │   └── debugger.txt
│   ├── languages/
│   │   ├── python-expert.txt
│   │   ├── javascript-expert.txt
│   │   └── go-expert.txt
│   └── domains/
│       ├── web-dev.txt
│       ├── data-science.txt
│       └── devops.txt
```

##### 2. 文件命名约定#

- 使用描述性名称：python-expert.txt 而不是 prompt1.txt
- 包含版本信息：code-reviewer-v2.txt
- 使用小写和连字符：security-auditor.txt 而不是 SecurityAuditor.txt

```
python-expert.txt
```

```
prompt1.txt
```

```
code-reviewer-v2.txt
```

```
security-auditor.txt
```

```
SecurityAuditor.txt
```

##### 3. 文档化提示#

在每个提示文件的开头添加注释：

```
text复制# 系统提示：Python 专家
# 版本：1.2
# 创建日期：2024-01-15
# 最后更新：2024-02-20
# 作者：团队 A
# 用途：为 Python 开发提供专家级建议

你是一位资深的 Python 开发专家...
```

```
# 系统提示：Python 专家
# 版本：1.2
# 创建日期：2024-01-15
# 最后更新：2024-02-20
# 作者：团队 A
# 用途：为 Python 开发提供专家级建议

你是一位资深的 Python 开发专家...
```

##### 4. 版本控制#

```
bash复制# 使用 Git 管理提示文件
cd ~/.claude/prompts
git init
git add .
git commit -m "Initial prompt collection"
# 创建分支进行实验
git checkout -b experiment-new-prompt
# 修改提示文件
git add .
git commit -m "Try new prompt structure"
```

```
# 使用 Git 管理提示文件
cd ~/.claude/prompts
git init
git add .
git commit -m "Initial prompt collection"
# 创建分支进行实验
git checkout -b experiment-new-prompt
# 修改提示文件
git add .
git commit -m "Try new prompt structure"
```

#### 常见问题#

##### Q1: 系统提示文件支持哪些格式？#

A: 支持纯文本格式（.txt, .md）。建议使用 .txt 或 .md 格式，便于编辑和版本控制。

##### Q2: 文件路径可以是相对路径吗？#

A: 可以。支持相对路径和绝对路径。相对路径是相对于当前工作目录。

##### Q3: 文件不存在会发生什么？#

A: Claude 会报错并提示文件不存在。请确保文件路径正确。

##### Q4: 可以使用环境变量吗？#

A: 可以。在命令行中使用环境变量：claude --system-prompt-file "$MY_PROMPT_FILE"

```
claude --system-prompt-file "$MY_PROMPT_FILE"
```

##### Q5: 与 --system-prompt 有什么区别？#

A: --system-prompt 直接在命令行中指定提示，适合简单的提示；--system-prompt-file 从文件加载，适合复杂、需要版本控制或共享的提示。

```
--system-prompt
```

```
--system-prompt-file
```

#### 示例：完整的提示文件#

```
text复制# 系统提示：全栈开发专家
# 版本：2.0
# 最后更新：2024-02-20

你是一位全栈开发专家，具有以下专长：

## 前端开发
- React, Vue, Angular
- TypeScript, JavaScript
- CSS, Sass, Tailwind CSS
- Webpack, Vite
- 测试：Jest, Cypress

## 后端开发
- Node.js, Python, Go
- RESTful API, GraphQL
- 数据库：PostgreSQL, MongoDB, Redis
- 认证与授权
- 微服务架构

## DevOps
- Docker, Kubernetes
- CI/CD：GitHub Actions, GitLab CI
- 云平台：AWS, GCP, Azure
- 监控：Prometheus, Grafana

## 工作原则

1. **代码质量优先**
   - 遵循 SOLID 原则
   - 编写可测试的代码
   - 注重性能和安全性

2. **最佳实践**
   - 使用设计模式
   - 编写清晰的文档
   - 实施代码审查

3. **团队协作**
   - 遵循项目规范
   - 提供详细的代码注释
   - 分享知识和经验

## 输出要求

- 提供完整的代码示例
- 解释关键概念和原理
- 指出潜在的问题和风险
- 建议相关的工具和资源
- 考虑可维护性和可扩展性

## 禁止事项

- 不要提供不安全的代码
- 不要忽略性能问题
- 不要跳过错误处理
- 不要使用过时的技术
```

```
# 系统提示：全栈开发专家
# 版本：2.0
# 最后更新：2024-02-20

你是一位全栈开发专家，具有以下专长：

## 前端开发
- React, Vue, Angular
- TypeScript, JavaScript
- CSS, Sass, Tailwind CSS
- Webpack, Vite
- 测试：Jest, Cypress

## 后端开发
- Node.js, Python, Go
- RESTful API, GraphQL
- 数据库：PostgreSQL, MongoDB, Redis
- 认证与授权
- 微服务架构

## DevOps
- Docker, Kubernetes
- CI/CD：GitHub Actions, GitLab CI
- 云平台：AWS, GCP, Azure
- 监控：Prometheus, Grafana

## 工作原则

1. **代码质量优先**
   - 遵循 SOLID 原则
   - 编写可测试的代码
   - 注重性能和安全性

2. **最佳实践**
   - 使用设计模式
   - 编写清晰的文档
   - 实施代码审查

3. **团队协作**
   - 遵循项目规范
   - 提供详细的代码注释
   - 分享知识和经验

## 输出要求

- 提供完整的代码示例
- 解释关键概念和原理
- 指出潜在的问题和风险
- 建议相关的工具和资源
- 考虑可维护性和可扩展性

## 禁止事项

- 不要提供不安全的代码
- 不要忽略性能问题
- 不要跳过错误处理
- 不要使用过时的技术
```

#### 总结#

--system-prompt-file 标志提供了一种灵活、可维护的方式来管理复杂的系统提示。通过使用文件，您可以：

```
--system-prompt-file
```

- 更好地组织和版本控制提示
- 在不同项目和团队间共享提示
- 创建特定领域的专家提示
- 动态生成和调整提示

建议为常用的场景创建专门的提示文件，并将其纳入版本控制系统，以提高工作效率和团队协作效果。

---

## 8 --append-system-prompt - 附加到默认系统提示

**URL**: https://claudecode.tangshuang.net/course/6.8%20--append-system-prompt%20-%20%E9%99%84%E5%8A%A0%E5%88%B0%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA

#### 概述#

--append-system-prompt 标志允许您将自定义内容附加到 Claude 的默认系统提示之后，而不是完全替换它。这种方式可以保留 Claude 的核心行为和能力，同时添加您特定的指导或约束。

```
--append-system-prompt
```

#### 基本语法#

```
bash复制claude --append-system-prompt "附加的提示内容"
```

```
claude --append-system-prompt "附加的提示内容"
```

#### 与 --system-prompt 的区别#

```
--system-prompt
```

```
--append-system-prompt
```

#### 使用场景#

##### 1. 添加项目特定规则#

保留 Claude 的核心能力，同时添加项目特定的约束：

```
bash复制claude --append-system-prompt "在这个项目中，所有 API 端点必须包含认证中间件，数据库操作必须使用事务，敏感数据必须加密存储。"
```

```
claude --append-system-prompt "在这个项目中，所有 API 端点必须包含认证中间件，数据库操作必须使用事务，敏感数据必须加密存储。"
```

##### 2. 指定输出格式#

要求 Claude 以特定格式输出，而不影响其核心推理能力：

```
bash复制claude --append-system-prompt "所有代码示例必须包含类型注解和文档字符串。输出格式必须使用 Markdown 代码块。"
```

```
claude --append-system-prompt "所有代码示例必须包含类型注解和文档字符串。输出格式必须使用 Markdown 代码块。"
```

##### 3. 添加领域特定知识#

在 Claude 的通用知识基础上，添加特定领域的指导：

```
bash复制claude --append-system-prompt "你正在为医疗设备软件工作。所有代码必须遵循 IEC 62304 标准，并包含详细的单元测试。"
```

```
claude --append-system-prompt "你正在为医疗设备软件工作。所有代码必须遵循 IEC 62304 标准，并包含详细的单元测试。"
```

##### 4. 设置语言偏好#

指定回答的语言或术语偏好：

```
bash复制claude --append-system-prompt "请使用简体中文回答所有问题。技术术语保留英文原文。"
```

```
claude --append-system-prompt "请使用简体中文回答所有问题。技术术语保留英文原文。"
```

##### 5. 添加安全约束#

在保留 Claude 安全能力的基础上，添加额外的安全要求：

```
bash复制claude --append-system-prompt "对于任何涉及用户数据的操作，必须先进行数据脱敏处理。所有密码必须使用 bcrypt 哈希。"
```

```
claude --append-system-prompt "对于任何涉及用户数据的操作，必须先进行数据脱敏处理。所有密码必须使用 bcrypt 哈希。"
```

#### 高级用法#

##### 1. 多行提示#

使用引号包裹多行提示：

```
bash复制claude --append-system-prompt "
在这个项目中：

"
```

```
claude --append-system-prompt "
在这个项目中：

"
```

##### 2. 与其他标志组合#

```
bash复制# 附加系统提示并设置模型
claude --append-system-prompt "使用 TypeScript 严格模式" --model opus

# 附加系统提示并限制工具
claude --append-system-prompt "只使用 Read 和 Grep 工具" --allowedTools "Read" "Grep"

# 附加系统提示并指定输出格式
claude --append-system-prompt "输出 JSON 格式" --output-format json
```

```
# 附加系统提示并设置模型
claude --append-system-prompt "使用 TypeScript 严格模式" --model opus

# 附加系统提示并限制工具
claude --append-system-prompt "只使用 Read 和 Grep 工具" --allowedTools "Read" "Grep"

# 附加系统提示并指定输出格式
claude --append-system-prompt "输出 JSON 格式" --output-format json
```

##### 3. 管道输入配合使用#

```
bash复制# 附加系统提示并处理管道输入
cat code.py | claude --append-system-prompt "使用 PEP 8 风格指南" -p "审查这段代码"

# 附加系统提示并使用 SDK 查询
claude --append-system-prompt "关注性能优化" -p "优化这个函数"
```

```
# 附加系统提示并处理管道输入
cat code.py | claude --append-system-prompt "使用 PEP 8 风格指南" -p "审查这段代码"

# 附加系统提示并使用 SDK 查询
claude --append-system-prompt "关注性能优化" -p "优化这个函数"
```

##### 4. 环境变量#

```
bash复制# 设置环境变量
export APPEND_PROMPT="使用公司内部代码规范"

# 使用环境变量
claude --append-system-prompt "$APPEND_PROMPT"
```

```
# 设置环境变量
export APPEND_PROMPT="使用公司内部代码规范"

# 使用环境变量
claude --append-system-prompt "$APPEND_PROMPT"
```

#### 实际应用示例#

##### 示例 1: Web 开发项目#

```
bash复制claude --append-system-prompt "
项目技术栈：React 18, TypeScript, Tailwind CSS
代码规范：
- 使用函数组件和 Hooks
- 所有组件必须有 PropTypes 或 TypeScript 类型
- 样式使用 Tailwind CSS 类名
- 状态管理使用 Redux Toolkit
"
```

```
claude --append-system-prompt "
项目技术栈：React 18, TypeScript, Tailwind CSS
代码规范：
- 使用函数组件和 Hooks
- 所有组件必须有 PropTypes 或 TypeScript 类型
- 样式使用 Tailwind CSS 类名
- 状态管理使用 Redux Toolkit
"
```

##### 示例 2: 数据科学项目#

```
bash复制claude --append-system-prompt "
数据科学项目规范：
- 使用 Python 3.9+
- 数据处理使用 Pandas
- 可视化使用 Matplotlib 和 Seaborn
- 机器学习使用 scikit-learn
- 所有代码必须有类型注解
- Jupyter Notebook 必须转换为 Python 脚本
"
```

```
claude --append-system-prompt "
数据科学项目规范：
- 使用 Python 3.9+
- 数据处理使用 Pandas
- 可视化使用 Matplotlib 和 Seaborn
- 机器学习使用 scikit-learn
- 所有代码必须有类型注解
- Jupyter Notebook 必须转换为 Python 脚本
"
```

##### 示例 3: DevOps 项目#

```
bash复制claude --append-system-prompt "
DevOps 项目要求：
- 所有基础设施即代码使用 Terraform
- CI/CD 使用 GitHub Actions
- 容器化使用 Docker
- 编排使用 Kubernetes
- 监控使用 Prometheus 和 Grafana
- 日志使用 ELK Stack
"
```

```
claude --append-system-prompt "
DevOps 项目要求：
- 所有基础设施即代码使用 Terraform
- CI/CD 使用 GitHub Actions
- 容器化使用 Docker
- 编排使用 Kubernetes
- 监控使用 Prometheus 和 Grafana
- 日志使用 ELK Stack
"
```

##### 示例 4: 移动应用开发#

```
bash复制claude --append-system-prompt "
移动应用开发规范：
- 使用 React Native
- 状态管理使用 MobX
- 导航使用 React Navigation
- 网络请求使用 Axios
- 本地存储使用 AsyncStorage
- 所有组件必须有 TypeScript 类型
"
```

```
claude --append-system-prompt "
移动应用开发规范：
- 使用 React Native
- 状态管理使用 MobX
- 导航使用 React Navigation
- 网络请求使用 Axios
- 本地存储使用 AsyncStorage
- 所有组件必须有 TypeScript 类型
"
```

#### 最佳实践#

##### 1. 明确且简洁#

保持附加提示明确且简洁：

```
bash复制# 好的示例
claude --append-system-prompt "所有函数必须有类型注解和文档字符串"

# 不好的示例
claude --append-system-prompt "请确保你编写的所有代码都包含适当的类型注解，并且每个函数都应该有详细的文档字符串来解释它的功能、参数和返回值"
```

```
# 好的示例
claude --append-system-prompt "所有函数必须有类型注解和文档字符串"

# 不好的示例
claude --append-system-prompt "请确保你编写的所有代码都包含适当的类型注解，并且每个函数都应该有详细的文档字符串来解释它的功能、参数和返回值"
```

##### 2. 使用编号列表#

对于多个要求，使用编号列表：

```
bash复制claude --append-system-prompt "代码规范：\n1. 所有函数必须有类型注解\n2. 所有函数必须有文档字符串\n3. 所有类必须有文档字符串"
```

```
claude --append-system-prompt "代码规范：\n1. 所有函数必须有类型注解\n2. 所有函数必须有文档字符串\n3. 所有类必须有文档字符串"
```

##### 3. 提供示例#

在提示中包含示例：

```
bash复制claude --append-system-prompt "
函数格式示例：
def calculate_total(items: List[Item]) -> float:
    \"\"\"计算商品总价\"\"\"
    return sum(item.price for item in items)
"
```

```
claude --append-system-prompt "
函数格式示例：
def calculate_total(items: List[Item]) -> float:
    \"\"\"计算商品总价\"\"\"
    return sum(item.price for item in items)
"
```

##### 4. 分离关注点#

将不同类型的关注点分开：

```
bash复制# 代码风格
claude --append-system-prompt "使用 PEP 8 风格指南"

# 安全要求
claude --append-system-prompt "所有用户输入必须验证和清理"

# 性能要求
claude --append-system-prompt "优先考虑时间复杂度 O(n) 的算法"
```

```
# 代码风格
claude --append-system-prompt "使用 PEP 8 风格指南"

# 安全要求
claude --append-system-prompt "所有用户输入必须验证和清理"

# 性能要求
claude --append-system-prompt "优先考虑时间复杂度 O(n) 的算法"
```

#### 常见问题#

##### Q1: 附加提示的长度有限制吗？#

A: 有一定的限制，但通常足够长。如果提示非常长，建议使用 --system-prompt-file 从文件加载。

```
--system-prompt-file
```

##### Q2: 可以多次使用 --append-system-prompt 吗？#

A: 不可以。每次只能使用一次。如果需要添加多个内容，请将它们合并为一个提示。

##### Q3: 附加提示会影响 Claude 的核心能力吗？#

A: 不会。--append-system-prompt 只是在默认系统提示后添加内容，不会替换核心能力。

```
--append-system-prompt
```

##### Q4: 何时使用 --append-system-prompt 而不是 --system-prompt？#

A: 当您希望保留 Claude 的核心行为和能力，只需要添加特定指导时使用 --append-system-prompt。当您需要完全自定义 Claude 的行为时使用 --system-prompt。

```
--append-system-prompt
```

```
--system-prompt
```

##### Q5: 附加提示的优先级如何？#

A: 附加提示会与默认系统提示一起工作。如果存在冲突，附加提示通常具有更高的优先级。

#### 与其他标志的组合示例#

##### 1. 完整的开发环境设置#

```
bash复制claude \
--append-system-prompt "使用 TypeScript 严格模式，编写单元测试" \
--model opus \
--allowedTools "Read" "Write" "Grep" "RunCommand" \
--verbose
```

```
claude \
--append-system-prompt "使用 TypeScript 严格模式，编写单元测试" \
--model opus \
--allowedTools "Read" "Write" "Grep" "RunCommand" \
--verbose
```

##### 2. 代码审查会话#

```
bash复制claude \
  --append-system-prompt "代码审查重点：安全性、性能、可维护性" \
  --model opus \
  --output-format json \
  -p "审查 src/auth.py"
```

```
claude \
  --append-system-prompt "代码审查重点：安全性、性能、可维护性" \
  --model opus \
  --output-format json \
  -p "审查 src/auth.py"
```

##### 3. 文档生成#

```
bash复制claude \
--append-system-prompt "生成符合 Google 风格的 API 文档" \
--model opus \
--output-format markdown \
-p "为所有 API 端点生成文档"
```

```
claude \
--append-system-prompt "生成符合 Google 风格的 API 文档" \
--model opus \
--output-format markdown \
-p "为所有 API 端点生成文档"
```

##### 4. 测试生成#

```
bash复制claude \
  --append-system-prompt "使用 pytest 编写单元测试，覆盖率至少 80%" \
  --model opus \
  --allowedTools "Read" "Write" \
  -p "为 src/utils.py 生成测试"

## 提示模板

### 代码风格模板

```bash
claude --append-system-prompt "
代码风格要求：
- 使用 2 空格缩进
- 每行不超过 80 字符
- 使用驼峰命名法（变量和函数）
- 使用帕斯卡命名法（类）
- 常量使用全大写和下划线
"
```

```
claude \
  --append-system-prompt "使用 pytest 编写单元测试，覆盖率至少 80%" \
  --model opus \
  --allowedTools "Read" "Write" \
  -p "为 src/utils.py 生成测试"

## 提示模板

### 代码风格模板

```bash
claude --append-system-prompt "
代码风格要求：
- 使用 2 空格缩进
- 每行不超过 80 字符
- 使用驼峰命名法（变量和函数）
- 使用帕斯卡命名法（类）
- 常量使用全大写和下划线
"
```

##### 安全模板#

```
bash复制claude --append-system-prompt "
安全要求：
- 所有用户输入必须验证
- 敏感数据必须加密
- 使用参数化查询防止 SQL 注入
- 实施 CSRF 保护
- 设置适当的安全头
"
```

```
claude --append-system-prompt "
安全要求：
- 所有用户输入必须验证
- 敏感数据必须加密
- 使用参数化查询防止 SQL 注入
- 实施 CSRF 保护
- 设置适当的安全头
"
```

##### 性能模板#

```
bash复制claude --append-system-prompt "
性能要求：
- 优先考虑 O(n) 或更好的算法
- 避免不必要的数据库查询
- 使用缓存减少重复计算
- 异步处理耗时操作
- 优化数据库索引
"
```

```
claude --append-system-prompt "
性能要求：
- 优先考虑 O(n) 或更好的算法
- 避免不必要的数据库查询
- 使用缓存减少重复计算
- 异步处理耗时操作
- 优化数据库索引
"
```

##### 文档模板#

```
bash复制claude --append-system-prompt "
文档要求：
- 所有函数必须有文档字符串
- 复杂逻辑必须有注释
- API 端点必须有 OpenAPI 规范
- README 必须包含安装和使用说明
- 变更日志必须记录所有重要更改
"
```

```
claude --append-system-prompt "
文档要求：
- 所有函数必须有文档字符串
- 复杂逻辑必须有注释
- API 端点必须有 OpenAPI 规范
- README 必须包含安装和使用说明
- 变更日志必须记录所有重要更改
"
```

#### 总结#

--append-system-prompt 标志提供了一种灵活的方式来增强 Claude 的默认行为，而不需要完全替换其系统提示。这种方式特别适合：

```
--append-system-prompt
```

- 添加项目特定的规则和约束
- 指定输出格式和风格
- 添加领域特定的知识
- 设置语言和术语偏好
- 添加额外的安全或性能要求

通过合理使用 --append-system-prompt，您可以在保留 Claude 核心能力的同时，定制其行为以适应您的具体需求。

```
--append-system-prompt
```

---

## 9 --output-format - 指定输出格式

**URL**: https://claudecode.tangshuang.net/course/6.9%20--output-format%20-%20%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F

#### 概述#

--output-format 标志允许您指定 Claude 响应的输出格式。这对于自动化脚本、数据处理、API 集成等场景非常有用。

```
--output-format
```

#### 基本语法#

```
bash复制claude --output-format <格式>
```

```
claude --output-format <格式>
```

#### 支持的格式#

```
text
```

```
json
```

```
markdown
```

```
yaml
```

#### 使用场景#

##### 1. JSON 格式输出#

用于自动化脚本和数据处理：

```
bash复制# 获取 JSON 格式的响应
claude --output-format json -p "分析这个 Python 文件的结构"

# 输出示例
{
  "analysis": {
    "language": "Python",
    "functions": ["main", "process_data", "calculate"],
    "imports": ["os", "sys", "json"],
    "complexity": "medium"
  },
  "suggestions": [
    "添加类型注解",
    "拆分长函数",
    "添加错误处理"
  ]
}
```

```
# 获取 JSON 格式的响应
claude --output-format json -p "分析这个 Python 文件的结构"

# 输出示例
{
  "analysis": {
    "language": "Python",
    "functions": ["main", "process_data", "calculate"],
    "imports": ["os", "sys", "json"],
    "complexity": "medium"
  },
  "suggestions": [
    "添加类型注解",
    "拆分长函数",
    "添加错误处理"
  ]
}
```

##### 2. Markdown 格式输出#

用于文档生成和技术写作：

```
bash复制# 生成 Markdown 格式的文档
claude --output-format markdown -p "为这个 API 生成文档"

# 输出示例
# API 文档
## 用户认证
### POST /api/auth/login
登录用户账号。
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "john_doe"
  }
}
```
```

```
# 生成 Markdown 格式的文档
claude --output-format markdown -p "为这个 API 生成文档"

# 输出示例
# API 文档
## 用户认证
### POST /api/auth/login
登录用户账号。
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "john_doe"
  }
}
```
```

##### 3. YAML 格式输出#

用于配置文件生成：

```
bash复制# 生成 YAML 格式的配置
claude --output-format yaml -p "生成一个 Docker Compose 配置"

# 输出示例
version: '3.8'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:
```

```
# 生成 YAML 格式的配置
claude --output-format yaml -p "生成一个 Docker Compose 配置"

# 输出示例
version: '3.8'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:
```

##### 4. 纯文本格式输出#

用于一般对话和代码生成：

```
bash复制# 默认文本格式
claude --output-format text -p "解释什么是递归"

# 输出示例
递归是一种编程技术，函数直接或间接地调用自身。

基本原理：
1. 基础情况：递归的终止条件
2. 递归情况：函数调用自身，但参数更接近基础情况

示例：
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

```
# 默认文本格式
claude --output-format text -p "解释什么是递归"

# 输出示例
递归是一种编程技术，函数直接或间接地调用自身。

基本原理：
1. 基础情况：递归的终止条件
2. 递归情况：函数调用自身，但参数更接近基础情况

示例：
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# JSON 格式 + 指定模型
claude --output-format json --model opus -p "分析代码"

# Markdown 格式 + 限制工具
claude --output-format markdown --allowedTools "Read" "Grep" -p "生成文档"

# YAML 格式 + 详细日志
claude --output-format yaml --verbose -p "生成配置"
```

```
# JSON 格式 + 指定模型
claude --output-format json --model opus -p "分析代码"

# Markdown 格式 + 限制工具
claude --output-format markdown --allowedTools "Read" "Grep" -p "生成文档"

# YAML 格式 + 详细日志
claude --output-format yaml --verbose -p "生成配置"
```

##### 2. 管道输出到文件#

```
bash复制# 将 JSON 输出保存到文件
claude --output-format json -p "分析项目结构" > analysis.json

# 将 Markdown 输出保存到文件
claude --output-format markdown -p "生成 README" > README.md

# 将 YAML 输出保存到文件
claude --output-format yaml -p "生成配置" > config.yaml
```

```
# 将 JSON 输出保存到文件
claude --output-format json -p "分析项目结构" > analysis.json

# 将 Markdown 输出保存到文件
claude --output-format markdown -p "生成 README" > README.md

# 将 YAML 输出保存到文件
claude --output-format yaml -p "生成配置" > config.yaml
```

##### 3. 与其他工具集成#

```
bash复制# 使用 jq 处理 JSON 输出
claude --output-format json -p "获取文件列表" | jq '.files[]'

# 使用 pandoc 转换 Markdown
claude --output-format markdown -p "生成文档" | pandoc -o doc.pdf

# 使用 yq 处理 YAML 输出
claude --output-format yaml -p "生成配置" | yq '.services[].image'
```

```
# 使用 jq 处理 JSON 输出
claude --output-format json -p "获取文件列表" | jq '.files[]'

# 使用 pandoc 转换 Markdown
claude --output-format markdown -p "生成文档" | pandoc -o doc.pdf

# 使用 yq 处理 YAML 输出
claude --output-format yaml -p "生成配置" | yq '.services[].image'
```

##### 4. 在脚本中使用#

```
bash复制#!/bin/bash
# analyze.sh

# 获取 JSON 格式的分析结果
RESULT=$(claude --output-format json -p "分析代码质量")

# 提取评分
SCORE=$(echo "$RESULT" | jq '.score')

# 根据评分执行不同操作
if [ "$SCORE" -gt 80 ]; then
    echo "代码质量优秀"
else
    echo "代码质量需要改进"
fi
```

```
#!/bin/bash
# analyze.sh

# 获取 JSON 格式的分析结果
RESULT=$(claude --output-format json -p "分析代码质量")

# 提取评分
SCORE=$(echo "$RESULT" | jq '.score')

# 根据评分执行不同操作
if [ "$SCORE" -gt 80 ]; then
    echo "代码质量优秀"
else
    echo "代码质量需要改进"
fi
```

#### 实际应用示例#

##### 示例 1: 自动化代码审查#

```
bash复制#!/bin/bash
# code-review.sh
FILE=$1

# 获取 JSON 格式的审查结果
REVIEW=$(claude --output-format json \
--append-system-prompt "代码审查重点：安全性、性能、可维护性" \
-p "审查 $FILE 的代码质量")

# 提取问题数量
ISSUES=$(echo "$REVIEW" | jq '.issues | length')
echo "发现 $ISSUES 个问题"

# 如果有问题，显示详细信息
if [ "$ISSUES" -gt 0 ]; then
echo "$REVIEW" | jq '.issues[]'
fi
```

```
#!/bin/bash
# code-review.sh
FILE=$1

# 获取 JSON 格式的审查结果
REVIEW=$(claude --output-format json \
--append-system-prompt "代码审查重点：安全性、性能、可维护性" \
-p "审查 $FILE 的代码质量")

# 提取问题数量
ISSUES=$(echo "$REVIEW" | jq '.issues | length')
echo "发现 $ISSUES 个问题"

# 如果有问题，显示详细信息
if [ "$ISSUES" -gt 0 ]; then
echo "$REVIEW" | jq '.issues[]'
fi
```

##### 示例 2: 自动生成文档#

```
bash复制#!/bin/bash
# generate-docs.sh

# 为所有 Python 文件生成 Markdown 文档
for file in src/*.py; do
    echo "为 $file 生成文档..."

    claude --output-format markdown \
      --append-system-prompt "生成符合 Google 风格的 API 文档" \
      -p "为 $file 生成文档" > "docs/$(basename $file .py).md"
done

echo "文档生成完成"
```

```
#!/bin/bash
# generate-docs.sh

# 为所有 Python 文件生成 Markdown 文档
for file in src/*.py; do
    echo "为 $file 生成文档..."

    claude --output-format markdown \
      --append-system-prompt "生成符合 Google 风格的 API 文档" \
      -p "为 $file 生成文档" > "docs/$(basename $file .py).md"
done

echo "文档生成完成"
```

##### 示例 3: 配置文件生成#

```
bash复制#!/bin/bash
# generate-config.sh

# 生成 YAML 格式的配置文件
claude --output-format yaml \
--append-system-prompt "生成生产环境的配置文件" \
-p "生成包含 Web 服务器、数据库和缓存的配置" > docker-compose.yml

echo "配置文件已生成：docker-compose.yml"
```

```
#!/bin/bash
# generate-config.sh

# 生成 YAML 格式的配置文件
claude --output-format yaml \
--append-system-prompt "生成生产环境的配置文件" \
-p "生成包含 Web 服务器、数据库和缓存的配置" > docker-compose.yml

echo "配置文件已生成：docker-compose.yml"
```

##### 示例 4: 数据分析报告#

```
bash复制#!/bin/bash
# analyze-data.sh

DATA_FILE=$1

# 获取 JSON 格式的分析结果
ANALYSIS=$(claude --output-format json \
  --append-system-prompt "数据分析重点：趋势、异常、建议" \
  -p "分析 $DATA_FILE 中的数据")

# 生成 Markdown 报告
cat > report.md << EOF
# 数据分析报告

## 概述
\$(echo "$ANALYSIS" | jq -r '.summary')

## 关键指标
\$(echo "$ANALYSIS" | jq -r '.metrics | to_entries[] | "- \(.key): \(.value)"')

## 建议
\$(echo "$ANALYSIS" | jq -r '.recommendations[] | "- \(.)"')
EOF

echo "报告已生成：report.md"
```

```
#!/bin/bash
# analyze-data.sh

DATA_FILE=$1

# 获取 JSON 格式的分析结果
ANALYSIS=$(claude --output-format json \
  --append-system-prompt "数据分析重点：趋势、异常、建议" \
  -p "分析 $DATA_FILE 中的数据")

# 生成 Markdown 报告
cat > report.md << EOF
# 数据分析报告

## 概述
\$(echo "$ANALYSIS" | jq -r '.summary')

## 关键指标
\$(echo "$ANALYSIS" | jq -r '.metrics | to_entries[] | "- \(.key): \(.value)"')

## 建议
\$(echo "$ANALYSIS" | jq -r '.recommendations[] | "- \(.)"')
EOF

echo "报告已生成：report.md"
```

#### 格式特定技巧#

##### JSON 格式技巧#

```
bash复制# 请求结构化的 JSON 输出
claude --output-format json -p "以 JSON 格式返回文件列表，包含文件名、大小和修改时间"

# 在提示中指定 JSON 结构
claude --output-format json -p "返回以下 JSON 结构：{\"files\": [{\"name\": \"\", \"size\": 0, \"lines\": 0}]}"

# 使用 jq 提取特定字段
claude --output-format json -p "分析代码" | jq '.suggestions[]'
```

```
# 请求结构化的 JSON 输出
claude --output-format json -p "以 JSON 格式返回文件列表，包含文件名、大小和修改时间"

# 在提示中指定 JSON 结构
claude --output-format json -p "返回以下 JSON 结构：{\"files\": [{\"name\": \"\", \"size\": 0, \"lines\": 0}]}"

# 使用 jq 提取特定字段
claude --output-format json -p "分析代码" | jq '.suggestions[]'
```

##### Markdown 格式技巧#

```
bash复制# 请求特定类型的 Markdown 内容
claude --output-format markdown -p "生成包含代码示例和表格的 Markdown 文档"

# 生成 API 文档
claude --output-format markdown -p "生成 OpenAPI 规范格式的 API 文档"

# 生成技术博客
claude --output-format markdown -p "写一篇关于微服务架构的技术博客"
```

```
# 请求特定类型的 Markdown 内容
claude --output-format markdown -p "生成包含代码示例和表格的 Markdown 文档"

# 生成 API 文档
claude --output-format markdown -p "生成 OpenAPI 规范格式的 API 文档"

# 生成技术博客
claude --output-format markdown -p "写一篇关于微服务架构的技术博客"
```

##### YAML 格式技巧#

```
bash复制# 生成 Kubernetes 配置
claude --output-format yaml -p "生成 Kubernetes Deployment 和 Service 配置"

# 生成 CI/CD 配置
claude --output-format yaml -p "生成 GitHub Actions 工作流配置"

# 生成多环境配置
claude --output-format yaml -p "生成开发、测试和生产环境的配置"
```

```
# 生成 Kubernetes 配置
claude --output-format yaml -p "生成 Kubernetes Deployment 和 Service 配置"

# 生成 CI/CD 配置
claude --output-format yaml -p "生成 GitHub Actions 工作流配置"

# 生成多环境配置
claude --output-format yaml -p "生成开发、测试和生产环境的配置"
```

#### 最佳实践#

##### 1. 选择合适的格式#

```
bash复制# 数据处理和自动化 -> JSON
claude --output-format json -p "分析数据"

# 文档和技术写作 -> Markdown
claude --output-format markdown -p "生成文档"

# 配置文件 -> YAML
claude --output-format yaml -p "生成配置"

# 一般对话 -> text（默认）
claude -p "解释概念"
```

```
# 数据处理和自动化 -> JSON
claude --output-format json -p "分析数据"

# 文档和技术写作 -> Markdown
claude --output-format markdown -p "生成文档"

# 配置文件 -> YAML
claude --output-format yaml -p "生成配置"

# 一般对话 -> text（默认）
claude -p "解释概念"
```

##### 2. 在提示中指定结构#

```
bash复制# 明确指定 JSON 结构
claude --output-format json -p "返回 JSON：{\"result\": \"\", \"confidence\": 0.0}"

# 明确指定 Markdown 结构
claude --output-format markdown -p "生成包含标题、代码块和表格的 Markdown"
```

```
# 明确指定 JSON 结构
claude --output-format json -p "返回 JSON：{\"result\": \"\", \"confidence\": 0.0}"

# 明确指定 Markdown 结构
claude --output-format markdown -p "生成包含标题、代码块和表格的 Markdown"
```

##### 3. 验证输出格式#

```
bash复制# 验证 JSON 格式
claude --output-format json -p "分析代码" | jq . > /dev/null && echo "JSON 有效"

# 验证 YAML 格式
claude --output-format yaml -p "生成配置" | yq eval . > /dev/null && echo "YAML 有效"
```

```
# 验证 JSON 格式
claude --output-format json -p "分析代码" | jq . > /dev/null && echo "JSON 有效"

# 验证 YAML 格式
claude --output-format yaml -p "生成配置" | yq eval . > /dev/null && echo "YAML 有效"
```

##### 4. 错误处理#

```
bash复制#!/bin/bash
# 处理 JSON 输出错误
RESULT=$(claude --output-format json -p "分析代码")
if ! echo "$RESULT" | jq . > /dev/null 2>&1; then
echo "错误：无效的 JSON 输出"
echo "$RESULT"
exit 1
fi
echo "JSON 输出有效"
```

```
#!/bin/bash
# 处理 JSON 输出错误
RESULT=$(claude --output-format json -p "分析代码")
if ! echo "$RESULT" | jq . > /dev/null 2>&1; then
echo "错误：无效的 JSON 输出"
echo "$RESULT"
exit 1
fi
echo "JSON 输出有效"
```

#### 常见问题#

##### Q1: 所有格式都支持吗？#

A: 支持的格式包括 text、json、markdown 和 yaml。某些复杂格式可能需要额外的处理。

##### Q2: 如何确保输出是有效的格式？#

A: 可以使用相应的验证工具（如 jq 验证 JSON，yq 验证 YAML）来验证输出。

##### Q3: 可以自定义输出格式吗？#

A: 不可以直接自定义格式，但可以在提示中指定输出的结构和内容。

##### Q4: JSON 输出的大小有限制吗？#

A: 有一定的限制，但对于大多数应用场景来说足够。如果输出很大，考虑分批处理。

##### Q5: 如何处理格式错误？#

A: 使用验证工具检查输出，并在脚本中添加错误处理逻辑。

#### 与其他工具的集成#

##### 1. 与 jq 集成#

```
bash复制# 提取特定字段
claude --output-format json -p "分析代码" | jq '.score'

# 过滤数据
claude --output-format json -p "获取文件列表" | jq '.files[] | select(.size > 1024)'

# 转换格式
claude --output-format json -p "分析数据" | jq -r '.summary'
```

```
# 提取特定字段
claude --output-format json -p "分析代码" | jq '.score'

# 过滤数据
claude --output-format json -p "获取文件列表" | jq '.files[] | select(.size > 1024)'

# 转换格式
claude --output-format json -p "分析数据" | jq -r '.summary'
```

##### 2. 与 yq 集成#

```
bash复制# 提取配置值
claude --output-format yaml -p "生成配置" | yq '.services.web.image'

# 更新配置
claude --output-format yaml -p "生成配置" | yq '.services.web.ports[0] = "8080:80"' > new-config.yaml
```

```
# 提取配置值
claude --output-format yaml -p "生成配置" | yq '.services.web.image'

# 更新配置
claude --output-format yaml -p "生成配置" | yq '.services.web.ports[0] = "8080:80"' > new-config.yaml
```

##### 3. 与 pandoc 集成#

```
bash复制# Markdown 转 PDF
claude --output-format markdown -p "生成文档" | pandoc -o document.pdf

# Markdown 转 HTML
claude --output-format markdown -p "生成文档" | pandoc -o document.html
```

```
# Markdown 转 PDF
claude --output-format markdown -p "生成文档" | pandoc -o document.pdf

# Markdown 转 HTML
claude --output-format markdown -p "生成文档" | pandoc -o document.html
```

##### 4. 与 Python 集成#

```
python复制import subprocess
import json

# 获取 JSON 输出
result = subprocess.run(
    ['claude', '--output-format', 'json', '-p', '分析代码'],
    capture_output=True,
    text=True
)

# 解析 JSON
data = json.loads(result.stdout)

# 使用数据
print(f"分数: {data['score']}")
print(f"建议: {data['suggestions']}")
```

```
import subprocess
import json

# 获取 JSON 输出
result = subprocess.run(
    ['claude', '--output-format', 'json', '-p', '分析代码'],
    capture_output=True,
    text=True
)

# 解析 JSON
data = json.loads(result.stdout)

# 使用数据
print(f"分数: {data['score']}")
print(f"建议: {data['suggestions']}")
```

---

## 10 --input-format - 指定输入格式

**URL**: https://claudecode.tangshuang.net/course/6.10%20--input-format%20-%20%E6%8C%87%E5%AE%9A%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F

#### 概述#

--input-format 标志允许您指定输入数据的格式。这对于处理不同格式的数据文件、API 响应或其他结构化数据非常有用。

```
--input-format
```

#### 基本语法#

```
bash复制claude --input-format <格式>
```

```
claude --input-format <格式>
```

#### 支持的格式#

```
text
```

```
json
```

```
yaml
```

```
markdown
```

#### 使用场景#

##### 1. 处理 JSON 输入#

```
bash复制# 从 JSON 文件读取并处理
cat data.json | claude --input-format json -p "分析这个数据"

# 示例 data.json
{
  "users": [
    {"id": 1, "name": "Alice", "age": 30},
    {"id": 2, "name": "Bob", "age": 25}
  ],
  "total": 2
}

# Claude 会理解这是一个 JSON 结构，并提供相应的分析
```

```
# 从 JSON 文件读取并处理
cat data.json | claude --input-format json -p "分析这个数据"

# 示例 data.json
{
  "users": [
    {"id": 1, "name": "Alice", "age": 30},
    {"id": 2, "name": "Bob", "age": 25}
  ],
  "total": 2
}

# Claude 会理解这是一个 JSON 结构，并提供相应的分析
```

##### 2. 处理 YAML 输入#

```
bash复制# 从 YAML 文件读取并处理
cat config.yaml | claude --input-format yaml -p "检查这个配置"

# 示例 config.yaml
version: '3.8'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: secret
```

```
# 从 YAML 文件读取并处理
cat config.yaml | claude --input-format yaml -p "检查这个配置"

# 示例 config.yaml
version: '3.8'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: secret
```

##### 3. 处理 Markdown 输入#

```
bash复制# 从 Markdown 文件读取并处理
cat README.md | claude --input-format markdown -p "改进这个文档"

# Claude 会理解 Markdown 结构（标题、列表、代码块等）
```

```
# 从 Markdown 文件读取并处理
cat README.md | claude --input-format markdown -p "改进这个文档"

# Claude 会理解 Markdown 结构（标题、列表、代码块等）
```

##### 4. 处理纯文本输入#

```
bash复制# 默认格式，可以省略 --input-format
cat log.txt | claude -p "分析这个日志"

# 或者显式指定
cat log.txt | claude --input-format text -p "分析这个日志"
## 高级用法
### 1. 与 --output-format 组合

```bash
# JSON 输入，JSON 输出
cat data.json | claude --input-format json --output-format json -p "转换数据"

# YAML 输入，Markdown 输出
cat config.yaml | claude --input-format yaml --output-format markdown -p "生成文档"

# Markdown 输入，JSON 输出
cat README.md | claude --input-format markdown --output-format json -p "提取关键信息"
```

```
# 默认格式，可以省略 --input-format
cat log.txt | claude -p "分析这个日志"

# 或者显式指定
cat log.txt | claude --input-format text -p "分析这个日志"
## 高级用法
### 1. 与 --output-format 组合

```bash
# JSON 输入，JSON 输出
cat data.json | claude --input-format json --output-format json -p "转换数据"

# YAML 输入，Markdown 输出
cat config.yaml | claude --input-format yaml --output-format markdown -p "生成文档"

# Markdown 输入，JSON 输出
cat README.md | claude --input-format markdown --output-format json -p "提取关键信息"
```

```
bash复制
### 2. 处理 API 响应

```bash
# 获取 API 响应并处理
curl -s https://api.example.com/users | claude --input-format json -p "分析用户数据"

# 处理分页数据
curl -s "https://api.example.com/data?page=1" | claude --input-format json -p "总结第一页数据"
```

```
### 2. 处理 API 响应

```bash
# 获取 API 响应并处理
curl -s https://api.example.com/users | claude --input-format json -p "分析用户数据"

# 处理分页数据
curl -s "https://api.example.com/data?page=1" | claude --input-format json -p "总结第一页数据"
```

##### 3. 配置文件转换#

```
bash复制# JSON 转 YAML
cat config.json | claude --input-format json --output-format yaml -p "转换为 YAML 格式" > config.yaml

# YAML 转 JSON
cat config.yaml | claude --input-format yaml --output-format json -p "转换为 JSON 格式" > config.json
```

```
# JSON 转 YAML
cat config.json | claude --input-format json --output-format yaml -p "转换为 YAML 格式" > config.yaml

# YAML 转 JSON
cat config.yaml | claude --input-format yaml --output-format json -p "转换为 JSON 格式" > config.json
```

##### 4. 数据验证#

```
bash复制# 验证 JSON 结构
cat data.json | claude --input-format json -p "验证 JSON 结构是否正确"

# 验证 YAML 配置
cat config.yaml | claude --input-format yaml -p "检查配置是否完整"
```

```
# 验证 JSON 结构
cat data.json | claude --input-format json -p "验证 JSON 结构是否正确"

# 验证 YAML 配置
cat config.yaml | claude --input-format yaml -p "检查配置是否完整"
```

#### 实际应用示例#

##### 示例 1: 数据分析管道#

```
bash复制#!/bin/bash
# analyze-pipeline.sh

# 1. 获取数据
curl -s https://api.example.com/data > data.json

# 2. 清洗数据
cat data.json | claude --input-format json --output-format json -p "清洗数据：移除无效条目，标准化格式" > cleaned.json

# 3. 分析数据
cat cleaned.json | claude --input-format json --output-format json -p "分析数据：计算统计信息，识别趋势" > analysis.json

# 4. 生成报告
cat analysis.json | claude --input-format json --output-format markdown -p "生成分析报告" > report.md

echo "分析完成：report.md"
```

```
#!/bin/bash
# analyze-pipeline.sh

# 1. 获取数据
curl -s https://api.example.com/data > data.json

# 2. 清洗数据
cat data.json | claude --input-format json --output-format json -p "清洗数据：移除无效条目，标准化格式" > cleaned.json

# 3. 分析数据
cat cleaned.json | claude --input-format json --output-format json -p "分析数据：计算统计信息，识别趋势" > analysis.json

# 4. 生成报告
cat analysis.json | claude --input-format json --output-format markdown -p "生成分析报告" > report.md

echo "分析完成：report.md"
```

##### 示例 2: 配置文件管理#

```
bash复制#!/bin/bash
# config-manager.sh

CONFIG_FILE=$1

# 检查配置格式
case "$CONFIG_FILE" in
    *.json)
        FORMAT="json"
        ;;
    *.yaml|*.yml)
        FORMAT="yaml"
        ;;
    *)
        echo "不支持的配置格式"
        exit 1
        ;;
esac

# 验证配置
cat "$CONFIG_FILE" | claude --input-format "$FORMAT" -p "验证配置文件"

# 转换为其他格式
if [ "$FORMAT" = "json" ]; then
    OUTPUT_FILE="${CONFIG_FILE%.json}.yaml"
    cat "$CONFIG_FILE" | claude --input-format json --output-format yaml -p "转换为 YAML" > "$OUTPUT_FILE"
else
    OUTPUT_FILE="${CONFIG_FILE%.*}.json"
    cat "$CONFIG_FILE" | claude --input-format yaml --output-format json -p "转换为 JSON" > "$OUTPUT_FILE"
fi

echo "配置已转换：$OUTPUT_FILE"
```

```
#!/bin/bash
# config-manager.sh

CONFIG_FILE=$1

# 检查配置格式
case "$CONFIG_FILE" in
    *.json)
        FORMAT="json"
        ;;
    *.yaml|*.yml)
        FORMAT="yaml"
        ;;
    *)
        echo "不支持的配置格式"
        exit 1
        ;;
esac

# 验证配置
cat "$CONFIG_FILE" | claude --input-format "$FORMAT" -p "验证配置文件"

# 转换为其他格式
if [ "$FORMAT" = "json" ]; then
    OUTPUT_FILE="${CONFIG_FILE%.json}.yaml"
    cat "$CONFIG_FILE" | claude --input-format json --output-format yaml -p "转换为 YAML" > "$OUTPUT_FILE"
else
    OUTPUT_FILE="${CONFIG_FILE%.*}.json"
    cat "$CONFIG_FILE" | claude --input-format yaml --output-format json -p "转换为 JSON" > "$OUTPUT_FILE"
fi

echo "配置已转换：$OUTPUT_FILE"
```

##### 示例 3: 日志分析#

```
bash复制#!/bin/bash
# log-analyzer.sh

LOG_FILE=$1

# 假设日志是 JSON 格式（每行一个 JSON 对象）
cat "$LOG_FILE" | claude --input-format json -p "分析日志：识别错误、警告和异常模式"

# 生成分析报告
cat "$LOG_FILE" | claude --input-format json --output-format markdown -p "生成日志分析报告" > log-report.md

echo "日志分析完成：log-report.md"
```

```
#!/bin/bash
# log-analyzer.sh

LOG_FILE=$1

# 假设日志是 JSON 格式（每行一个 JSON 对象）
cat "$LOG_FILE" | claude --input-format json -p "分析日志：识别错误、警告和异常模式"

# 生成分析报告
cat "$LOG_FILE" | claude --input-format json --output-format markdown -p "生成日志分析报告" > log-report.md

echo "日志分析完成：log-report.md"
```

##### 示例 4: 文档处理#

```
bash复制#!/bin/bash
# doc-processor.sh

DOC_FILE=$1

# 改进文档
cat "$DOC_FILE" | claude --input-format markdown -p "改进文档：修复格式错误，改善可读性" > improved.md

# 提取关键信息
cat "$DOC_FILE" | claude --input-format markdown --output-format json -p "提取关键信息：标题、章节、代码示例" > info.json

# 生成摘要
cat "$DOC_FILE" | claude --input-format markdown -p "生成文档摘要" > summary.txt

echo "文档处理完成"
```

```
#!/bin/bash
# doc-processor.sh

DOC_FILE=$1

# 改进文档
cat "$DOC_FILE" | claude --input-format markdown -p "改进文档：修复格式错误，改善可读性" > improved.md

# 提取关键信息
cat "$DOC_FILE" | claude --input-format markdown --output-format json -p "提取关键信息：标题、章节、代码示例" > info.json

# 生成摘要
cat "$DOC_FILE" | claude --input-format markdown -p "生成文档摘要" > summary.txt

echo "文档处理完成"
```

#### 格式特定技巧#

##### JSON 格式技巧#

```
bash复制# 处理嵌套 JSON
cat nested.json | claude --input-format json -p "分析嵌套结构"

# 处理大型 JSON 文件
cat large-data.json | claude --input-format json -p "总结数据结构和内容"

# 处理 JSON 数组
cat array.json | claude --input-format json -p "分析数组元素"
```

```
# 处理嵌套 JSON
cat nested.json | claude --input-format json -p "分析嵌套结构"

# 处理大型 JSON 文件
cat large-data.json | claude --input-format json -p "总结数据结构和内容"

# 处理 JSON 数组
cat array.json | claude --input-format json -p "分析数组元素"
```

##### YAML 格式技巧#

```
bash复制# 处理多文档 YAML
cat multi-doc.yaml | claude --input-format yaml -p "分析所有文档"

# 处理复杂的 YAML 配置
cat complex-config.yaml | claude --input-format yaml -p "检查配置依赖关系"

# 处理 YAML 锚点和别名
cat anchors.yaml | claude --input-format yaml -p "解释锚点和别名的使用"
```

```
# 处理多文档 YAML
cat multi-doc.yaml | claude --input-format yaml -p "分析所有文档"

# 处理复杂的 YAML 配置
cat complex-config.yaml | claude --input-format yaml -p "检查配置依赖关系"

# 处理 YAML 锚点和别名
cat anchors.yaml | claude --input-format yaml -p "解释锚点和别名的使用"
```

##### Markdown 格式技巧#

```
bash复制# 处理包含代码块的 Markdown
cat code-docs.md | claude --input-format markdown -p "检查代码示例"

# 处理包含表格的 Markdown
cat tables.md | claude --input-format markdown -p "验证表格格式"

# 处理包含链接的 Markdown
cat links.md | claude --input-format markdown -p "检查所有链接是否有效"
```

```
# 处理包含代码块的 Markdown
cat code-docs.md | claude --input-format markdown -p "检查代码示例"

# 处理包含表格的 Markdown
cat tables.md | claude --input-format markdown -p "验证表格格式"

# 处理包含链接的 Markdown
cat links.md | claude --input-format markdown -p "检查所有链接是否有效"
```

#### 最佳实践#

##### 1. 自动检测格式#

```
bash复制#!/bin/bash
# 根据文件扩展名自动检测格式
FILE=$1

case "$FILE" in
    *.json)
        FORMAT="json"
        ;;
    *.yaml|*.yml)
        FORMAT="yaml"
        ;;
    *.md)
        FORMAT="markdown"
        ;;
    *)
        FORMAT="text"
        ;;
esac

cat "$FILE" | claude --input-format "$FORMAT" -p "处理这个文件"
```

```
#!/bin/bash
# 根据文件扩展名自动检测格式
FILE=$1

case "$FILE" in
    *.json)
        FORMAT="json"
        ;;
    *.yaml|*.yml)
        FORMAT="yaml"
        ;;
    *.md)
        FORMAT="markdown"
        ;;
    *)
        FORMAT="text"
        ;;
esac

cat "$FILE" | claude --input-format "$FORMAT" -p "处理这个文件"
```

##### 2. 格式转换#

```
bash复制# 通用格式转换脚本
convert_format() {
    INPUT_FILE=$1
    OUTPUT_FORMAT=$2

    # 检测输入格式
    case "$INPUT_FILE" in
        *.json)
            INPUT_FORMAT="json"
            ;;
        *.yaml|*.yml)
            INPUT_FORMAT="yaml"
            ;;
        *)
            echo "不支持的输入格式"
            return 1
            ;;
    esac

    # 转换
    cat "$INPUT_FILE" | claude --input-format "$INPUT_FORMAT" --output-format "$OUTPUT_FORMAT" -p "转换格式"
}

# 使用
convert_format config.json yaml > config.yaml
```

```
# 通用格式转换脚本
convert_format() {
    INPUT_FILE=$1
    OUTPUT_FORMAT=$2

    # 检测输入格式
    case "$INPUT_FILE" in
        *.json)
            INPUT_FORMAT="json"
            ;;
        *.yaml|*.yml)
            INPUT_FORMAT="yaml"
            ;;
        *)
            echo "不支持的输入格式"
            return 1
            ;;
    esac

    # 转换
    cat "$INPUT_FILE" | claude --input-format "$INPUT_FORMAT" --output-format "$OUTPUT_FORMAT" -p "转换格式"
}

# 使用
convert_format config.json yaml > config.yaml
```

##### 3. 批量处理#

```
bash复制#!/bin/bash
# 批量处理文件
for file in *.json; do
    echo "处理 $file..."
    cat "$file" | claude --input-format json -p "分析这个文件" > "analysis_${file%.json}.txt"
done
```

```
#!/bin/bash
# 批量处理文件
for file in *.json; do
    echo "处理 $file..."
    cat "$file" | claude --input-format json -p "分析这个文件" > "analysis_${file%.json}.txt"
done
```

##### 4. 错误处理#

```
bash复制#!/bin/bash
# 处理格式错误
FILE=$1

# 尝试解析
RESULT=$(cat "$FILE" | claude --input-format json -p "验证格式" 2>&1)

if echo "$RESULT" | grep -q "错误"; then
    echo "格式错误：$RESULT"
    exit 1
fi

echo "格式正确"
```

```
#!/bin/bash
# 处理格式错误
FILE=$1

# 尝试解析
RESULT=$(cat "$FILE" | claude --input-format json -p "验证格式" 2>&1)

if echo "$RESULT" | grep -q "错误"; then
    echo "格式错误：$RESULT"
    exit 1
fi

echo "格式正确"
```

#### 常见问题#

##### Q1: 如何知道应该使用哪种输入格式？#

A: 根据文件扩展名或内容判断。.json 文件使用 json，.yaml/.yml 文件使用 yaml，.md 文件使用 markdown。

##### Q2: 可以混合使用不同格式吗？#

A: 不可以直接混合。如果文件包含多种格式，需要先分割或转换。

##### Q3: 输入格式错误会发生什么？#

A: Claude 可能无法正确解析输入，导致分析结果不准确。建议先验证格式。

##### Q4: 如何处理大型文件？#

A: 可以分割文件或使用流式处理。对于非常大的文件，考虑先提取关键部分。

##### Q5: 可以自定义输入格式吗？#

A: 不可以直接自定义。如果需要处理特殊格式，先转换为支持的格式。

#### 与其他工具的集成#

##### 1. 与 jq 集成#

```
bash复制# 先用 jq 处理，再用 Claude 分析
cat data.json | jq '.users[]' | claude --input-format json -p "分析每个用户"
```

```
# 先用 jq 处理，再用 Claude 分析
cat data.json | jq '.users[]' | claude --input-format json -p "分析每个用户"
```

##### 2. 与 yq 集成#

```
bash复制# 先用 yq 处理，再用 Claude 分析
cat config.yaml | yq '.services.web' | claude --input-format yaml -p "分析 Web 服务配置"

### 3. 与 curl 集成

# 直接处理 API 响应
curl -s https://api.example.com/data | claude --input-format json -p "分析响应"
```

```
# 先用 yq 处理，再用 Claude 分析
cat config.yaml | yq '.services.web' | claude --input-format yaml -p "分析 Web 服务配置"

### 3. 与 curl 集成

# 直接处理 API 响应
curl -s https://api.example.com/data | claude --input-format json -p "分析响应"
```

##### 4. 与文件处理工具集成#

```
bash复制# 使用 find 批量处理
find . -name "*.json" -exec cat {} \; | claude --input-format json -p "分析所有 JSON 文件"
```

```
# 使用 find 批量处理
find . -name "*.json" -exec cat {} \; | claude --input-format json -p "分析所有 JSON 文件"
```

#### 总结#

--input-format 标志提供了一种灵活的方式来处理不同格式的输入数据。通过指定正确的输入格式，您可以：

```
--input-format
```

- 让 Claude 更好地理解数据结构
- 进行格式转换和数据验证
- 构建自动化数据处理管道
- 与其他工具和 API 无缝集成

合理使用 --input-format 可以大大提高数据处理的效率和准确性，特别是在处理结构化数据时。

```
--input-format
```

---

## 11 --include-partial-messages - 包含部分流事件

**URL**: https://claudecode.tangshuang.net/course/6.11%20--include-partial-messages%20-%20%E5%8C%85%E5%90%AB%E9%83%A8%E5%88%86%E6%B5%81%E4%BA%8B%E4%BB%B6

#### 概述#

--include-partial-messages 标志允许您在流式响应中包含部分消息。这对于实时处理、调试和监控流式输出非常有用。

```
--include-partial-messages
```

#### 基本语法#

```
bash复制claude --include-partial-messages
```

```
claude --include-partial-messages
```

#### 工作原理#

当使用流式输出时，Claude 的响应会分块发送。默认情况下，只有完整的消息才会被处理。使用 --include-partial-messages 标志后，部分消息也会被包含在输出中。

```
--include-partial-messages
```

#### 使用场景#

##### 1. 实时监控流式输出#

```
bash复制# 监控流式输出的每个部分
claude --include-partial-messages -p "生成一个长篇技术文档"

# 输出会显示每个部分消息，包括不完整的句子和段落
```

```
# 监控流式输出的每个部分
claude --include-partial-messages -p "生成一个长篇技术文档"

# 输出会显示每个部分消息，包括不完整的句子和段落
```

##### 2. 调试流式响应#

```
bash复制# 调试流式响应的生成过程
claude --include-partial-messages --verbose -p "解释复杂的概念"
# 可以看到响应是如何逐步生成的
```

```
# 调试流式响应的生成过程
claude --include-partial-messages --verbose -p "解释复杂的概念"
# 可以看到响应是如何逐步生成的
```

##### 3. 实时处理流式数据#

```
bash复制# 实时处理流式输出
claude --include-partial-messages -p "生成代码" | while read line; do
    echo "收到: $line"
    # 实时处理每一行
done
```

```
# 实时处理流式输出
claude --include-partial-messages -p "生成代码" | while read line; do
    echo "收到: $line"
    # 实时处理每一行
done
```

##### 4. 网络延迟测试#

```
bash复制# 测试流式输出的网络延迟
claude --include-partial-messages -p "生成大量文本" | pv -l > output.txt
# pv 会显示每秒接收到的行数
```

```
# 测试流式输出的网络延迟
claude --include-partial-messages -p "生成大量文本" | pv -l > output.txt
# pv 会显示每秒接收到的行数
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 包含部分消息 + 详细日志
claude --include-partial-messages --verbose -p "生成文档"

# 包含部分消息 + JSON 输出
claude --include-partial-messages --output-format json -p "分析数据"

# 包含部分消息 + 限制工具
claude --include-partial-messages --allowedTools "Read" "Grep" -p "搜索代码"
```

```
# 包含部分消息 + 详细日志
claude --include-partial-messages --verbose -p "生成文档"

# 包含部分消息 + JSON 输出
claude --include-partial-messages --output-format json -p "分析数据"

# 包含部分消息 + 限制工具
claude --include-partial-messages --allowedTools "Read" "Grep" -p "搜索代码"
```

##### 2. 实时进度显示#

```
bash复制#!/bin/bash
# 显示实时进度
claude --include-partial-messages -p "生成 100 行代码" | while IFS= read -r line; do
# 计算进度
PROGRESS=$(echo "$line" | grep -oE '[0-9]+' | head -1)
if [ -n "$PROGRESS" ]; then
echo -ne "进度: $PROGRESS%\r"
fi
done
echo -e "\n完成"
```

```
#!/bin/bash
# 显示实时进度
claude --include-partial-messages -p "生成 100 行代码" | while IFS= read -r line; do
# 计算进度
PROGRESS=$(echo "$line" | grep -oE '[0-9]+' | head -1)
if [ -n "$PROGRESS" ]; then
echo -ne "进度: $PROGRESS%\r"
fi
done
echo -e "\n完成"
```

##### 3. 流式输出到文件#

```
bash复制# 将流式输出保存到文件
claude --include-partial-messages -p "生成长文档" > output.txt

# 同时显示和保存
claude --include-partial-messages -p "生成文档" | tee output.txt
```

```
# 将流式输出保存到文件
claude --include-partial-messages -p "生成长文档" > output.txt

# 同时显示和保存
claude --include-partial-messages -p "生成文档" | tee output.txt
```

##### 4. 实时过滤#

```
bash复制# 实时过滤流式输出
claude --include-partial-messages -p "生成代码" | grep "def " | head -10
# 只显示函数定义
```

```
# 实时过滤流式输出
claude --include-partial-messages -p "生成代码" | grep "def " | head -10
# 只显示函数定义
```

#### 实际应用示例#

##### 示例 1: 实时代码生成监控#

```
bash复制#!/bin/bash
# monitor-code-gen.sh

echo "开始生成代码..."
claude --include-partial-messages -p "生成一个完整的 REST API" | while IFS= read -r line; do
    # 高亮显示函数定义
    if echo "$line" | grep -q "def \|class \|async def "; then
        echo -e "\033[32m$line\033[0m"  # 绿色
    # 高亮显示注释
    elif echo "$line" | grep -q "#"; then
        echo -e "\033[36m$line\033[0m"  # 青色
    else
        echo "$line"
    fi
done
```

```
#!/bin/bash
# monitor-code-gen.sh

echo "开始生成代码..."
claude --include-partial-messages -p "生成一个完整的 REST API" | while IFS= read -r line; do
    # 高亮显示函数定义
    if echo "$line" | grep -q "def \|class \|async def "; then
        echo -e "\033[32m$line\033[0m"  # 绿色
    # 高亮显示注释
    elif echo "$line" | grep -q "#"; then
        echo -e "\033[36m$line\033[0m"  # 青色
    else
        echo "$line"
    fi
done
```

##### 示例 2: 流式日志记录#

```
bash复制#!/bin/bash
# stream-logger.sh
LOG_FILE="stream-$(date +%Y%m%d-%H%M%S).log"
echo "开始记录流式输出到 $LOG_FILE"
claude --include-partial-messages -p "生成技术文档" | while IFS= read -r line; do
# 添加时间戳
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "[$TIMESTAMP] $line" | tee -a "$LOG_FILE"
done
echo "记录完成"
```

```
#!/bin/bash
# stream-logger.sh
LOG_FILE="stream-$(date +%Y%m%d-%H%M%S).log"
echo "开始记录流式输出到 $LOG_FILE"
claude --include-partial-messages -p "生成技术文档" | while IFS= read -r line; do
# 添加时间戳
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "[$TIMESTAMP] $line" | tee -a "$LOG_FILE"
done
echo "记录完成"
```

##### 示例 3: 实时字数统计#

```
bash复制#!/bin/bash
# word-counter.sh

TOTAL_WORDS=0

claude --include-partial-messages -p "写一篇关于 AI 的文章" | while IFS= read -r line; do
    # 统计当前行的字数
    WORDS=$(echo "$line" | wc -w)
    TOTAL_WORDS=$((TOTAL_WORDS + WORDS))

    # 显示累计字数
    echo -ne "已生成字数: $TOTAL_WORDS\r"

    # 输出内容
    echo "$line"
done

echo -e "\n总字数: $TOTAL_WORDS"
```

```
#!/bin/bash
# word-counter.sh

TOTAL_WORDS=0

claude --include-partial-messages -p "写一篇关于 AI 的文章" | while IFS= read -r line; do
    # 统计当前行的字数
    WORDS=$(echo "$line" | wc -w)
    TOTAL_WORDS=$((TOTAL_WORDS + WORDS))

    # 显示累计字数
    echo -ne "已生成字数: $TOTAL_WORDS\r"

    # 输出内容
    echo "$line"
done

echo -e "\n总字数: $TOTAL_WORDS"
```

##### 示例 4: 流式输出分析#

```
bash复制#!/bin/bash
# analyze-stream.sh
echo "分析流式输出..."
claude --include-partial-messages -p "生成代码" | {
LINES=0
FUNCTIONS=0
CLASSES=0
while IFS= read -r line; do
LINES=$((LINES + 1))
if echo "$line" | grep -q "def "; then
FUNCTIONS=$((FUNCTIONS + 1))
fi
if echo "$line" | grep -q "class "; then
CLASSES=$((CLASSES + 1))
fi
echo "$line"
done
echo -e "\n--- 分析结果 ---"
echo "总行数: $LINES"
echo "函数数: $FUNCTIONS"
echo "类数: $CLASSES"
}
```

```
#!/bin/bash
# analyze-stream.sh
echo "分析流式输出..."
claude --include-partial-messages -p "生成代码" | {
LINES=0
FUNCTIONS=0
CLASSES=0
while IFS= read -r line; do
LINES=$((LINES + 1))
if echo "$line" | grep -q "def "; then
FUNCTIONS=$((FUNCTIONS + 1))
fi
if echo "$line" | grep -q "class "; then
CLASSES=$((CLASSES + 1))
fi
echo "$line"
done
echo -e "\n--- 分析结果 ---"
echo "总行数: $LINES"
echo "函数数: $FUNCTIONS"
echo "类数: $CLASSES"
}
```

#### 性能考虑#

##### 1. 网络延迟#

```
bash复制# 测试网络延迟对流式输出的影响
time claude --include-partial-messages -p "生成 1000 行文本"

# 比较包含和不包含部分消息的性能
time claude -p "生成 1000 行文本"
```

```
# 测试网络延迟对流式输出的影响
time claude --include-partial-messages -p "生成 1000 行文本"

# 比较包含和不包含部分消息的性能
time claude -p "生成 1000 行文本"
```

##### 2. 内存使用#

```
bash复制# 监控内存使用
/usr/bin/time -v claude --include-partial-messages -p "生成大量文本" 2>&1 | grep "Maximum resident set size"
```

```
# 监控内存使用
/usr/bin/time -v claude --include-partial-messages -p "生成大量文本" 2>&1 | grep "Maximum resident set size"
```

##### 3. 输出缓冲#

```
bash复制# 禁用输出缓冲以获得更实时的输出
stdbuf -o0 claude --include-partial-messages -p "生成文本"
```

```
# 禁用输出缓冲以获得更实时的输出
stdbuf -o0 claude --include-partial-messages -p "生成文本"
```

#### 调试技巧#

##### 1. 查看流式事件#

```
bash复制# 查看所有流式事件
claude --include-partial-messages --verbose -p "生成代码"
# 输出会包含详细的事件信息
```

```
# 查看所有流式事件
claude --include-partial-messages --verbose -p "生成代码"
# 输出会包含详细的事件信息
```

##### 2. 分析部分消息#

```
bash复制# 分析部分消息的结构
claude --include-partial-messages -p "生成文本" | cat -A

# 显示所有特殊字符
```

```
# 分析部分消息的结构
claude --include-partial-messages -p "生成文本" | cat -A

# 显示所有特殊字符
```

##### 3. 比较完整和部分消息#

```
bash复制# 保存完整输出
claude -p "生成文本" > full-output.txt
# 保存部分输出
claude --include-partial-messages -p "生成文本" > partial-output.txt
# 比较差异
diff full-output.txt partial-output.txt
```

```
# 保存完整输出
claude -p "生成文本" > full-output.txt
# 保存部分输出
claude --include-partial-messages -p "生成文本" > partial-output.txt
# 比较差异
diff full-output.txt partial-output.txt
```

#### 最佳实践#

##### 1. 选择合适的场景#

适合使用 --include-partial-messages 的场景：

- 需要实时监控输出
- 需要调试流式响应
- 需要实时处理数据

不适合使用的场景：

- 只需要最终结果
- 网络连接不稳定
- 输出量非常大

##### 2. 处理部分消息#

```
bash复制#!/bin/bash
# 正确处理部分消息
claude --include-partial-messages -p "生成文本" | {
BUFFER=""
while IFS= read -r line; do
BUFFER="$BUFFER$line"
# 检查是否是完整的句子
if echo "$BUFFER" | grep -q "\.$\|!\|?"; then
echo "完整句子: $BUFFER"
BUFFER=""
fi
done
# 处理剩余的缓冲区
if [ -n "$BUFFER" ]; then
echo "剩余部分: $BUFFER"
fi
}
```

```
#!/bin/bash
# 正确处理部分消息
claude --include-partial-messages -p "生成文本" | {
BUFFER=""
while IFS= read -r line; do
BUFFER="$BUFFER$line"
# 检查是否是完整的句子
if echo "$BUFFER" | grep -q "\.$\|!\|?"; then
echo "完整句子: $BUFFER"
BUFFER=""
fi
done
# 处理剩余的缓冲区
if [ -n "$BUFFER" ]; then
echo "剩余部分: $BUFFER"
fi
}
```

##### 3. 错误处理#

```
bash复制#!/bin/bash
# 处理流式输出错误

claude --include-partial-messages -p "生成文本" | while IFS= read -r line; do
    # 检查错误
    if echo "$line" | grep -qi "error\|错误"; then
        echo "发现错误: $line" >&2
        # 可以选择中断或继续
    fi

    echo "$line"
done
```

```
#!/bin/bash
# 处理流式输出错误

claude --include-partial-messages -p "生成文本" | while IFS= read -r line; do
    # 检查错误
    if echo "$line" | grep -qi "error\|错误"; then
        echo "发现错误: $line" >&2
        # 可以选择中断或继续
    fi

    echo "$line"
done
```

##### 4. 性能优化#

```
bash复制# 使用缓冲减少 I/O 操作
claude --include-partial-messages -p "生成文本" | stdbuf -oL grep "关键词"
# 只处理必要的部分
claude --include-partial-messages -p "生成文本" | head -100
```

```
# 使用缓冲减少 I/O 操作
claude --include-partial-messages -p "生成文本" | stdbuf -oL grep "关键词"
# 只处理必要的部分
claude --include-partial-messages -p "生成文本" | head -100
```

#### 常见问题#

##### Q1: 什么时候应该使用 --include-partial-messages？#

A: 当您需要实时监控、调试或处理流式输出时使用。如果只需要最终结果，不需要使用此标志。

##### Q2: 包含部分消息会影响性能吗？#

A: 可能会有轻微的性能影响，因为需要处理更多的消息。但对于大多数应用场景来说，影响可以忽略不计。

##### Q3: 部分消息是完整的吗？#

A: 不一定。部分消息可能是不完整的句子、段落或代码片段。

##### Q4: 如何区分完整和部分消息？#

A: 部分消息通常不包含完整的句子或代码结构。可以通过检查句子结束符（如句号、问号、感叹号）来判断。

##### Q5: 可以在交互模式中使用吗？#

A: 可以。在交互模式中使用时，会实时显示部分响应。

#### 与其他工具的集成#

##### 1. 与 grep 集成#

```
bash复制# 实时过滤流式输出
claude --include-partial-messages -p "生成代码" | grep "import "
```

```
# 实时过滤流式输出
claude --include-partial-messages -p "生成代码" | grep "import "
```

##### 2. 与 awk 集成#

```
bash复制# 实时处理流式输出
claude --include-partial-messages -p "生成文本" | awk '{print NR": "$0}'
```

```
# 实时处理流式输出
claude --include-partial-messages -p "生成文本" | awk '{print NR": "$0}'
```

##### 3. 与 sed 集成#

```
bash复制# 实时转换流式输出
claude --include-partial-messages -p "生成文本" | sed 's/foo/bar/g'
```

```
# 实时转换流式输出
claude --include-partial-messages -p "生成文本" | sed 's/foo/bar/g'
```

##### 4. 与 jq 集成#

```
bash复制# 处理 JSON 流式输出
claude --include-partial-messages --output-format json -p "生成数据" | jq '.'
```

```
# 处理 JSON 流式输出
claude --include-partial-messages --output-format json -p "生成数据" | jq '.'
```

---

## 12 --verbose - 启用详细日志记录

**URL**: https://claudecode.tangshuang.net/course/6.12%20--verbose%20-%20%E5%90%AF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95

#### 概述#

--verbose 标志启用详细的日志记录，显示 Claude Code 执行过程中的详细信息。这对于调试、问题排查和理解系统行为非常有用。

```
--verbose
```

#### 基本语法#

```
bash复制claude --verbose
```

```
claude --verbose
```

#### 日志级别#

```
--verbose
```

```
--verbose --verbose
```

#### 使用场景#

##### 1. 调试工具调用#

```
bash复制# 查看工具调用的详细信息
claude --verbose -p "读取项目中的所有 Python 文件"

# 输出会显示：
# - 哪些工具被调用
# - 工具调用的参数
# - 工具调用的结果
```

```
# 查看工具调用的详细信息
claude --verbose -p "读取项目中的所有 Python 文件"

# 输出会显示：
# - 哪些工具被调用
# - 工具调用的参数
# - 工具调用的结果
```

##### 2. 问题排查#

```
bash复制# 当遇到问题时，使用详细日志
claude --verbose -p "生成代码"
# 可以看到：
# - 请求的详细信息
# - 响应的状态
# - 错误信息（如果有）
```

```
# 当遇到问题时，使用详细日志
claude --verbose -p "生成代码"
# 可以看到：
# - 请求的详细信息
# - 响应的状态
# - 错误信息（如果有）
```

##### 3. 性能分析#

```
bash复制# 分析性能瓶颈
claude --verbose -p "处理大量数据"

# 可以看到：
# - 每个操作的耗时
# - 数据传输的大小
# - 系统资源使用情况
```

```
# 分析性能瓶颈
claude --verbose -p "处理大量数据"

# 可以看到：
# - 每个操作的耗时
# - 数据传输的大小
# - 系统资源使用情况
```

##### 4. 理解系统行为#

```
bash复制# 了解 Claude Code 的工作原理
claude --verbose -p "解释这段代码"
# 可以看到：
# - 如何解析请求
# - 如何选择工具
# - 如何生成响应
```

```
# 了解 Claude Code 的工作原理
claude --verbose -p "解释这段代码"
# 可以看到：
# - 如何解析请求
# - 如何选择工具
# - 如何生成响应
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 详细日志 + JSON 输出
claude --verbose --output-format json -p "分析代码"

# 详细日志 + 限制工具
claude --verbose --allowedTools "Read" "Grep" -p "搜索代码"

# 详细日志 + 自定义系统提示
claude --verbose --system-prompt "你是一位 Python 专家" -p "编写代码"
```

```
# 详细日志 + JSON 输出
claude --verbose --output-format json -p "分析代码"

# 详细日志 + 限制工具
claude --verbose --allowedTools "Read" "Grep" -p "搜索代码"

# 详细日志 + 自定义系统提示
claude --verbose --system-prompt "你是一位 Python 专家" -p "编写代码"
```

##### 2. 保存详细日志#

```
bash复制# 将详细日志保存到文件
claude --verbose -p "生成代码" 2>&1 | tee verbose.log
# 只保存错误日志
claude --verbose -p "生成代码" 2> error.log
```

```
# 将详细日志保存到文件
claude --verbose -p "生成代码" 2>&1 | tee verbose.log
# 只保存错误日志
claude --verbose -p "生成代码" 2> error.log
```

##### 3. 过滤日志#

```
bash复制# 只显示错误日志
claude --verbose -p "生成代码" 2>&1 | grep -i "error"

# 只显示工具调用
claude --verbose -p "生成代码" 2>&1 | grep "tool"

# 只显示时间戳
claude --verbose -p "生成代码" 2>&1 | grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}"
```

```
# 只显示错误日志
claude --verbose -p "生成代码" 2>&1 | grep -i "error"

# 只显示工具调用
claude --verbose -p "生成代码" 2>&1 | grep "tool"

# 只显示时间戳
claude --verbose -p "生成代码" 2>&1 | grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}"
```

##### 4. 实时监控#

```
bash复制# 实时监控日志输出
claude --verbose -p "生成代码" | tee -a monitor.log
# 使用 tail 实时查看日志
claude --verbose -p "生成代码" > log.txt &
tail -f log.txt
```

```
# 实时监控日志输出
claude --verbose -p "生成代码" | tee -a monitor.log
# 使用 tail 实时查看日志
claude --verbose -p "生成代码" > log.txt &
tail -f log.txt
```

#### 实际应用示例#

##### 示例 1: 调试脚本#

```
bash复制#!/bin/bash
# debug-script.sh

echo "开始调试..."
echo "详细日志将保存到 debug.log"

# 运行命令并保存详细日志
claude --verbose -p "生成代码" 2>&1 | tee debug.log

# 分析日志
echo "分析日志..."
grep -i "error" debug.log
grep "tool" debug.log | wc -l

echo "调试完成"
```

```
#!/bin/bash
# debug-script.sh

echo "开始调试..."
echo "详细日志将保存到 debug.log"

# 运行命令并保存详细日志
claude --verbose -p "生成代码" 2>&1 | tee debug.log

# 分析日志
echo "分析日志..."
grep -i "error" debug.log
grep "tool" debug.log | wc -l

echo "调试完成"
```

##### 示例 2: 性能分析#

```
bash复制#!/bin/bash
# performance-analysis.sh
echo "开始性能分析..."
# 记录开始时间
START_TIME=$(date +%s)
# 运行命令并保存详细日志
claude --verbose -p "处理大量数据" 2>&1 | tee performance.log
# 记录结束时间
END_TIME=$(date +%s)
# 计算总耗时
DURATION=$((END_TIME - START_TIME))
echo "总耗时: $DURATION 秒"
# 分析性能日志
echo "工具调用次数:"
grep "tool" performance.log | wc -l
echo "数据传输量:"
grep "bytes" performance.log | awk '{sum+=$2} END {print sum " bytes"}'
```

```
#!/bin/bash
# performance-analysis.sh
echo "开始性能分析..."
# 记录开始时间
START_TIME=$(date +%s)
# 运行命令并保存详细日志
claude --verbose -p "处理大量数据" 2>&1 | tee performance.log
# 记录结束时间
END_TIME=$(date +%s)
# 计算总耗时
DURATION=$((END_TIME - START_TIME))
echo "总耗时: $DURATION 秒"
# 分析性能日志
echo "工具调用次数:"
grep "tool" performance.log | wc -l
echo "数据传输量:"
grep "bytes" performance.log | awk '{sum+=$2} END {print sum " bytes"}'
```

##### 示例 3: 错误追踪#

```
bash复制#!/bin/bash
# error-tracker.sh

echo "开始追踪错误..."

# 运行命令并保存详细日志
claude --verbose -p "生成代码" 2>&1 | tee error.log

# 提取错误信息
echo "发现的错误:"
grep -i "error" error.log | nl

# 提取警告信息
echo "发现的警告:"
grep -i "warning" error.log | nl

# 统计错误和警告数量
ERROR_COUNT=$(grep -ic "error" error.log)
WARNING_COUNT=$(grep -ic "warning" error.log)

echo "错误总数: $ERROR_COUNT"
echo "警告总数: $WARNING_COUNT"
```

```
#!/bin/bash
# error-tracker.sh

echo "开始追踪错误..."

# 运行命令并保存详细日志
claude --verbose -p "生成代码" 2>&1 | tee error.log

# 提取错误信息
echo "发现的错误:"
grep -i "error" error.log | nl

# 提取警告信息
echo "发现的警告:"
grep -i "warning" error.log | nl

# 统计错误和警告数量
ERROR_COUNT=$(grep -ic "error" error.log)
WARNING_COUNT=$(grep -ic "warning" error.log)

echo "错误总数: $ERROR_COUNT"
echo "警告总数: $WARNING_COUNT"
```

##### 示例 4: 日志分析工具#

```
bash复制#!/bin/bash
# log-analyzer.sh
LOG_FILE=$1
if [ -z "$LOG_FILE" ]; then
echo "用法: $0 <日志文件>"
exit 1
fi
echo "分析日志文件: $LOG_FILE"
echo "---"
# 统计工具调用
echo "工具调用统计:"
grep "tool" "$LOG_FILE" | awk '{print $2}' | sort | uniq -c | sort -rn
echo "---"
# 统计错误
echo "错误统计:"
grep -i "error" "$LOG_FILE" | wc -l
echo "---"
# 统计警告
echo "警告统计:"
grep -i "warning" "$LOG_FILE" | wc -l
echo "---"
# 显示时间范围
echo "时间范围:"
grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}" "$LOG_FILE" | head -1
grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}" "$LOG_FILE" | tail -1
```

```
#!/bin/bash
# log-analyzer.sh
LOG_FILE=$1
if [ -z "$LOG_FILE" ]; then
echo "用法: $0 <日志文件>"
exit 1
fi
echo "分析日志文件: $LOG_FILE"
echo "---"
# 统计工具调用
echo "工具调用统计:"
grep "tool" "$LOG_FILE" | awk '{print $2}' | sort | uniq -c | sort -rn
echo "---"
# 统计错误
echo "错误统计:"
grep -i "error" "$LOG_FILE" | wc -l
echo "---"
# 统计警告
echo "警告统计:"
grep -i "warning" "$LOG_FILE" | wc -l
echo "---"
# 显示时间范围
echo "时间范围:"
grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}" "$LOG_FILE" | head -1
grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}" "$LOG_FILE" | tail -1
```

#### 日志内容说明#

##### 1. 请求日志#

```
log复制[2024-01-15 10:30:00] INFO: Request received
[2024-01-15 10:30:00] INFO: Query: "生成代码"
[2024-01-15 10:30:00] INFO: Model: claude-opus-4-5
```

```
[2024-01-15 10:30:00] INFO: Request received
[2024-01-15 10:30:00] INFO: Query: "生成代码"
[2024-01-15 10:30:00] INFO: Model: claude-opus-4-5
```

##### 2. 工具调用日志#

```
log复制[2024-01-15 10:30:01] INFO: Tool called: Read
[2024-01-15 10:30:01] INFO: Parameters: {"file_path": "src/main.py"}
[2024-01-15 10:30:01] INFO: Result: Success
```

```
[2024-01-15 10:30:01] INFO: Tool called: Read
[2024-01-15 10:30:01] INFO: Parameters: {"file_path": "src/main.py"}
[2024-01-15 10:30:01] INFO: Result: Success
```

##### 3. 响应日志#

```
log复制[2024-01-15 10:30:02] INFO: Response generated
[2024-01-15 10:30:02] INFO: Tokens: 150
[2024-01-15 10:30:02] INFO: Duration: 1.5s
```

```
[2024-01-15 10:30:02] INFO: Response generated
[2024-01-15 10:30:02] INFO: Tokens: 150
[2024-01-15 10:30:02] INFO: Duration: 1.5s
```

##### 4. 错误日志#

```
log复制[2024-01-15 10:30:03] ERROR: Tool failed: Write
[2024-01-15 10:30:03] ERROR: Error: Permission denied
```

```
[2024-01-15 10:30:03] ERROR: Tool failed: Write
[2024-01-15 10:30:03] ERROR: Error: Permission denied
```

#### 最佳实践#

##### 1. 选择合适的日志级别#

```
bash复制# 正常使用：不需要详细日志
claude -p "生成代码"

# 调试问题：使用详细日志
claude --verbose -p "生成代码"

# 深度调试：使用更详细的日志
claude --verbose --verbose -p "生成代码"
```

```
# 正常使用：不需要详细日志
claude -p "生成代码"

# 调试问题：使用详细日志
claude --verbose -p "生成代码"

# 深度调试：使用更详细的日志
claude --verbose --verbose -p "生成代码"
```

##### 2. 保存日志以便分析#

```
bash复制# 为每次运行创建单独的日志文件
LOG_FILE="claude-$(date +%Y%m%d-%H%M%S).log"
claude --verbose -p "生成代码" 2>&1 | tee "$LOG_FILE"
```

```
# 为每次运行创建单独的日志文件
LOG_FILE="claude-$(date +%Y%m%d-%H%M%S).log"
claude --verbose -p "生成代码" 2>&1 | tee "$LOG_FILE"
```

##### 3. 定期清理日志#

```
bash复制# 清理 7 天前的日志
find . -name "claude-*.log" -mtime +7 -delete
```

```
# 清理 7 天前的日志
find . -name "claude-*.log" -mtime +7 -delete
```

##### 4. 使用日志分析工具#

```
bash复制# 使用 grep 过滤日志
claude --verbose -p "生成代码" 2>&1 | grep "ERROR"
# 使用 awk 分析日志
claude --verbose -p "生成代码" 2>&1 | awk '{print $1, $2, $5}'
# 使用 sed 格式化日志
claude --verbose -p "生成代码" 2>&1 | sed 's/INFO:/\x1b[32mINFO:\x1b[0m/g'
```

```
# 使用 grep 过滤日志
claude --verbose -p "生成代码" 2>&1 | grep "ERROR"
# 使用 awk 分析日志
claude --verbose -p "生成代码" 2>&1 | awk '{print $1, $2, $5}'
# 使用 sed 格式化日志
claude --verbose -p "生成代码" 2>&1 | sed 's/INFO:/\x1b[32mINFO:\x1b[0m/g'
```

#### 常见问题#

##### Q1: 详细日志会影响性能吗？#

A: 会有轻微的性能影响，因为需要记录更多的信息。但对于大多数应用场景来说，影响可以忽略不计。

##### Q2: 如何只查看特定类型的日志？#

A: 使用 grep 过滤日志输出：

```
bash复制claude --verbose -p "生成代码" 2>&1 | grep "ERROR"
```

```
claude --verbose -p "生成代码" 2>&1 | grep "ERROR"
```

##### Q3: 日志文件会变得很大吗？#

A: 会。建议定期清理旧日志，或者使用日志轮转工具。

##### Q4: 可以自定义日志格式吗？#

A: 不可以直接自定义。但可以使用 sed、awk 等工具格式化日志输出。

##### Q5: 如何在日志中添加自定义信息？#

A: 可以在命令中添加 echo 语句：

```
bash复制echo "开始处理..." | tee -a log.txt
claude --verbose -p "生成代码" 2>&1 | tee -a log.txt
echo "处理完成" | tee -a log.txt
```

```
echo "开始处理..." | tee -a log.txt
claude --verbose -p "生成代码" 2>&1 | tee -a log.txt
echo "处理完成" | tee -a log.txt
```

#### 与其他工具的集成#

##### 1. 与 grep 集成#

```
bash复制# 过滤错误日志
claude --verbose -p "生成代码" 2>&1 | grep -i "error"

# 过滤工具调用
claude --verbose -p "生成代码" 2>&1 | grep "tool"
```

```
# 过滤错误日志
claude --verbose -p "生成代码" 2>&1 | grep -i "error"

# 过滤工具调用
claude --verbose -p "生成代码" 2>&1 | grep "tool"
```

##### 2. 与 awk 集成#

```
bash复制# 提取特定字段
claude --verbose -p "生成代码" 2>&1 | awk '{print $1, $5}'
# 统计工具调用次数
claude --verbose -p "生成代码" 2>&1 | awk '/tool/ {count++} END {print count}'
```

```
# 提取特定字段
claude --verbose -p "生成代码" 2>&1 | awk '{print $1, $5}'
# 统计工具调用次数
claude --verbose -p "生成代码" 2>&1 | awk '/tool/ {count++} END {print count}'
```

##### 3. 与 sed 集成#

```
bash复制# 高亮显示错误
claude --verbose -p "生成代码" 2>&1 | sed 's/ERROR:/\x1b[31mERROR:\x1b[0m/g'

# 格式化时间戳
claude --verbose -p "生成代码" 2>&1 | sed 's/\[//g' | sed 's/\]//g'
```

```
# 高亮显示错误
claude --verbose -p "生成代码" 2>&1 | sed 's/ERROR:/\x1b[31mERROR:\x1b[0m/g'

# 格式化时间戳
claude --verbose -p "生成代码" 2>&1 | sed 's/\[//g' | sed 's/\]//g'
```

##### 4. 与日志管理工具集成#

```
bash复制# 使用 logrotate 管理日志
# /etc/logrotate.d/claude
/path/to/claude-*.log {
daily
rotate 7
compress
missingok
notifempty
}
```

```
# 使用 logrotate 管理日志
# /etc/logrotate.d/claude
/path/to/claude-*.log {
daily
rotate 7
compress
missingok
notifempty
}
```

---

## 13 --max-turns - 限制非交互模式中的代理轮数

**URL**: https://claudecode.tangshuang.net/course/6.13%20--max-turns%20-%20%E9%99%90%E5%88%B6%E9%9D%9E%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E8%BD%AE%E6%95%B0

#### 概述#

--max-turns 标志允许您限制非交互模式中代理的轮数（对话轮次）。这对于控制执行时间、资源使用和防止无限循环非常有用。

```
--max-turns
```

#### 基本语法#

```
bash复制claude --max-turns <数字>
```

```
claude --max-turns <数字>
```

#### 参数说明#

```
<数字>
```

#### 使用场景#

##### 1. 限制执行时间#

```
bash复制# 限制代理最多执行 5 轮
claude --max-turns 5 -p "分析项目中的所有文件"
# 代理会在 5 轮后停止，即使任务未完成
```

```
# 限制代理最多执行 5 轮
claude --max-turns 5 -p "分析项目中的所有文件"
# 代理会在 5 轮后停止，即使任务未完成
```

##### 2. 控制资源使用#

```
bash复制# 限制轮数以控制 API 调用次数
claude --max-turns 10 -p "生成完整的测试套件"
# 避免过多的 API 调用和资源消耗
```

```
# 限制轮数以控制 API 调用次数
claude --max-turns 10 -p "生成完整的测试套件"
# 避免过多的 API 调用和资源消耗
```

##### 3. 防止无限循环#

```
bash复制# 防止代理陷入无限循环
claude --max-turns 3 -p "递归处理所有子目录"
# 即使代理尝试继续，也会在 3 轮后停止
```

```
# 防止代理陷入无限循环
claude --max-turns 3 -p "递归处理所有子目录"
# 即使代理尝试继续，也会在 3 轮后停止
```

##### 4. 快速原型开发#

```
bash复制# 快速获取初步结果
claude --max-turns 2 -p "设计系统架构"
# 获取初步想法，不进行深入分析
```

```
# 快速获取初步结果
claude --max-turns 2 -p "设计系统架构"
# 获取初步想法，不进行深入分析
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 限制轮数 + 指定模型
claude --max-turns 5 --model opus -p "生成代码"

# 限制轮数 + 限制工具
claude --max-turns 3 --allowedTools "Read" "Grep" -p "搜索代码"

# 限制轮数 + JSON 输出
claude --max-turns 10 --output-format json -p "分析数据"
```

```
# 限制轮数 + 指定模型
claude --max-turns 5 --model opus -p "生成代码"

# 限制轮数 + 限制工具
claude --max-turns 3 --allowedTools "Read" "Grep" -p "搜索代码"

# 限制轮数 + JSON 输出
claude --max-turns 10 --output-format json -p "分析数据"
```

##### 2. 渐进式执行#

```
bash复制#!/bin/bash
# progressive-execution.sh
# 第一轮：快速分析
echo "第一轮：快速分析"
claude --max-turns 1 -p "分析项目结构" > analysis-round1.txt
# 第二轮：深入分析
echo "第二轮：深入分析"
claude --max-turns 2 -p "基于初步分析，深入分析代码" > analysis-round2.txt
# 第三轮：生成建议
echo "第三轮：生成建议"
claude --max-turns 3 -p "基于分析结果，生成改进建议" > suggestions.txt
echo "渐进式执行完成"
```

```
#!/bin/bash
# progressive-execution.sh
# 第一轮：快速分析
echo "第一轮：快速分析"
claude --max-turns 1 -p "分析项目结构" > analysis-round1.txt
# 第二轮：深入分析
echo "第二轮：深入分析"
claude --max-turns 2 -p "基于初步分析，深入分析代码" > analysis-round2.txt
# 第三轮：生成建议
echo "第三轮：生成建议"
claude --max-turns 3 -p "基于分析结果，生成改进建议" > suggestions.txt
echo "渐进式执行完成"
```

##### 3. 动态调整轮数#

```
bash复制#!/bin/bash
# dynamic-turns.sh

# 根据任务复杂度动态调整轮数
TASK=$1

case "$TASK" in
    "simple")
        MAX_TURNS=2
        ;;
    "medium")
        MAX_TURNS=5
        ;;
    "complex")
        MAX_TURNS=10
        ;;
    *)
        MAX_TURNS=3
        ;;
esac

echo "执行任务: $TASK (最大轮数: $MAX_TURNS)"
claude --max-turns "$MAX_TURNS" -p "完成这个任务"
```

```
#!/bin/bash
# dynamic-turns.sh

# 根据任务复杂度动态调整轮数
TASK=$1

case "$TASK" in
    "simple")
        MAX_TURNS=2
        ;;
    "medium")
        MAX_TURNS=5
        ;;
    "complex")
        MAX_TURNS=10
        ;;
    *)
        MAX_TURNS=3
        ;;
esac

echo "执行任务: $TASK (最大轮数: $MAX_TURNS)"
claude --max-turns "$MAX_TURNS" -p "完成这个任务"
```

##### 4. 超时控制#

```
bash复制#!/bin/bash
# timeout-control.sh
MAX_TURNS=5
TIMEOUT=60
# 使用 timeout 命令限制总时间
timeout "$TIMEOUT" claude --max-turns "$MAX_TURNS" -p "生成代码"
if [ $? -eq 124 ]; then
echo "任务超时"
else
echo "任务完成"
fi
```

```
#!/bin/bash
# timeout-control.sh
MAX_TURNS=5
TIMEOUT=60
# 使用 timeout 命令限制总时间
timeout "$TIMEOUT" claude --max-turns "$MAX_TURNS" -p "生成代码"
if [ $? -eq 124 ]; then
echo "任务超时"
else
echo "任务完成"
fi
```

#### 实际应用示例#

##### 示例 1: 代码审查#

```
bash复制#!/bin/bash
# code-review.sh

FILE=$1

# 第一轮：快速审查
echo "快速审查..."
claude --max-turns 2 -p "快速审查 $FILE 的代码质量" > quick-review.txt

# 第二轮：详细审查
echo "详细审查..."
claude --max-turns 5 -p "详细审查 $FILE，包括安全性、性能和可维护性" > detailed-review.txt

# 第三轮：生成修复建议
echo "生成修复建议..."
claude --max-turns 3 -p "基于审查结果，生成具体的修复建议" > fixes.txt

echo "代码审查完成"
```

```
#!/bin/bash
# code-review.sh

FILE=$1

# 第一轮：快速审查
echo "快速审查..."
claude --max-turns 2 -p "快速审查 $FILE 的代码质量" > quick-review.txt

# 第二轮：详细审查
echo "详细审查..."
claude --max-turns 5 -p "详细审查 $FILE，包括安全性、性能和可维护性" > detailed-review.txt

# 第三轮：生成修复建议
echo "生成修复建议..."
claude --max-turns 3 -p "基于审查结果，生成具体的修复建议" > fixes.txt

echo "代码审查完成"
```

##### 示例 2: 文档生成#

```
bash复制#!/bin/bash
# generate-docs.sh
# 第一轮：生成大纲
echo "生成大纲..."
claude --max-turns 2 -p "为项目生成文档大纲" > outline.md
# 第二轮：生成内容
echo "生成内容..."
claude --max-turns 10 -p "基于大纲，生成完整的文档内容" > docs.md
# 第三轮：完善文档
echo "完善文档..."
claude --max-turns 3 -p "完善文档，添加示例和说明" > final-docs.md
echo "文档生成完成"
```

```
#!/bin/bash
# generate-docs.sh
# 第一轮：生成大纲
echo "生成大纲..."
claude --max-turns 2 -p "为项目生成文档大纲" > outline.md
# 第二轮：生成内容
echo "生成内容..."
claude --max-turns 10 -p "基于大纲，生成完整的文档内容" > docs.md
# 第三轮：完善文档
echo "完善文档..."
claude --max-turns 3 -p "完善文档，添加示例和说明" > final-docs.md
echo "文档生成完成"
```

##### 示例 3: 测试生成#

```
bash复制#!/bin/bash
# generate-tests.sh

# 第一轮：分析代码
echo "分析代码..."
claude --max-turns 3 -p "分析 src/ 目录下的代码结构" > analysis.txt

# 第二轮：生成测试用例
echo "生成测试用例..."
claude --max-turns 5 -p "基于分析结果，生成测试用例" > test-cases.txt

# 第三轮：生成测试代码
echo "生成测试代码..."
claude --max-turns 10 -p "将测试用例转换为 pytest 代码" > tests.py

echo "测试生成完成"
```

```
#!/bin/bash
# generate-tests.sh

# 第一轮：分析代码
echo "分析代码..."
claude --max-turns 3 -p "分析 src/ 目录下的代码结构" > analysis.txt

# 第二轮：生成测试用例
echo "生成测试用例..."
claude --max-turns 5 -p "基于分析结果，生成测试用例" > test-cases.txt

# 第三轮：生成测试代码
echo "生成测试代码..."
claude --max-turns 10 -p "将测试用例转换为 pytest 代码" > tests.py

echo "测试生成完成"
```

##### 示例 4: 重构代码#

```
bash复制#!/bin/bash
# refactor-code.sh
FILE=$1
# 第一轮：分析问题
echo "分析问题..."
claude --max-turns 2 -p "分析 $FILE 中的代码问题" > problems.txt
# 第二轮：设计重构方案
echo "设计重构方案..."
claude --max-turns 3 -p "设计重构方案" > refactor-plan.txt
# 第三轮：执行重构
echo "执行重构..."
claude --max-turns 10 -p "执行重构，生成重构后的代码" > refactored-code.py
echo "重构完成"
```

```
#!/bin/bash
# refactor-code.sh
FILE=$1
# 第一轮：分析问题
echo "分析问题..."
claude --max-turns 2 -p "分析 $FILE 中的代码问题" > problems.txt
# 第二轮：设计重构方案
echo "设计重构方案..."
claude --max-turns 3 -p "设计重构方案" > refactor-plan.txt
# 第三轮：执行重构
echo "执行重构..."
claude --max-turns 10 -p "执行重构，生成重构后的代码" > refactored-code.py
echo "重构完成"
```

#### 轮数选择建议#

##### 1. 简单任务：1-2 轮#

```
bash复制# 简单查询
claude --max-turns 1 -p "解释什么是递归"

# 快速检查
claude --max-turns 2 -p "检查代码语法"
```

```
# 简单查询
claude --max-turns 1 -p "解释什么是递归"

# 快速检查
claude --max-turns 2 -p "检查代码语法"
```

##### 2. 中等任务：3-5 轮#

```
bash复制# 代码审查
claude --max-turns 3 -p "审查代码质量"
# 文档生成
claude --max-turns 5 -p "生成 API 文档"
```

```
# 代码审查
claude --max-turns 3 -p "审查代码质量"
# 文档生成
claude --max-turns 5 -p "生成 API 文档"
```

##### 3. 复杂任务：6-10 轮#

```
bash复制# 完整功能开发
claude --max-turns 10 -p "开发一个 REST API"

# 系统设计
claude --max-turns 8 -p "设计微服务架构"
```

```
# 完整功能开发
claude --max-turns 10 -p "开发一个 REST API"

# 系统设计
claude --max-turns 8 -p "设计微服务架构"
```

##### 4. 非常复杂的任务：10+ 轮#

```
bash复制# 大型项目重构
claude --max-turns 15 -p "重构整个项目"
# 完整测试套件生成
claude --max-turns 20 -p "为整个项目生成测试"
```

```
# 大型项目重构
claude --max-turns 15 -p "重构整个项目"
# 完整测试套件生成
claude --max-turns 20 -p "为整个项目生成测试"
```

#### 最佳实践#

##### 1. 从小轮数开始#

```
bash复制# 先用小轮数测试
claude --max-turns 2 -p "生成代码"

# 如果需要，增加轮数
claude --max-turns 5 -p "生成代码"
```

```
# 先用小轮数测试
claude --max-turns 2 -p "生成代码"

# 如果需要，增加轮数
claude --max-turns 5 -p "生成代码"
```

##### 2. 监控执行进度#

```
bash复制#!/bin/bash
# monitor-progress.sh
MAX_TURNS=5
for i in $(seq 1 $MAX_TURNS); do
echo "轮次 $i/$MAX_TURNS"
claude --max-turns 1 -p "继续任务" > "turn-$i.txt"
# 检查是否完成
if grep -q "完成" "turn-$i.txt"; then
echo "任务已完成"
break
fi
done
```

```
#!/bin/bash
# monitor-progress.sh
MAX_TURNS=5
for i in $(seq 1 $MAX_TURNS); do
echo "轮次 $i/$MAX_TURNS"
claude --max-turns 1 -p "继续任务" > "turn-$i.txt"
# 检查是否完成
if grep -q "完成" "turn-$i.txt"; then
echo "任务已完成"
break
fi
done
```

##### 3. 保存中间结果#

```
bash复制#!/bin/bash
# save-intermediate.sh

MAX_TURNS=5

for i in $(seq 1 $MAX_TURNS); do
    claude --max-turns 1 -p "继续任务" > "intermediate-$i.txt"

    # 检查是否需要继续
    if [ $? -ne 0 ]; then
        echo "任务失败"
        break
    fi
done
```

```
#!/bin/bash
# save-intermediate.sh

MAX_TURNS=5

for i in $(seq 1 $MAX_TURNS); do
    claude --max-turns 1 -p "继续任务" > "intermediate-$i.txt"

    # 检查是否需要继续
    if [ $? -ne 0 ]; then
        echo "任务失败"
        break
    fi
done
```

##### 4. 错误处理#

```
bash复制#!/bin/bash
# error-handling.sh
MAX_TURNS=5
claude --max-turns "$MAX_TURNS" -p "生成代码" 2>&1 | tee output.txt
# 检查是否达到最大轮数
if grep -q "max turns" output.txt; then
echo "警告：达到最大轮数，任务可能未完成"
fi
```

```
#!/bin/bash
# error-handling.sh
MAX_TURNS=5
claude --max-turns "$MAX_TURNS" -p "生成代码" 2>&1 | tee output.txt
# 检查是否达到最大轮数
if grep -q "max turns" output.txt; then
echo "警告：达到最大轮数，任务可能未完成"
fi
```

#### 常见问题#

##### Q1: 如何选择合适的轮数？#

A: 根据任务复杂度选择。简单任务 1-2 轮，中等任务 3-5 轮，复杂任务 6-10 轮。

##### Q2: 达到最大轮数后会发生什么？#

A: 代理会停止执行，即使任务未完成。建议检查输出并决定是否增加轮数。

##### Q3: 可以在交互模式中使用吗？#

A: 不可以。--max-turns 只适用于非交互模式（使用 -p 标志）。

```
--max-turns
```

```
-p
```

##### Q4: 如何知道任务是否完成？#

A: 检查输出中是否包含完成指示，或者根据输出内容判断。

##### Q5: 轮数限制会影响结果质量吗？#

A: 可能会。如果轮数太少，任务可能无法完成。建议根据任务复杂度选择合适的轮数。

#### 与其他标志的组合示例#

##### 与其他标志的组合示例#

##### 1. 完整的开发流程#

```
bash复制#!/bin/bash
# full-development.sh

# 分析阶段
claude --max-turns 3 -p "分析需求" > analysis.txt

# 设计阶段
claude --max-turns 5 -p "设计系统架构" > design.txt

# 实现阶段
claude --max-turns 10 -p "实现功能" > implementation.txt

# 测试阶段
claude --max-turns 5 -p "生成测试" > tests.txt

echo "开发流程完成"
```

```
#!/bin/bash
# full-development.sh

# 分析阶段
claude --max-turns 3 -p "分析需求" > analysis.txt

# 设计阶段
claude --max-turns 5 -p "设计系统架构" > design.txt

# 实现阶段
claude --max-turns 10 -p "实现功能" > implementation.txt

# 测试阶段
claude --max-turns 5 -p "生成测试" > tests.txt

echo "开发流程完成"
```

##### 2. 迭代优化#

```
bash复制#!/bin/bash
# iterative-optimization.sh
for i in 1 2 3; do
echo "迭代 $i"
claude --max-turns 3 -p "优化代码" > "optimization-$i.txt"
# 检查是否需要继续
if grep -q "无需优化" "optimization-$i.txt"; then
echo "优化完成"
break
fi
done
```

```
#!/bin/bash
# iterative-optimization.sh
for i in 1 2 3; do
echo "迭代 $i"
claude --max-turns 3 -p "优化代码" > "optimization-$i.txt"
# 检查是否需要继续
if grep -q "无需优化" "optimization-$i.txt"; then
echo "优化完成"
break
fi
done
```

##### 3. 分阶段执行#

```
bash复制#!/bin/bash
# staged-execution.sh

# 阶段 1：快速原型
claude --max-turns 2 -p "创建快速原型" > prototype.txt

# 阶段 2：完善功能
claude --max-turns 5 -p "完善原型功能" > refined.txt

# 阶段 3：最终实现
claude --max-turns 10 -p "实现最终版本" > final.txt

echo "分阶段执行完成"
```

```
#!/bin/bash
# staged-execution.sh

# 阶段 1：快速原型
claude --max-turns 2 -p "创建快速原型" > prototype.txt

# 阶段 2：完善功能
claude --max-turns 5 -p "完善原型功能" > refined.txt

# 阶段 3：最终实现
claude --max-turns 10 -p "实现最终版本" > final.txt

echo "分阶段执行完成"
```

#### 总结#

--max-turns 标志提供了一种控制非交互模式中代理执行轮数的方式。通过使用此标志，您可以：

```
--max-turns
```

- 限制执行时间和资源使用
- 防止无限循环
- 实现渐进式执行
- 控制成本和效率

合理使用 --max-turns 可以帮助您更好地控制代理行为，特别是在需要限制执行时间或资源的场景中。

```
--max-turns
```

---

## 14 --model - 设置会话模型

**URL**: https://claudecode.tangshuang.net/course/6.14%20--model%20-%20%E8%AE%BE%E7%BD%AE%E4%BC%9A%E8%AF%9D%E6%A8%A1%E5%9E%8B

#### 概述#

--model 标志允许您指定 Claude Code 使用的模型。不同的模型有不同的性能、速度和成本特点，您可以根据任务需求选择合适的模型。

```
--model
```

#### 基本语法#

```
bash复制claude --model <模型名称>
```

```
claude --model <模型名称>
```

```
bash复制
## 可用模型
Claude 是由 Anthropic 开发的最先进的大型语言模型系列。所有当前的 Claude 模型都支持文本和图像输入、文本输出、多语言功能和视觉能力。

| 模型 | Claude API ID | 描述 | 适用场景 | 相对速度 | 上下文窗口 |
|------|---------------|------|----------|----------|------------|
| Claude Opus 4.5 | `claude-opus-4-5-20251101` | 结合最大智能和实际性能的高级模型 | 复杂任务、深度分析、高级代码生成 | 中等 | 200K 令牌 |
| Claude Sonnet 4.5 | `claude-sonnet-4-5-20250929` | 用于复杂代理和编码的智能模型，提供最佳的智能、速度和成本平衡 | 一般编程任务、文档生成、代理任务 | 快速 | 200K 令牌 / 1M 令牌(测试版) |
| Claude Haiku 4.5 | `claude-haiku-4-5-20251001` | 最快的模型，具有接近前沿的智能 | 快速查询、简单任务、快速原型 | 最快 | 200K 令牌 |

**别名支持**：您也可以使用更简洁的别名 `claude-opus-4-5`、`claude-sonnet-4-5` 和 `claude-haiku-4-5`，这些别名会自动指向最新的模型快照。
## 使用场景
### 1. 复杂任务使用 Opus

```bash
# 复杂的代码生成
claude --model claude-opus-4-5 -p "生成一个完整的微服务架构"
# 或使用完整模型 ID
claude --model claude-opus-4-5-20251101 -p "生成一个完整的微服务架构"

# 深度代码分析
claude --model claude-opus-4-5 -p "分析这个大型项目的架构问题"
```

```
## 可用模型
Claude 是由 Anthropic 开发的最先进的大型语言模型系列。所有当前的 Claude 模型都支持文本和图像输入、文本输出、多语言功能和视觉能力。

| 模型 | Claude API ID | 描述 | 适用场景 | 相对速度 | 上下文窗口 |
|------|---------------|------|----------|----------|------------|
| Claude Opus 4.5 | `claude-opus-4-5-20251101` | 结合最大智能和实际性能的高级模型 | 复杂任务、深度分析、高级代码生成 | 中等 | 200K 令牌 |
| Claude Sonnet 4.5 | `claude-sonnet-4-5-20250929` | 用于复杂代理和编码的智能模型，提供最佳的智能、速度和成本平衡 | 一般编程任务、文档生成、代理任务 | 快速 | 200K 令牌 / 1M 令牌(测试版) |
| Claude Haiku 4.5 | `claude-haiku-4-5-20251001` | 最快的模型，具有接近前沿的智能 | 快速查询、简单任务、快速原型 | 最快 | 200K 令牌 |

**别名支持**：您也可以使用更简洁的别名 `claude-opus-4-5`、`claude-sonnet-4-5` 和 `claude-haiku-4-5`，这些别名会自动指向最新的模型快照。
## 使用场景
### 1. 复杂任务使用 Opus

```bash
# 复杂的代码生成
claude --model claude-opus-4-5 -p "生成一个完整的微服务架构"
# 或使用完整模型 ID
claude --model claude-opus-4-5-20251101 -p "生成一个完整的微服务架构"

# 深度代码分析
claude --model claude-opus-4-5 -p "分析这个大型项目的架构问题"
```

##### 2. 一般任务使用 Sonnet#

```
bash复制# 一般的代码编写
claude --model claude-sonnet-4-5 -p "编写一个用户认证模块"

# 文档生成
claude --model claude-sonnet-4-5 -p "为这个 API 生成文档"
```

```
# 一般的代码编写
claude --model claude-sonnet-4-5 -p "编写一个用户认证模块"

# 文档生成
claude --model claude-sonnet-4-5 -p "为这个 API 生成文档"
```

##### 3. 快速任务使用 Haiku#

```
bash复制# 快速查询
claude --model claude-haiku-4-5 -p "这个函数是做什么的？"

# 简单的代码修复
claude --model claude-haiku-4-5 -p "修复这个语法错误"
```

```
# 快速查询
claude --model claude-haiku-4-5 -p "这个函数是做什么的？"

# 简单的代码修复
claude --model claude-haiku-4-5 -p "修复这个语法错误"
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 指定模型 + JSON 输出
claude --model claude-opus-4-5 --output-format json -p "分析代码"

# 指定模型 + 限制工具
claude --model claude-sonnet-4-5 --allowedTools "Read" "Grep" -p "搜索代码"

# 指定模型 + 自定义系统提示
claude --model  --system-prompt "你是一位 Python 专家" -p "编写代码"
```

```
# 指定模型 + JSON 输出
claude --model claude-opus-4-5 --output-format json -p "分析代码"

# 指定模型 + 限制工具
claude --model claude-sonnet-4-5 --allowedTools "Read" "Grep" -p "搜索代码"

# 指定模型 + 自定义系统提示
claude --model  --system-prompt "你是一位 Python 专家" -p "编写代码"
```

##### 2. 根据任务类型选择模型#

```
bash复制#!/bin/bash
# select-model.sh
TASK_TYPE=$1
case "$TASK_TYPE" in
"complex")
MODEL="claude-opus-4-5"
;;
"general")
MODEL="claude-sonnet-4-5"
;;
"fast")
MODEL="claude-haiku-4-5"
;;
"latest")
MODEL=""
;;
*)
MODEL="claude-sonnet-4-5"
;;
esac
echo "使用模型: $MODEL"
claude --model "$MODEL" -p "完成任务"
```

```
#!/bin/bash
# select-model.sh
TASK_TYPE=$1
case "$TASK_TYPE" in
"complex")
MODEL="claude-opus-4-5"
;;
"general")
MODEL="claude-sonnet-4-5"
;;
"fast")
MODEL="claude-haiku-4-5"
;;
"latest")
MODEL=""
;;
*)
MODEL="claude-sonnet-4-5"
;;
esac
echo "使用模型: $MODEL"
claude --model "$MODEL" -p "完成任务"
```

##### 3. 模型性能比较#

```
bash复制#!/bin/bash
# compare-models.sh

TASK="分析这个 Python 文件的性能"

echo "比较不同模型的性能..."

for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
    echo "测试模型: $model"
    time claude --model "$model" -p "$TASK" > "result-$model.txt"
    echo "---"
done

echo "性能比较完成"
```

```
#!/bin/bash
# compare-models.sh

TASK="分析这个 Python 文件的性能"

echo "比较不同模型的性能..."

for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
    echo "测试模型: $model"
    time claude --model "$model" -p "$TASK" > "result-$model.txt"
    echo "---"
done

echo "性能比较完成"
```

##### 4. 成本优化#

```
bash复制#!/bin/bash
# cost-optimization.sh
# 根据任务复杂度选择模型
TASK=$1
# 简单任务使用 Haiku
if echo "$TASK" | grep -qi "简单\|快速\|查询"; then
MODEL="claude-haiku-4-5"
# 复杂任务使用 Opus
elif echo "$TASK" | grep -qi "复杂\|深度\|分析"; then
MODEL="claude-opus-4-5"
# 一般任务使用 Sonnet
else
MODEL="claude-sonnet-4-5"
fi
echo "使用模型: $MODEL (成本优化)"
claude --model "$MODEL" -p "$TASK"
```

```
#!/bin/bash
# cost-optimization.sh
# 根据任务复杂度选择模型
TASK=$1
# 简单任务使用 Haiku
if echo "$TASK" | grep -qi "简单\|快速\|查询"; then
MODEL="claude-haiku-4-5"
# 复杂任务使用 Opus
elif echo "$TASK" | grep -qi "复杂\|深度\|分析"; then
MODEL="claude-opus-4-5"
# 一般任务使用 Sonnet
else
MODEL="claude-sonnet-4-5"
fi
echo "使用模型: $MODEL (成本优化)"
claude --model "$MODEL" -p "$TASK"
```

#### 实际应用示例#

##### 示例 1: 分层开发#

```
bash复制#!/bin/bash
# layered-development.sh

# 第一层：快速原型（Haiku）
echo "快速原型..."
claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

# 第二层：功能完善（Sonnet）
echo "功能完善..."
claude --model claude-sonnet-4-5 -p "完善原型功能" > refined.txt

# 第三层：深度优化（Opus）
echo "深度优化..."
claude --model claude-opus-4-5 -p "优化性能和安全性" > optimized.txt

echo "分层开发完成"
```

```
#!/bin/bash
# layered-development.sh

# 第一层：快速原型（Haiku）
echo "快速原型..."
claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

# 第二层：功能完善（Sonnet）
echo "功能完善..."
claude --model claude-sonnet-4-5 -p "完善原型功能" > refined.txt

# 第三层：深度优化（Opus）
echo "深度优化..."
claude --model claude-opus-4-5 -p "优化性能和安全性" > optimized.txt

echo "分层开发完成"
```

##### 示例 2: 代码审查流程#

```
bash复制#!/bin/bash
# code-review-flow.sh
FILE=$1
# 第一轮：快速检查（Haiku）
echo "快速检查..."
claude --model claude-haiku-4-5 -p "快速检查 $FILE 的语法错误" > quick-check.txt
# 第二轮：标准审查（Sonnet）
echo "标准审查..."
claude --model claude-sonnet-4-5 -p "审查 $FILE 的代码质量" > standard-review.txt
# 第三轮：深度分析（Opus）
echo "深度分析..."
claude --model claude-opus-4-5 -p "深度分析 $FILE 的架构和设计" > deep-analysis.txt
echo "代码审查完成"
```

```
#!/bin/bash
# code-review-flow.sh
FILE=$1
# 第一轮：快速检查（Haiku）
echo "快速检查..."
claude --model claude-haiku-4-5 -p "快速检查 $FILE 的语法错误" > quick-check.txt
# 第二轮：标准审查（Sonnet）
echo "标准审查..."
claude --model claude-sonnet-4-5 -p "审查 $FILE 的代码质量" > standard-review.txt
# 第三轮：深度分析（Opus）
echo "深度分析..."
claude --model claude-opus-4-5 -p "深度分析 $FILE 的架构和设计" > deep-analysis.txt
echo "代码审查完成"
```

##### 示例 3: 文档生成#

```
bash复制#!/bin/bash
# generate-docs.sh

# 生成大纲（Haiku）
echo "生成大纲..."
claude --model claude-haiku-4-5 -p "生成文档大纲" > outline.txt

# 生成内容（Sonnet）
echo "生成内容..."
claude --model claude-sonnet-4-5 -p "生成文档内容" > content.txt

# 完善文档（Opus）
echo "完善文档..."
claude --model claude-opus-4-5 -p "完善文档，添加示例和最佳实践" > final-docs.txt

echo "文档生成完成"
```

```
#!/bin/bash
# generate-docs.sh

# 生成大纲（Haiku）
echo "生成大纲..."
claude --model claude-haiku-4-5 -p "生成文档大纲" > outline.txt

# 生成内容（Sonnet）
echo "生成内容..."
claude --model claude-sonnet-4-5 -p "生成文档内容" > content.txt

# 完善文档（Opus）
echo "完善文档..."
claude --model claude-opus-4-5 -p "完善文档，添加示例和最佳实践" > final-docs.txt

echo "文档生成完成"
```

##### 示例 4: 测试生成#

```
bash复制#!/bin/bash
# generate-tests.sh
# 分析代码（Sonnet）
echo "分析代码..."
claude --model claude-sonnet-4-5 -p "分析代码结构" > analysis.txt
# 生成测试用例（Sonnet）
echo "生成测试用例..."
claude --model claude-sonnet-4-5 -p "生成测试用例" > test-cases.txt
# 生成测试代码（Opus）
echo "生成测试代码..."
claude --model claude-opus-4-5 -p "生成完整的测试代码" > tests.py
echo "测试生成完成"
```

```
#!/bin/bash
# generate-tests.sh
# 分析代码（Sonnet）
echo "分析代码..."
claude --model claude-sonnet-4-5 -p "分析代码结构" > analysis.txt
# 生成测试用例（Sonnet）
echo "生成测试用例..."
claude --model claude-sonnet-4-5 -p "生成测试用例" > test-cases.txt
# 生成测试代码（Opus）
echo "生成测试代码..."
claude --model claude-opus-4-5 -p "生成完整的测试代码" > tests.py
echo "测试生成完成"
```

#### 模型选择指南#

##### 1. 按任务复杂度选择#

##### 2. 按性能要求选择#

##### 3. 按成本考虑选择#

#### 最佳实践#

##### 1. 从平衡模型开始#

```
bash复制# 默认使用 Sonnet
claude --model claude-sonnet-4-5 -p "完成任务"

# 如果需要更强的能力，升级到 Opus
claude --model claude-opus-4-5 -p "完成任务"
```

```
# 默认使用 Sonnet
claude --model claude-sonnet-4-5 -p "完成任务"

# 如果需要更强的能力，升级到 Opus
claude --model claude-opus-4-5 -p "完成任务"
```

##### 2. 根据结果调整#

```
bash复制#!/bin/bash
# adaptive-model.sh
TASK=$1
# 先用 Sonnet 尝试
echo "尝试使用 Sonnet..."
claude --model claude-sonnet-4-5 -p "$TASK" > result.txt
# 检查结果质量
if grep -qi "无法完成\|需要更多信息" result.txt; then
echo "升级到 Opus..."
claude --model claude-opus-4-5 -p "$TASK" > result.txt
fi
```

```
#!/bin/bash
# adaptive-model.sh
TASK=$1
# 先用 Sonnet 尝试
echo "尝试使用 Sonnet..."
claude --model claude-sonnet-4-5 -p "$TASK" > result.txt
# 检查结果质量
if grep -qi "无法完成\|需要更多信息" result.txt; then
echo "升级到 Opus..."
claude --model claude-opus-4-5 -p "$TASK" > result.txt
fi
```

##### 3. 批量处理使用 Haiku#

```
bash复制# 批量简单任务使用 Haiku
for file in *.py; do
    echo "处理 $file..."
    claude --model claude-haiku-4-5 -p "检查 $file 的语法" > "check-$file.txt"
done
```

```
# 批量简单任务使用 Haiku
for file in *.py; do
    echo "处理 $file..."
    claude --model claude-haiku-4-5 -p "检查 $file 的语法" > "check-$file.txt"
done
```

##### 4. 关键任务使用 Opus#

```
bash复制# 关键任务使用 Opus
claude --model claude-opus-4-5 -p "生成生产环境代码"

# 安全审查使用 Opus
claude --model claude-opus-4-5 -p "进行安全审查"
```

```
# 关键任务使用 Opus
claude --model claude-opus-4-5 -p "生成生产环境代码"

# 安全审查使用 Opus
claude --model claude-opus-4-5 -p "进行安全审查"
```

#### 常见问题#

##### Q1: 如何选择合适的模型？#

A: 根据任务复杂度、性能要求和成本考虑选择。简单任务用 Haiku，一般任务用 Sonnet，复杂任务用 Opus。

##### Q2: 可以在会话中切换模型吗？#

A: 不可以。模型在会话开始时确定，整个会话使用同一个模型。

##### Q3: 不同模型的价格差异大吗？#

A: 是的。Opus 最贵，Haiku 最便宜。建议根据任务需求选择合适的模型。

##### Q4: 3.5 Sonnet 与 3 Sonnet 有什么区别？#

A: 3.5 Sonnet 是更新的模型，具有更强的能力和更好的性能，但可能定价不同。

##### Q5: 如何知道哪个模型最适合我的任务？#

A: 可以尝试不同的模型，比较结果质量和响应时间，选择最适合的模型。

#### 与其他标志的组合示例#

##### 1. 完整的开发流程#

```
bash复制#!/bin/bash
# full-development.sh

# 快速原型（Haiku）
claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

# 功能开发（Sonnet）
claude --model claude-sonnet-4-5 -p "开发完整功能" > implementation.txt

# 深度优化（Opus）
claude --model claude-opus-4-5 -p "优化性能和安全性" > optimization.txt

echo "开发流程完成"
```

```
#!/bin/bash
# full-development.sh

# 快速原型（Haiku）
claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

# 功能开发（Sonnet）
claude --model claude-sonnet-4-5 -p "开发完整功能" > implementation.txt

# 深度优化（Opus）
claude --model claude-opus-4-5 -p "优化性能和安全性" > optimization.txt

echo "开发流程完成"
```

##### 2. 迭代改进#

```
bash复制#!/bin/bash
# iterative-improvement.sh
for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
echo "使用 $model 改进..."
claude --model "$model" -p "改进代码" > "improvement-$model.txt"
done
echo "迭代改进完成"
```

```
#!/bin/bash
# iterative-improvement.sh
for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
echo "使用 $model 改进..."
claude --model "$model" -p "改进代码" > "improvement-$model.txt"
done
echo "迭代改进完成"
```

##### 3. 成本优化流程#

```
bash复制#!/bin/bash
# cost-optimized-flow.sh

# 简单任务（Haiku）
claude --model claude-haiku-4-5 -p "快速检查" > check.txt

# 一般任务（Sonnet）
claude --model claude-sonnet-4-5 -p "标准开发" > dev.txt

# 关键任务（Opus）
claude --model claude-opus-4-5 -p "关键审查" > review.txt

echo "成本优化流程完成"
```

```
#!/bin/bash
# cost-optimized-flow.sh

# 简单任务（Haiku）
claude --model claude-haiku-4-5 -p "快速检查" > check.txt

# 一般任务（Sonnet）
claude --model claude-sonnet-4-5 -p "标准开发" > dev.txt

# 关键任务（Opus）
claude --model claude-opus-4-5 -p "关键审查" > review.txt

echo "成本优化流程完成"
```

#### 总结#

--model 标志提供了一种选择合适模型的方式。通过选择不同的模型，您可以：

```
--model
```

- 平衡性能、速度和成本
- 根据任务复杂度选择合适的模型
- 优化资源使用和成本
- 获得最佳的结果质量

合理使用 --model 可以帮助您在不同场景下获得最佳的性能和成本效益。

```
--model
```

---

## 15 --permission-mode - 指定权限模式

**URL**: https://claudecode.tangshuang.net/course/6.15%20--permission-mode%20-%20%E6%8C%87%E5%AE%9A%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F

#### 概述#

--permission-mode 标志允许您指定 Claude Code 的权限模式，控制工具调用的权限检查行为。这对于安全性和自动化场景非常重要。

```
--permission-mode
```

#### 基本语法#

```
bash复制claude --permission-mode <模式>
```

```
claude --permission-mode <模式>
```

#### 可用模式#

```
auto
```

```
manual
```

```
always-approve
```

```
always-deny
```

#### 使用场景#

##### 1. 自动化脚本使用 auto#

```
bash复制# 自动化脚本中自动批准权限
claude --permission-mode auto -p "生成并保存代码"

# 所有工具调用都会自动批准
```

```
# 自动化脚本中自动批准权限
claude --permission-mode auto -p "生成并保存代码"

# 所有工具调用都会自动批准
```

##### 2. 交互式开发使用 manual#

```
bash复制# 交互式开发中手动批准权限
claude --permission-mode manual

# 每次工具调用都需要手动批准
```

```
# 交互式开发中手动批准权限
claude --permission-mode manual

# 每次工具调用都需要手动批准
```

##### 3. 完全自动化使用 always-approve#

```
bash复制# 完全自动化的 CI/CD 流程
claude --permission-mode always-approve -p "部署应用"

# 所有权限都会自动批准
```

```
# 完全自动化的 CI/CD 流程
claude --permission-mode always-approve -p "部署应用"

# 所有权限都会自动批准
```

##### 4. 只读模式使用 always-deny#

```
bash复制# 只读模式，只允许读取操作
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 所有写入操作都会被拒绝
```

```
# 只读模式，只允许读取操作
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 所有写入操作都会被拒绝
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 权限模式 + 限制工具
claude --permission-mode auto --allowedTools "Read" "Grep" -p "分析代码"

# 权限模式 + 指定模型
claude --permission-mode manual --model opus -p "生成代码"

# 权限模式 + 自定义系统提示
claude --permission-mode auto --system-prompt "你是一位 Python 专家" -p "编写代码"
```

```
# 权限模式 + 限制工具
claude --permission-mode auto --allowedTools "Read" "Grep" -p "分析代码"

# 权限模式 + 指定模型
claude --permission-mode manual --model opus -p "生成代码"

# 权限模式 + 自定义系统提示
claude --permission-mode auto --system-prompt "你是一位 Python 专家" -p "编写代码"
```

##### 2. 根据环境选择权限模式#

```
bash复制#!/bin/bash
# select-permission-mode.sh
ENV=$1
case "$ENV" in
"production")
MODE="manual"
;;
"staging")
MODE="auto"
;;
"development")
MODE="always-approve"
;;
"readonly")
MODE="always-deny"
;;
*)
MODE="manual"
;;
esac
echo "使用权限模式: $MODE"
claude --permission-mode "$MODE" -p "完成任务"
```

```
#!/bin/bash
# select-permission-mode.sh
ENV=$1
case "$ENV" in
"production")
MODE="manual"
;;
"staging")
MODE="auto"
;;
"development")
MODE="always-approve"
;;
"readonly")
MODE="always-deny"
;;
*)
MODE="manual"
;;
esac
echo "使用权限模式: $MODE"
claude --permission-mode "$MODE" -p "完成任务"
```

##### 3. 安全的自动化流程#

```
bash复制#!/bin/bash
# safe-automation.sh

# 只允许读取和搜索
claude \
  --permission-mode auto \
  --allowedTools "Read" "Grep" \
  -p "分析代码结构"

# 手动批准写入操作
claude \
  --permission-mode manual \
  -p "生成代码"
```

```
#!/bin/bash
# safe-automation.sh

# 只允许读取和搜索
claude \
  --permission-mode auto \
  --allowedTools "Read" "Grep" \
  -p "分析代码结构"

# 手动批准写入操作
claude \
  --permission-mode manual \
  -p "生成代码"
```

##### 4. 分阶段权限控制#

```
bash复制#!/bin/bash
# staged-permission.sh

# 第一阶段：只读分析
echo "只读分析..."
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 第二阶段：手动批准写入
echo "手动批准写入..."
claude --permission-mode manual -p "生成代码"

# 第三阶段：自动部署
echo "自动部署..."
claude --permission-mode always-approve -p "部署应用"
```

```
#!/bin/bash
# staged-permission.sh

# 第一阶段：只读分析
echo "只读分析..."
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 第二阶段：手动批准写入
echo "手动批准写入..."
claude --permission-mode manual -p "生成代码"

# 第三阶段：自动部署
echo "自动部署..."
claude --permission-mode always-approve -p "部署应用"
```

#### 实际应用示例#

##### 示例 1: CI/CD 流程#

```
bash复制#!/bin/bash
# cicd-pipeline.sh

# 阶段 1：代码分析（只读）
echo "代码分析..."
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "分析代码质量" > analysis.txt

# 阶段 2：测试生成（自动批准）
echo "生成测试..."
claude \
  --permission-mode auto \
  -p "生成测试代码" > tests.py

# 阶段 3：部署（手动批准）
echo "部署应用..."
claude \
  --permission-mode manual \
  -p "部署到生产环境"

echo "CI/CD 流程完成"
```

```
#!/bin/bash
# cicd-pipeline.sh

# 阶段 1：代码分析（只读）
echo "代码分析..."
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "分析代码质量" > analysis.txt

# 阶段 2：测试生成（自动批准）
echo "生成测试..."
claude \
  --permission-mode auto \
  -p "生成测试代码" > tests.py

# 阶段 3：部署（手动批准）
echo "部署应用..."
claude \
  --permission-mode manual \
  -p "部署到生产环境"

echo "CI/CD 流程完成"
```

##### 示例 2: 安全审查#

```
bash复制#!/bin/bash
# security-audit.sh

# 只读模式进行安全审查
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "进行安全审查" > security-audit.txt

# 检查结果
if grep -qi "vulnerability\|漏洞" security-audit.txt; then
  echo "发现安全问题，请审查"
  exit 1
fi

echo "安全审查通过"
```

```
#!/bin/bash
# security-audit.sh

# 只读模式进行安全审查
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "进行安全审查" > security-audit.txt

# 检查结果
if grep -qi "vulnerability\|漏洞" security-audit.txt; then
  echo "发现安全问题，请审查"
  exit 1
fi

echo "安全审查通过"
```

##### 示例 3: 开发环境设置#

```
bash复制#!/bin/bash
# dev-environment.sh

# 开发环境：自动批准
if [ "$ENV" = "development" ]; then
    claude --permission-mode always-approve -p "开发功能"
# 生产环境：手动批准
elif [ "$ENV" = "production" ]; then
    claude --permission-mode manual -p "部署功能"
fi
```

```
#!/bin/bash
# dev-environment.sh

# 开发环境：自动批准
if [ "$ENV" = "development" ]; then
    claude --permission-mode always-approve -p "开发功能"
# 生产环境：手动批准
elif [ "$ENV" = "production" ]; then
    claude --permission-mode manual -p "部署功能"
fi
```

##### 示例 4: 代码生成流程#

```
bash复制#!/bin/bash
# code-generation.sh

# 分析阶段（只读）
echo "分析阶段..."
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "分析现有代码" > analysis.txt

# 生成阶段（自动批准）
echo "生成阶段..."
claude \
  --permission-mode auto \
  -p "基于分析生成代码" > generated-code.txt

# 审查阶段（手动批准）
echo "审查阶段..."
claude \
  --permission-mode manual \
  -p "审查生成的代码"

echo "代码生成完成"
```

```
#!/bin/bash
# code-generation.sh

# 分析阶段（只读）
echo "分析阶段..."
claude \
  --permission-mode always-deny \
  --allowedTools "Read" "Grep" \
  -p "分析现有代码" > analysis.txt

# 生成阶段（自动批准）
echo "生成阶段..."
claude \
  --permission-mode auto \
  -p "基于分析生成代码" > generated-code.txt

# 审查阶段（手动批准）
echo "审查阶段..."
claude \
  --permission-mode manual \
  -p "审查生成的代码"

echo "代码生成完成"
```

#### 权限模式对比#

##### 1. Auto 模式#

##### 2. Manual 模式#

##### 3. Always-approve 模式#

##### 4. Always-deny 模式#

#### 最佳实践#

##### 1. 根据环境选择模式#

```
bash复制# 开发环境：always-approve
if [ "$ENV" = "development" ]; then
    MODE="always-approve"
# 测试环境：auto
elif [ "$ENV" = "testing" ]; then
    MODE="auto"
# 生产环境：manual
elif [ "$ENV" = "production" ]; then
    MODE="manual"
fi

claude --permission-mode "$MODE" -p "完成任务"
```

```
# 开发环境：always-approve
if [ "$ENV" = "development" ]; then
    MODE="always-approve"
# 测试环境：auto
elif [ "$ENV" = "testing" ]; then
    MODE="auto"
# 生产环境：manual
elif [ "$ENV" = "production" ]; then
    MODE="manual"
fi

claude --permission-mode "$MODE" -p "完成任务"
```

##### 2. 分离读写操作#

```
bash复制# 只读操作使用 always-deny
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 写入操作使用 manual
claude --permission-mode manual -p "生成代码"
```

```
# 只读操作使用 always-deny
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 写入操作使用 manual
claude --permission-mode manual -p "生成代码"
```

##### 3. 使用工具限制增强安全#

```
bash复制# 结合权限模式和工具限制
claude \
  --permission-mode auto \
  --allowedTools "Read" "Grep" "Write" \
  --disallowedTools "RunCommand" \
  -p "分析代码"
```

```
# 结合权限模式和工具限制
claude \
  --permission-mode auto \
  --allowedTools "Read" "Grep" "Write" \
  --disallowedTools "RunCommand" \
  -p "分析代码"
```

##### 4. 记录权限决策#

```
bash复制#!/bin/bash
# log-permissions.sh
LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"
claude --permission-mode manual -p "生成代码" 2>&1 | tee "$LOG_FILE"
echo "权限决策已记录到 $LOG_FILE"
```

```
#!/bin/bash
# log-permissions.sh
LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"
claude --permission-mode manual -p "生成代码" 2>&1 | tee "$LOG_FILE"
echo "权限决策已记录到 $LOG_FILE"
```

#### 常见问题#

##### Q1: 如何选择合适的权限模式？#

A: 根据环境和使用场景选择。开发环境用 always-approve，生产环境用 manual，自动化脚本用 auto。

##### Q2: 可以在会话中切换权限模式吗？#

A: 不可以。权限模式在会话开始时确定，整个会话使用同一个模式。

##### Q3: always-approve 模式安全吗？#

A: 不安全。建议只在高度信任的环境中使用，如本地开发环境。

##### Q4: 如何在 CI/CD 中使用权限模式？#

A: 使用 auto 或 always-approve 模式，确保自动化流程不会因为权限提示而中断。

##### Q5: always-deny 模式有什么用？#

A: 用于只读操作，如代码分析、安全审查等，确保不会意外修改文件。

#### 与其他标志的组合示例#

##### 1. 安全的开发流程#

```
bash复制#!/bin/bash
# secure-dev-flow.sh

# 只读分析
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 手动批准生成
claude --permission-mode manual -p "生成代码"

# 自动测试
claude --permission-mode auto -p "运行测试"
```

```
#!/bin/bash
# secure-dev-flow.sh

# 只读分析
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "分析代码"

# 手动批准生成
claude --permission-mode manual -p "生成代码"

# 自动测试
claude --permission-mode auto -p "运行测试"
```

##### 2. 自动化部署#

```
bash复制#!/bin/bash
# automated-deploy.sh

# 只读检查
claude --permission-mode always-deny -p "检查部署准备" > check.txt

# 自动部署
claude --permission-mode always-approve -p "部署应用"
```

```
#!/bin/bash
# automated-deploy.sh

# 只读检查
claude --permission-mode always-deny -p "检查部署准备" > check.txt

# 自动部署
claude --permission-mode always-approve -p "部署应用"
```

##### 3. 安全审查流程#

```
bash复制#!/bin/bash
# security-review.sh

# 只读审查
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "安全审查" > audit.txt

# 手动批准修复
claude --permission-mode manual -p "修复安全问题"
```

```
#!/bin/bash
# security-review.sh

# 只读审查
claude --permission-mode always-deny --allowedTools "Read" "Grep" -p "安全审查" > audit.txt

# 手动批准修复
claude --permission-mode manual -p "修复安全问题"
```

#### 总结#

--permission-mode 标志提供了一种控制工具调用权限的方式。通过选择不同的权限模式，您可以：

```
--permission-mode
```

- 平衡安全性和效率
- 根据环境调整权限策略
- 实现自动化和手动控制的混合
- 增强安全性，防止意外操作

合理使用 --permission-mode 可以帮助您在不同场景下获得最佳的安全性和效率平衡。

```
--permission-mode
```

---

## 16 --permission-prompt-tool - 处理权限提示的工具

**URL**: https://claudecode.tangshuang.net/course/6.16%20--permission-prompt-tool%20-%20%E5%A4%84%E7%90%86%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E7%9A%84%E5%B7%A5%E5%85%B7

#### 概述#

--permission-prompt-tool 标志允许您指定用于处理权限提示的工具。这对于自定义权限处理流程和集成外部权限管理系统非常有用。

```
--permission-prompt-tool
```

#### 基本语法#

```
bash复制claude --permission-prompt-tool <工具名称>
```

```
claude --permission-prompt-tool <工具名称>
```

#### 使用场景#

##### 1. 使用自定义权限工具#

```
bash复制# 使用自定义的权限处理工具
claude --permission-prompt-tool my-permission-handler -p "生成代码"

# 权限提示将由 my-permission-handler 工具处理
```

```
# 使用自定义的权限处理工具
claude --permission-prompt-tool my-permission-handler -p "生成代码"

# 权限提示将由 my-permission-handler 工具处理
```

##### 2. 集成外部权限系统#

```
bash复制# 集成企业权限管理系统
claude --permission-prompt-tool enterprise-permission-manager -p "部署应用"

# 权限决策将与企业系统集成
```

```
# 集成企业权限管理系统
claude --permission-prompt-tool enterprise-permission-manager -p "部署应用"

# 权限决策将与企业系统集成
```

##### 3. 自动化权限审批#

```
bash复制# 使用自动化审批工具
claude --permission-prompt-tool auto-approver -p "生成代码"

# 权限将根据预定义规则自动审批
```

```
# 使用自动化审批工具
claude --permission-prompt-tool auto-approver -p "生成代码"

# 权限将根据预定义规则自动审批
```

##### 4. 记录权限决策#

```
bash复制# 使用权限记录工具
claude --permission-prompt-tool permission-logger -p "生成代码"

# 所有权限决策将被记录
```

```
# 使用权限记录工具
claude --permission-prompt-tool permission-logger -p "生成代码"

# 所有权限决策将被记录
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 权限工具 + 权限模式
claude --permission-prompt-tool my-handler --permission-mode manual -p "生成代码"

# 权限工具 + 限制工具
claude --permission-prompt-tool my-handler --allowedTools "Read" "Grep" -p "分析代码"

# 权限工具 + 指定模型
claude --permission-prompt-tool my-handler --model opus -p "生成代码"
```

```
# 权限工具 + 权限模式
claude --permission-prompt-tool my-handler --permission-mode manual -p "生成代码"

# 权限工具 + 限制工具
claude --permission-prompt-tool my-handler --allowedTools "Read" "Grep" -p "分析代码"

# 权限工具 + 指定模型
claude --permission-prompt-tool my-handler --model opus -p "生成代码"
```

##### 2. 自定义权限处理流程#

```
bash复制#!/bin/bash
# custom-permission-flow.sh

# 定义自定义权限处理工具
export PERMISSION_TOOL="my-permission-handler"

# 使用自定义工具
claude --permission-prompt-tool "$PERMISSION_TOOL" -p "生成代码"
```

```
#!/bin/bash
# custom-permission-flow.sh

# 定义自定义权限处理工具
export PERMISSION_TOOL="my-permission-handler"

# 使用自定义工具
claude --permission-prompt-tool "$PERMISSION_TOOL" -p "生成代码"
```

##### 3. 条件权限处理#

```
bash复制#!/bin/bash
# conditional-permission.sh

TOOL=$1

# 根据工具类型选择权限处理器
case "$TOOL" in
    "Read"|"Grep")
        PERMISSION_TOOL="read-permission-handler"
        ;;
    "Write"|"Edit")
        PERMISSION_TOOL="write-permission-handler"
        ;;
    "RunCommand")
        PERMISSION_TOOL="command-permission-handler"
        ;;
    *)
        PERMISSION_TOOL="default-permission-handler"
        ;;
esac

claude --permission-prompt-tool "$PERMISSION_TOOL" -p "完成任务"
```

```
#!/bin/bash
# conditional-permission.sh

TOOL=$1

# 根据工具类型选择权限处理器
case "$TOOL" in
    "Read"|"Grep")
        PERMISSION_TOOL="read-permission-handler"
        ;;
    "Write"|"Edit")
        PERMISSION_TOOL="write-permission-handler"
        ;;
    "RunCommand")
        PERMISSION_TOOL="command-permission-handler"
        ;;
    *)
        PERMISSION_TOOL="default-permission-handler"
        ;;
esac

claude --permission-prompt-tool "$PERMISSION_TOOL" -p "完成任务"
```

##### 4. 权限审计#

```
bash复制#!/bin/bash
# permission-audit.sh

# 使用权限审计工具
claude --permission-prompt-tool permission-auditor -p "生成代码" 2>&1 | tee audit.log

# 分析审计日志
grep "permission" audit.log | nl
```

```
#!/bin/bash
# permission-audit.sh

# 使用权限审计工具
claude --permission-prompt-tool permission-auditor -p "生成代码" 2>&1 | tee audit.log

# 分析审计日志
grep "permission" audit.log | nl
```

#### 实际应用示例#

##### 示例 1: 企业权限管理#

```
bash复制#!/bin/bash
# enterprise-permission.sh

# 企业权限管理工具
ENTERPRISE_PERMISSION_TOOL="enterprise-permission-manager"

# 使用企业权限管理
claude --permission-prompt-tool "$ENTERPRISE_PERMISSION_TOOL" -p "部署应用"

# 权限决策将与企业的 IAM 系统集成
```

```
#!/bin/bash
# enterprise-permission.sh

# 企业权限管理工具
ENTERPRISE_PERMISSION_TOOL="enterprise-permission-manager"

# 使用企业权限管理
claude --permission-prompt-tool "$ENTERPRISE_PERMISSION_TOOL" -p "部署应用"

# 权限决策将与企业的 IAM 系统集成
```

##### 示例 2: 多级权限审批#

```
bash复制#!/bin/bash
# multi-level-approval.sh

# 第一级：自动审批
claude --permission-prompt-tool level1-approver -p "生成代码" > level1.txt

# 第二级：手动审批
claude --permission-prompt-tool level2-approver -p "审查代码" > level2.txt

# 第三级：高级审批
claude --permission-prompt-tool level3-approver -p "最终批准" > level3.txt

echo "多级审批完成"
```

```
#!/bin/bash
# multi-level-approval.sh

# 第一级：自动审批
claude --permission-prompt-tool level1-approver -p "生成代码" > level1.txt

# 第二级：手动审批
claude --permission-prompt-tool level2-approver -p "审查代码" > level2.txt

# 第三级：高级审批
claude --permission-prompt-tool level3-approver -p "最终批准" > level3.txt

echo "多级审批完成"
```

##### 示例 3: 权限决策记录#

```
bash复制#!/bin/bash
# permission-logging.sh

LOG_FILE="permission-decisions-$(date +%Y%m%d-%H%M%S).log"

# 使用权限记录工具
claude --permission-prompt-tool permission-logger -p "生成代码" 2>&1 | tee "$LOG_FILE"

# 分析决策
echo "权限决策统计:"
grep -c "approved" "$LOG_FILE"
grep -c "denied" "$LOG_FILE"
```

```
#!/bin/bash
# permission-logging.sh

LOG_FILE="permission-decisions-$(date +%Y%m%d-%H%M%S).log"

# 使用权限记录工具
claude --permission-prompt-tool permission-logger -p "生成代码" 2>&1 | tee "$LOG_FILE"

# 分析决策
echo "权限决策统计:"
grep -c "approved" "$LOG_FILE"
grep -c "denied" "$LOG_FILE"
```

##### 示例 4: 基于角色的权限#

```
bash复制#!/bin/bash
# role-based-permission.sh

ROLE=$1

# 根据角色选择权限处理器
case "$ROLE" in
"admin")
PERMISSION_TOOL="admin-permission-handler"
;;
"developer")
PERMISSION_TOOL="developer-permission-handler"
;;
"reviewer")
PERMISSION_TOOL="reviewer-permission-handler"
;;
*)
PERMISSION_TOOL="default-permission-handler"
;;
esac

echo "使用角色: $ROLE"
claude --permission-prompt-tool "$PERMISSION_TOOL" -p "完成任务"
```

```
#!/bin/bash
# role-based-permission.sh

ROLE=$1

# 根据角色选择权限处理器
case "$ROLE" in
"admin")
PERMISSION_TOOL="admin-permission-handler"
;;
"developer")
PERMISSION_TOOL="developer-permission-handler"
;;
"reviewer")
PERMISSION_TOOL="reviewer-permission-handler"
;;
*)
PERMISSION_TOOL="default-permission-handler"
;;
esac

echo "使用角色: $ROLE"
claude --permission-prompt-tool "$PERMISSION_TOOL" -p "完成任务"
```

#### 自定义权限工具开发#

##### 1. 基本权限工具结构#

```
bash复制#!/bin/bash
# my-permission-handler.sh

# 接收权限请求
read -r PERMISSION_REQUEST

# 解析请求
TOOL=$(echo "$PERMISSION_REQUEST" | jq -r '.tool')
ACTION=$(echo "$PERMISSION_REQUEST" | jq -r '.action')

# 决策逻辑
case "$TOOL" in
    "Read"|"Grep")
        DECISION="approved"
        ;;
    "Write"|"Edit")
        # 检查文件路径
        FILE=$(echo "$PERMISSION_REQUEST" | jq -r '.file')
        if [[ "$FILE" == /safe/* ]]; then
            DECISION="approved"
        else
            DECISION="denied"
        fi
        ;;
    "RunCommand")
        # 检查命令
        COMMAND=$(echo "$PERMISSION_REQUEST" | jq -r '.command')
        if [[ "$COMMAND" == "safe-"* ]]; then
            DECISION="approved"
        else
            DECISION="denied"
        fi
        ;;
    *)
        DECISION="denied"
        ;;
esac

# 返回决策
echo "{\"decision\": \"$DECISION\", \"reason\": \"自定义权限规则\"}"
```

```
#!/bin/bash
# my-permission-handler.sh

# 接收权限请求
read -r PERMISSION_REQUEST

# 解析请求
TOOL=$(echo "$PERMISSION_REQUEST" | jq -r '.tool')
ACTION=$(echo "$PERMISSION_REQUEST" | jq -r '.action')

# 决策逻辑
case "$TOOL" in
    "Read"|"Grep")
        DECISION="approved"
        ;;
    "Write"|"Edit")
        # 检查文件路径
        FILE=$(echo "$PERMISSION_REQUEST" | jq -r '.file')
        if [[ "$FILE" == /safe/* ]]; then
            DECISION="approved"
        else
            DECISION="denied"
        fi
        ;;
    "RunCommand")
        # 检查命令
        COMMAND=$(echo "$PERMISSION_REQUEST" | jq -r '.command')
        if [[ "$COMMAND" == "safe-"* ]]; then
            DECISION="approved"
        else
            DECISION="denied"
        fi
        ;;
    *)
        DECISION="denied"
        ;;
esac

# 返回决策
echo "{\"decision\": \"$DECISION\", \"reason\": \"自定义权限规则\"}"
```

##### 2. 集成外部权限系统#

```
bash复制#!/bin/bash
# external-permission-handler.sh
# 调用外部权限 API
PERMISSION_REQUEST=$1
# 发送请求到外部系统
RESPONSE=$(curl -s -X POST \
-H "Content-Type: application/json" \
-d "$PERMISSION_REQUEST" \
https://permission-system.example.com/api/check)
# 返回决策
echo "$RESPONSE"
```

```
#!/bin/bash
# external-permission-handler.sh
# 调用外部权限 API
PERMISSION_REQUEST=$1
# 发送请求到外部系统
RESPONSE=$(curl -s -X POST \
-H "Content-Type: application/json" \
-d "$PERMISSION_REQUEST" \
https://permission-system.example.com/api/check)
# 返回决策
echo "$RESPONSE"
```

##### 3. 基于策略的权限工具#

```
bash复制#!/bin/bash
# policy-based-handler.sh

POLICY_FILE=$1
PERMISSION_REQUEST=$2

# 读取策略
POLICY=$(cat "$POLICY_FILE")

# 应用策略
# 这里可以实现复杂的策略匹配逻辑
DECISION=$(echo "$PERMISSION_REQUEST" | jq --argjson policy "$POLICY" '
  if .tool == $policy.tool and .action == $policy.action then
    "approved"
  else
    "denied"
  end
')

echo "{\"decision\": $DECISION}"
```

```
#!/bin/bash
# policy-based-handler.sh

POLICY_FILE=$1
PERMISSION_REQUEST=$2

# 读取策略
POLICY=$(cat "$POLICY_FILE")

# 应用策略
# 这里可以实现复杂的策略匹配逻辑
DECISION=$(echo "$PERMISSION_REQUEST" | jq --argjson policy "$POLICY" '
  if .tool == $policy.tool and .action == $policy.action then
    "approved"
  else
    "denied"
  end
')

echo "{\"decision\": $DECISION}"
```

#### 权限工具类型#

##### 1. 审批工具#

```
auto-approver
```

```
manual-approver
```

```
multi-level-approver
```

##### 2. 记录工具#

```
permission-logger
```

```
permission-auditor
```

```
decision-tracker
```

##### 3. 集成工具#

```
enterprise-permission-manager
```

```
cloud-permission-handler
```

```
iam-integrator
```

#### 最佳实践#

##### 1. 选择合适的权限工具#

```
bash复制# 自动化流程使用 auto-approver
claude --permission-prompt-tool auto-approver -p "生成代码"
# 生产环境使用 manual-approver
claude --permission-prompt-tool manual-approver -p "部署应用"
# 企业环境使用 enterprise-permission-manager
claude --permission-prompt-tool enterprise-permission-manager -p "完成任务"
```

```
# 自动化流程使用 auto-approver
claude --permission-prompt-tool auto-approver -p "生成代码"
# 生产环境使用 manual-approver
claude --permission-prompt-tool manual-approver -p "部署应用"
# 企业环境使用 enterprise-permission-manager
claude --permission-prompt-tool enterprise-permission-manager -p "完成任务"
```

##### 2. 记录权限决策#

```
bash复制#!/bin/bash
# log-decisions.sh

LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"

claude --permission-prompt-tool permission-logger -p "生成代码" 2>&1 | tee "$LOG_FILE"

echo "权限决策已记录到 $LOG_FILE"
```

```
#!/bin/bash
# log-decisions.sh

LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"

claude --permission-prompt-tool permission-logger -p "生成代码" 2>&1 | tee "$LOG_FILE"

echo "权限决策已记录到 $LOG_FILE"
```

##### 3. 实现策略检查#

```
bash复制#!/bin/bash
# policy-check.sh
POLICY_FILE="permission-policy.json"
claude --permission-prompt-tool policy-based-handler -p "生成代码" \
--permission-policy "$POLICY_FILE"
```

```
#!/bin/bash
# policy-check.sh
POLICY_FILE="permission-policy.json"
claude --permission-prompt-tool policy-based-handler -p "生成代码" \
--permission-policy "$POLICY_FILE"
```

##### 4. 定期审计权限#

```
bash复制#!/bin/bash
# audit-permissions.sh

# 使用权限审计工具
claude --permission-prompt-tool permission-auditor -p "完成任务" > audit.txt

# 分析审计结果
grep "denied" audit.txt | wc -l
```

```
#!/bin/bash
# audit-permissions.sh

# 使用权限审计工具
claude --permission-prompt-tool permission-auditor -p "完成任务" > audit.txt

# 分析审计结果
grep "denied" audit.txt | wc -l
```

#### 常见问题#

##### Q1: 如何创建自定义权限工具？#

A: 创建一个脚本或程序，接收权限请求并返回决策。参考上面的示例代码。

##### Q2: 权限工具的输入输出格式是什么？#

A: 输入通常是 JSON 格式的权限请求，输出是 JSON 格式的决策。

##### Q3: 可以同时使用多个权限工具吗？#

A: 不可以。每次只能指定一个权限工具。

##### Q4: 权限工具失败会发生什么？#

A: 通常会回退到默认的权限处理方式。

##### Q5: 如何测试权限工具？#

A: 可以使用测试用例模拟权限请求，验证工具的决策逻辑。

#### 与其他标志的组合示例#

##### 1. 完整的权限管理流程#

```
bash复制#!/bin/bash
# full-permission-flow.sh
# 记录决策
LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"
# 使用权限记录工具
claude --permission-prompt-tool permission-logger \
--permission-mode manual \
-p "生成代码" 2>&1 | tee "$LOG_FILE"
# 分析决策
grep "decision" "$LOG_FILE"
```

```
#!/bin/bash
# full-permission-flow.sh
# 记录决策
LOG_FILE="permissions-$(date +%Y%m%d-%H%M%S).log"
# 使用权限记录工具
claude --permission-prompt-tool permission-logger \
--permission-mode manual \
-p "生成代码" 2>&1 | tee "$LOG_FILE"
# 分析决策
grep "decision" "$LOG_FILE"
```

##### 2. 企业集成流程#

```
bash复制#!/bin/bash
# enterprise-integration.sh

# 使用企业权限管理工具
claude --permission-prompt-tool enterprise-permission-manager \
  --permission-mode auto \
  -p "部署应用"

# 权限决策将与企业系统集成
```

```
#!/bin/bash
# enterprise-integration.sh

# 使用企业权限管理工具
claude --permission-prompt-tool enterprise-permission-manager \
  --permission-mode auto \
  -p "部署应用"

# 权限决策将与企业系统集成
```

##### 3. 多级审批流程#

```
bash复制#!/bin/bash
# multi-level-flow.sh
# 第一级：自动审批
claude --permission-prompt-tool level1-approver -p "生成代码"
# 第二级：手动审批
claude --permission-prompt-tool level2-approver -p "审查代码"
# 第三级：最终审批
claude --permission-prompt-tool level3-approver -p "最终批准"
```

```
#!/bin/bash
# multi-level-flow.sh
# 第一级：自动审批
claude --permission-prompt-tool level1-approver -p "生成代码"
# 第二级：手动审批
claude --permission-prompt-tool level2-approver -p "审查代码"
# 第三级：最终审批
claude --permission-prompt-tool level3-approver -p "最终批准"
```

---

## 17 --resume - 恢复特定会话

**URL**: https://claudecode.tangshuang.net/course/6.17%20--resume%20-%20%E6%81%A2%E5%A4%8D%E7%89%B9%E5%AE%9A%E4%BC%9A%E8%AF%9D

#### 概述#

--resume 标志允许您恢复之前保存的特定会话。这对于继续中断的工作、回顾历史对话或在不同设备间同步会话非常有用。

```
--resume
```

#### 基本语法#

```
bash复制claude --resume <会话ID>
```

```
claude --resume <会话ID>
```

#### 使用场景#

##### 1. 恢复中断的会话#

```
bash复制# 恢复之前中断的会话
claude --resume session-abc123

# 继续之前的工作
```

```
# 恢复之前中断的会话
claude --resume session-abc123

# 继续之前的工作
```

##### 2. 回顾历史对话#

```
bash复制# 查看并恢复历史会话
claude --resume session-xyz789
# 回顾之前的讨论
```

```
# 查看并恢复历史会话
claude --resume session-xyz789
# 回顾之前的讨论
```

##### 3. 在不同设备间同步#

```
bash复制# 在设备 A 上保存会话
claude --session-id my-session

# 在设备 B 上恢复会话
claude --resume my-session
```

```
# 在设备 A 上保存会话
claude --session-id my-session

# 在设备 B 上恢复会话
claude --resume my-session
```

##### 4. 分支开发#

```
bash复制# 从主会话创建分支
claude --resume main-session
# 在新分支上工作
claude --session-id branch-session
```

```
# 从主会话创建分支
claude --resume main-session
# 在新分支上工作
claude --session-id branch-session
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 恢复会话 + 指定模型
claude --resume session-abc123 --model opus

# 恢复会话 + 自定义系统提示
claude --resume session-abc123 --system-prompt "你是一位 Python 专家"

# 恢复会话 + 限制工具
claude --resume session-abc123 --allowedTools "Read" "Grep"
```

```
# 恢复会话 + 指定模型
claude --resume session-abc123 --model opus

# 恢复会话 + 自定义系统提示
claude --resume session-abc123 --system-prompt "你是一位 Python 专家"

# 恢复会话 + 限制工具
claude --resume session-abc123 --allowedTools "Read" "Grep"
```

##### 2. 会话管理#

```
bash复制#!/bin/bash
# session-manager.sh
# 列出所有会话
claude --list-sessions
# 恢复特定会话
SESSION_ID=$1
claude --resume "$SESSION_ID"
```

```
#!/bin/bash
# session-manager.sh
# 列出所有会话
claude --list-sessions
# 恢复特定会话
SESSION_ID=$1
claude --resume "$SESSION_ID"
```

##### 3. 会话备份#

```
bash复制#!/bin/bash
# backup-session.sh

SESSION_ID=$1
BACKUP_DIR="backups/sessions"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 备份会话
claude --export-session "$SESSION_ID" > "$BACKUP_DIR/$SESSION_ID.json"

echo "会话已备份到 $BACKUP_DIR/$SESSION_ID.json"
```

```
#!/bin/bash
# backup-session.sh

SESSION_ID=$1
BACKUP_DIR="backups/sessions"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 备份会话
claude --export-session "$SESSION_ID" > "$BACKUP_DIR/$SESSION_ID.json"

echo "会话已备份到 $BACKUP_DIR/$SESSION_ID.json"
```

##### 4. 会话迁移#

```
bash复制#!/bin/bash
# migrate-session.sh
OLD_SESSION=$1
NEW_SESSION=$2
# 导出旧会话
claude --export-session "$OLD_SESSION" > temp-session.json
# 导入为新会话
claude --import-session temp-session.json --session-id "$NEW_SESSION"
# 清理临时文件
rm temp-session.json
echo "会话已迁移从 $OLD_SESSION 到 $NEW_SESSION"
```

```
#!/bin/bash
# migrate-session.sh
OLD_SESSION=$1
NEW_SESSION=$2
# 导出旧会话
claude --export-session "$OLD_SESSION" > temp-session.json
# 导入为新会话
claude --import-session temp-session.json --session-id "$NEW_SESSION"
# 清理临时文件
rm temp-session.json
echo "会话已迁移从 $OLD_SESSION 到 $NEW_SESSION"
```

#### 实际应用示例#

##### 示例 1: 项目开发会话#

```
bash复制#!/bin/bash
# project-session.sh

PROJECT=$1
SESSION_ID="project-$PROJECT-$(date +%Y%m%d)"

# 检查会话是否存在
if claude --session-exists "$SESSION_ID"; then
    echo "恢复会话: $SESSION_ID"
    claude --resume "$SESSION_ID"
else
    echo "创建新会话: $SESSION_ID"
    claude --session-id "$SESSION_ID"
fi
```

```
#!/bin/bash
# project-session.sh

PROJECT=$1
SESSION_ID="project-$PROJECT-$(date +%Y%m%d)"

# 检查会话是否存在
if claude --session-exists "$SESSION_ID"; then
    echo "恢复会话: $SESSION_ID"
    claude --resume "$SESSION_ID"
else
    echo "创建新会话: $SESSION_ID"
    claude --session-id "$SESSION_ID"
fi
```

##### 示例 2: 多阶段任务#

```
bash复制#!/bin/bash
# multi-stage-task.sh
TASK=$1
# 阶段 1：分析
echo "阶段 1：分析"
claude --session-id "$TASK-stage1" -p "分析需求"
# 阶段 2：设计
echo "阶段 2：设计"
claude --resume "$TASK-stage1" -p "设计系统"
# 阶段 3：实现
echo "阶段 3：实现"
claude --resume "$TASK-stage2" -p "实现功能"
```

```
#!/bin/bash
# multi-stage-task.sh
TASK=$1
# 阶段 1：分析
echo "阶段 1：分析"
claude --session-id "$TASK-stage1" -p "分析需求"
# 阶段 2：设计
echo "阶段 2：设计"
claude --resume "$TASK-stage1" -p "设计系统"
# 阶段 3：实现
echo "阶段 3：实现"
claude --resume "$TASK-stage2" -p "实现功能"
```

##### 示例 3: 代码审查会话#

```
bash复制#!/bin/bash
# code-review-session.sh

REVIEW_ID="review-$(date +%Y%m%d-%H%M%S)"

# 开始审查
echo "开始代码审查: $REVIEW_ID"
claude --session-id "$REVIEW_ID" -p "开始代码审查"

# 恢复审查
echo "恢复代码审查: $REVIEW_ID"
claude --resume "$REVIEW_ID"
```

```
#!/bin/bash
# code-review-session.sh

REVIEW_ID="review-$(date +%Y%m%d-%H%M%S)"

# 开始审查
echo "开始代码审查: $REVIEW_ID"
claude --session-id "$REVIEW_ID" -p "开始代码审查"

# 恢复审查
echo "恢复代码审查: $REVIEW_ID"
claude --resume "$REVIEW_ID"
```

##### 示例 4: 学习会话#

```
bash复制#!/bin/bash
# learning-session.sh
TOPIC=$1
SESSION_ID="learning-$TOPIC-$(date +%Y%m%d)"
# 检查是否有学习会话
if [ -f "sessions/$SESSION_ID.json" ]; then
echo "继续学习: $TOPIC"
claude --resume "$SESSION_ID"
else
echo "开始学习: $TOPIC"
claude --session-id "$SESSION_ID" -p "学习 $TOPIC"
fi
```

```
#!/bin/bash
# learning-session.sh
TOPIC=$1
SESSION_ID="learning-$TOPIC-$(date +%Y%m%d)"
# 检查是否有学习会话
if [ -f "sessions/$SESSION_ID.json" ]; then
echo "继续学习: $TOPIC"
claude --resume "$SESSION_ID"
else
echo "开始学习: $TOPIC"
claude --session-id "$SESSION_ID" -p "学习 $TOPIC"
fi
```

#### 会话生命周期#

##### 1. 创建会话#

```
bash复制# 创建新会话
claude --session-id my-new-session

# 会话自动创建并保存
```

```
# 创建新会话
claude --session-id my-new-session

# 会话自动创建并保存
```

##### 2. 恢复会话#

```
bash复制# 恢复现有会话
claude --resume my-existing-session
# 继续之前的对话
```

```
# 恢复现有会话
claude --resume my-existing-session
# 继续之前的对话
```

##### 3. 更新会话#

```
bash复制# 恢复会话并继续对话
claude --resume my-session

# 新的对话会更新会话
```

```
# 恢复会话并继续对话
claude --resume my-session

# 新的对话会更新会话
```

##### 4. 删除会话#

```
bash复制# 删除会话
claude --delete-session my-session
```

```
# 删除会话
claude --delete-session my-session
```

#### 会话管理技巧#

##### 1. 命名约定#

```
bash复制# 使用描述性的会话 ID
claude --session-id "project-auth-module-20240115"
claude --session-id "bugfix-login-issue-20240115"
claude --session-id "learning-python-async-20240115"
```

```
# 使用描述性的会话 ID
claude --session-id "project-auth-module-20240115"
claude --session-id "bugfix-login-issue-20240115"
claude --session-id "learning-python-async-20240115"
```

##### 2. 会话分组#

```
bash复制# 使用前缀分组
claude --session-id "dev-auth-module"
claude --session-id "dev-user-module"
claude --session-id "test-auth-module"
```

```
# 使用前缀分组
claude --session-id "dev-auth-module"
claude --session-id "dev-user-module"
claude --session-id "test-auth-module"
```

##### 3. 会话归档#

```
bash复制#!/bin/bash
# archive-sessions.sh

ARCHIVE_DIR="archive/sessions"
mkdir -p "$ARCHIVE_DIR"

# 归档旧会话
for session in $(claude --list-sessions | grep "2023"); do
    claude --export-session "$session" > "$ARCHIVE_DIR/$session.json"
    claude --delete-session "$session"
done

echo "旧会话已归档"
```

```
#!/bin/bash
# archive-sessions.sh

ARCHIVE_DIR="archive/sessions"
mkdir -p "$ARCHIVE_DIR"

# 归档旧会话
for session in $(claude --list-sessions | grep "2023"); do
    claude --export-session "$session" > "$ARCHIVE_DIR/$session.json"
    claude --delete-session "$session"
done

echo "旧会话已归档"
```

##### 4. 会话搜索#

```
bash复制#!/bin/bash
# search-sessions.sh
KEYWORD=$1
# 搜索包含关键词的会话
claude --list-sessions | grep "$KEYWORD"
```

```
#!/bin/bash
# search-sessions.sh
KEYWORD=$1
# 搜索包含关键词的会话
claude --list-sessions | grep "$KEYWORD"
```

#### 最佳实践#

##### 1. 定期保存会话#

```
bash复制# 为重要任务创建会话
claude --session-id "important-task-$(date +%Y%m%d-%H%M%S)"
```

```
# 为重要任务创建会话
claude --session-id "important-task-$(date +%Y%m%d-%H%M%S)"
```

##### 2. 使用有意义的会话 ID#

```
bash复制# 好的会话 ID
claude --session-id "project-api-design-20240115"
# 不好的会话 ID
claude --session-id "session1"
```

```
# 好的会话 ID
claude --session-id "project-api-design-20240115"
# 不好的会话 ID
claude --session-id "session1"
```

##### 3. 备份重要会话#

```
bash复制#!/bin/bash
# backup-important-sessions.sh

BACKUP_DIR="backups/sessions"
mkdir -p "$BACKUP_DIR"

# 备份所有会话
for session in $(claude --list-sessions); do
    claude --export-session "$session" > "$BACKUP_DIR/$session.json"
done

echo "所有会话已备份"
```

```
#!/bin/bash
# backup-important-sessions.sh

BACKUP_DIR="backups/sessions"
mkdir -p "$BACKUP_DIR"

# 备份所有会话
for session in $(claude --list-sessions); do
    claude --export-session "$session" > "$BACKUP_DIR/$session.json"
done

echo "所有会话已备份"
```

##### 4. 清理旧会话#

```
bash复制#!/bin/bash
# cleanup-old-sessions.sh
# 删除 30 天前的会话
for session in $(claude --list-sessions | grep "2023"); do
claude --delete-session "$session"
done
echo "旧会话已清理"
```

```
#!/bin/bash
# cleanup-old-sessions.sh
# 删除 30 天前的会话
for session in $(claude --list-sessions | grep "2023"); do
claude --delete-session "$session"
done
echo "旧会话已清理"
```

#### 常见问题#

##### Q1: 如何查看所有可用的会话？#

A: 使用 claude --list-sessions 命令列出所有会话。

```
claude --list-sessions
```

##### Q2: 会话会自动保存吗？#

A: 是的。会话会自动保存，除非显式删除。

##### Q3: 会话有大小限制吗？#

A: 有一定的限制。如果会话太大，建议创建新会话。

##### Q4: 可以导出会话吗？#

A: 可以。使用 claude --export-session <会话ID> 导出会话。

```
claude --export-session <会话ID>
```

##### Q5: 可以在不同设备间共享会话吗？#

A: 可以。导出会话后，在另一个设备上导入。

#### 与其他标志的组合示例#

##### 1. 完整的项目开发流程#

```
bash复制#!/bin/bash
# project-development.sh

PROJECT=$1

# 创建项目会话
SESSION_ID="project-$PROJECT-$(date +%Y%m%d)"

# 阶段 1：需求分析
claude --session-id "$SESSION_ID" -p "分析需求"

# 阶段 2：设计
claude --resume "$SESSION_ID" -p "设计系统"

# 阶段 3：实现
claude --resume "$SESSION_ID" -p "实现功能"

# 阶段 4：测试
claude --resume "$SESSION_ID" -p "生成测试"
```

```
#!/bin/bash
# project-development.sh

PROJECT=$1

# 创建项目会话
SESSION_ID="project-$PROJECT-$(date +%Y%m%d)"

# 阶段 1：需求分析
claude --session-id "$SESSION_ID" -p "分析需求"

# 阶段 2：设计
claude --resume "$SESSION_ID" -p "设计系统"

# 阶段 3：实现
claude --resume "$SESSION_ID" -p "实现功能"

# 阶段 4：测试
claude --resume "$SESSION_ID" -p "生成测试"
```

##### 2. 学习流程#

```
bash复制#!/bin/bash
# learning-flow.sh
TOPIC=$1
SESSION_ID="learning-$TOPIC-$(date +%Y%m%d)"
# 检查是否有学习会话
if [ -f "sessions/$SESSION_ID.json" ]; then
echo "继续学习: $TOPIC"
claude --resume "$SESSION_ID"
else
echo "开始学习: $TOPIC"
claude --session-id "$SESSION_ID" -p "学习 $TOPIC"
fi
```

```
#!/bin/bash
# learning-flow.sh
TOPIC=$1
SESSION_ID="learning-$TOPIC-$(date +%Y%m%d)"
# 检查是否有学习会话
if [ -f "sessions/$SESSION_ID.json" ]; then
echo "继续学习: $TOPIC"
claude --resume "$SESSION_ID"
else
echo "开始学习: $TOPIC"
claude --session-id "$SESSION_ID" -p "学习 $TOPIC"
fi
```

##### 3. Bug 修复流程#

```
bash复制#!/bin/bash
# bug-fix-flow.sh

BUG_ID=$1
SESSION_ID="bugfix-$BUG_ID-$(date +%Y%m%d)"

# 开始修复
claude --session-id "$SESSION_ID" -p "分析 bug: $BUG_ID"

# 继续修复
claude --resume "$SESSION_ID" -p "实现修复"

# 验证修复
claude --resume "$SESSION_ID" -p "验证修复"
```

```
#!/bin/bash
# bug-fix-flow.sh

BUG_ID=$1
SESSION_ID="bugfix-$BUG_ID-$(date +%Y%m%d)"

# 开始修复
claude --session-id "$SESSION_ID" -p "分析 bug: $BUG_ID"

# 继续修复
claude --resume "$SESSION_ID" -p "实现修复"

# 验证修复
claude --resume "$SESSION_ID" -p "验证修复"
```

#### 总结#

--resume 标志提供了一种恢复之前会话的方式。通过使用此标志，您可以：

```
--resume
```

- 继续中断的工作
- 回顾历史对话
- 在不同设备间同步会话
- 实现分支开发

合理使用 --resume 可以帮助您更好地管理和组织工作，特别是在需要长时间或分阶段完成任务时。

```
--resume
```

---

## 18 --continue - 加载最近的对话

**URL**: https://claudecode.tangshuang.net/course/6.18%20--continue%20-%20%E5%8A%A0%E8%BD%BD%E6%9C%80%E8%BF%91%E7%9A%84%E5%AF%B9%E8%AF%9D

#### 概述#

--continue 标志允许您加载并继续最近的对话会话。这是快速恢复工作的便捷方式，无需记住会话 ID。

```
--continue
```

#### 基本语法#

```
bash复制claude --continue
```

```
claude --continue
```

#### 使用场景#

##### 1. 快速恢复工作#

```
bash复制# 快速恢复最近的对话
claude --continue

# 继续之前的工作
```

```
# 快速恢复最近的对话
claude --continue

# 继续之前的工作
```

##### 2. 中断后继续#

```
bash复制# 工作中断后，快速恢复
claude --continue
# 继续之前的任务
```

```
# 工作中断后，快速恢复
claude --continue
# 继续之前的任务
```

##### 3. 日常开发#

```
bash复制# 每天开始工作时，恢复昨天的对话
claude --continue

# 继续开发
```

```
# 每天开始工作时，恢复昨天的对话
claude --continue

# 继续开发
```

##### 4. 快速回顾#

```
bash复制# 快速回顾最近的对话
claude --continue
# 查看上下文
```

```
# 快速回顾最近的对话
claude --continue
# 查看上下文
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 继续对话 + 指定模型
claude --continue --model opus

# 继续对话 + 自定义系统提示
claude --continue --system-prompt "你是一位 Python 专家"

# 继续对话 + 限制工具
claude --continue --allowedTools "Read" "Grep"
```

```
# 继续对话 + 指定模型
claude --continue --model opus

# 继续对话 + 自定义系统提示
claude --continue --system-prompt "你是一位 Python 专家"

# 继续对话 + 限制工具
claude --continue --allowedTools "Read" "Grep"
```

##### 2. 检查最近的会话#

```
bash复制#!/bin/bash
# check-recent-session.sh
# 查看最近的会话
claude --list-sessions | head -1
# 继续最近的会话
claude --continue
```

```
#!/bin/bash
# check-recent-session.sh
# 查看最近的会话
claude --list-sessions | head -1
# 继续最近的会话
claude --continue
```

##### 3. 条件继续#

```
bash复制#!/bin/bash
# conditional-continue.sh

# 检查是否有最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)

if [ -n "$RECENT_SESSION" ]; then
    echo "继续最近的会话: $RECENT_SESSION"
    claude --continue
else
    echo "没有最近的会话，创建新会话"
    claude --session-id "new-session-$(date +%Y%m%d-%H%M%S)"
fi
```

```
#!/bin/bash
# conditional-continue.sh

# 检查是否有最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)

if [ -n "$RECENT_SESSION" ]; then
    echo "继续最近的会话: $RECENT_SESSION"
    claude --continue
else
    echo "没有最近的会话，创建新会话"
    claude --session-id "new-session-$(date +%Y%m%d-%H%M%S)"
fi
```

##### 4. 自动恢复工作流#

```
bash复制#!/bin/bash
# auto-resume-workflow.sh
# 检查工作目录
if [ -f ".claude/session" ]; then
    SESSION_ID=$(cat .claude/session)
    echo "恢复会话: $SESSION_ID"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

```
#!/bin/bash
# auto-resume-workflow.sh
# 检查工作目录
if [ -f ".claude/session" ]; then
    SESSION_ID=$(cat .claude/session)
    echo "恢复会话: $SESSION_ID"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

#### 实际应用示例#

##### 示例 1: 日常开发流程#

```
bash复制#!/bin/bash
# daily-dev-flow.sh

# 检查是否有项目特定的会话
if [ -f ".claude/project-session" ]; then
    PROJECT_SESSION=$(cat .claude/project-session)
    echo "恢复项目会话: $PROJECT_SESSION"
    claude --resume "$PROJECT_SESSION"
else
    echo "继续最近的会话"
    claude --continue
fi
```

```
#!/bin/bash
# daily-dev-flow.sh

# 检查是否有项目特定的会话
if [ -f ".claude/project-session" ]; then
    PROJECT_SESSION=$(cat .claude/project-session)
    echo "恢复项目会话: $PROJECT_SESSION"
    claude --resume "$PROJECT_SESSION"
else
    echo "继续最近的会话"
    claude --continue
fi
```

##### 示例 2: 多项目工作流#

```
bash复制#!/bin/bash
# multi-project-flow.sh
PROJECT=$1
# 检查项目会话
if [ -f ".claude/$PROJECT-session" ]; then
    SESSION_ID=$(cat ".claude/$PROJECT-session")
    echo "恢复项目 $PROJECT 的会话"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

```
#!/bin/bash
# multi-project-flow.sh
PROJECT=$1
# 检查项目会话
if [ -f ".claude/$PROJECT-session" ]; then
    SESSION_ID=$(cat ".claude/$PROJECT-session")
    echo "恢复项目 $PROJECT 的会话"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

##### 示例 3: 任务切换#

```
bash复制#!/bin/bash
# task-switching.sh

# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session

# 切换到新任务
NEW_TASK=$1
claude --session-id "task-$NEW_TASK-$(date +%Y%m%d-%H%M%S)"

# 稍后可以恢复之前的会话
# claude --resume $(cat .claude/last-session)
```

```
#!/bin/bash
# task-switching.sh

# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session

# 切换到新任务
NEW_TASK=$1
claude --session-id "task-$NEW_TASK-$(date +%Y%m%d-%H%M%S)"

# 稍后可以恢复之前的会话
# claude --resume $(cat .claude/last-session)
```

##### 示例 4: 工作日志#

```
bash复制#!/bin/bash
# work-log.sh
LOG_FILE="work-log-$(date +%Y%m%d).log"
# 记录开始工作
echo "$(date): 开始工作" >> "$LOG_FILE"
# 继续最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)
echo "$(date): 恢复会话 $RECENT_SESSION" >> "$LOG_FILE"
claude --continue
# 记录结束工作
echo "$(date): 结束工作" >> "$LOG_FILE"
```

```
#!/bin/bash
# work-log.sh
LOG_FILE="work-log-$(date +%Y%m%d).log"
# 记录开始工作
echo "$(date): 开始工作" >> "$LOG_FILE"
# 继续最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)
echo "$(date): 恢复会话 $RECENT_SESSION" >> "$LOG_FILE"
claude --continue
# 记录结束工作
echo "$(date): 结束工作" >> "$LOG_FILE"
```

#### 与 --resume 的区别#

```
--continue
```

```
--resume <ID>
```

##### 使用建议#

```
bash复制# 快速恢复工作
claude --continue

# 恢复特定会话
claude --resume session-abc123

# 查看会话列表后选择
claude --list-sessions
claude --resume chosen-session
```

```
# 快速恢复工作
claude --continue

# 恢复特定会话
claude --resume session-abc123

# 查看会话列表后选择
claude --list-sessions
claude --resume chosen-session
```

#### 会话管理技巧#

##### 1. 定期清理#

```
bash复制#!/bin/bash
# cleanup-sessions.sh
# 保留最近 10 个会话
claude --list-sessions | tail -n +11 | while read session; do
    claude --delete-session "$session"
done
echo "旧会话已清理"
```

```
#!/bin/bash
# cleanup-sessions.sh
# 保留最近 10 个会话
claude --list-sessions | tail -n +11 | while read session; do
    claude --delete-session "$session"
done
echo "旧会话已清理"
```

##### 2. 会话标记#

```
bash复制#!/bin/bash
# mark-session.sh

MARK=$1

# 标记最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)
echo "$RECENT_SESSION" > ".claude/marked-$MARK"

echo "会话 $RECENT_SESSION 已标记为 $MARK"
```

```
#!/bin/bash
# mark-session.sh

MARK=$1

# 标记最近的会话
RECENT_SESSION=$(claude --list-sessions | head -1)
echo "$RECENT_SESSION" > ".claude/marked-$MARK"

echo "会话 $RECENT_SESSION 已标记为 $MARK"
```

##### 3. 会话切换#

```
bash复制#!/bin/bash
# switch-session.sh
# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session
# 切换到标记的会话
MARK=$1
if [ -f ".claude/marked-$MARK" ]; then
    SESSION_ID=$(cat ".claude/marked-$MARK")
    claude --resume "$SESSION_ID"
else
    echo "没有找到标记为 $MARK 的会话"
fi
```

```
#!/bin/bash
# switch-session.sh
# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session
# 切换到标记的会话
MARK=$1
if [ -f ".claude/marked-$MARK" ]; then
    SESSION_ID=$(cat ".claude/marked-$MARK")
    claude --resume "$SESSION_ID"
else
    echo "没有找到标记为 $MARK 的会话"
fi
```

##### 4. 会话历史#

```
bash复制#!/bin/bash
# session-history.sh

# 显示会话历史
echo "会话历史:"
claude --list-sessions | nl

# 继续最近的会话
echo ""
echo "继续最近的会话？(y/n)"
read answer

if [ "$answer" = "y" ]; then
    claude --continue
fi
```

```
#!/bin/bash
# session-history.sh

# 显示会话历史
echo "会话历史:"
claude --list-sessions | nl

# 继续最近的会话
echo ""
echo "继续最近的会话？(y/n)"
read answer

if [ "$answer" = "y" ]; then
    claude --continue
fi
```

#### 常见问题#

##### Q1: --continue 和 --resume 有什么区别？#

A: --continue 自动加载最近的会话，--resume 需要指定会话 ID。

```
--continue
```

```
--resume
```

##### Q2: 如何知道最近的会话是什么？#

A: 使用 claude --list-sessions 查看会话列表，第一个就是最近的会话。

```
claude --list-sessions
```

##### Q3: 可以继续几天前的会话吗？#

A: --continue 只能继续最近的会话。要继续其他会话，使用 --resume <会话ID>。

```
--continue
```

```
--resume <会话ID>
```

##### Q4: 会话会自动保存吗？#

A: 是的。会话会自动保存，除非显式删除。

##### Q5: 如何避免意外继续错误的会话？#

A: 使用 --resume <会话ID> 明确指定要恢复的会话。

```
--resume <会话ID>
```

#### 与其他标志的组合示例#

##### 1. 完整的工作流程#

```
bash复制#!/bin/bash
# complete-workflow.sh
# 检查是否有项目会话
if [ -f ".claude/project-session" ]; then
    SESSION_ID=$(cat .claude/project-session)
    echo "恢复项目会话"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

```
#!/bin/bash
# complete-workflow.sh
# 检查是否有项目会话
if [ -f ".claude/project-session" ]; then
    SESSION_ID=$(cat .claude/project-session)
    echo "恢复项目会话"
    claude --resume "$SESSION_ID"
else
    echo "继续最近的会话"
    claude --continue
fi
```

##### 2. 多项目切换#

```
bash复制#!/bin/bash
# multi-project-switch.sh

PROJECT=$1

# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session

# 切换到项目会话
if [ -f ".claude/$PROJECT-session" ]; then
    SESSION_ID=$(cat ".claude/$PROJECT-session")
    claude --resume "$SESSION_ID"
else
    echo "没有找到项目 $PROJECT 的会话，继续最近的会话"
    claude --continue
fi
```

```
#!/bin/bash
# multi-project-switch.sh

PROJECT=$1

# 保存当前会话
CURRENT_SESSION=$(claude --list-sessions | head -1)
echo "$CURRENT_SESSION" > .claude/last-session

# 切换到项目会话
if [ -f ".claude/$PROJECT-session" ]; then
    SESSION_ID=$(cat ".claude/$PROJECT-session")
    claude --resume "$SESSION_ID"
else
    echo "没有找到项目 $PROJECT 的会话，继续最近的会话"
    claude --continue
fi
```

##### 3. 任务跟踪#

```
bash复制#!/bin/bash
# task-tracking.sh
TASK=$1
# 记录任务开始
echo "$(date): 开始任务 $TASK" >> task-log.txt
# 继续最近的会话
claude --continue
# 记录任务结束
echo "$(date): 结束任务 $TASK" >> task-log.txt
```

```
#!/bin/bash
# task-tracking.sh
TASK=$1
# 记录任务开始
echo "$(date): 开始任务 $TASK" >> task-log.txt
# 继续最近的会话
claude --continue
# 记录任务结束
echo "$(date): 结束任务 $TASK" >> task-log.txt
```

---

## 19 --dangerously-skip-permissions - 跳过权限提示

**URL**: https://claudecode.tangshuang.net/course/6.19%20--dangerously-skip-permissions%20-%20%E8%B7%B3%E8%BF%87%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA

#### 概述#

--dangerously-skip-permissions 标志允许您跳过所有权限提示，自动批准所有工具调用。这是一个危险的操作，只应该在完全信任的环境中使用。

```
--dangerously-skip-permissions
```

#### 基本语法#

```
bash复制claude --dangerously-skip-permissions
```

```
claude --dangerously-skip-permissions
```

```
bash复制
## ⚠️ 安全警告
**重要提示：** 此标志会跳过所有权限检查，可能导致以下风险：
- 意外删除或修改重要文件
- 执行危险的系统命令
- 泄露敏感信息
- 造成不可逆的系统损坏
**仅在以下情况下使用：**
- 完全信任的环境（本地开发）
- 测试环境
- 自动化脚本（经过充分测试）
## 使用场景
### 1. 本地开发环境

```bash
# 在完全信任的本地开发环境中
claude --dangerously-skip-permissions -p "生成并保存代码"

# 所有操作都会自动批准
```

```
## ⚠️ 安全警告
**重要提示：** 此标志会跳过所有权限检查，可能导致以下风险：
- 意外删除或修改重要文件
- 执行危险的系统命令
- 泄露敏感信息
- 造成不可逆的系统损坏
**仅在以下情况下使用：**
- 完全信任的环境（本地开发）
- 测试环境
- 自动化脚本（经过充分测试）
## 使用场景
### 1. 本地开发环境

```bash
# 在完全信任的本地开发环境中
claude --dangerously-skip-permissions -p "生成并保存代码"

# 所有操作都会自动批准
```

##### 2. 自动化脚本#

```
bash复制#!/bin/bash
# automated-script.sh
# 在充分测试的自动化脚本中
claude --dangerously-skip-permissions -p "执行自动化任务"
# 确保脚本不会中断
```

```
#!/bin/bash
# automated-script.sh
# 在充分测试的自动化脚本中
claude --dangerously-skip-permissions -p "执行自动化任务"
# 确保脚本不会中断
```

##### 3. 沙箱环境#

```
bash复制# 在隔离的沙箱环境中
claude --dangerously-skip-permissions -p "测试功能"

# 即使出错也不会影响生产环境
```

```
# 在隔离的沙箱环境中
claude --dangerously-skip-permissions -p "测试功能"

# 即使出错也不会影响生产环境
```

##### 4. 快速原型开发#

```
bash复制# 快速原型开发，需要频繁操作
claude --dangerously-skip-permissions -p "创建原型"
# 提高开发效率
```

```
# 快速原型开发，需要频繁操作
claude --dangerously-skip-permissions -p "创建原型"
# 提高开发效率
```

#### 高级用法#

##### 1. 与其他标志组合#

```
bash复制# 跳过权限 + 限制工具
claude --dangerously-skip-permissions --allowedTools "Read" "Grep" -p "分析代码"

# 跳过权限 + 指定模型
claude --dangerously-skip-permissions --model opus -p "生成代码"

# 跳过权限 + 自定义系统提示
claude --dangerously-skip-permissions --system-prompt "你是一位 Python 专家" -p "编写代码"
```

```
# 跳过权限 + 限制工具
claude --dangerously-skip-permissions --allowedTools "Read" "Grep" -p "分析代码"

# 跳过权限 + 指定模型
claude --dangerously-skip-permissions --model opus -p "生成代码"

# 跳过权限 + 自定义系统提示
claude --dangerously-skip-permissions --system-prompt "你是一位 Python 专家" -p "编写代码"
```

##### 2. 环境检查#

```
bash复制#!/bin/bash
# safe-skip-permissions.sh
# 检查环境
if [ "$ENV" != "development" ]; then
    echo "错误：只能在开发环境中使用 --dangerously-skip-permissions"
    exit 1
fi
# 检查工作目录
if [[ "$(pwd)" != /safe/development/* ]]; then
    echo "错误：只能在安全目录中使用 --dangerously-skip-permissions"
    exit 1
fi
# 安全使用
claude --dangerously-skip-permissions -p "完成任务"
```

```
#!/bin/bash
# safe-skip-permissions.sh
# 检查环境
if [ "$ENV" != "development" ]; then
    echo "错误：只能在开发环境中使用 --dangerously-skip-permissions"
    exit 1
fi
# 检查工作目录
if [[ "$(pwd)" != /safe/development/* ]]; then
    echo "错误：只能在安全目录中使用 --dangerously-skip-permissions"
    exit 1
fi
# 安全使用
claude --dangerously-skip-permissions -p "完成任务"
```

##### 3. 备份保护#

```
bash复制#!/bin/bash
# backup-protected-skip.sh

# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"

echo "备份已创建: $BACKUP_DIR"

# 跳过权限
claude --dangerously-skip-permissions -p "执行任务"

echo "任务完成，备份保留在 $BACKUP_DIR"
```

```
#!/bin/bash
# backup-protected-skip.sh

# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"

echo "备份已创建: $BACKUP_DIR"

# 跳过权限
claude --dangerously-skip-permissions -p "执行任务"

echo "任务完成，备份保留在 $BACKUP_DIR"
```

##### 4. 时间限制#

```
bash复制#!/bin/bash
# time-limited-skip.sh
TIMEOUT=300  # 5 分钟
# 使用 timeout 限制执行时间
timeout "$TIMEOUT" claude --dangerously-skip-permissions -p "执行任务"
if [ $? -eq 124 ]; then
    echo "任务超时，已自动终止"
else
    echo "任务完成"
fi
```

```
#!/bin/bash
# time-limited-skip.sh
TIMEOUT=300  # 5 分钟
# 使用 timeout 限制执行时间
timeout "$TIMEOUT" claude --dangerously-skip-permissions -p "执行任务"
if [ $? -eq 124 ]; then
    echo "任务超时，已自动终止"
else
    echo "任务完成"
fi
```

#### 实际应用示例#

##### 示例 1: 本地开发脚本#

```
bash复制#!/bin/bash
# local-dev-script.sh

# 确保是本地开发环境
if [ "$ENV" != "local" ]; then
    echo "错误：只能在本地环境中运行此脚本"
    exit 1
fi

# 确保工作目录安全
if [[ "$(pwd)" != ~/dev/* ]]; then
    echo "错误：只能在 ~/dev/ 目录下运行此脚本"
    exit 1
fi

# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"

echo "开始本地开发..."
claude --dangerously-skip-permissions -p "开发功能"

echo "开发完成，备份保留在 $BACKUP_DIR"
```

```
#!/bin/bash
# local-dev-script.sh

# 确保是本地开发环境
if [ "$ENV" != "local" ]; then
    echo "错误：只能在本地环境中运行此脚本"
    exit 1
fi

# 确保工作目录安全
if [[ "$(pwd)" != ~/dev/* ]]; then
    echo "错误：只能在 ~/dev/ 目录下运行此脚本"
    exit 1
fi

# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"

echo "开始本地开发..."
claude --dangerously-skip-permissions -p "开发功能"

echo "开发完成，备份保留在 $BACKUP_DIR"
```

##### 示例 2: 测试环境自动化#

```
bash复制#!/bin/bash
# test-automation.sh
# 确保是测试环境
if [ "$ENV" != "test" ]; then
    echo "错误：只能在测试环境中运行此脚本"
    exit 1
fi
# 使用测试数据库
export DB_URL="test-db.example.com"
# 运行自动化测试
claude --dangerously-skip-permissions -p "运行自动化测试"
echo "测试完成"
```

```
#!/bin/bash
# test-automation.sh
# 确保是测试环境
if [ "$ENV" != "test" ]; then
    echo "错误：只能在测试环境中运行此脚本"
    exit 1
fi
# 使用测试数据库
export DB_URL="test-db.example.com"
# 运行自动化测试
claude --dangerously-skip-permissions -p "运行自动化测试"
echo "测试完成"
```

##### 示例 3: 沙箱环境实验#

```
bash复制#!/bin/bash
# sandbox-experiment.sh

# 确保是沙箱环境
if [ "$ENV" != "sandbox" ]; then
    echo "错误：只能在沙箱环境中运行此脚本"
    exit 1
fi

# 使用隔离的容器
docker run --rm -v "$(pwd):/workspace" sandbox-image \
  claude --dangerously-skip-permissions -p "实验功能"

echo "实验完成"
```

```
#!/bin/bash
# sandbox-experiment.sh

# 确保是沙箱环境
if [ "$ENV" != "sandbox" ]; then
    echo "错误：只能在沙箱环境中运行此脚本"
    exit 1
fi

# 使用隔离的容器
docker run --rm -v "$(pwd):/workspace" sandbox-image \
  claude --dangerously-skip-permissions -p "实验功能"

echo "实验完成"
```

##### 示例 4: 快速原型开发#

```
bash复制#!/bin/bash
# quick-prototype.sh
# 创建临时目录
TEMP_DIR="tmp/prototype-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$TEMP_DIR"
cd "$TEMP_DIR"
echo "在临时目录中开发原型: $TEMP_DIR"
# 快速开发原型
claude --dangerously-skip-permissions -p "创建快速原型"
echo "原型开发完成，位于 $TEMP_DIR"
```

```
#!/bin/bash
# quick-prototype.sh
# 创建临时目录
TEMP_DIR="tmp/prototype-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$TEMP_DIR"
cd "$TEMP_DIR"
echo "在临时目录中开发原型: $TEMP_DIR"
# 快速开发原型
claude --dangerously-skip-permissions -p "创建快速原型"
echo "原型开发完成，位于 $TEMP_DIR"
```

#### 安全最佳实践#

##### 1. 环境验证#

```
bash复制#!/bin/bash
# verify-environment.sh

# 验证环境
if [ "$ENV" != "development" ] && [ "$ENV" != "test" ]; then
    echo "错误：不允许在生产环境中使用 --dangerously-skip-permissions"
    exit 1
fi

# 验证工作目录
SAFE_DIRS=("~/dev" "~/test" "/tmp")
SAFE=false

for dir in "${SAFE_DIRS[@]}"; do
    if [[ "$(pwd)" == $dir/* ]]; then
        SAFE=true
        break
    fi
done

if [ "$SAFE" = false ]; then
    echo "错误：不在安全目录中"
    exit 1
fi

# 安全使用
claude --dangerously-skip-permissions -p "完成任务"
```

```
#!/bin/bash
# verify-environment.sh

# 验证环境
if [ "$ENV" != "development" ] && [ "$ENV" != "test" ]; then
    echo "错误：不允许在生产环境中使用 --dangerously-skip-permissions"
    exit 1
fi

# 验证工作目录
SAFE_DIRS=("~/dev" "~/test" "/tmp")
SAFE=false

for dir in "${SAFE_DIRS[@]}"; do
    if [[ "$(pwd)" == $dir/* ]]; then
        SAFE=true
        break
    fi
done

if [ "$SAFE" = false ]; then
    echo "错误：不在安全目录中"
    exit 1
fi

# 安全使用
claude --dangerously-skip-permissions -p "完成任务"
```

##### 2. 备份策略#

```
bash复制#!/bin/bash
# backup-strategy.sh
# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"
echo "备份已创建: $BACKUP_DIR"
# 执行任务
claude --dangerously-skip-permissions -p "执行任务"
# 询问是否保留备份
echo "任务完成，是否保留备份？(y/n)"
read answer
if [ "$answer" != "y" ]; then
    rm -rf "$BACKUP_DIR"
    echo "备份已删除"
fi
```

```
#!/bin/bash
# backup-strategy.sh
# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"
echo "备份已创建: $BACKUP_DIR"
# 执行任务
claude --dangerously-skip-permissions -p "执行任务"
# 询问是否保留备份
echo "任务完成，是否保留备份？(y/n)"
read answer
if [ "$answer" != "y" ]; then
    rm -rf "$BACKUP_DIR"
    echo "备份已删除"
fi
```

##### 3. 权限限制#

```
bash复制#!/bin/bash
# permission-limits.sh

# 限制可用的工具
claude \
  --dangerously-skip-permissions \
  --allowedTools "Read" "Write" "Grep" \
  --disallowedTools "RunCommand" \
  -p "完成任务"
```

```
#!/bin/bash
# permission-limits.sh

# 限制可用的工具
claude \
  --dangerously-skip-permissions \
  --allowedTools "Read" "Write" "Grep" \
  --disallowedTools "RunCommand" \
  -p "完成任务"
```

##### 4. 日志记录#

```
bash复制#!/bin/bash
# log-operations.sh
LOG_FILE="operations-$(date +%Y%m%d-%H%M%S).log"
# 记录所有操作
claude --dangerously-skip-permissions -p "执行任务" 2>&1 | tee "$LOG_FILE"
echo "操作已记录到 $LOG_FILE"
```

```
#!/bin/bash
# log-operations.sh
LOG_FILE="operations-$(date +%Y%m%d-%H%M%S).log"
# 记录所有操作
claude --dangerously-skip-permissions -p "执行任务" 2>&1 | tee "$LOG_FILE"
echo "操作已记录到 $LOG_FILE"
```

#### 风险缓解策略#

##### 1. 使用容器隔离#

```
bash复制#!/bin/bash
# container-isolation.sh

# 在容器中运行
docker run --rm -v "$(pwd):/workspace" -w /workspace \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

```
#!/bin/bash
# container-isolation.sh

# 在容器中运行
docker run --rm -v "$(pwd):/workspace" -w /workspace \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

##### 2. 使用虚拟环境#

```
bash复制#!/bin/bash
# virtual-environment.sh
# 使用虚拟环境
python -m venv venv
source venv/bin/activate
# 在虚拟环境中执行
claude --dangerously-skip-permissions -p "执行任务"
```

```
#!/bin/bash
# virtual-environment.sh
# 使用虚拟环境
python -m venv venv
source venv/bin/activate
# 在虚拟环境中执行
claude --dangerously-skip-permissions -p "执行任务"
```

##### 3. 使用只读文件系统#

```
bash复制#!/bin/bash
# readonly-filesystem.sh

# 挂载只读文件系统
docker run --rm -v "$(pwd):/workspace:ro" \
  claude-image \
  claude --dangerously-skip-permissions -p "分析代码"
```

```
#!/bin/bash
# readonly-filesystem.sh

# 挂载只读文件系统
docker run --rm -v "$(pwd):/workspace:ro" \
  claude-image \
  claude --dangerously-skip-permissions -p "分析代码"
```

##### 4. 使用网络隔离#

```
bash复制#!/bin/bash
# network-isolation.sh
# 使用网络隔离
docker run --rm --network none -v "$(pwd):/workspace" \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

```
#!/bin/bash
# network-isolation.sh
# 使用网络隔离
docker run --rm --network none -v "$(pwd):/workspace" \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

#### 常见问题#

##### Q1: 什么时候可以使用 --dangerously-skip-permissions？#

A: 只在完全信任的环境中使用，如本地开发、测试环境或沙箱环境。

##### Q2: 使用此标志有什么风险？#

A: 可能导致意外删除或修改文件、执行危险命令、泄露敏感信息等。

##### Q3: 如何安全地使用此标志？#

A: 在安全的环境中、创建备份、限制工具、使用容器隔离等。

##### Q4: 可以在生产环境中使用吗？#

A: 绝对不可以。生产环境中永远不要使用此标志。

##### Q5: 如何验证环境是否安全？#

A: 检查环境变量、工作目录、网络隔离等。

#### 与其他标志的组合示例#

##### 1. 安全的自动化流程#

```
bash复制#!/bin/bash
# safe-automation.sh

# 验证环境
if [ "$ENV" != "test" ]; then
    exit 1
fi

# 限制工具
claude \
  --dangerously-skip-permissions \
  --allowedTools "Read" "Write" "Grep" \
  -p "执行任务"
```

```
#!/bin/bash
# safe-automation.sh

# 验证环境
if [ "$ENV" != "test" ]; then
    exit 1
fi

# 限制工具
claude \
  --dangerously-skip-permissions \
  --allowedTools "Read" "Write" "Grep" \
  -p "执行任务"
```

##### 2. 备份保护的流程#

```
bash复制#!/bin/bash
# backup-protected-flow.sh
# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"
# 执行任务
claude --dangerously-skip-permissions -p "执行任务"
echo "备份保留在 $BACKUP_DIR"
```

```
#!/bin/bash
# backup-protected-flow.sh
# 创建备份
BACKUP_DIR="backups/$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp -r . "$BACKUP_DIR/"
# 执行任务
claude --dangerously-skip-permissions -p "执行任务"
echo "备份保留在 $BACKUP_DIR"
```

##### 3. 容器隔离的流程#

```
bash复制#!/bin/bash
# container-isolated-flow.sh

# 在容器中运行
docker run --rm -v "$(pwd):/workspace" -w /workspace \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

```
#!/bin/bash
# container-isolated-flow.sh

# 在容器中运行
docker run --rm -v "$(pwd):/workspace" -w /workspace \
  claude-image \
  claude --dangerously-skip-permissions -p "执行任务"
```

#### 总结#

--dangerously-skip-permissions 标志提供了一种跳过所有权限检查的方式。这是一个危险的标志，只应该在完全信任的环境中使用。

```
--dangerously-skip-permissions
```

使用此标志时，请务必：

- 确保环境安全（本地开发、测试环境、沙箱环境）
- 创建备份
- 限制可用工具
- 使用容器隔离
- 记录所有操作

永远不要在生产环境中使用此标志。

合理使用 --dangerously-skip-permissions 可以提高自动化脚本的效率，但必须严格遵循安全最佳实践。

```
--dangerously-skip-permissions
```

---

# 第 7 章

## 1 /init - 初始化命令

**URL**: https://claudecode.tangshuang.net/course/7.1%20%2Finit%20-%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4

#### 概述#

/init 命令是 Claude Code 的核心命令，用于初始化项目知识图谱。它会扫描当前文件夹下的所有文件，将解析结果保存到 CLAUDE.md 文件中，为后续对话提供完整的项目上下文。

```
/init
```

```
CLAUDE.md
```

#### 基本语法#

```
bash复制/init
```

```
/init
```

#### 功能说明#

执行 /init 命令后，Claude Code 会：

```
/init
```

True. 扫描当前目录下的所有文件
True. 解析文件内容并生成项目知识图谱
True. 将解析结果保存到 CLAUDE.md 文件中
True. 后续对话会自动引用该文件作为上下文

```
CLAUDE.md
```

#### 使用场景#

##### 1. 新项目初始化#

当你首次在项目中使用 Claude Code 时，建议先运行 /init 命令，让 AI 全面了解项目结构和代码。

```
/init
```

```
bash复制# 在项目根目录执行初始化
/init
```

```
# 在项目根目录执行初始化
/init
```

##### 2. 项目文件更新后重新初始化#

当项目文件结构或关键代码发生较大变化时，可以再次运行 /init 命令，更新 CLAUDE.md 文件，确保 AI 拥有最新的项目上下文。

```
/init
```

```
CLAUDE.md
```

```
bash复制# 更新项目知识图谱
/init
```

```
# 更新项目知识图谱
/init
```

#### 关键特点#

True. 生成 CLAUDE.md 文件：该文件包含项目所有文件的解析结果，是 AI 理解项目的核心依据
True. 支持手动编辑：你可以直接修改 CLAUDE.md 文件，添加框架说明、项目架构或其他重要信息
True. 自动作为上下文：后续与 Claude Code 的对话会自动引用 CLAUDE.md 文件，无需手动指定
True. 提升对话效率：有了完整的项目上下文，AI 能更准确地理解你的问题和需求

```
CLAUDE.md
```

```
CLAUDE.md
```

#### 注意事项#

- /init 命令不会修改或创建除 CLAUDE.md 外的任何文件
- 大型项目可能需要较长时间来完成扫描和解析
- 建议定期更新 CLAUDE.md 文件，尤其是在项目结构发生重大变化后
- CLAUDE.md 文件可以添加到 .gitignore 中，避免不必要的版本控制

```
/init
```

```
CLAUDE.md
```

```
CLAUDE.md
```

```
CLAUDE.md
```

```
.gitignore
```

#### 与其他命令的配合使用#

```
bash复制# 初始化项目知识，然后开始新的对话
/init
/clear

# 执行流程：
# 1. 生成 CLAUDE.md 文件，包含完整项目上下文
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会自动使用 CLAUDE.md 作为上下文
```

```
# 初始化项目知识，然后开始新的对话
/init
/clear

# 执行流程：
# 1. 生成 CLAUDE.md 文件，包含完整项目上下文
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会自动使用 CLAUDE.md 作为上下文
```

#### 最佳实践#

True. 新项目必用：在任何新项目中首次使用 Claude Code 时，先运行 /init
True. 定期更新：当项目文件发生较大变化时，重新运行 /init
True. 手动补充：根据需要手动编辑 CLAUDE.md，添加 AI 可能需要的额外信息
True. 合理管理：根据项目大小和需求，决定是否将 CLAUDE.md 添加到版本控制中

```
/init
```

```
/init
```

```
CLAUDE.md
```

```
CLAUDE.md
```

---

## 2 /add-dir - 添加额外工作目录

**URL**: https://claudecode.tangshuang.net/course/7.2%20%2Fadd-dir%20-%20%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95

#### 概述#

/add-dir 命令用于向 Claude Code 添加额外的工作目录，使 AI 能够访问和操作多个目录中的文件。这对于多模块项目或需要同时处理多个代码库的场景非常有用。

```
/add-dir
```

#### 基本语法#

```
bash复制/add-dir <directory-path>
```

```
/add-dir <directory-path>
```

#### 参数说明#

```
<directory-path>
```

#### 功能说明#

执行 /add-dir 命令后，Claude Code 会：

```
/add-dir
```

True. 将指定目录添加到工作目录列表
True. Claude 可以访问该目录下的所有文件
True. 文件操作（读取、编辑、创建）可以在多个目录中进行

#### 使用场景#

##### 1. 多模块项目#

```
bash复制# 在主项目中添加子模块目录
/add-dir ./modules/auth
/add-dir ./modules/payment

# 现在 Claude 可以同时访问主项目和子模块的代码
```

```
# 在主项目中添加子模块目录
/add-dir ./modules/auth
/add-dir ./modules/payment

# 现在 Claude 可以同时访问主项目和子模块的代码
```

##### 2. 共享代码库#

```
bash复制# 添加共享代码库
/add-dir ../shared-lib

# Claude 可以引用共享库中的代码
```

```
# 添加共享代码库
/add-dir ../shared-lib

# Claude 可以引用共享库中的代码
```

##### 3. 测试目录#

```
bash复制# 添加测试目录
/add-dir ./tests

# Claude 可以查看和修改测试文件
```

```
# 添加测试目录
/add-dir ./tests

# Claude 可以查看和修改测试文件
```

#### 注意事项#

True. 添加的目录路径必须存在且可访问
True. 可以多次执行 /add-dir 添加多个目录
True. 添加的目录会在当前会话中保持有效
True. 建议使用相对路径，便于项目迁移
True. 敏感目录（如包含密钥的目录）应谨慎添加

```
/add-dir
```

#### 与其他命令的配合使用#

```
bash复制# 初始化主项目，添加额外目录，然后开始工作
/init
/add-dir ./shared
/add-dir ./tests

# 执行流程：
# 1. 初始化主项目知识图谱
# 2. 添加共享代码目录
# 3. 添加测试目录
# 4. Claude 现在可以访问所有这些目录
```

```
# 初始化主项目，添加额外目录，然后开始工作
/init
/add-dir ./shared
/add-dir ./tests

# 执行流程：
# 1. 初始化主项目知识图谱
# 2. 添加共享代码目录
# 3. 添加测试目录
# 4. Claude 现在可以访问所有这些目录
```

#### 最佳实践#

True. 项目结构清晰：在多模块项目中，使用 /add-dir 让 Claude 了解完整的项目结构
True. 按需添加：只添加当前任务需要的目录，避免不必要的目录访问
True. 相对路径优先：使用相对路径而不是绝对路径，便于团队协作
True. 注意安全：避免添加包含敏感信息的目录

```
/add-dir
```

#### 总结#

/add-dir 命令是 Claude Code 中用于扩展工作范围的重要命令。通过使用此命令，你可以：

```
/add-dir
```

- 让 Claude 访问多个目录中的文件
- 处理多模块项目或多个代码库
- 提高跨目录操作的效率

合理使用 /add-dir 命令可以帮助你在复杂项目结构中更高效地使用 Claude Code。

```
/add-dir
```

---

## 3 /mcp - 配置模型上下文协议服务器

**URL**: https://claudecode.tangshuang.net/course/7.3%20%2Fmcp%20-%20%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8

#### 概述#

/mcp 命令用于管理 Claude Code 的模型上下文协议（Model Context Protocol，简称 MCP）服务器。MCP 是一种协议，允许 Claude Code 连接外部工具和数据源，扩展其能力范围。

```
/mcp
```

#### 基本语法#

```
bash复制/mcp <子命令> [参数]
```

```
/mcp <子命令> [参数]
```

#### 子命令#

```
list
```

```
add
```

```
remove
```

```
enable
```

```
disable
```

```
info
```

```
test
```

#### 功能说明#

通过 /mcp 命令，Claude Code 可以：

```
/mcp
```

True. 连接外部文件系统，访问更多项目文件
True. 集成 GitHub 等代码托管平台
True. 连接数据库和 API 服务
True. 使用外部搜索工具
True. 扩展 Claude Code 的功能范围

#### 使用场景#

##### 1. 列出已配置的 MCP 服务器#

```
bash复制# 列出所有已配置的 MCP 服务器
/mcp list
```

```
# 列出所有已配置的 MCP 服务器
/mcp list
```

##### 2. 添加文件系统 MCP 服务器#

```
bash复制# 添加本地文件系统访问
/mcp add filesystem stdio npx @modelcontextprotocol/server-filesystem /path/to/directory
```

```
# 添加本地文件系统访问
/mcp add filesystem stdio npx @modelcontextprotocol/server-filesystem /path/to/directory
```

##### 3. 添加 GitHub MCP 服务器#

```
bash复制# 添加 GitHub 集成
/mcp add github sse https://api.github.com/mcp --token $GITHUB_TOKEN
```

```
# 添加 GitHub 集成
/mcp add github sse https://api.github.com/mcp --token $GITHUB_TOKEN
```

##### 4. 测试 MCP 服务器连接#

```
bash复制# 测试特定 MCP 服务器连接
/mcp test filesystem

# 测试所有 MCP 服务器
/mcp test --all
```

```
# 测试特定 MCP 服务器连接
/mcp test filesystem

# 测试所有 MCP 服务器
/mcp test --all
```

#### 常见 MCP 服务器类型#

##### 1. 文件系统服务器#

```
bash复制# 配置文件系统访问
/mcp add filesystem stdio npx @modelcontextprotocol/server-filesystem ~/projects
```

```
# 配置文件系统访问
/mcp add filesystem stdio npx @modelcontextprotocol/server-filesystem ~/projects
```

##### 2. GitHub 服务器#

```
bash复制# 配置 GitHub 集成
/mcp add github sse https://api.github.com/mcp --token $GITHUB_TOKEN
```

```
# 配置 GitHub 集成
/mcp add github sse https://api.github.com/mcp --token $GITHUB_TOKEN
```

##### 3. 数据库服务器#

```
bash复制# 配置数据库连接
/mcp add database stdio npx @modelcontextprotocol/server-postgres --connection-string "postgresql://user:pass@localhost/db"
```

```
# 配置数据库连接
/mcp add database stdio npx @modelcontextprotocol/server-postgres --connection-string "postgresql://user:pass@localhost/db"
```

#### 注意事项#

True. MCP 服务器需要单独安装和配置
True. 某些 MCP 服务器可能需要 API 密钥或其他凭证
True. 请确保只连接受信任的 MCP 服务器，以保护您的数据安全
True. MCP 服务器的性能取决于服务器类型和网络连接

#### 最佳实践#

True. 只连接必要的 MCP 服务器：避免连接不必要的 MCP 服务器，以提高性能和安全性
True. 使用环境变量存储凭证：不要在命令中直接硬编码 API 密钥或密码
True. 定期测试连接：确保 MCP 服务器始终可用
True. 使用描述性名称：为 MCP 服务器使用清晰、描述性的名称

#### 总结#

/mcp 命令是 Claude Code 中用于扩展功能的重要命令，通过连接外部 MCP 服务器，可以大大增强 Claude Code 的能力。合理使用 /mcp 命令可以帮助您更高效地使用 Claude Code 进行开发工作。

```
/mcp
```

```
/mcp
```

---

## 4 /agents - 管理自定义AI子代理

**URL**: https://claudecode.tangshuang.net/course/7.4%20%2Fagents%20-%20%E7%AE%A1%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89AI%E5%AD%90%E4%BB%A3%E7%90%86

#### 概述#

/agents 命令用于管理专门的自定义 AI 子代理。子代理是具有特定角色和技能的 AI 实例，可以处理特定类型的任务，提高工作效率。

```
/agents
```

#### 基本语法#

```
bash复制/agents [subcommand]
```

```
/agents [subcommand]
```

#### 子命令#

```
create
```

```
edit
```

```
delete
```

```
use
```

#### 功能说明#

##### 列出子代理#

```
bash复制/agents

# 输出示例：
# Available agents:
# - code-reviewer: 专注于代码审查
# - bug-fixer: 专注于修复错误
# - refactoring: 专注于代码重构
```

```
/agents

# 输出示例：
# Available agents:
# - code-reviewer: 专注于代码审查
# - bug-fixer: 专注于修复错误
# - refactoring: 专注于代码重构
```

##### 创建子代理#

```
bash复制/agents create

# 按照提示输入：
# - 代理名称
# - 角色描述
# - 技能要求
# - 工作流程
```

```
/agents create

# 按照提示输入：
# - 代理名称
# - 角色描述
# - 技能要求
# - 工作流程
```

##### 使用子代理#

```
bash复制/agents use code-reviewer

# 现在所有请求将由 code-reviewer 代理处理
```

```
/agents use code-reviewer

# 现在所有请求将由 code-reviewer 代理处理
```

#### 使用场景#

##### 1. 代码审查#

```
bash复制# 使用专门的代码审查代理
/agents use code-reviewer

# 请求代码审查
请审查 src/utils.js 文件
```

```
# 使用专门的代码审查代理
/agents use code-reviewer

# 请求代码审查
请审查 src/utils.js 文件
```

##### 2. 错误修复#

```
bash复制# 切换到错误修复代理
/agents use bug-fixer

# 请求修复错误
修复这个错误：TypeError: Cannot read property 'x' of undefined
```

```
# 切换到错误修复代理
/agents use bug-fixer

# 请求修复错误
修复这个错误：TypeError: Cannot read property 'x' of undefined
```

##### 3. 代码重构#

```
bash复制# 使用重构代理
/agents use refactoring

# 请求重构
重构这个函数以提高性能
```

```
# 使用重构代理
/agents use refactoring

# 请求重构
重构这个函数以提高性能
```

#### 子代理的优势#

True. 专业化：每个子代理专注于特定领域，提供更专业的服务
True. 一致性：使用相同的子代理可以保持输出风格的一致性
True. 效率：子代理已经预设了特定任务的工作流程，提高效率
True. 可定制：可以根据团队需求创建自定义子代理

#### 注意事项#

True. 子代理配置存储在项目或用户级别
True. 切换子代理会影响后续所有请求
True. 可以随时切换回默认代理
True. 子代理的技能和角色需要在创建时明确定义

#### 与其他命令的配合使用#

```
bash复制# 初始化项目，使用特定代理，然后开始工作
/init
/agents use code-reviewer

# 执行流程：
# 1. 初始化项目知识图谱
# 2. 切换到代码审查代理
# 3. 所有后续请求将由代码审查代理处理
```

```
# 初始化项目，使用特定代理，然后开始工作
/init
/agents use code-reviewer

# 执行流程：
# 1. 初始化项目知识图谱
# 2. 切换到代码审查代理
# 3. 所有后续请求将由代码审查代理处理
```

#### 最佳实践#

True. 任务匹配：根据任务类型选择合适的子代理
True. 创建专用代理：为频繁使用的任务创建专门的子代理
True. 团队共享：将团队常用的子代理配置共享到项目中
True. 定期更新：根据需求变化更新子代理配置

#### 总结#

/agents 命令是 Claude Code 中用于管理 AI 子代理的核心命令。通过使用此命令，你可以：

```
/agents
```

- 创建和管理专门的自定义 AI 子代理
- 根据任务类型切换不同的代理
- 提高特定任务的效率和质量
- 保持团队工作风格的一致性

合理使用 /agents 命令可以帮助你在不同类型的任务中获得更专业、更高效的 AI 辅助。

```
/agents
```

---

## 5 /bashes - 管理后台任务

**URL**: https://claudecode.tangshuang.net/course/7.5%20%2Fbashes%20-%20%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1

#### 概述#

/bashes 命令用于列出和管理 Claude Code 中的后台任务。后台任务是在后台运行的 shell 命令，不会阻塞主对话流程，适合长时间运行的操作。

```
/bashes
```

#### 基本语法#

```
bash复制/bashes [subcommand]
```

```
/bashes [subcommand]
```

#### 子命令#

```
kill <task-id>
```

```
output <task-id>
```

```
clear
```

#### 功能说明#

##### 列出后台任务#

```
bash复制/bashes

# 输出示例：
# Background tasks:
# [1] Running - npm install
# [2] Completed - npm run build
# [3] Failed - npm test
```

```
/bashes

# 输出示例：
# Background tasks:
# [1] Running - npm install
# [2] Completed - npm run build
# [3] Failed - npm test
```

##### 终止任务#

```
bash复制/bashes kill 1

# 终止任务 ID 为 1 的后台任务
```

```
/bashes kill 1

# 终止任务 ID 为 1 的后台任务
```

##### 查看任务输出#

```
bash复制/bashes output 2

# 查看任务 ID 为 2 的输出内容
```

```
/bashes output 2

# 查看任务 ID 为 2 的输出内容
```

##### 清除已完成任务#

```
bash复制/bashes clear

# 清除所有已完成的任务
```

```
/bashes clear

# 清除所有已完成的任务
```

#### 使用场景#

##### 1. 长时间运行的构建#

```
bash复制# 在后台运行构建任务
npm run build &

# 查看任务状态
/bashes
```

```
# 在后台运行构建任务
npm run build &

# 查看任务状态
/bashes
```

##### 2. 安装依赖#

```
bash复制# 在后台安装依赖
npm install &

# 继续其他工作，稍后检查状态
/bashes
```

```
# 在后台安装依赖
npm install &

# 继续其他工作，稍后检查状态
/bashes
```

##### 3. 运行测试#

```
bash复制# 在后台运行测试
npm test &

# 查看测试结果
/bashes output 3
```

```
# 在后台运行测试
npm test &

# 查看测试结果
/bashes output 3
```

##### 4. 监控任务#

```
bash复制# 定期检查后台任务状态
/bashes

# 根据需要终止或查看输出
/bashes kill 1
/bashes output 2
```

```
# 定期检查后台任务状态
/bashes

# 根据需要终止或查看输出
/bashes kill 1
/bashes output 2
```

#### 后台任务的优势#

True. 非阻塞：后台任务不会阻塞主对话流程
True. 多任务：可以同时运行多个后台任务
True. 监控：可以随时查看任务状态和输出
True. 控制：可以终止不需要的任务

#### 注意事项#

True. 后台任务会在 Claude Code 会话结束时终止
True. 任务 ID 是会话内唯一的，会话结束后会重置
True. 终止任务会立即停止其执行
True. 已完成任务可以查看输出，但会被清除命令清理

#### 与其他命令的配合使用#

```
bash复制# 启动后台任务，然后继续其他工作
npm run build &
/bashes

# 执行流程：
# 1. 在后台启动构建任务
# 2. 查看所有后台任务状态
# 3. 可以继续其他对话，构建在后台进行
```

```
# 启动后台任务，然后继续其他工作
npm run build &
/bashes

# 执行流程：
# 1. 在后台启动构建任务
# 2. 查看所有后台任务状态
# 3. 可以继续其他对话，构建在后台进行
```

#### 最佳实践#

True. 长时间任务：将长时间运行的任务放在后台执行
True. 定期检查：定期使用 /bashes 检查任务状态
True. 及时清理：使用 /bashes clear 清理已完成的任务
True. 合理终止：及时终止不需要的任务，释放资源

```
/bashes
```

```
/bashes clear
```

#### 总结#

/bashes 命令是 Claude Code 中用于管理后台任务的重要命令。通过使用此命令，你可以：

```
/bashes
```

- 查看所有后台任务的状态
- 终止不需要的任务
- 查看任务的输出
- 清理已完成的任务

合理使用 /bashes 命令可以帮助你更高效地管理长时间运行的任务，保持对话流程的流畅性。

```
/bashes
```

---

## 6 /clear - 清除对话历史

**URL**: https://claudecode.tangshuang.net/course/7.6%20%2Fclear%20-%20%E6%B8%85%E9%99%A4%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2

#### 概述#

/clear 命令用于清除 Claude Code 的对话历史，重置当前会话上下文。执行后，Claude 将从空上下文开始理解你的下一条指令。

```
/clear
```

#### 基本语法#

```
bash复制/clear
```

```
/clear
```

#### 功能说明#

执行 /clear 命令后，Claude Code 会：

```
/clear
```

True. 清除当前会话的所有对话历史
True. 重置上下文窗口
True. 保持 Claude Code 界面打开，准备新的对话

#### 使用场景#

##### 1. 任务切换时重置上下文#

```
bash复制# 完成一个任务后，开始新任务前
/clear

# 执行后，Claude 将忘记之前的所有对话内容
```

```
# 完成一个任务后，开始新任务前
/clear

# 执行后，Claude 将忘记之前的所有对话内容
```

##### 2. 清理过长的对话#

```
bash复制# 当对话持续很久、上下文累积过多时
/clear

# 重置上下文，保持思路清晰
```

```
# 当对话持续很久、上下文累积过多时
/clear

# 重置上下文，保持思路清晰
```

##### 3. 修复对话偏离#

```
bash复制# 当 Claude 的回答出现偏离正轨或上下文混乱时
/clear

# 一键"重启"对话，重新开始
```

```
# 当 Claude 的回答出现偏离正轨或上下文混乱时
/clear

# 一键"重启"对话，重新开始
```

#### 注意事项#

True. /clear 命令无任何参数，执行后将彻底清除对话历史
True. 清除的对话内容无法恢复，请谨慎使用
True. 该命令只会清除对话历史，不会退出 Claude Code 界面
True. 不会影响已生成的 CLAUDE.md 文件或其他项目文件

```
/clear
```

```
CLAUDE.md
```

#### 与其他命令的组合#

```
bash复制# 初始化项目知识后，开始新的对话
/init
/clear

# 执行流程：
# 1. 生成 CLAUDE.md 文件，包含完整项目上下文
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会自动使用 CLAUDE.md 作为上下文，但忘记之前的对话
```

```
# 初始化项目知识后，开始新的对话
/init
/clear

# 执行流程：
# 1. 生成 CLAUDE.md 文件，包含完整项目上下文
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会自动使用 CLAUDE.md 作为上下文，但忘记之前的对话
```

#### 最佳实践#

True. 任务切换必用：在完成一个独立任务后，开始新任务前执行 /clear
True. 定期清理：长时间对话时，定期执行 /clear 保持上下文简洁
True. 及时重置：当对话出现混乱时，立即使用 /clear 重置
True. 避免频繁使用：在同一个任务的连续对话中，避免不必要的 /clear 调用

```
/clear
```

```
/clear
```

```
/clear
```

```
/clear
```

#### 总结#

/clear 命令是 Claude Code 中用于管理会话上下文的核心命令。通过使用此命令，你可以：

```
/clear
```

- 清除当前会话的所有对话历史
- 重置上下文窗口，保持思路清晰
- 避免旧话题干扰新需求
- 修复对话偏离正轨的情况

合理使用 /clear 命令可以帮助你在与 Claude Code 交互时保持高效和专注。

```
/clear
```

---

## 7 /bug - 报告错误

**URL**: https://claudecode.tangshuang.net/course/7.7%20%2Fbug%20-%20%E6%8A%A5%E5%91%8A%E9%94%99%E8%AF%AF

#### 概述#

/bug 命令用于向 Anthropic 报告 Claude Code 的错误或问题。执行此命令会将当前对话内容发送给 Anthropic 团队，帮助他们诊断和修复问题。

```
/bug
```

#### 基本语法#

```
bash复制/bug
```

```
/bug
```

#### 功能说明#

执行 /bug 命令后，Claude Code 会：

```
/bug
```

True. 收集当前会话的对话历史
True. 收集系统信息和错误日志
True. 将这些信息发送给 Anthropic 团队
True. 显示报告提交确认信息

#### 使用场景#

##### 1. 遇到程序错误#

```
bash复制# 当 Claude Code 出现异常或错误时
/bug

# 系统会收集错误信息并发送给 Anthropic
```

```
# 当 Claude Code 出现异常或错误时
/bug

# 系统会收集错误信息并发送给 Anthropic
```

##### 2. 功能异常#

```
bash复制# 当某个功能不按预期工作时
/bug

# 报告功能问题，帮助改进产品
```

```
# 当某个功能不按预期工作时
/bug

# 报告功能问题，帮助改进产品
```

##### 3. 性能问题#

```
bash复制# 当遇到性能问题时
/bug

# 报告性能瓶颈，帮助优化
```

```
# 当遇到性能问题时
/bug

# 报告性能瓶颈，帮助优化
```

#### 报告内容#

/bug 命令会收集以下信息：

```
/bug
```

True. 对话历史：当前会话的完整对话内容
True. 系统信息：操作系统、Claude Code 版本等
True. 错误日志：相关的错误信息和堆栈跟踪
True. 环境信息：工作目录、文件结构等

#### 注意事项#

True. 报告会包含当前对话的完整内容，请确保不包含敏感信息
True. 报告是匿名的，不会关联到你的账户
True. 提交报告后，Anthropic 团队会进行分析和修复
True. 不要滥用此命令，只在遇到真正的问题时使用
True. 报告后无法撤销，请谨慎使用

#### 隐私保护#

- 对话内容仅用于问题诊断
- 不会用于训练 AI 模型
- 不会与第三方共享
- 数据会按照 Anthropic 的隐私政策处理

#### 与其他命令的配合使用#

```
bash复制# 遇到问题时，先尝试诊断，然后报告
/doctor
/bug

# 执行流程：
# 1. 运行诊断检查
# 2. 如果问题无法解决，提交错误报告
```

```
# 遇到问题时，先尝试诊断，然后报告
/doctor
/bug

# 执行流程：
# 1. 运行诊断检查
# 2. 如果问题无法解决，提交错误报告
```

#### 最佳实践#

True. 先诊断：在使用 /bug 前，先尝试 /doctor 诊断问题
True. 描述清楚：在报告前，确保对话中清楚描述了问题
True. 避免敏感信息：确保对话中不包含密码、密钥等敏感信息
True. 合理使用：只在遇到真正的 bug 时使用，不要滥用

```
/bug
```

```
/doctor
```

#### 何时使用 /bug#

适合使用的情况：

- Claude Code 崩溃或无响应
- 功能完全不工作
- 出现明显的程序错误
- 性能严重下降

不适合使用的情况：

- AI 回答不准确（这是模型能力问题）
- 功能不符合预期（这是使用问题）
- 需要功能建议（这是功能请求）

#### 总结#

/bug 命令是 Claude Code 中用于报告错误的重要工具。通过使用此命令，你可以：

```
/bug
```

- 向 Anthropic 团队报告程序错误
- 帮助改进 Claude Code 的质量
- 促进产品的持续优化

合理使用 /bug 命令可以帮助 Anthropic 团队更快地发现和修复问题，提升所有用户的体验。

```
/bug
```

---

## 8 /config - 打开设置界面

**URL**: https://claudecode.tangshuang.net/course/7.8%20%2Fconfig%20-%20%E6%89%93%E5%BC%80%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2

#### 概述#

/config 命令用于打开 Claude Code 的设置界面，允许你配置各种选项和偏好设置。设置界面提供了图形化的配置方式，方便用户自定义 Claude Code 的行为。

```
/config
```

#### 基本语法#

```
bash复制/config
```

```
/config
```

#### 功能说明#

执行 /config 命令后，Claude Code 会：

```
/config
```

True. 打开设置界面（配置选项卡）
True. 显示所有可配置的选项
True. 允许用户修改配置
True. 保存配置更改

#### 配置选项#

设置界面包含以下主要配置类别：

##### 1. 模型设置#

- 选择默认 AI 模型
- 配置模型参数
- 设置温度、最大令牌数等

##### 2. 界面设置#

- 主题选择
- 字体大小
- 界面布局

##### 3. 行为设置#

- 自动保存
- 文件监听
- 上下文管理

##### 4. 集成设置#

- Git 集成
- MCP 服务器
- 插件配置

##### 5. 安全设置#

- 权限管理
- 隐私设置
- 沙箱配置

#### 使用场景#

##### 1. 更改默认模型#

```
bash复制/config

# 在设置界面中：
# 1. 选择"模型"选项卡
# 2. 选择默认模型
# 3. 保存更改
```

```
/config

# 在设置界面中：
# 1. 选择"模型"选项卡
# 2. 选择默认模型
# 3. 保存更改
```

##### 2. 调整界面主题#

```
bash复制/config

# 在设置界面中：
# 1. 选择"界面"选项卡
# 2. 选择主题
# 3. 保存更改
```

```
/config

# 在设置界面中：
# 1. 选择"界面"选项卡
# 2. 选择主题
# 3. 保存更改
```

##### 3. 配置权限#

```
bash复制/config

# 在设置界面中：
# 1. 选择"安全"选项卡
# 2. 配置权限规则
# 3. 保存更改
```

```
/config

# 在设置界面中：
# 1. 选择"安全"选项卡
# 2. 配置权限规则
# 3. 保存更改
```

#### 注意事项#

True. 配置更改会立即生效
True. 某些配置可能需要重启 Claude Code 才能完全生效
True. 配置文件存储在用户目录中
True. 可以手动编辑配置文件进行高级配置

#### 配置文件位置#

配置文件通常位于：

- Windows: %APPDATA%\claude\config.json
- macOS: ~/Library/Application Support/claude/config.json
- Linux: ~/.config/claude/config.json

```
%APPDATA%\claude\config.json
```

```
~/Library/Application Support/claude/config.json
```

```
~/.config/claude/config.json
```

#### 与其他命令的配合使用#

```
bash复制# 打开配置，然后验证更改
/config
/doctor

# 执行流程：
# 1. 打开设置界面
# 2. 修改配置
# 3. 运行诊断检查验证配置
```

```
# 打开配置，然后验证更改
/config
/doctor

# 执行流程：
# 1. 打开设置界面
# 2. 修改配置
# 3. 运行诊断检查验证配置
```

#### 最佳实践#

True. 定期检查：定期检查配置设置，确保符合当前需求
True. 备份配置：在大幅修改配置前，备份配置文件
True. 测试更改：修改配置后，测试相关功能是否正常
True. 团队共享：将团队常用的配置共享到项目中

#### 常用配置建议#

##### 开发环境#

```
json复制{
  "model": "claude-3-5-sonnet-20241022",
  "theme": "dark",
  "autoSave": true
}
```

```
{
  "model": "claude-3-5-sonnet-20241022",
  "theme": "dark",
  "autoSave": true
}
```

##### 生产环境#

```
json复制{
  "model": "claude-3-5-haiku-20241022",
  "theme": "light",
  "autoSave": false,
  "sandbox": true
}
```

```
{
  "model": "claude-3-5-haiku-20241022",
  "theme": "light",
  "autoSave": false,
  "sandbox": true
}
```

#### 总结#

/config 命令是 Claude Code 中用于配置的重要工具。通过使用此命令，你可以：

```
/config
```

- 打开图形化设置界面
- 配置各种选项和偏好
- 自定义 Claude Code 的行为
- 优化工作流程

合理使用 /config 命令可以帮助你创建最适合自己工作习惯的 Claude Code 环境。

```
/config
```

---

## 9 /context - 查看上下文使用情况

**URL**: https://claudecode.tangshuang.net/course/7.9%20%2Fcontext%20-%20%E6%9F%A5%E7%9C%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5

#### 概述#

/context 命令用于将当前上下文使用情况可视化为彩色网格，帮助你了解 token 使用情况，优化对话效率。

```
/context
```

#### 基本语法#

```
bash复制/context
```

```
/context
```

#### 功能说明#

执行 /context 命令后，Claude Code 会：

```
/context
```

True. 分析当前会话的上下文使用情况
True. 以彩色网格形式显示 token 使用分布
True. 显示各组件的 token 占用比例
True. 提供优化建议

#### 可视化说明#

彩色网格使用不同颜色表示不同的上下文组件：

- 绿色：对话历史
- 蓝色：文件内容
- 黄色：系统提示
- 红色：接近上限
- 灰色：未使用空间

#### 使用场景#

##### 1. 监控 token 使用#

```
bash复制# 在长时间对话中定期检查
/context

# 查看当前 token 使用情况
```

```
# 在长时间对话中定期检查
/context

# 查看当前 token 使用情况
```

##### 2. 诊断性能问题#

```
bash复制# 当响应变慢时
/context

# 检查是否因上下文过大导致
```

```
# 当响应变慢时
/context

# 检查是否因上下文过大导致
```

##### 3. 优化对话#

```
bash复制# 查看 token 使用分布
/context

# 根据结果优化对话策略
```

```
# 查看 token 使用分布
/context

# 根据结果优化对话策略
```

#### 输出示例#

```
bash复制Context Usage:
███████████████████████████████████████████████████ 85%
[GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG]
[BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB]
[YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY]

Components:
- Conversation History: 45,000 tokens (45%)
- File Contents: 30,000 tokens (30%)
- System Prompts: 10,000 tokens (10%)
- Available: 15,000 tokens (15%)

Total: 100,000 / 200,000 tokens
```

```
Context Usage:
███████████████████████████████████████████████████ 85%
[GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG]
[BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB]
[YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY]

Components:
- Conversation History: 45,000 tokens (45%)
- File Contents: 30,000 tokens (30%)
- System Prompts: 10,000 tokens (10%)
- Available: 15,000 tokens (15%)

Total: 100,000 / 200,000 tokens
```

#### 优化建议#

##### 1. 减少文件引用#

```
bash复制# 避免引用过多文件
# 只引用当前需要的文件
```

```
# 避免引用过多文件
# 只引用当前需要的文件
```

##### 2. 压缩对话历史#

```
bash复制# 使用 /compact 压缩对话
/compact
```

```
# 使用 /compact 压缩对话
/compact
```

##### 3. 清除不必要的内容#

```
bash复制# 使用 /clear 清空对话
/clear
```

```
# 使用 /clear 清空对话
/clear
```

#### 注意事项#

True. 上下文窗口大小取决于使用的模型
True. 不同的模型有不同的 token 限制
True. 接近上限时，建议压缩或清除上下文
True. 彩色网格是实时更新的

#### 与其他命令的配合使用#

```
bash复制# 查看上下文，然后优化
/context
/compact
/context

# 执行流程：
# 1. 查看当前上下文使用情况
# 2. 压缩对话历史
# 3. 再次查看，确认优化效果
```

```
# 查看上下文，然后优化
/context
/compact
/context

# 执行流程：
# 1. 查看当前上下文使用情况
# 2. 压缩对话历史
# 3. 再次查看，确认优化效果
```

#### 最佳实践#

True. 定期检查：在长时间对话中定期使用 /context 检查
True. 及时优化：当使用率超过 70% 时，考虑优化
True. 合理引用：只引用当前任务需要的文件
True. 压缩历史：定期使用 /compact 压缩对话历史

```
/context
```

```
/compact
```

#### 总结#

/context 命令是 Claude Code 中用于监控上下文使用的重要工具。通过使用此命令，你可以：

```
/context
```

- 可视化当前上下文使用情况
- 了解 token 使用分布
- 诊断性能问题
- 优化对话效率

合理使用 /context 命令可以帮助你更好地管理 token 使用，提高对话效率。

```
/context
```

---

## 10 /cost - 显示令牌使用统计

**URL**: https://claudecode.tangshuang.net/course/7.10%20%2Fcost%20-%20%E6%98%BE%E7%A4%BA%E4%BB%A4%E7%89%8C%E4%BD%BF%E7%94%A8%E7%BB%9F%E8%AE%A1

#### 概述#

/cost 命令用于显示令牌使用统计信息，帮助你跟踪和优化 Claude Code 的使用成本。

```
/cost
```

#### 基本语法#

```
bash复制/cost
```

```
/cost
```

#### 功能说明#

执行 /cost 命令后，Claude Code 会：

```
/cost
```

True. 显示当前会话的令牌使用统计
True. 显示输入和输出令牌数量
True. 估算使用成本
True. 显示使用限制和速率限制状态

#### 使用场景#

##### 1. 监控使用情况#

```
bash复制# 查看当前会话的使用统计
/cost

# 了解令牌消耗情况
```

```
# 查看当前会话的使用统计
/cost

# 了解令牌消耗情况
```

##### 2. 成本跟踪#

```
bash复制# 定期检查使用成本
/cost

# 估算月度使用成本
```

```
# 定期检查使用成本
/cost

# 估算月度使用成本
```

##### 3. 优化使用#

```
bash复制# 查看使用统计，优化对话策略
/cost

# 根据统计结果调整使用方式
```

```
# 查看使用统计，优化对话策略
/cost

# 根据统计结果调整使用方式
```

#### 输出示例#

```
bash复制Token Usage Statistics:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Current Session:
- Input Tokens: 45,000
- Output Tokens: 30,000
- Total Tokens: 75,000

Estimated Cost:
- Input: $0.045 (at $1.00/1M tokens)
- Output: $0.150 (at $5.00/1M tokens)
- Total: $0.195

Usage Limits:
- Daily: 75,000 / 200,000 tokens (37.5%)
- Monthly: 150,000 / 1,000,000 tokens (15%)
```

```
Token Usage Statistics:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Current Session:
- Input Tokens: 45,000
- Output Tokens: 30,000
- Total Tokens: 75,000

Estimated Cost:
- Input: $0.045 (at $1.00/1M tokens)
- Output: $0.150 (at $5.00/1M tokens)
- Total: $0.195

Usage Limits:
- Daily: 75,000 / 200,000 tokens (37.5%)
- Monthly: 150,000 / 1,000,000 tokens (15%)
```

#### 令牌类型#

##### 输入令牌 (Input Tokens)#

- 你发送给 Claude 的文本
- 包括对话历史、文件内容、系统提示等
- 通常比输出令牌便宜

##### 输出令牌 (Output Tokens)#

- Claude 生成的文本
- 包括回答、代码、建议等
- 通常比输入令牌贵

#### 成本优化建议#

##### 1. 减少输入令牌#

```
bash复制# 避免引用过多文件
# 只引用当前需要的文件
# 使用 /compact 压缩对话历史
```

```
# 避免引用过多文件
# 只引用当前需要的文件
# 使用 /compact 压缩对话历史
```

##### 2. 优化提示词#

```
bash复制# 使用简洁明确的提示
# 避免重复的上下文
# 定期使用 /clear 清空对话
```

```
# 使用简洁明确的提示
# 避免重复的上下文
# 定期使用 /clear 清空对话
```

##### 3. 选择合适的模型#

```
bash复制# 使用 /model 选择适合的模型
# 对于简单任务，使用较小的模型
# 对于复杂任务，使用较大的模型
```

```
# 使用 /model 选择适合的模型
# 对于简单任务，使用较小的模型
# 对于复杂任务，使用较大的模型
```

#### 使用限制#

不同的订阅计划有不同的使用限制：

##### 免费计划#

- 每日：200,000 令牌
- 每月：1,000,000 令牌

##### 付费计划#

- 每日：500,000 令牌
- 每月：5,000,000 令牌

#### 注意事项#

True. 令牌统计是估算值，实际计费可能略有差异
True. 成本基于当前模型的定价
True. 使用限制会在每日/每月重置
True. 超出限制后，可能需要升级计划

#### 与其他命令的配合使用#

```
bash复制# 查看使用统计，然后优化
/cost
/compact
/cost

# 执行流程：
# 1. 查看当前使用统计
# 2. 压缩对话历史
# 3. 再次查看，确认优化效果
```

```
# 查看使用统计，然后优化
/cost
/compact
/cost

# 执行流程：
# 1. 查看当前使用统计
# 2. 压缩对话历史
# 3. 再次查看，确认优化效果
```

#### 最佳实践#

True. 定期检查：定期使用 /cost 检查使用情况
True. 及时优化：当使用率超过 70% 时，考虑优化
True. 合理使用：根据任务复杂度选择合适的模型
True. 压缩历史：定期使用 /compact 减少令牌消耗

```
/cost
```

```
/compact
```

#### 总结#

/cost 命令是 Claude Code 中用于跟踪使用成本的重要工具。通过使用此命令，你可以：

```
/cost
```

- 查看令牌使用统计
- 估算使用成本
- 监控使用限制
- 优化使用策略

合理使用 /cost 命令可以帮助你更好地控制使用成本，提高使用效率。

```
/cost
```

---

## 11 /doctor - 检查安装健康状况

**URL**: https://claudecode.tangshuang.net/course/7.11%20%2Fdoctor%20-%20%E6%A3%80%E6%9F%A5%E5%AE%89%E8%A3%85%E5%81%A5%E5%BA%B7%E7%8A%B6%E5%86%B5

#### 概述#

/doctor 命令用于检查 Claude Code 的安装健康状况，诊断常见问题，并提供修复建议。

```
/doctor
```

#### 基本语法#

```
bash复制/doctor
```

```
/doctor
```

#### 功能说明#

执行 /doctor 命令后，Claude Code 会：

```
/doctor
```

True. 检查系统环境
True. 验证安装完整性
True. 测试网络连接
True. 检查配置文件
True. 提供诊断报告和修复建议

#### 检查项目#

##### 1. 系统环境#

- 操作系统版本
- Node.js 版本
- 内存和磁盘空间

##### 2. 安装完整性#

- Claude Code 版本
- 依赖包完整性
- 可执行文件路径

##### 3. 网络连接#

- Anthropic API 连接
- 代理设置
- DNS 解析

##### 4. 配置文件#

- 配置文件语法
- 配置文件路径
- 配置项有效性

##### 5. 认证状态#

- 登录状态
- 令牌有效性
- 账户权限

#### 使用场景#

##### 1. 遇到问题时诊断#

```
bash复制# 当 Claude Code 出现问题时
/doctor

# 查看诊断报告
```

```
# 当 Claude Code 出现问题时
/doctor

# 查看诊断报告
```

##### 2. 安装后验证#

```
bash复制# 安装完成后验证
/doctor

# 确保安装正常
```

```
# 安装完成后验证
/doctor

# 确保安装正常
```

##### 3. 定期健康检查#

```
bash复制# 定期运行健康检查
/doctor

# 确保系统运行正常
```

```
# 定期运行健康检查
/doctor

# 确保系统运行正常
```

#### 输出示例#

```
bash复制Claude Code Health Check
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ System Environment
  - OS: Windows 11
  - Node.js: v18.17.0
  - Memory: 16 GB
  - Disk: 50 GB available

✓ Installation
  - Version: 1.0.124
  - Dependencies: All installed
  - Executable: Found at C:\Program Files\claude\bin\claude.exe

✓ Network Connection
  - API Connection: OK
  - Proxy: Not configured
  - DNS: Resolving correctly

✓ Configuration
  - Config File: Valid
  - Config Path: C:\Users\user\.config\claude\config.json
  - Settings: All valid

✓ Authentication
  - Status: Logged in
  - Token: Valid
  - Permissions: Full access

Overall Status: ✓ Healthy
```

```
Claude Code Health Check
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ System Environment
  - OS: Windows 11
  - Node.js: v18.17.0
  - Memory: 16 GB
  - Disk: 50 GB available

✓ Installation
  - Version: 1.0.124
  - Dependencies: All installed
  - Executable: Found at C:\Program Files\claude\bin\claude.exe

✓ Network Connection
  - API Connection: OK
  - Proxy: Not configured
  - DNS: Resolving correctly

✓ Configuration
  - Config File: Valid
  - Config Path: C:\Users\user\.config\claude\config.json
  - Settings: All valid

✓ Authentication
  - Status: Logged in
  - Token: Valid
  - Permissions: Full access

Overall Status: ✓ Healthy
```

#### 常见问题诊断#

##### 问题 1：网络连接失败#

```
bash复制✗ Network Connection
  - API Connection: Failed
  - Error: Connection timeout

Suggested Fix:
1. Check internet connection
2. Verify proxy settings
3. Try disabling VPN
```

```
✗ Network Connection
  - API Connection: Failed
  - Error: Connection timeout

Suggested Fix:
1. Check internet connection
2. Verify proxy settings
3. Try disabling VPN
```

##### 问题 2：认证失败#

```
bash复制✗ Authentication
  - Status: Not logged in
  - Error: Invalid token

Suggested Fix:
1. Run /logout
2. Run /login
3. Verify account credentials
```

```
✗ Authentication
  - Status: Not logged in
  - Error: Invalid token

Suggested Fix:
1. Run /logout
2. Run /login
3. Verify account credentials
```

##### 问题 3：配置文件错误#

```
bash复制✗ Configuration
  - Config File: Invalid syntax
  - Error: Unexpected token at line 10

Suggested Fix:
1. Check config.json syntax
2. Run /config to reset settings
3. Restore from backup
```

```
✗ Configuration
  - Config File: Invalid syntax
  - Error: Unexpected token at line 10

Suggested Fix:
1. Check config.json syntax
2. Run /config to reset settings
3. Restore from backup
```

#### 注意事项#

True. /doctor 不会修改任何文件或设置
True. 诊断报告会保存到日志文件中
True. 某些检查可能需要网络连接
True. 修复建议需要手动执行

```
/doctor
```

#### 与其他命令的配合使用#

```
bash复制# 诊断问题，然后修复
/doctor
/login
/doctor

# 执行流程：
# 1. 运行诊断检查
# 2. 根据建议执行修复
# 3. 再次运行诊断确认修复
```

```
# 诊断问题，然后修复
/doctor
/login
/doctor

# 执行流程：
# 1. 运行诊断检查
# 2. 根据建议执行修复
# 3. 再次运行诊断确认修复
```

#### 最佳实践#

True. 安装后检查：安装完成后立即运行 /doctor
True. 问题诊断：遇到问题时首先运行 /doctor
True. 定期检查：定期运行健康检查，确保系统正常
True. 备份配置：在修改配置前，先备份配置文件

```
/doctor
```

```
/doctor
```

#### 总结#

/doctor 命令是 Claude Code 中用于诊断问题的重要工具。通过使用此命令，你可以：

```
/doctor
```

- 检查系统环境
- 验证安装完整性
- 测试网络连接
- 检查配置文件
- 获取修复建议

合理使用 /doctor 命令可以帮助你快速诊断和解决 Claude Code 的问题。

```
/doctor
```

---

## 12 /exit - 退出REPL

**URL**: https://claudecode.tangshuang.net/course/7.12%20%2Fexit%20-%20%E9%80%80%E5%87%BAREPL

#### 概述#

/exit 命令用于退出 Claude Code 的交互式 REPL（Read-Eval-Print Loop）环境，结束当前会话。

```
/exit
```

#### 基本语法#

```
bash复制/exit
```

```
/exit
```

#### 功能说明#

执行 /exit 命令后，Claude Code 会：

```
/exit
```

True. 保存当前会话状态（如果配置了自动保存）
True. 清理临时文件
True. 关闭所有后台任务
True. 退出 REPL 环境
True. 返回命令行

#### 使用场景#

##### 1. 完成工作后退出#

```
bash复制# 完成所有工作后
/exit

# 退出 Claude Code
```

```
# 完成所有工作后
/exit

# 退出 Claude Code
```

##### 2. 需要重启时退出#

```
bash复制# 需要重启 Claude Code 时
/exit

# 然后重新启动
```

```
# 需要重启 Claude Code 时
/exit

# 然后重新启动
```

##### 3. 切换项目时退出#

```
bash复制# 切换到另一个项目前
/exit

# 在新项目目录中重新启动
```

```
# 切换到另一个项目前
/exit

# 在新项目目录中重新启动
```

#### 注意事项#

True. /exit 会立即退出，不会提示保存
True. 未保存的对话历史会丢失
True. 后台任务会被终止
True. 配置和设置会保留

```
/exit
```

#### 与其他命令的配合使用#

```
bash复制# 退出前清理
/export session.md
/exit

# 执行流程：
# 1. 导出当前对话到文件
# 2. 退出 Claude Code
```

```
# 退出前清理
/export session.md
/exit

# 执行流程：
# 1. 导出当前对话到文件
# 2. 退出 Claude Code
```

#### 最佳实践#

True. 导出对话：退出前使用 /export 保存重要对话
True. 清理后台：退出前使用 /bashes 检查后台任务
True. 保存状态：确保重要工作已保存
True. 正常退出：使用 /exit 而不是强制终止

```
/export
```

```
/bashes
```

```
/exit
```

#### 总结#

/exit 命令是 Claude Code 中用于退出 REPL 的命令。通过使用此命令，你可以：

```
/exit
```

- 正常退出 Claude Code
- 清理临时文件
- 关闭后台任务
- 保存会话状态

合理使用 /exit 命令可以帮助你安全地结束 Claude Code 会话。

```
/exit
```

---

## 13 /export - 导出对话

**URL**: https://claudecode.tangshuang.net/course/7.13%20%2Fexport%20-%20%E5%AF%BC%E5%87%BA%E5%AF%B9%E8%AF%9D

#### 概述#

/export 命令用于将当前对话导出到文件或剪贴板，方便保存和分享重要的对话内容。

```
/export
```

#### 基本语法#

```
bash复制/export [filename]
```

```
/export [filename]
```

#### 参数说明#

```
[filename]
```

#### 功能说明#

执行 /export 命令后，Claude Code 会：

```
/export
```

True. 收集当前会话的完整对话历史
True. 格式化为 Markdown 格式
True. 导出到指定文件或剪贴板
True. 显示导出成功确认

#### 使用场景#

##### 1. 导出到文件#

```
bash复制# 导出对话到文件
/export session-2024-01-01.md

# 对话会保存到当前目录
```

```
# 导出对话到文件
/export session-2024-01-01.md

# 对话会保存到当前目录
```

##### 2. 导出到剪贴板#

```
bash复制# 导出到剪贴板
/export

# 对话内容会复制到剪贴板
```

```
# 导出到剪贴板
/export

# 对话内容会复制到剪贴板
```

##### 3. 导出重要对话#

```
bash复制# 导出重要的对话记录
/export important-discussion.md

# 保存以便后续参考
```

```
# 导出重要的对话记录
/export important-discussion.md

# 保存以便后续参考
```

##### 4. 分享对话#

```
bash复制# 导出对话以便分享
/export share-with-team.md

# 可以通过邮件或其他方式分享
```

```
# 导出对话以便分享
/export share-with-team.md

# 可以通过邮件或其他方式分享
```

#### 导出格式#

导出的文件采用 Markdown 格式，包含：

```
markdown复制# Claude Code Session

Date: 2024-01-01 14:30:00
Model: claude-3-5-sonnet-20241022

## Conversation

### User
你好，请帮我写一个 Python 函数。

### Assistant
好的，这是一个示例函数...

### User
谢谢，能解释一下吗？

### Assistant
当然，这个函数的作用是...

---
End of Session
```

```
# Claude Code Session

Date: 2024-01-01 14:30:00
Model: claude-3-5-sonnet-20241022

## Conversation

### User
你好，请帮我写一个 Python 函数。

### Assistant
好的，这是一个示例函数...

### User
谢谢，能解释一下吗？

### Assistant
当然，这个函数的作用是...

---
End of Session
```

#### 注意事项#

True. 导出的文件会覆盖同名文件
True. 导出到剪贴板会替换剪贴板内容
True. 导出包含完整的对话历史
True. 敏感信息会被包含在导出中

#### 与其他命令的配合使用#

```
bash复制# 导出对话，然后退出
/export session.md
/exit

# 执行流程：
# 1. 导出当前对话到文件
# 2. 退出 Claude Code
```

```
# 导出对话，然后退出
/export session.md
/exit

# 执行流程：
# 1. 导出当前对话到文件
# 2. 退出 Claude Code
```

#### 最佳实践#

True. 定期导出：定期导出重要对话，避免丢失
True. 命名规范：使用有意义的文件名，便于管理
True. 敏感信息：导出前检查是否包含敏感信息
True. 版本控制：可以将导出的文件加入版本控制

#### 总结#

/export 命令是 Claude Code 中用于保存对话的重要工具。通过使用此命令，你可以：

```
/export
```

- 导出对话到文件
- 导出对话到剪贴板
- 保存重要对话记录
- 分享对话内容

合理使用 /export 命令可以帮助你保存和管理重要的对话内容。

```
/export
```

---

## 14 /compact - 压缩对话历史

**URL**: https://claudecode.tangshuang.net/course/7.14%20%2Fcompact%20-%20%E5%8E%8B%E7%BC%A9%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2

#### 概述#

/compact 命令是 Claude Code 的核心命令之一，用于压缩对话历史，保留核心信息，减少 token 消耗，同时保持对话的连贯性。

```
/compact
```

#### 基本语法#

```
bash复制/compact
```

```
/compact
```

#### 功能说明#

执行 /compact 命令后，Claude Code 会：

```
/compact
```

True. 分析当前对话历史
True. 保留对话的核心信息和上下文
True. 压缩对话内容，减少 token 数量
True. 保持对话的连贯性，使 Claude 能够继续理解后续对话

#### 使用场景#

##### 1. 对话过长时压缩#

```
bash复制# 当对话持续很久，上下文累积过多时
/compact

# 压缩对话历史，减少 token 消耗
```

```
# 当对话持续很久，上下文累积过多时
/compact

# 压缩对话历史，减少 token 消耗
```

##### 2. 任务切换前压缩#

```
bash复制# 在完成一个任务，准备开始新任务前
/compact

# 保留核心信息，为新任务腾出上下文空间
```

```
# 在完成一个任务，准备开始新任务前
/compact

# 保留核心信息，为新任务腾出上下文空间
```

##### 3. token 消耗过高时压缩#

```
bash复制# 当提示 token 消耗过高时
/compact

# 降低后续对话的 token 消耗
```

```
# 当提示 token 消耗过高时
/compact

# 降低后续对话的 token 消耗
```

##### 4. 定期压缩保持效率#

```
bash复制# 在长时间对话中定期压缩
/compact

# 保持对话效率，避免上下文过长
```

```
# 在长时间对话中定期压缩
/compact

# 保持对话效率，避免上下文过长
```

#### 注意事项#

True. /compact 命令无任何参数，执行后会自动压缩对话历史
True. 压缩过程会保留对话的核心信息和上下文
True. 压缩后无法恢复原始对话历史
True. 压缩可以显著减少 token 消耗，提高对话效率
True. 不会影响已生成的 CLAUDE.md 文件或其他项目文件

```
/compact
```

```
CLAUDE.md
```

#### 与其他命令的组合#

```
bash复制# 压缩对话历史后，开始新的对话
/compact
/clear

# 执行流程：
# 1. 压缩对话历史，保留核心信息
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会保留压缩后的核心信息
```

```
# 压缩对话历史后，开始新的对话
/compact
/clear

# 执行流程：
# 1. 压缩对话历史，保留核心信息
# 2. 清空历史对话，开始全新的对话
# 3. 新对话会保留压缩后的核心信息
```

#### 最佳实践#

True. 对话过长时使用：当对话超过 20 轮或 token 消耗过高时，建议使用 /compact
True. 任务切换前使用：在完成一个任务，准备开始新任务前使用 /compact
True. 定期使用：在长时间对话中，每完成一个子任务后使用 /compact
True. 结合 /clear 使用：在需要完全重置对话时，先使用 /compact 保留核心信息，再使用 /clear 清空对话

```
/compact
```

```
/compact
```

```
/compact
```

```
/compact
```

```
/clear
```

#### 总结#

/compact 命令是 Claude Code 中用于管理对话历史的重要命令。通过使用此命令，你可以：

```
/compact
```

- 压缩对话历史，减少 token 消耗
- 保留对话的核心信息和上下文
- 提高对话效率
- 为新任务腾出上下文空间

合理使用 /compact 命令可以帮助你在与 Claude Code 交互时保持高效，减少不必要的 token 消耗。

```
/compact
```

---

## 15 /help - 获取使用帮助

**URL**: https://claudecode.tangshuang.net/course/7.15%20%2Fhelp%20-%20%E8%8E%B7%E5%8F%96%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9

#### 概述#

/help 命令用于获取 Claude Code 的使用帮助，显示所有可用的命令和功能说明。

```
/help
```

#### 基本语法#

```
bash复制/help [command]
```

```
/help [command]
```

#### 参数说明#

```
[command]
```

#### 功能说明#

##### 查看所有命令#

```
bash复制/help

# 显示所有可用的斜杠命令
```

```
/help

# 显示所有可用的斜杠命令
```

##### 查看特定命令#

```
bash复制/help init

# 显示 /init 命令的详细帮助
```

```
/help init

# 显示 /init 命令的详细帮助
```

#### 使用场景#

##### 1. 查看所有可用命令#

```
bash复制# 新手入门，查看所有命令
/help

# 了解 Claude Code 的功能
```

```
# 新手入门，查看所有命令
/help

# 了解 Claude Code 的功能
```

##### 2. 查看特定命令帮助#

```
bash复制# 忘记某个命令的用法
/help compact

# 查看该命令的详细说明
```

```
# 忘记某个命令的用法
/help compact

# 查看该命令的详细说明
```

##### 3. 探索新功能#

```
bash复制# 发现新功能
/help

# 查看所有命令，了解新功能
```

```
# 发现新功能
/help

# 查看所有命令，了解新功能
```

#### 输出示例#

##### 查看所有命令#

```
bash复制Available Commands:

Built-in Commands:
  /add-dir          添加额外的工作目录
  /agents           管理用于专门任务的自定义 AI 子代理
  /bashes           列出并管理后台任务
  /bug              报告错误（将对话发送给 Anthropic）
  /clear            清除对话历史
  /compact          压缩对话，可选择性地提供焦点指令
  /config           打开设置界面（配置选项卡）
  /context          将当前上下文使用情况可视化为彩色网格
  /cost             显示令牌使用统计信息
  /doctor           检查 Claude Code 安装的健康状况
  /exit             退出 REPL
  /export           将当前对话导出到文件或剪贴板
  /help             获取使用帮助
  /hooks            管理工具事件的钩子配置
  /init             使用 CLAUDE.md 指南初始化项目
  /login            切换 Anthropic 账户
  /logout           从 Anthropic 账户登出
  /mcp              管理 MCP 服务器连接和 OAuth 身份验证
  /memory           编辑 CLAUDE.md 内存文件
  /model            选择或更改 AI 模型
  /output-style     直接设置输出样式或从选择菜单中选择
  /permissions      查看或更新权限
  /pr_comments      查看拉取请求评论
  /privacy-settings 查看并更新隐私设置
  /review           请求代码审查
  /sandbox          启用沙箱化 bash 工具
  /rewind           回退对话和/或代码
  /status           打开设置界面（状态选项卡）
  /statusline       设置 Claude Code 的状态行 UI
  /terminal-setup   安装 Shift+Enter 键绑定
  /todos            列出当前待办事项
  /usage            显示计划使用限制和速率限制状态
  /vim              进入 vim 模式

Custom Commands (project):
  /optimize         优化代码性能 (project)

Custom Commands (user):
  /security-review  安全审查 (user)

For more information on a specific command, type /help <command>
```

```
Available Commands:

Built-in Commands:
  /add-dir          添加额外的工作目录
  /agents           管理用于专门任务的自定义 AI 子代理
  /bashes           列出并管理后台任务
  /bug              报告错误（将对话发送给 Anthropic）
  /clear            清除对话历史
  /compact          压缩对话，可选择性地提供焦点指令
  /config           打开设置界面（配置选项卡）
  /context          将当前上下文使用情况可视化为彩色网格
  /cost             显示令牌使用统计信息
  /doctor           检查 Claude Code 安装的健康状况
  /exit             退出 REPL
  /export           将当前对话导出到文件或剪贴板
  /help             获取使用帮助
  /hooks            管理工具事件的钩子配置
  /init             使用 CLAUDE.md 指南初始化项目
  /login            切换 Anthropic 账户
  /logout           从 Anthropic 账户登出
  /mcp              管理 MCP 服务器连接和 OAuth 身份验证
  /memory           编辑 CLAUDE.md 内存文件
  /model            选择或更改 AI 模型
  /output-style     直接设置输出样式或从选择菜单中选择
  /permissions      查看或更新权限
  /pr_comments      查看拉取请求评论
  /privacy-settings 查看并更新隐私设置
  /review           请求代码审查
  /sandbox          启用沙箱化 bash 工具
  /rewind           回退对话和/或代码
  /status           打开设置界面（状态选项卡）
  /statusline       设置 Claude Code 的状态行 UI
  /terminal-setup   安装 Shift+Enter 键绑定
  /todos            列出当前待办事项
  /usage            显示计划使用限制和速率限制状态
  /vim              进入 vim 模式

Custom Commands (project):
  /optimize         优化代码性能 (project)

Custom Commands (user):
  /security-review  安全审查 (user)

For more information on a specific command, type /help <command>
```

##### 查看特定命令#

```
bash复制Command: /init
Description: 使用 CLAUDE.md 指南初始化项目

Usage:
  /init

Description:
  初始化项目知识图谱。扫描当前目录下的所有文件，
  将解析结果保存到 CLAUDE.md 文件中。

Examples:
  /init              初始化当前项目

See also:
  /memory            编辑 CLAUDE.md 文件
  /clear             清除对话历史
```

```
Command: /init
Description: 使用 CLAUDE.md 指南初始化项目

Usage:
  /init

Description:
  初始化项目知识图谱。扫描当前目录下的所有文件，
  将解析结果保存到 CLAUDE.md 文件中。

Examples:
  /init              初始化当前项目

See also:
  /memory            编辑 CLAUDE.md 文件
  /clear             清除对话历史
```

#### 注意事项#

True. /help 命令不会修改任何文件或设置
True. 帮助信息是实时更新的
True. 自定义命令会显示在帮助中
True. 插件命令也会显示在帮助中

```
/help
```

#### 与其他命令的配合使用#

```
bash复制# 查看帮助，然后使用命令
/help init
/init

# 执行流程：
# 1. 查看 /init 命令的帮助
# 2. 了解用法后执行命令
```

```
# 查看帮助，然后使用命令
/help init
/init

# 执行流程：
# 1. 查看 /init 命令的帮助
# 2. 了解用法后执行命令
```

#### 最佳实践#

True. 新手必用：首次使用时，先运行 /help 了解所有命令
True. 忘记用法：忘记某个命令的用法时，使用 /help <command> 查看
True. 定期查看：定期查看帮助，了解新功能和命令
True. 探索功能：通过 /help 发现你可能不知道的功能

```
/help
```

```
/help <command>
```

```
/help
```

#### 总结#

/help 命令是 Claude Code 中获取帮助的核心命令。通过使用此命令，你可以：

```
/help
```

- 查看所有可用的命令
- 了解特定命令的用法
- 探索新功能
- 快速找到需要的命令

合理使用 /help 命令可以帮助你更好地掌握 Claude Code 的功能。

```
/help
```

---

## 16 /hooks - 管理钩子配置

**URL**: https://claudecode.tangshuang.net/course/7.16%20%2Fhooks%20-%20%E7%AE%A1%E7%90%86%E9%92%A9%E5%AD%90%E9%85%8D%E7%BD%AE

#### 概述#

/hooks 命令用于管理工具事件的钩子配置。钩子允许你在特定事件发生时自动执行自定义脚本或命令。

```
/hooks
```

#### 基本语法#

```
bash复制/hooks [subcommand]
```

```
/hooks [subcommand]
```

#### 子命令#

```
add
```

```
edit
```

```
remove
```

```
enable
```

```
disable
```

#### 功能说明#

##### 列出钩子#

```
bash复制/hooks

# 显示所有已配置的钩子及其状态
```

```
/hooks

# 显示所有已配置的钩子及其状态
```

##### 添加钩子#

```
bash复制/hooks add

# 按照提示输入：
# - 钩子名称
# - 触发事件
# - 执行命令
# - 工作目录
```

```
/hooks add

# 按照提示输入：
# - 钩子名称
# - 触发事件
# - 执行命令
# - 工作目录
```

##### 删除钩子#

```
bash复制/hooks remove <hook-name>

# 删除指定的钩子
```

```
/hooks remove <hook-name>

# 删除指定的钩子
```

#### 钩子事件#

Claude Code 支持以下钩子事件：

```
before-edit
```

```
after-edit
```

```
before-run
```

```
after-run
```

```
on-error
```

```
on-success
```

#### 使用场景#

##### 1. 代码格式化#

```
bash复制# 添加文件编辑后的格式化钩子
/hooks add

# 配置：
# - 事件: after-edit
# - 命令: prettier --write $FILE
# - 作用: 每次编辑文件后自动格式化
```

```
# 添加文件编辑后的格式化钩子
/hooks add

# 配置：
# - 事件: after-edit
# - 命令: prettier --write $FILE
# - 作用: 每次编辑文件后自动格式化
```

##### 2. 运行测试#

```
bash复制# 添加代码编辑后的测试钩子
/hooks add

# 配置：
# - 事件: after-edit
# - 命令: npm test
# - 作用: 每次编辑代码后运行测试
```

```
# 添加代码编辑后的测试钩子
/hooks add

# 配置：
# - 事件: after-edit
# - 命令: npm test
# - 作用: 每次编辑代码后运行测试
```

##### 3. 备份文件#

```
bash复制# 添加文件编辑前的备份钩子
/hooks add

# 配置：
# - 事件: before-edit
# - 命令: cp $FILE $FILE.backup
# - 作用: 编辑前自动备份文件
```

```
# 添加文件编辑前的备份钩子
/hooks add

# 配置：
# - 事件: before-edit
# - 命令: cp $FILE $FILE.backup
# - 作用: 编辑前自动备份文件
```

##### 4. 通知#

```
bash复制# 添加任务完成后的通知钩子
/hooks add

# 配置：
# - 事件: on-success
# - 命令: notify-send "Task completed"
# - 作用: 任务完成后发送通知
```

```
# 添加任务完成后的通知钩子
/hooks add

# 配置：
# - 事件: on-success
# - 命令: notify-send "Task completed"
# - 作用: 任务完成后发送通知
```

#### 钩子配置示例#

##### 格式化钩子#

```
yaml复制name: format-code
event: after-edit
command: prettier --write $FILE
enabled: true
```

```
name: format-code
event: after-edit
command: prettier --write $FILE
enabled: true
```

##### 测试钩子#

```
yaml复制name: run-tests
event: after-edit
command: npm test
working-dir: ./tests
enabled: true
```

```
name: run-tests
event: after-edit
command: npm test
working-dir: ./tests
enabled: true
```

##### 备份钩子#

```
yaml复制name: backup-file
event: before-edit
command: cp $FILE $FILE.backup
enabled: true
```

```
name: backup-file
event: before-edit
command: cp $FILE $FILE.backup
enabled: true
```

#### 环境变量#

钩子命令可以使用以下环境变量：

```
$FILE
```

```
$COMMAND
```

```
$STATUS
```

```
$WORKING_DIR
```

#### 注意事项#

True. 钩子命令在工作目录中执行
True. 钩子执行失败不会阻止主流程
True. 可以禁用钩子而不删除
True. 钩子配置保存在项目或用户级别

#### 与其他命令的配合使用#

```
bash复制# 配置钩子，然后测试
/hooks add
# 编辑文件
# 钩子自动执行
```

```
# 配置钩子，然后测试
/hooks add
# 编辑文件
# 钩子自动执行
```

#### 最佳实践#

True. 合理使用：只在必要时使用钩子，避免过度自动化
True. 错误处理：确保钩子命令有适当的错误处理
True. 性能考虑：避免在钩子中执行耗时操作
True. 测试钩子：添加钩子后，测试其行为是否符合预期

#### 总结#

/hooks 命令是 Claude Code 中用于自动化工作流的重要工具。通过使用此命令，你可以：

```
/hooks
```

- 在特定事件发生时自动执行命令
- 自动化重复性任务
- 实现自定义工作流
- 提高工作效率

合理使用 /hooks 命令可以帮助你创建更高效的开发工作流。

```
/hooks
```

---

## 17 /login - 切换Anthropic账户

**URL**: https://claudecode.tangshuang.net/course/7.17%20%2Flogin%20-%20%E5%88%87%E6%8D%A2Anthropic%E8%B4%A6%E6%88%B7

#### 概述#

/login 命令用于切换 Anthropic 账户，允许你在不同的 Anthropic 账户之间切换。

```
/login
```

#### 基本语法#

```
bash复制/login
```

```
/login
```

#### 功能说明#

执行 /login 命令后，Claude Code 会：

```
/login
```

True. 打开浏览器进行身份验证
True. 提示你登录 Anthropic 账户
True. 获取访问令牌
True. 保存令牌到本地配置
True. 切换到新账户

#### 使用场景#

##### 1. 切换账户#

```
bash复制# 切换到另一个 Anthropic 账户
/login

# 按照提示完成身份验证
```

```
# 切换到另一个 Anthropic 账户
/login

# 按照提示完成身份验证
```

##### 2. 重新认证#

```
bash复制# 当令牌过期时
/login

# 重新获取访问令牌
```

```
# 当令牌过期时
/login

# 重新获取访问令牌
```

##### 3. 首次登录#

```
bash复制# 首次使用 Claude Code
/login

# 登录 Anthropic 账户
```

```
# 首次使用 Claude Code
/login

# 登录 Anthropic 账户
```

#### 登录流程#

True. 执行 /login 命令
True. 浏览器自动打开 Anthropic 登录页面
True. 输入账户凭据
True. 授权 Claude Code 访问
True. 返回命令行，登录成功

```
/login
```

#### 注意事项#

True. 需要有效的 Anthropic 账户
True. 需要互联网连接
True. 令牌会保存在本地配置文件中
True. 切换账户会影响当前会话
True. 旧账户的令牌会被替换

#### 与其他命令的配合使用#

```
bash复制# 登录后检查状态
/login
/status

# 执行流程：
# 1. 登录 Anthropic 账户
# 2. 查看账户状态
```

```
# 登录后检查状态
/login
/status

# 执行流程：
# 1. 登录 Anthropic 账户
# 2. 查看账户状态
```

#### 最佳实践#

True. 账户安全：不要在公共设备上保存令牌
True. 定期更新：定期重新登录以更新令牌
True. 账户管理：为不同用途使用不同的账户
True. 退出登录：在公共设备上使用后，记得 /logout

```
/logout
```

#### 总结#

/login 命令是 Claude Code 中用于账户管理的重要命令。通过使用此命令，你可以：

```
/login
```

- 切换 Anthropic 账户
- 重新获取访问令牌
- 管理多个账户
- 保持账户安全

合理使用 /login 命令可以帮助你灵活地管理 Anthropic 账户。

```
/login
```

---

## 18 /logout - 从Anthropic账户登出

**URL**: https://claudecode.tangshuang.net/course/7.18%20%2Flogout%20-%20%E4%BB%8EAnthropic%E8%B4%A6%E6%88%B7%E7%99%BB%E5%87%BA

#### 概述#

/logout 命令用于从 Anthropic 账户登出，清除本地保存的访问令牌。

```
/logout
```

#### 基本语法#

```
bash复制/logout
```

```
/logout
```

#### 功能说明#

执行 /logout 命令后，Claude Code 会：

```
/logout
```

True. 清除本地保存的访问令牌
True. 断开与 Anthropic API 的连接
True. 显示登出成功确认
True. 需要重新登录才能使用

#### 使用场景#

##### 1. 在公共设备上登出#

```
bash复制# 在公共设备上使用后
/logout

# 清除访问令牌，保护账户安全
```

```
# 在公共设备上使用后
/logout

# 清除访问令牌，保护账户安全
```

##### 2. 切换账户前登出#

```
bash复制# 切换到另一个账户前
/logout
/login

# 先登出，再登录新账户
```

```
# 切换到另一个账户前
/logout
/login

# 先登出，再登录新账户
```

##### 3. 令牌问题#

```
bash复制# 当令牌出现问题时
/logout
/login

# 重新登录获取新令牌
```

```
# 当令牌出现问题时
/logout
/login

# 重新登录获取新令牌
```

#### 注意事项#

True. 登出后无法使用 Claude Code
True. 需要重新登录才能继续使用
True. 本地保存的配置不会丢失
True. 访问令牌会被完全清除
True. 会话状态会被重置

#### 与其他命令的配合使用#

```
bash复制# 登出后重新登录
/logout
/login

# 执行流程：
# 1. 登出当前账户
# 2. 登录新账户或重新登录
```

```
# 登出后重新登录
/logout
/login

# 执行流程：
# 1. 登出当前账户
# 2. 登录新账户或重新登录
```

#### 最佳实践#

True. 公共设备：在公共设备上使用后，务必登出
True. 账户切换：切换账户前先登出
True. 定期登出：定期登出并重新登录，更新令牌
True. 安全第一：不要在共享设备上保存令牌

#### 总结#

/logout 命令是 Claude Code 中用于账户安全的重要命令。通过使用此命令，你可以：

```
/logout
```

- 从 Anthropic 账户登出
- 清除本地访问令牌
- 保护账户安全
- 为切换账户做准备

合理使用 /logout 命令可以帮助你保护 Anthropic 账户的安全。

```
/logout
```

---

## 19 /memory - 编辑CLAUDE.md内存文件

**URL**: https://claudecode.tangshuang.net/course/7.19%20%2Fmemory%20-%20%E7%BC%96%E8%BE%91CLAUDE.md%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6

#### 概述#

/memory 命令用于编辑 CLAUDE.md 内存文件，该文件包含项目的上下文信息和重要知识。

```
/memory
```

```
CLAUDE.md
```

#### 基本语法#

```
bash复制/memory
```

```
/memory
```

#### 功能说明#

执行 /memory 命令后，Claude Code 会：

```
/memory
```

True. 打开 CLAUDE.md 文件
True. 在编辑器中显示文件内容
True. 允许你编辑文件
True. 保存更改后，更新项目上下文

```
CLAUDE.md
```

#### CLAUDE.md 文件#

CLAUDE.md 文件通常包含：

```
CLAUDE.md
```

True. 项目概述：项目的基本信息和目标
True. 架构说明：项目架构和技术栈
True. 代码规范：编码标准和最佳实践
True. 重要说明：需要注意的事项
True. 上下文信息：AI 需要了解的项目细节

#### 使用场景#

##### 1. 添加项目信息#

```
bash复制# 添加项目概述
/memory

# 在文件中添加项目的基本信息
```

```
# 添加项目概述
/memory

# 在文件中添加项目的基本信息
```

##### 2. 更新架构说明#

```
bash复制# 项目架构发生变化时
/memory

# 更新架构说明
```

```
# 项目架构发生变化时
/memory

# 更新架构说明
```

##### 3. 添加代码规范#

```
bash复制# 添加编码标准
/memory

# 在文件中添加代码规范
```

```
# 添加编码标准
/memory

# 在文件中添加代码规范
```

##### 4. 补充上下文#

```
bash复制# 添加 AI 需要了解的信息
/memory

# 补充项目上下文
```

```
# 添加 AI 需要了解的信息
/memory

# 补充项目上下文
```

#### CLAUDE.md 示例#

```
markdown复制# 项目名称

## 项目概述

这是一个示例项目，用于演示 CLAUDE.md 的使用。

## 技术栈

- 前端：React + TypeScript
- 后端：Node.js + Express
- 数据库：PostgreSQL

## 架构说明

项目采用前后端分离架构：
- 前端负责用户界面
- 后端提供 API 接口
- 数据库存储数据

## 代码规范

- 使用 TypeScript 进行类型检查
- 遵循 ESLint 规则
- 使用 Prettier 格式化代码

## 重要说明

- 所有 API 请求需要认证
- 敏感信息存储在环境变量中
- 不要在代码中硬编码密钥
```

```
# 项目名称

## 项目概述

这是一个示例项目，用于演示 CLAUDE.md 的使用。

## 技术栈

- 前端：React + TypeScript
- 后端：Node.js + Express
- 数据库：PostgreSQL

## 架构说明

项目采用前后端分离架构：
- 前端负责用户界面
- 后端提供 API 接口
- 数据库存储数据

## 代码规范

- 使用 TypeScript 进行类型检查
- 遵循 ESLint 规则
- 使用 Prettier 格式化代码

## 重要说明

- 所有 API 请求需要认证
- 敏感信息存储在环境变量中
- 不要在代码中硬编码密钥
```

#### 注意事项#

True. CLAUDE.md 文件会自动作为上下文
True. 文件内容会影响 AI 的理解
True. 建议定期更新文件内容
True. 文件可以添加到版本控制中
True. 避免在文件中包含敏感信息

```
CLAUDE.md
```

#### 与其他命令的配合使用#

```
bash复制# 初始化项目，然后编辑内存文件
/init
/memory

# 执行流程：
# 1. 初始化项目知识图谱
# 2. 编辑 CLAUDE.md 文件
# 3. 补充或更新项目信息
```

```
# 初始化项目，然后编辑内存文件
/init
/memory

# 执行流程：
# 1. 初始化项目知识图谱
# 2. 编辑 CLAUDE.md 文件
# 3. 补充或更新项目信息
```

#### 最佳实践#

True. 定期更新：定期更新 CLAUDE.md 文件
True. 清晰描述：使用清晰的语言描述项目
True. 结构化内容：使用标题和列表组织内容
True. 避免冗余：避免重复或无关的信息
True. 团队协作：与团队共享和维护文件

```
CLAUDE.md
```

#### 总结#

/memory 命令是 Claude Code 中用于管理项目上下文的重要命令。通过使用此命令，你可以：

```
/memory
```

- 编辑 CLAUDE.md 文件
- 更新项目上下文信息
- 补充 AI 需要了解的细节
- 提高对话的准确性

```
CLAUDE.md
```

合理使用 /memory 命令可以帮助你更好地管理项目上下文，提高 AI 的理解能力。

```
/memory
```

---

## 20 /model - 选择或更改AI模型

**URL**: https://claudecode.tangshuang.net/course/7.20%20%2Fmodel%20-%20%E9%80%89%E6%8B%A9%E6%88%96%E6%9B%B4%E6%94%B9AI%E6%A8%A1%E5%9E%8B

#### 概述#

/model 命令用于选择或更改 Claude Code 使用的 AI 模型，允许你根据任务需求选择最合适的模型。

```
/model
```

#### 基本语法#

```
bash复制/model [model-name]
```

```
/model [model-name]
```

#### 参数说明#

```
[model-name]
```

#### 可用模型#

##### Claude 3.5 Sonnet#

- 名称: claude-3-5-sonnet-20241022
- 特点: 平衡性能和速度
- 适用场景: 通用任务、代码生成、文档编写

```
claude-3-5-sonnet-20241022
```

##### Claude 3.5 Haiku#

- 名称: claude-3-5-haiku-20241022
- 特点: 快速响应，成本低
- 适用场景: 简单任务、快速查询、成本敏感场景

```
claude-3-5-haiku-20241022
```

##### Claude 3 Opus#

- 名称: claude-3-opus-20240229
- 特点: 最强性能，成本高
- 适用场景: 复杂任务、深度分析、高质量要求

```
claude-3-opus-20240229
```

#### 使用场景#

##### 1. 查看可用模型#

```
bash复制# 查看所有可用的模型
/model

# 显示模型列表和特点
```

```
# 查看所有可用的模型
/model

# 显示模型列表和特点
```

##### 2. 选择模型#

```
bash复制# 选择特定模型
/model claude-3-5-sonnet-20241022

# 切换到该模型
```

```
# 选择特定模型
/model claude-3-5-sonnet-20241022

# 切换到该模型
```

##### 3. 根据任务选择#

```
bash复制# 简单任务使用快速模型
/model claude-3-5-haiku-20241022

# 复杂任务使用高性能模型
/model claude-3-opus-20240229
```

```
# 简单任务使用快速模型
/model claude-3-5-haiku-20241022

# 复杂任务使用高性能模型
/model claude-3-opus-20240229
```

#### 模型选择建议#

##### 代码生成#

```
bash复制# 代码生成推荐使用 Sonnet
/model claude-3-5-sonnet-20241022
```

```
# 代码生成推荐使用 Sonnet
/model claude-3-5-sonnet-20241022
```

##### 文档编写#

```
bash复制# 文档编写推荐使用 Sonnet
/model claude-3-5-sonnet-20241022
```

```
# 文档编写推荐使用 Sonnet
/model claude-3-5-sonnet-20241022
```

##### 简单查询#

```
bash复制# 简单查询推荐使用 Haiku
/model claude-3-5-haiku-20241022
```

```
# 简单查询推荐使用 Haiku
/model claude-3-5-haiku-20241022
```

##### 复杂分析#

```
bash复制# 复杂分析推荐使用 Opus
/model claude-3-opus-20240229
```

```
# 复杂分析推荐使用 Opus
/model claude-3-opus-20240229
```

#### 注意事项#

True. 不同模型的成本不同
True. 模型切换会影响当前会话
True. 某些功能可能需要特定模型
True. 模型性能取决于任务复杂度

#### 与其他命令的配合使用#

```
bash复制# 查看模型，然后选择
/model
/model claude-3-5-sonnet-20241022

# 执行流程：
# 1. 查看可用模型
# 2. 选择合适的模型
```

```
# 查看模型，然后选择
/model
/model claude-3-5-sonnet-20241022

# 执行流程：
# 1. 查看可用模型
# 2. 选择合适的模型
```

#### 最佳实践#

True. 任务匹配：根据任务复杂度选择合适的模型
True. 成本考虑：在简单任务上使用成本较低的模型
True. 性能优先：在重要任务上使用高性能模型
True. 定期评估：定期评估模型选择是否合理

#### 总结#

/model 命令是 Claude Code 中用于选择 AI 模型的重要命令。通过使用此命令，你可以：

```
/model
```

- 查看可用的 AI 模型
- 选择最适合当前任务的模型
- 平衡性能和成本
- 优化使用体验

合理使用 /model 命令可以帮助你根据任务需求选择最合适的 AI 模型。

```
/model
```

---

## 21 /output-style - 设置输出样式

**URL**: https://claudecode.tangshuang.net/course/7.21%20%2Foutput-style%20-%20%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E6%A0%B7%E5%BC%8F

#### 概述#

/output-style 命令用于直接设置输出样式或从选择菜单中选择，允许你自定义 Claude Code 的输出格式。

```
/output-style
```

#### 基本语法#

```
bash复制/output-style [style]
```

```
/output-style [style]
```

#### 参数说明#

```
[style]
```

#### 可用样式#

##### default#

- 描述: 默认样式
- 特点: 平衡的格式，适合大多数场景
- 适用场景: 通用任务

##### concise#

- 描述: 简洁样式
- 特点: 精简输出，去除冗余信息
- 适用场景: 快速查询、简单任务

##### detailed#

- 描述: 详细样式
- 特点: 提供详细的解释和示例
- 适用场景: 学习、教学、复杂任务

##### code-focused#

- 描述: 代码优先样式
- 特点: 侧重代码，减少文字说明
- 适用场景: 代码生成、调试

##### documentation#

- 描述: 文档样式
- 特点: 格式化为文档，结构清晰
- 适用场景: 文档编写、技术说明

#### 使用场景#

##### 1. 查看可用样式#

```
bash复制# 查看所有可用的样式
/output-style

# 显示样式选择菜单
```

```
# 查看所有可用的样式
/output-style

# 显示样式选择菜单
```

##### 2. 选择样式#

```
bash复制# 选择特定样式
/output-style concise

# 切换到简洁样式
```

```
# 选择特定样式
/output-style concise

# 切换到简洁样式
```

##### 3. 根据任务选择#

```
bash复制# 快速查询使用简洁样式
/output-style concise

# 学习使用详细样式
/output-style detailed
```

```
# 快速查询使用简洁样式
/output-style concise

# 学习使用详细样式
/output-style detailed
```

#### 样式效果示例#

##### default 样式#

```
bash复制这是一个函数，用于计算两个数的和：

```javascript
function add(a, b) {
  return a + b;
}
```

```
这是一个函数，用于计算两个数的和：

```javascript
function add(a, b) {
  return a + b;
}
```

```
javascript复制const result = add(1, 2);
console.log(result); // 3
```

```
const result = add(1, 2);
console.log(result); // 3
```

```
bash复制
### concise 样式
```

```
### concise 样式
```

```
javascript复制function add(a, b) {
  return a + b;
}
```

```
function add(a, b) {
  return a + b;
}
```

```
bash复制
### detailed 样式
```

```
### detailed 样式
```

#### 加法函数#

这个函数接受两个参数 a 和 b，返回它们的和。

##### 参数#

- a: 第一个数字
- b: 第二个数字

```
a
```

```
b
```

##### 返回值#

两个数字的和

##### 示例#

```
javascript复制function add(a, b) {
  return a + b;
}

// 使用示例
const result = add(1, 2);
console.log(result); // 输出: 3
```

```
function add(a, b) {
  return a + b;
}

// 使用示例
const result = add(1, 2);
console.log(result); // 输出: 3
```

##### 注意事项#

- 参数必须是数字类型
- 如果传入非数字，会进行类型转换

```
bash复制
## 注意事项

1. 样式切换会影响当前会话
2. 不同样式的输出长度不同
3. 可以根据任务随时切换样式
4. 样式设置会保存到配置文件

## 与其他命令的配合使用

```bash
# 查看样式，然后选择
/output-style
/output-style concise

# 执行流程：
# 1. 查看可用样式
# 2. 选择合适的样式
```

```
## 注意事项

1. 样式切换会影响当前会话
2. 不同样式的输出长度不同
3. 可以根据任务随时切换样式
4. 样式设置会保存到配置文件

## 与其他命令的配合使用

```bash
# 查看样式，然后选择
/output-style
/output-style concise

# 执行流程：
# 1. 查看可用样式
# 2. 选择合适的样式
```

#### 最佳实践#

True. 任务匹配：根据任务类型选择合适的样式
True. 灵活切换：根据需要随时切换样式
True. 团队统一：团队内部统一使用相同的样式
True. 定期评估：定期评估样式选择是否合理

#### 总结#

/output-style 命令是 Claude Code 中用于自定义输出样式的重要命令。通过使用此命令，你可以：

```
/output-style
```

- 查看可用的输出样式
- 选择最适合当前任务的样式
- 自定义输出格式
- 优化阅读体验

合理使用 /output-style 命令可以帮助你获得更符合需求的输出格式。

```
/output-style
```

---

## 22 /permissions - 查看或更新权限

**URL**: https://claudecode.tangshuang.net/course/7.22%20%2Fpermissions%20-%20%E6%9F%A5%E7%9C%8B%E6%88%96%E6%9B%B4%E6%96%B0%E6%9D%83%E9%99%90

#### 概述#

/permissions 命令用于查看或更新 Claude Code 的权限配置，控制 Claude 可以执行的操作。

```
/permissions
```

#### 基本语法#

```
bash复制/permissions [subcommand]
```

```
/permissions [subcommand]
```

#### 子命令#

```
add
```

```
remove
```

```
clear
```

```
reset
```

#### 权限类型#

##### 工具权限#

- Bash: 执行 shell 命令
- Read: 读取文件
- Write: 写入文件
- Edit: 编辑文件
- Delete: 删除文件
- Grep: 搜索文件内容

```
Bash
```

```
Read
```

```
Write
```

```
Edit
```

```
Delete
```

```
Grep
```

##### 命令权限#

- SlashCommand: 执行斜杠命令
- RunCommand: 运行命令

```
SlashCommand
```

```
RunCommand
```

#### 使用场景#

##### 1. 查看权限#

```
bash复制# 查看当前权限配置
/permissions

# 显示所有权限规则
```

```
# 查看当前权限配置
/permissions

# 显示所有权限规则
```

##### 2. 添加权限#

```
bash复制# 添加权限规则
/permissions add

# 按照提示添加权限
```

```
# 添加权限规则
/permissions add

# 按照提示添加权限
```

##### 3. 删除权限#

```
bash复制# 删除权限规则
/permissions remove Bash

# 删除 Bash 工具权限
```

```
# 删除权限规则
/permissions remove Bash

# 删除 Bash 工具权限
```

##### 4. 重置权限#

```
bash复制# 重置为默认权限
/permissions reset

# 恢复默认配置
```

```
# 重置为默认权限
/permissions reset

# 恢复默认配置
```

#### 权限规则示例#

##### 允许特定命令#

```
yaml复制allow:
  - Bash(git add:*)
  - Bash(git commit:*)
  - Bash(git status:*)
```

```
allow:
  - Bash(git add:*)
  - Bash(git commit:*)
  - Bash(git status:*)
```

##### 拒绝特定操作#

```
yaml复制deny:
  - Delete(*)
  - Bash(rm:*)
```

```
deny:
  - Delete(*)
  - Bash(rm:*)
```

##### 限制文件访问#

```
yaml复制allow:
  - Read(./src/*)
  - Write(./src/*)
deny:
  - Read(./config/*)
  - Write(./config/*)
```

```
allow:
  - Read(./src/*)
  - Write(./src/*)
deny:
  - Read(./config/*)
  - Write(./config/*)
```

#### 注意事项#

True. 权限规则按顺序评估
True. 拒绝规则优先于允许规则
True. 权限配置保存在配置文件中
True. 更改权限会影响当前会话

#### 安全建议#

##### 最小权限原则#

```
bash复制# 只授予必要的权限
/permissions add

# 只允许需要的工具和命令
```

```
# 只授予必要的权限
/permissions add

# 只允许需要的工具和命令
```

##### 敏感目录保护#

```
bash复制# 保护敏感目录
/permissions add

# 拒绝访问敏感文件
```

```
# 保护敏感目录
/permissions add

# 拒绝访问敏感文件
```

##### 命令限制#

```
bash复制# 限制危险命令
/permissions add

# 拒绝执行危险命令
```

```
# 限制危险命令
/permissions add

# 拒绝执行危险命令
```

#### 与其他命令的配合使用#

```
bash复制# 查看权限，然后更新
/permissions
/permissions add

# 执行流程：
# 1. 查看当前权限
# 2. 添加新的权限规则
```

```
# 查看权限，然后更新
/permissions
/permissions add

# 执行流程：
# 1. 查看当前权限
# 2. 添加新的权限规则
```

#### 最佳实践#

True. 最小权限：只授予必要的权限
True. 定期审查：定期审查权限配置
True. 明确规则：使用明确的权限规则
True. 测试验证：更改权限后测试功能

#### 总结#

/permissions 命令是 Claude Code 中用于权限管理的重要命令。通过使用此命令，你可以：

```
/permissions
```

- 查看当前权限配置
- 添加或删除权限规则
- 控制 Claude 可以执行的操作
- 提高安全性

合理使用 /permissions 命令可以帮助你更好地控制 Claude Code 的行为，提高安全性。

```
/permissions
```

---

## 23 /pr_comments - 查看拉取请求评论

**URL**: https://claudecode.tangshuang.net/course/7.23%20%2Fpr_comments%20-%20%E6%9F%A5%E7%9C%8B%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E8%AF%84%E8%AE%BA

#### 概述#

/pr_comments 命令用于查看拉取请求（Pull Request）的评论，帮助你了解代码审查的反馈。

```
/pr_comments
```

#### 基本语法#

```
bash复制/pr_comments [pr-number]
```

```
/pr_comments [pr-number]
```

#### 参数说明#

```
[pr-number]
```

#### 功能说明#

执行 /pr_comments 命令后，Claude Code 会：

```
/pr_comments
```

True. 查找相关的拉取请求
True. 获取 PR 的所有评论
True. 显示评论内容和作者
True. 提供评论摘要

#### 使用场景#

##### 1. 查看当前 PR 的评论#

```
bash复制# 查看当前分支的 PR 评论
/pr_comments

# 显示所有评论
```

```
# 查看当前分支的 PR 评论
/pr_comments

# 显示所有评论
```

##### 2. 查看特定 PR 的评论#

```
bash复制# 查看特定 PR 的评论
/pr_comments 123

# 显示 PR #123 的所有评论
```

```
# 查看特定 PR 的评论
/pr_comments 123

# 显示 PR #123 的所有评论
```

##### 3. 了解审查反馈#

```
bash复制# 查看审查评论
/pr_comments

# 了解需要修改的地方
```

```
# 查看审查评论
/pr_comments

# 了解需要修改的地方
```

#### 输出示例#

```
bash复制Pull Request #123 Comments
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Review Comments:

1. @alice (Line 45)
   "这个函数缺少错误处理，建议添加 try-catch"

2. @bob (Line 78)
   "变量命名不够清晰，建议使用更具描述性的名称"

3. @charlie (Line 102)
   "这段代码可以提取为独立函数，提高可读性"

General Comments:

1. @alice
   "整体实现不错，但需要补充单元测试"

2. @bob
   "建议添加更多的文档注释"

Summary:
- 3 个代码审查评论
- 2 个一般性评论
- 主要关注点：错误处理、代码风格、测试覆盖
```

```
Pull Request #123 Comments
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Review Comments:

1. @alice (Line 45)
   "这个函数缺少错误处理，建议添加 try-catch"

2. @bob (Line 78)
   "变量命名不够清晰，建议使用更具描述性的名称"

3. @charlie (Line 102)
   "这段代码可以提取为独立函数，提高可读性"

General Comments:

1. @alice
   "整体实现不错，但需要补充单元测试"

2. @bob
   "建议添加更多的文档注释"

Summary:
- 3 个代码审查评论
- 2 个一般性评论
- 主要关注点：错误处理、代码风格、测试覆盖
```

#### 注意事项#

True. 需要配置 Git 集成
True. 需要有访问 PR 的权限
True. 评论会按时间顺序显示
True. 可以根据评论进行代码修改

#### 与其他命令的配合使用#

```
bash复制# 查看 PR 评论，然后修改代码
/pr_comments
# 根据评论修改代码
```

```
# 查看 PR 评论，然后修改代码
/pr_comments
# 根据评论修改代码
```

#### 最佳实践#

True. 及时查看：及时查看 PR 评论，了解反馈
True. 逐条处理：逐条处理评论，确保所有问题都得到解决
True. 沟通确认：不确定的地方，及时与审查者沟通
True. 持续改进：根据评论改进代码质量

#### 总结#

/pr_comments 命令是 Claude Code 中用于查看 PR 评论的重要命令。通过使用此命令，你可以：

```
/pr_comments
```

- 查看拉取请求的评论
- 了解代码审查的反馈
- 根据评论改进代码
- 提高代码质量

合理使用 /pr_comments 命令可以帮助你更好地参与代码审查流程。

```
/pr_comments
```

---

## 24 /privacy-settings - 查看并更新隐私设置

**URL**: https://claudecode.tangshuang.net/course/7.24%20%2Fprivacy-settings%20-%20%E6%9F%A5%E7%9C%8B%E5%B9%B6%E6%9B%B4%E6%96%B0%E9%9A%90%E7%A7%81%E8%AE%BE%E7%BD%AE

#### 概述#

/privacy-settings 命令用于查看并更新 Claude Code 的隐私设置，控制数据使用和隐私保护。

```
/privacy-settings
```

#### 基本语法#

```
bash复制/privacy-settings
```

```
/privacy-settings
```

#### 功能说明#

执行 /privacy-settings 命令后，Claude Code 会：

```
/privacy-settings
```

True. 打开隐私设置界面
True. 显示当前隐私配置
True. 允许修改隐私选项
True. 保存隐私设置

#### 隐私设置选项#

##### 数据使用#

- 对话数据: 是否允许使用对话数据改进服务
- 代码数据: 是否允许使用代码数据改进服务
- 匿名化: 是否对数据进行匿名化处理

##### 数据保留#

- 对话历史: 对话历史的保留时间
- 错误日志: 错误日志的保留时间
- 使用统计: 使用统计的保留时间

##### 数据共享#

- 第三方共享: 是否与第三方共享数据
- 研究用途: 是否用于研究目的
- 匿名共享: 是否允许匿名共享数据

#### 使用场景#

##### 1. 查看隐私设置#

```
bash复制# 查看当前隐私设置
/privacy-settings

# 显示所有隐私配置
```

```
# 查看当前隐私设置
/privacy-settings

# 显示所有隐私配置
```

##### 2. 更新隐私设置#

```
bash复制# 更新隐私设置
/privacy-settings

# 修改隐私选项
```

```
# 更新隐私设置
/privacy-settings

# 修改隐私选项
```

##### 3. 保护敏感数据#

```
bash复制# 配置隐私设置以保护敏感数据
/privacy-settings

# 禁用数据共享
```

```
# 配置隐私设置以保护敏感数据
/privacy-settings

# 禁用数据共享
```

#### 隐私设置示例#

```
json复制{
  "dataUsage": {
    "conversationData": false,
    "codeData": false,
    "anonymization": true
  },
  "dataRetention": {
    "conversationHistory": "30days",
    "errorLogs": "7days",
    "usageStatistics": "90days"
  },
  "dataSharing": {
    "thirdParty": false,
    "research": false,
    "anonymousSharing": false
  }
}
```

```
{
  "dataUsage": {
    "conversationData": false,
    "codeData": false,
    "anonymization": true
  },
  "dataRetention": {
    "conversationHistory": "30days",
    "errorLogs": "7days",
    "usageStatistics": "90days"
  },
  "dataSharing": {
    "thirdParty": false,
    "research": false,
    "anonymousSharing": false
  }
}
```

#### 注意事项#

True. 隐私设置会影响数据使用政策
True. 某些功能可能需要特定的隐私设置
True. 隐私设置保存在配置文件中
True. 更改设置会影响当前和未来的会话

#### 隐私保护建议#

##### 最小化数据共享#

```
bash复制# 禁用所有数据共享
/privacy-settings

# 设置为最严格的隐私保护
```

```
# 禁用所有数据共享
/privacy-settings

# 设置为最严格的隐私保护
```

##### 启用匿名化#

```
bash复制# 启用数据匿名化
/privacy-settings

# 保护个人和敏感信息
```

```
# 启用数据匿名化
/privacy-settings

# 保护个人和敏感信息
```

##### 限制数据保留#

```
bash复制# 缩短数据保留时间
/privacy-settings

# 减少数据存储时间
```

```
# 缩短数据保留时间
/privacy-settings

# 减少数据存储时间
```

#### 与其他命令的配合使用#

```
bash复制# 查看隐私设置，然后更新
/privacy-settings
# 根据需要修改设置
```

```
# 查看隐私设置，然后更新
/privacy-settings
# 根据需要修改设置
```

#### 最佳实践#

True. 定期审查：定期审查隐私设置
True. 最小权限：使用最严格的隐私设置
True. 了解政策：了解 Anthropic 的数据使用政策
True. 保护敏感：保护敏感项目和数据

#### 总结#

/privacy-settings 命令是 Claude Code 中用于隐私管理的重要命令。通过使用此命令，你可以：

```
/privacy-settings
```

- 查看当前隐私设置
- 更新隐私配置
- 控制数据使用和共享
- 保护敏感信息

合理使用 /privacy-settings 命令可以帮助你更好地保护隐私和数据安全。

```
/privacy-settings
```

---

## 25 /review - 请求代码审查

**URL**: https://claudecode.tangshuang.net/course/7.25%20%2Freview%20-%20%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5

#### 概述#

/review 命令用于请求代码审查，让 Claude 帮助你检查代码质量、发现潜在问题并提供改进建议。

```
/review
```

#### 基本语法#

```
bash复制/review [file-or-code]
```

```
/review [file-or-code]
```

#### 参数说明#

```
[file-or-code]
```

#### 审查内容#

执行 /review 命令后，Claude 会检查：

```
/review
```

True. 代码质量

代码风格一致性
命名规范
代码结构
True. 代码风格一致性
True. 命名规范
True. 代码结构
True. 潜在问题

逻辑错误
边界情况
性能问题
True. 逻辑错误
True. 边界情况
True. 性能问题
True. 安全性

安全漏洞
输入验证
数据保护
True. 安全漏洞
True. 输入验证
True. 数据保护
True. 最佳实践

设计模式
代码复用
可维护性
True. 设计模式
True. 代码复用
True. 可维护性

- 代码风格一致性
- 命名规范
- 代码结构

- 逻辑错误
- 边界情况
- 性能问题

- 安全漏洞
- 输入验证
- 数据保护

- 设计模式
- 代码复用
- 可维护性

#### 使用场景#

##### 1. 审查文件#

```
bash复制# 审查特定文件
/review src/utils.js

# 检查文件中的代码
```

```
# 审查特定文件
/review src/utils.js

# 检查文件中的代码
```

##### 2. 审查代码片段#

```
bash复制# 审查代码片段
/review

# 然后粘贴代码片段
```

```
# 审查代码片段
/review

# 然后粘贴代码片段
```

##### 3. 审查当前更改#

```
bash复制# 审查当前更改的代码
/review

# Claude 会审查最近的修改
```

```
# 审查当前更改的代码
/review

# Claude 会审查最近的修改
```

#### 审查报告示例#

```
bash复制代码审查报告
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

文件: src/utils.js

✓ 优点:
- 函数命名清晰，易于理解
- 错误处理完善
- 代码注释详细

⚠ 建议:
1. 第 15 行：可以使用更简洁的语法
   当前: if (condition) { return true; } else { return false; }
   建议: return condition;

2. 第 28 行：建议添加输入验证
   当前: function process(data) { ... }
   建议: function process(data) {
     if (!data) throw new Error('Invalid data');
     ...
   }

3. 第 42 行：考虑使用 const 替代 let
   当前: let result = calculate();
   建议: const result = calculate();

✗ 问题:
1. 第 56 行：潜在的内存泄漏
   问题: 未关闭文件句柄
   修复: 添加 file.close()

总体评分: 7/10
```

```
代码审查报告
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

文件: src/utils.js

✓ 优点:
- 函数命名清晰，易于理解
- 错误处理完善
- 代码注释详细

⚠ 建议:
1. 第 15 行：可以使用更简洁的语法
   当前: if (condition) { return true; } else { return false; }
   建议: return condition;

2. 第 28 行：建议添加输入验证
   当前: function process(data) { ... }
   建议: function process(data) {
     if (!data) throw new Error('Invalid data');
     ...
   }

3. 第 42 行：考虑使用 const 替代 let
   当前: let result = calculate();
   建议: const result = calculate();

✗ 问题:
1. 第 56 行：潜在的内存泄漏
   问题: 未关闭文件句柄
   修复: 添加 file.close()

总体评分: 7/10
```

#### 审查选项#

##### 指定审查重点#

```
bash复制# 专注于安全性
/review --focus security

# 专注于性能
/review --focus performance

# 专注于代码风格
/review --focus style
```

```
# 专注于安全性
/review --focus security

# 专注于性能
/review --focus performance

# 专注于代码风格
/review --focus style
```

##### 排除某些检查#

```
bash复制# 排除性能检查
/review --exclude performance

# 排除风格检查
/review --exclude style
```

```
# 排除性能检查
/review --exclude performance

# 排除风格检查
/review --exclude style
```

#### 注意事项#

True. 审查结果基于静态分析
True. 建议需要人工验证
True. 审查不会修改代码
True. 可以多次审查同一代码

#### 与其他命令的配合使用#

```
bash复制# 审查代码，然后修复
/review
# 根据建议修改代码
```

```
# 审查代码，然后修复
/review
# 根据建议修改代码
```

#### 最佳实践#

True. 定期审查：定期审查代码，保持代码质量
True. 重点审查：在提交前审查代码
True. 团队协作：与团队成员一起审查代码
True. 持续改进：根据审查建议持续改进代码

#### 总结#

/review 命令是 Claude Code 中用于代码审查的重要命令。通过使用此命令，你可以：

```
/review
```

- 检查代码质量
- 发现潜在问题
- 获取改进建议
- 提高代码质量

合理使用 /review 命令可以帮助你保持代码的高质量。

```
/review
```

---

## 26 /sandbox - 启用沙箱化bash工具

**URL**: https://claudecode.tangshuang.net/course/7.26%20%2Fsandbox%20-%20%E5%90%AF%E7%94%A8%E6%B2%99%E7%AE%B1%E5%8C%96bash%E5%B7%A5%E5%85%B7

#### 概述#

/sandbox 命令用于启用沙箱化 bash 工具，提供文件系统和网络隔离，以实现更安全、更自主的执行。

```
/sandbox
```

#### 基本语法#

```
bash复制/sandbox
```

```
/sandbox
```

#### 功能说明#

执行 /sandbox 命令后，Claude Code 会：

```
/sandbox
```

True. 启用沙箱化 bash 工具
True. 隔离文件系统访问
True. 隔离网络访问
True. 限制系统资源使用
True. 提供更安全的执行环境

#### 沙箱特性#

##### 文件系统隔离#

- 只能访问指定目录
- 无法访问系统关键文件
- 文件操作受限制

##### 网络隔离#

- 限制网络访问
- 控制网络连接
- 防止未授权访问

##### 资源限制#

- 限制 CPU 使用
- 限制内存使用
- 限制磁盘使用

#### 使用场景#

##### 1. 执行不可信代码#

```
bash复制# 执行来自外部的代码
/sandbox

# 在沙箱中安全执行
```

```
# 执行来自外部的代码
/sandbox

# 在沙箱中安全执行
```

##### 2. 测试脚本#

```
bash复制# 测试未知脚本
/sandbox

# 隔离环境测试
```

```
# 测试未知脚本
/sandbox

# 隔离环境测试
```

##### 3. 自动化任务#

```
bash复制# 执行自动化任务
/sandbox

# 安全地运行任务
```

```
# 执行自动化任务
/sandbox

# 安全地运行任务
```

#### 沙箱配置#

##### 配置文件#

沙箱配置保存在配置文件中：

```
json复制{
  "sandbox": {
    "enabled": true,
    "allowedDirectories": [
      "./project",
      "./temp"
    ],
    "networkAccess": "restricted",
    "resourceLimits": {
      "cpu": "50%",
      "memory": "1GB",
      "disk": "100MB"
    }
  }
}
```

```
{
  "sandbox": {
    "enabled": true,
    "allowedDirectories": [
      "./project",
      "./temp"
    ],
    "networkAccess": "restricted",
    "resourceLimits": {
      "cpu": "50%",
      "memory": "1GB",
      "disk": "100MB"
    }
  }
}
```

##### 允许的目录#

```
bash复制# 配置允许访问的目录
/sandbox --add-dir ./project
/sandbox --add-dir ./temp
```

```
# 配置允许访问的目录
/sandbox --add-dir ./project
/sandbox --add-dir ./temp
```

#### 注意事项#

True. 沙箱会限制某些功能
True. 某些操作可能无法在沙箱中执行
True. 沙箱配置需要合理设置
True. 沙箱不是完全隔离的

#### 安全建议#

##### 最小权限原则#

```
bash复制# 只允许必要的目录访问
/sandbox --add-dir ./project

# 限制网络访问
/sandbox --network restricted
```

```
# 只允许必要的目录访问
/sandbox --add-dir ./project

# 限制网络访问
/sandbox --network restricted
```

##### 资源限制#

```
bash复制# 限制资源使用
/sandbox --cpu-limit 50%
/sandbox --memory-limit 1GB
```

```
# 限制资源使用
/sandbox --cpu-limit 50%
/sandbox --memory-limit 1GB
```

#### 与其他命令的配合使用#

```
bash复制# 启用沙箱，然后执行命令
/sandbox
npm install

# 在沙箱中安全执行
```

```
# 启用沙箱，然后执行命令
/sandbox
npm install

# 在沙箱中安全执行
```

#### 最佳实践#

True. 默认启用：在不确定的情况下，默认启用沙箱
True. 合理配置：根据需要配置沙箱参数
True. 定期检查：定期检查沙箱配置
True. 测试验证：在沙箱中测试后再在生产环境执行

#### 总结#

/sandbox 命令是 Claude Code 中用于提供安全执行环境的重要命令。通过使用此命令，你可以：

```
/sandbox
```

- 启用沙箱化 bash 工具
- 隔离文件系统和网络访问
- 限制系统资源使用
- 提高执行安全性

合理使用 /sandbox 命令可以帮助你在更安全的环境中执行命令。

```
/sandbox
```

---

## 27 /rewind - 回退对话和/或代码

**URL**: https://claudecode.tangshuang.net/course/7.27%20%2Frewind%20-%20%E5%9B%9E%E9%80%80%E5%AF%B9%E8%AF%9D%E5%92%8C%2F%E6%88%96%E4%BB%A3%E7%A0%81

#### 概述#

/rewind 命令用于回退对话和/或代码，允许你撤销之前的操作，恢复到之前的状态。

```
/rewind
```

#### 基本语法#

```
bash复制/rewind [steps]
```

```
/rewind [steps]
```

#### 参数说明#

```
[steps]
```

#### 功能说明#

执行 /rewind 命令后，Claude Code 会：

```
/rewind
```

True. 显示可回退的操作列表
True. 允许选择要回退的操作
True. 撤销选定的操作
True. 恢复到之前的状态

#### 使用场景#

##### 1. 查看可回退的操作#

```
bash复制# 查看可回退的操作列表
/rewind

# 显示所有可回退的操作
```

```
# 查看可回退的操作列表
/rewind

# 显示所有可回退的操作
```

##### 2. 回退特定步数#

```
bash复制# 回退 3 步
/rewind 3

# 撤销最近的 3 个操作
```

```
# 回退 3 步
/rewind 3

# 撤销最近的 3 个操作
```

##### 3. 撤销错误操作#

```
bash复制# 撤销错误的操作
/rewind

# 选择要撤销的操作
```

```
# 撤销错误的操作
/rewind

# 选择要撤销的操作
```

#### 可回退的操作#

##### 对话操作#

- 消息发送
- 命令执行
- 上下文更改

##### 文件操作#

- 文件创建
- 文件编辑
- 文件删除

##### 代码操作#

- 代码生成
- 代码修改
- 代码重构

#### 回退示例#

##### 查看操作列表#

```
bash复制可回退的操作:
1. 编辑 src/utils.js (2 分钟前)
2. 创建 test.js (5 分钟前)
3. 发送消息 "帮我写一个函数" (8 分钟前)
4. 执行 /init 命令 (10 分钟前)

选择要回退的操作 (输入编号):
```

```
可回退的操作:
1. 编辑 src/utils.js (2 分钟前)
2. 创建 test.js (5 分钟前)
3. 发送消息 "帮我写一个函数" (8 分钟前)
4. 执行 /init 命令 (10 分钟前)

选择要回退的操作 (输入编号):
```

##### 回退操作#

```
bash复制# 回退到操作 2
/rewind 2

# 撤销操作 2、3、4
```

```
# 回退到操作 2
/rewind 2

# 撤销操作 2、3、4
```

#### 注意事项#

True. 回退会撤销操作，无法恢复
True. 某些操作可能无法回退
True. 回退会影响对话历史
True. 建议在回退前导出对话

#### 与其他命令的配合使用#

```
bash复制# 导出对话，然后回退
/export backup.md
/rewind 3

# 执行流程：
# 1. 导出当前对话
# 2. 回退 3 步
```

```
# 导出对话，然后回退
/export backup.md
/rewind 3

# 执行流程：
# 1. 导出当前对话
# 2. 回退 3 步
```

#### 最佳实践#

True. 谨慎使用：回退操作无法恢复，谨慎使用
True. 先导出：回退前先导出对话，避免丢失
True. 确认操作：回退前确认要撤销的操作
True. 定期保存：定期保存重要状态

#### 总结#

/rewind 命令是 Claude Code 中用于撤销操作的重要命令。通过使用此命令，你可以：

```
/rewind
```

- 查看可回退的操作
- 撤销之前的操作
- 恢复到之前的状态
- 修正错误操作

合理使用 /rewind 命令可以帮助你管理操作历史，修正错误。

```
/rewind
```

---

## 28 /status - 打开状态界面

**URL**: https://claudecode.tangshuang.net/course/7.28%20%2Fstatus%20-%20%E6%89%93%E5%BC%80%E7%8A%B6%E6%80%81%E7%95%8C%E9%9D%A2

#### 概述#

/status 命令用于打开 Claude Code 的状态界面（状态选项卡），显示版本、模型、账户和连接性信息。

```
/status
```

#### 基本语法#

```
bash复制/status
```

```
/status
```

#### 功能说明#

执行 /status 命令后，Claude Code 会：

```
/status
```

True. 打开状态界面
True. 显示系统信息
True. 显示模型信息
True. 显示账户信息
True. 显示连接状态

#### 状态信息#

##### 系统信息#

- Claude Code 版本
- 操作系统
- Node.js 版本
- 内存使用

##### 模型信息#

- 当前使用的模型
- 模型版本
- 模型状态

##### 账户信息#

- 登录状态
- 账户类型
- 使用限制

##### 连接状态#

- API 连接状态
- 网络延迟
- 最后连接时间

#### 使用场景#

##### 1. 查看系统状态#

```
bash复制# 查看系统状态
/status

# 显示所有状态信息
```

```
# 查看系统状态
/status

# 显示所有状态信息
```

##### 2. 检查连接#

```
bash复制# 检查 API 连接状态
/status

# 查看连接信息
```

```
# 检查 API 连接状态
/status

# 查看连接信息
```

##### 3. 查看使用情况#

```
bash复制# 查看使用情况
/status

# 显示使用限制和当前使用量
```

```
# 查看使用情况
/status

# 显示使用限制和当前使用量
```

#### 状态显示示例#

```
bash复制Claude Code Status
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

System Information:
  Version: 1.0.124
  OS: Windows 11
  Node.js: v18.17.0
  Memory: 2.3 GB / 16 GB

Model Information:
  Current Model: claude-3-5-sonnet-20241022
  Model Version: 20241022
  Status: ✓ Online

Account Information:
  Login Status: ✓ Logged in
  Account Type: Pro
  Usage: 75,000 / 200,000 tokens (37.5%)

Connection Information:
  API Status: ✓ Connected
  Latency: 150ms
  Last Connection: 2024-01-01 14:30:00
```

```
Claude Code Status
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

System Information:
  Version: 1.0.124
  OS: Windows 11
  Node.js: v18.17.0
  Memory: 2.3 GB / 16 GB

Model Information:
  Current Model: claude-3-5-sonnet-20241022
  Model Version: 20241022
  Status: ✓ Online

Account Information:
  Login Status: ✓ Logged in
  Account Type: Pro
  Usage: 75,000 / 200,000 tokens (37.5%)

Connection Information:
  API Status: ✓ Connected
  Latency: 150ms
  Last Connection: 2024-01-01 14:30:00
```

#### 注意事项#

True. 状态信息实时更新
True. 某些信息需要网络连接
True. 状态界面不会自动刷新
True. 可以手动刷新状态

#### 与其他命令的配合使用#

```
bash复制# 查看状态，然后检查健康
/status
/doctor

# 执行流程：
# 1. 查看状态信息
# 2. 运行健康检查
```

```
# 查看状态，然后检查健康
/status
/doctor

# 执行流程：
# 1. 查看状态信息
# 2. 运行健康检查
```

#### 最佳实践#

True. 定期检查：定期查看状态，了解系统情况
True. 问题诊断：遇到问题时，先查看状态
True. 连接监控：监控 API 连接状态
True. 使用跟踪：跟踪使用情况，避免超限

#### 总结#

/status 命令是 Claude Code 中用于查看状态的重要命令。通过使用此命令，你可以：

```
/status
```

- 查看系统信息
- 查看模型信息
- 查看账户信息
- 查看连接状态

合理使用 /status 命令可以帮助你了解 Claude Code 的运行状态。

```
/status
```

---

## 29 /statusline - 设置状态行UI

**URL**: https://claudecode.tangshuang.net/course/7.29%20%2Fstatusline%20-%20%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E8%A1%8CUI

#### 概述#

/statusline 命令用于设置 Claude Code 的状态行 UI，自定义状态栏显示的信息和样式。

```
/statusline
```

#### 基本语法#

```
bash复制/statusline [option]
```

```
/statusline [option]
```

#### 参数说明#

```
[option]
```

#### 状态行选项#

##### 显示选项#

- model: 显示当前模型
- tokens: 显示 token 使用情况
- connection: 显示连接状态
- account: 显示账户信息
- time: 显示当前时间

```
model
```

```
tokens
```

```
connection
```

```
account
```

```
time
```

##### 样式选项#

- compact: 紧凑样式
- detailed: 详细样式
- minimal: 最小样式

```
compact
```

```
detailed
```

```
minimal
```

#### 使用场景#

##### 1. 配置状态行#

```
bash复制# 打开状态行配置界面
/statusline

# 配置显示选项
```

```
# 打开状态行配置界面
/statusline

# 配置显示选项
```

##### 2. 显示特定信息#

```
bash复制# 显示模型和 token 使用
/statusline model tokens

# 状态行显示这些信息
```

```
# 显示模型和 token 使用
/statusline model tokens

# 状态行显示这些信息
```

##### 3. 更改样式#

```
bash复制# 使用紧凑样式
/statusline --style compact

# 状态行使用紧凑样式
```

```
# 使用紧凑样式
/statusline --style compact

# 状态行使用紧凑样式
```

#### 状态行配置示例#

##### 紧凑样式#

```
bash复制[claude-3-5-sonnet] 75k/200k tokens ✓
```

```
[claude-3-5-sonnet] 75k/200k tokens ✓
```

##### 详细样式#

```
bash复制Model: claude-3-5-sonnet-20241022 | Tokens: 75,000/200,000 (37.5%) | Connection: ✓ Connected | Account: Pro
```

```
Model: claude-3-5-sonnet-20241022 | Tokens: 75,000/200,000 (37.5%) | Connection: ✓ Connected | Account: Pro
```

##### 最小样式#

```
bash复制✓ 75k/200k
```

```
✓ 75k/200k
```

#### 配置文件#

状态行配置保存在配置文件中：

```
json复制{
  "statusline": {
    "enabled": true,
    "showModel": true,
    "showTokens": true,
    "showConnection": true,
    "showAccount": false,
    "showTime": false,
    "style": "compact"
  }
}
```

```
{
  "statusline": {
    "enabled": true,
    "showModel": true,
    "showTokens": true,
    "showConnection": true,
    "showAccount": false,
    "showTime": false,
    "style": "compact"
  }
}
```

#### 注意事项#

True. 状态行配置会立即生效
True. 某些终端可能不支持状态行
True. 状态行会占用一行空间
True. 可以随时禁用状态行

#### 与其他命令的配合使用#

```
bash复制# 配置状态行，然后查看
/statusline
/status

# 执行流程：
# 1. 配置状态行
# 2. 查看状态信息
```

```
# 配置状态行，然后查看
/statusline
/status

# 执行流程：
# 1. 配置状态行
# 2. 查看状态信息
```

#### 最佳实践#

True. 简洁明了：选择简洁的样式，避免信息过多
True. 有用信息：只显示有用的信息
True. 定期调整：根据需要调整状态行配置
True. 终端兼容：确保状态行与终端兼容

#### 总结#

/statusline 命令是 Claude Code 中用于自定义状态行的重要命令。通过使用此命令，你可以：

```
/statusline
```

- 配置状态行显示的信息
- 选择状态行样式
- 自定义状态栏外观
- 优化状态栏信息

合理使用 /statusline 命令可以帮助你创建更符合需求的状态行。

```
/statusline
```

---

## 30 /terminal-setup - 安装Shift+Enter键绑定

**URL**: https://claudecode.tangshuang.net/course/7.30%20%2Fterminal-setup%20-%20%E5%AE%89%E8%A3%85Shift%2BEnter%E9%94%AE%E7%BB%91%E5%AE%9A

#### 概述#

/terminal-setup 命令用于安装 Shift+Enter 键绑定，以便在终端中输入多行文本。此功能仅限 iTerm2 和 VSCode 终端。

```
/terminal-setup
```

#### 基本语法#

```
bash复制/terminal-setup
```

```
/terminal-setup
```

#### 功能说明#

执行 /terminal-setup 命令后，Claude Code 会：

```
/terminal-setup
```

True. 检测当前终端类型
True. 安装 Shift+Enter 键绑定
True. 配置多行输入模式
True. 显示安装成功确认

#### 支持的终端#

##### iTerm2#

- 支持: ✓ 完全支持
- 配置: 自动配置
- 功能: Shift+Enter 换行，Enter 发送

##### VSCode 终端#

- 支持: ✓ 完全支持
- 配置: 自动配置
- 功能: Shift+Enter 换行，Enter 发送

##### 其他终端#

- 支持: ✗ 不支持
- 建议: 使用 iTerm2 或 VSCode 终端

#### 使用场景#

##### 1. 在 iTerm2 中使用#

```
bash复制# 在 iTerm2 中安装键绑定
/terminal-setup

# 配置完成后，可以使用 Shift+Enter 换行
```

```
# 在 iTerm2 中安装键绑定
/terminal-setup

# 配置完成后，可以使用 Shift+Enter 换行
```

##### 2. 在 VSCode 终端中使用#

```
bash复制# 在 VSCode 终端中安装键绑定
/terminal-setup

# 配置完成后，可以使用 Shift+Enter 换行
```

```
# 在 VSCode 终端中安装键绑定
/terminal-setup

# 配置完成后，可以使用 Shift+Enter 换行
```

##### 3. 输入多行文本#

```
bash复制# 安装后，可以输入多行文本
function hello() {
  console.log("Hello, World!");
}

# 使用 Shift+Enter 换行，Enter 发送
```

```
# 安装后，可以输入多行文本
function hello() {
  console.log("Hello, World!");
}

# 使用 Shift+Enter 换行，Enter 发送
```

#### 键绑定说明#

##### 默认行为#

- Enter: 发送命令
- Shift+Enter: 换行

##### 安装后行为#

- Enter: 发送命令
- Shift+Enter: 换行（不发送）

#### 注意事项#

True. 仅支持 iTerm2 和 VSCode 终端
True. 需要重启终端才能生效
True. 键绑定会影响所有终端会话
True. 可以手动卸载键绑定

#### 卸载键绑定#

##### iTerm2#

```
bash复制# 在 iTerm2 中手动卸载
1. 打开 Preferences
2. 选择 Profiles -> Keys
3. 删除 Shift+Enter 键绑定
```

```
# 在 iTerm2 中手动卸载
1. 打开 Preferences
2. 选择 Profiles -> Keys
3. 删除 Shift+Enter 键绑定
```

##### VSCode#

```
bash复制# 在 VSCode 中手动卸载
1. 打开 Settings
2. 搜索 "terminal.integrated.sendShiftEnter"
3. 禁用该选项
```

```
# 在 VSCode 中手动卸载
1. 打开 Settings
2. 搜索 "terminal.integrated.sendShiftEnter"
3. 禁用该选项
```

#### 与其他命令的配合使用#

```
bash复制# 安装键绑定，然后使用
/terminal-setup
# 输入多行文本
```

```
# 安装键绑定，然后使用
/terminal-setup
# 输入多行文本
```

#### 最佳实践#

True. 确认终端：确认使用支持的终端
True. 重启终端：安装后重启终端
True. 测试功能：安装后测试键绑定
True. 备份配置：卸载前备份配置

#### 总结#

/terminal-setup 命令是 Claude Code 中用于配置终端键绑定的命令。通过使用此命令，你可以：

```
/terminal-setup
```

- 安装 Shift+Enter 键绑定
- 在终端中输入多行文本
- 提高终端使用效率
- 改善多行输入体验

合理使用 /terminal-setup 命令可以帮助你在终端中更方便地输入多行文本。

```
/terminal-setup
```

---

## 31 /todos - 列出当前待办事项

**URL**: https://claudecode.tangshuang.net/course/7.31%20%2Ftodos%20-%20%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9

#### 概述#

/todos 命令用于列出当前待办事项，帮助你跟踪和管理任务进度。

```
/todos
```

#### 基本语法#

```
bash复制/todos [subcommand]
```

```
/todos [subcommand]
```

#### 子命令#

```
add
```

```
complete
```

```
remove
```

```
clear
```

#### 功能说明#

##### 列出待办事项#

```
bash复制/todos

# 显示所有待办事项及其状态
```

```
/todos

# 显示所有待办事项及其状态
```

##### 添加待办事项#

```
bash复制/todos add

# 按照提示输入待办事项
```

```
/todos add

# 按照提示输入待办事项
```

##### 完成待办事项#

```
bash复制/todos complete 1

# 标记待办事项 #1 为完成
```

```
/todos complete 1

# 标记待办事项 #1 为完成
```

##### 删除待办事项#

```
bash复制/todos remove 2

# 删除待办事项 #2
```

```
/todos remove 2

# 删除待办事项 #2
```

#### 使用场景#

##### 1. 查看待办事项#

```
bash复制# 查看所有待办事项
/todos

# 了解当前任务列表
```

```
# 查看所有待办事项
/todos

# 了解当前任务列表
```

##### 2. 添加任务#

```
bash复制# 添加新的待办事项
/todos add

# 输入任务描述
```

```
# 添加新的待办事项
/todos add

# 输入任务描述
```

##### 3. 完成任务#

```
bash复制# 标记任务为完成
/todos complete 1

# 更新任务状态
```

```
# 标记任务为完成
/todos complete 1

# 更新任务状态
```

##### 4. 清理任务#

```
bash复制# 清除已完成的任务
/todos clear

# 清空待办事项列表
```

```
# 清除已完成的任务
/todos clear

# 清空待办事项列表
```

#### 待办事项示例#

```
bash复制待办事项列表
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[ ] 1. 实现用户登录功能
[ ] 2. 编写单元测试
[✓] 3. 修复登录页面的 bug
[ ] 4. 更新文档
[ ] 5. 代码审查

总计: 5 个任务
已完成: 1 个
待完成: 4 个
```

```
待办事项列表
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[ ] 1. 实现用户登录功能
[ ] 2. 编写单元测试
[✓] 3. 修复登录页面的 bug
[ ] 4. 更新文档
[ ] 5. 代码审查

总计: 5 个任务
已完成: 1 个
待完成: 4 个
```

#### 注意事项#

True. 待办事项保存在本地
True. 待办事项不会自动同步
True. 可以手动编辑待办事项文件
True. 清除操作无法撤销

#### 与其他命令的配合使用#

```
bash复制# 查看待办事项，然后完成任务
/todos
/todos complete 1

# 执行流程：
# 1. 查看待办事项列表
# 2. 完成指定任务
```

```
# 查看待办事项，然后完成任务
/todos
/todos complete 1

# 执行流程：
# 1. 查看待办事项列表
# 2. 完成指定任务
```

#### 最佳实践#

True. 定期更新：定期更新待办事项列表
True. 明确任务：使用清晰的任务描述
True. 优先级排序：按优先级排序任务
True. 及时完成：及时完成任务并更新状态

#### 总结#

/todos 命令是 Claude Code 中用于任务管理的重要命令。通过使用此命令，你可以：

```
/todos
```

- 查看待办事项列表
- 添加新的任务
- 标记任务为完成
- 删除任务

合理使用 /todos 命令可以帮助你更好地跟踪和管理任务进度。

```
/todos
```

---

## 32 /usage - 显示使用限制和速率限制状态

**URL**: https://claudecode.tangshuang.net/course/7.32%20%2Fusage%20-%20%E6%98%BE%E7%A4%BA%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6%E5%92%8C%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6%E7%8A%B6%E6%80%81

#### 概述#

/usage 命令用于显示计划使用限制和速率限制状态，帮助你了解当前使用情况和剩余配额。

```
/usage
```

#### 基本语法#

```
bash复制/usage
```

```
/usage
```

#### 功能说明#

执行 /usage 命令后，Claude Code 会：

```
/usage
```

True. 显示当前使用量
True. 显示使用限制
True. 显示速率限制状态
True. 显示配额剩余情况

#### 使用信息#

##### 令牌使用#

- 当前使用量
- 每日限制
- 每月限制
- 使用百分比

##### 速率限制#

- 请求速率
- 剩余请求数
- 重置时间
- 限制状态

##### 计划信息#

- 当前计划类型
- 计划限制
- 升级选项

#### 使用场景#

##### 1. 查看使用情况#

```
bash复制# 查看当前使用情况
/usage

# 显示使用量和限制
```

```
# 查看当前使用情况
/usage

# 显示使用量和限制
```

##### 2. 检查速率限制#

```
bash复制# 检查速率限制状态
/usage

# 查看速率限制信息
```

```
# 检查速率限制状态
/usage

# 查看速率限制信息
```

##### 3. 监控配额#

```
bash复制# 监控配额使用情况
/usage

# 了解剩余配额
```

```
# 监控配额使用情况
/usage

# 了解剩余配额
```

#### 输出示例#

```
bash复制使用情况统计
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

令牌使用:
  每日: 75,000 / 200,000 (37.5%)
  每月: 150,000 / 1,000,000 (15.0%)

速率限制:
  请求速率: 50 / 分钟
  剩余请求: 35
  重置时间: 2024-01-01 15:00:00
  状态: ✓ 正常

计划信息:
  当前计划: Pro
  每日限制: 200,000 令牌
  每月限制: 1,000,000 令牌
  速率限制: 50 请求/分钟

建议:
  ✓ 当前使用量在正常范围内
  - 距离每日限制还有 125,000 令牌
  - 距离每月限制还有 850,000 令牌
```

```
使用情况统计
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

令牌使用:
  每日: 75,000 / 200,000 (37.5%)
  每月: 150,000 / 1,000,000 (15.0%)

速率限制:
  请求速率: 50 / 分钟
  剩余请求: 35
  重置时间: 2024-01-01 15:00:00
  状态: ✓ 正常

计划信息:
  当前计划: Pro
  每日限制: 200,000 令牌
  每月限制: 1,000,000 令牌
  速率限制: 50 请求/分钟

建议:
  ✓ 当前使用量在正常范围内
  - 距离每日限制还有 125,000 令牌
  - 距离每月限制还有 850,000 令牌
```

#### 计划类型#

##### 免费计划#

- 每日限制: 200,000 令牌
- 每月限制: 1,000,000 令牌
- 速率限制: 20 请求/分钟

##### Pro 计划#

- 每日限制: 500,000 令牌
- 每月限制: 5,000,000 令牌
- 速率限制: 50 请求/分钟

##### Enterprise 计划#

- 每日限制: 2,000,000 令牌
- 每月限制: 20,000,000 令牌
- 速率限制: 100 请求/分钟

#### 注意事项#

True. 使用限制会在每日/每月重置
True. 速率限制按分钟计算
True. 超出限制后需要等待或升级计划
True. 使用量实时更新

#### 与其他命令的配合使用#

```
bash复制# 查看使用情况，然后优化
/usage
/compact

# 执行流程：
# 1. 查看使用情况
# 2. 压缩对话以减少令牌使用
```

```
# 查看使用情况，然后优化
/usage
/compact

# 执行流程：
# 1. 查看使用情况
# 2. 压缩对话以减少令牌使用
```

#### 最佳实践#

True. 定期检查：定期查看使用情况
True. 提前规划：提前规划使用量
True. 优化使用：优化对话以减少令牌消耗
True. 及时升级：接近限制时考虑升级计划

#### 总结#

/usage 命令是 Claude Code 中用于查看使用情况的重要命令。通过使用此命令，你可以：

```
/usage
```

- 查看当前使用量
- 查看使用限制
- 查看速率限制状态
- 了解剩余配额

合理使用 /usage 命令可以帮助你更好地管理和规划使用配额。

```
/usage
```

---

## 33 /vim - 进入vim模式

**URL**: https://claudecode.tangshuang.net/course/7.33%20%2Fvim%20-%20%E8%BF%9B%E5%85%A5vim%E6%A8%A1%E5%BC%8F

#### 概述#

/vim 命令用于进入 vim 模式，允许你使用 vim 的插入和命令模式交替输入文本。

```
/vim
```

#### 基本语法#

```
bash复制/vim
```

```
/vim
```

#### 功能说明#

执行 /vim 命令后，Claude Code 会：

```
/vim
```

True. 启用 vim 模式
True. 切换到正常模式
True. 允许使用 vim 快捷键
True. 显示 vim 模式激活提示

#### Vim 模式#

##### 正常模式 (Normal Mode)#

- 进入: 默认模式
- 功能: 浏览和编辑文本
- 快捷键: h, j, k, l, dd, yy, p 等

##### 插入模式 (Insert Mode)#

- 进入: 按 i 或 a
- 功能: 输入文本
- 退出: 按 Esc

```
i
```

```
a
```

```
Esc
```

##### 命令模式 (Command Mode)#

- 进入: 按 : 或 /
- 功能: 执行命令
- 退出: 按 Esc

```
:
```

```
/
```

```
Esc
```

#### 使用场景#

##### 1. 进入 vim 模式#

```
bash复制# 进入 vim 模式
/vim

# 现在可以使用 vim 快捷键
```

```
# 进入 vim 模式
/vim

# 现在可以使用 vim 快捷键
```

##### 2. 编辑文本#

```
bash复制# 在 vim 模式下编辑文本
/vim
# 按 i 进入插入模式
# 输入文本
# 按 Esc 返回正常模式
```

```
# 在 vim 模式下编辑文本
/vim
# 按 i 进入插入模式
# 输入文本
# 按 Esc 返回正常模式
```

##### 3. 浏览文本#

```
bash复制# 使用 vim 快捷键浏览文本
/vim
# 使用 h, j, k, l 移动光标
```

```
# 使用 vim 快捷键浏览文本
/vim
# 使用 h, j, k, l 移动光标
```

#### 常用 Vim 快捷键#

##### 移动#

- h: 左移
- j: 下移
- k: 上移
- l: 右移
- w: 下一个词
- b: 上一个词

```
h
```

```
j
```

```
k
```

```
l
```

```
w
```

```
b
```

##### 编辑#

- i: 在光标前插入
- a: 在光标后插入
- dd: 删除行
- yy: 复制行
- p: 粘贴

```
i
```

```
a
```

```
dd
```

```
yy
```

```
p
```

##### 退出#

- Esc: 返回正常模式
- :q: 退出
- :w: 保存
- :wq: 保存并退出

```
Esc
```

```
:q
```

```
:w
```

```
:wq
```

#### 注意事项#

True. Vim 模式会影响所有输入
True. 需要了解 vim 基本操作
True. 可以随时退出 vim 模式
True. 不熟悉 vim 的用户可能需要学习

#### 退出 Vim 模式#

```
bash复制# 退出 vim 模式
/vim

# 再次执行 /vim 命令可以退出
```

```
# 退出 vim 模式
/vim

# 再次执行 /vim 命令可以退出
```

#### 与其他命令的配合使用#

```
bash复制# 进入 vim 模式，然后编辑
/vim
# 使用 vim 快捷键编辑文本
```

```
# 进入 vim 模式，然后编辑
/vim
# 使用 vim 快捷键编辑文本
```

#### 最佳实践#

True. 学习基础：先学习 vim 基础操作
True. 练习使用：多练习使用 vim 快捷键
True. 按需使用：根据需要使用 vim 模式
True. 快捷键参考：准备快捷键参考表

#### 总结#

/vim 命令是 Claude Code 中用于启用 vim 模式的命令。通过使用此命令，你可以：

```
/vim
```

- 进入 vim 模式
- 使用 vim 快捷键
- 提高编辑效率
- 享受 vim 的强大功能

合理使用 /vim 命令可以帮助你更高效地编辑文本，如果你熟悉 vim 的话。

```
/vim
```

---

# 第 8 章

## 1 命令组合基础

**URL**: https://claudecode.tangshuang.net/course/8.1%20%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88%E5%9F%BA%E7%A1%80

在前面的章节中，我们已经学习了 CLI 命令、CLI 标志和斜杠命令的单独使用。在本章中，我们将学习如何将这些命令和标志组合起来，创建更强大、更高效的自动化工作流。

#### 命令组合的概念#

命令组合是指将多个命令、标志和参数按照一定的逻辑组合在一起，以实现复杂的功能。通过命令组合，您可以：

- 串联多个操作：将多个独立的命令串联起来执行
- 传递数据：使用管道将一个命令的输出传递给另一个命令
- 条件执行：根据前一个命令的结果决定是否执行后续命令
- 并行处理：同时执行多个独立的命令以提高效率

#### 基本组合模式#

##### 1. 标志组合#

最简单的组合方式是同时使用多个标志来配置 Claude Code 的行为。

###### 示例：使用多个标志

```
bash复制# 使用多个标志配置会话
claude --model sonnet --verbose --add-dir ./src --add-dir ./tests
```

```
# 使用多个标志配置会话
claude --model sonnet --verbose --add-dir ./src --add-dir ./tests
```

这个命令组合了四个标志：

- --model sonnet：指定使用 Sonnet 模型
- --verbose：启用详细日志记录
- --add-dir ./src：添加 src 目录
- --add-dir ./tests：添加 tests 目录

```
--model sonnet
```

```
--verbose
```

```
--add-dir ./src
```

```
--add-dir ./tests
```

###### 标志组合的原则

- 顺序无关：大多数标志的顺序不影响功能
- 优先级：后指定的标志可能覆盖前面的标志
- 兼容性：某些标志可能互斥，不能同时使用

##### 2. 管道组合#

使用管道（|）将一个命令的输出传递给另一个命令。

```
|
```

###### 示例：处理文件内容

```
bash复制# 读取文件并通过管道传递给 Claude Code
cat main.py | claude -p "优化这段代码的性能"
```

```
# 读取文件并通过管道传递给 Claude Code
cat main.py | claude -p "优化这段代码的性能"
```

这个命令的工作流程：

True. cat main.py：读取 main.py 文件的内容
True. |：将文件内容通过管道传递
True. claude -p "优化这段代码的性能"：接收文件内容并执行优化任务

```
cat main.py
```

```
|
```

```
claude -p "优化这段代码的性能"
```

###### 示例：链式处理

```
bash复制# 多个命令的链式处理
cat code.py | claude -p "提取函数定义" | grep "def " | sort
```

```
# 多个命令的链式处理
cat code.py | claude -p "提取函数定义" | grep "def " | sort
```

这个命令的工作流程：

True. cat code.py：读取 code.py 文件
True. claude -p "提取函数定义"：提取所有函数定义
True. grep "def "：过滤出包含 "def " 的行
True. sort：对结果进行排序

```
cat code.py
```

```
claude -p "提取函数定义"
```

```
grep "def "
```

```
sort
```

###### 管道组合的注意事项

- 数据格式：确保管道传递的数据格式正确
- 错误处理：管道中的任何命令失败都会导致整个链失败
- 性能考虑：长管道链可能影响性能

##### 3. 命令替换#

使用命令替换将一个命令的输出作为另一个命令的参数。

###### 示例：使用命令替换

```
bash复制# 将命令输出作为参数
claude -p "审查 $(git diff --name-only) 中的文件"
```

```
# 将命令输出作为参数
claude -p "审查 $(git diff --name-only) 中的文件"
```

这个命令的工作流程：

True. git diff --name-only：获取修改的文件列表
True. $()：将输出作为参数传递
True. claude -p "审查 ... 中的文件"：审查这些文件

```
git diff --name-only
```

```
$()
```

```
claude -p "审查 ... 中的文件"
```

###### 示例：动态参数

```
bash复制# 根据当前分支动态生成参数
claude -p "为 $(git branch --show-current) 分支生成提交信息"
```

```
# 根据当前分支动态生成参数
claude -p "为 $(git branch --show-current) 分支生成提交信息"
```

##### 4. 条件执行#

根据前一个命令的执行结果决定是否执行后续命令。

###### 示例：使用 && 操作符

```
bash复制# 前一个命令成功后才执行后一个命令
claude -p "生成测试代码" && claude -p "运行测试"
```

```
# 前一个命令成功后才执行后一个命令
claude -p "生成测试代码" && claude -p "运行测试"
```

这个命令的工作流程：

True. 执行 claude -p "生成测试代码"
True. 如果成功，执行 claude -p "运行测试"
True. 如果失败，不执行后续命令

```
claude -p "生成测试代码"
```

```
claude -p "运行测试"
```

###### 示例：使用 || 操作符

```
bash复制# 前一个命令失败时才执行后一个命令
claude -p "尝试快速修复" || claude -p "使用备用方案"
```

```
# 前一个命令失败时才执行后一个命令
claude -p "尝试快速修复" || claude -p "使用备用方案"
```

这个命令的工作流程：

True. 执行 claude -p "尝试快速修复"
True. 如果失败，执行 claude -p "使用备用方案"
True. 如果成功，不执行后续命令

```
claude -p "尝试快速修复"
```

```
claude -p "使用备用方案"
```

###### 示例：使用 ; 操作符

```
bash复制# 无论前一个命令是否成功都执行后一个命令
claude -p "生成代码" ; claude -p "生成文档"
```

```
# 无论前一个命令是否成功都执行后一个命令
claude -p "生成代码" ; claude -p "生成文档"
```

##### 5. 后台执行#

将命令放在后台执行，不阻塞当前终端。

###### 示例：后台执行

```
bash复制# 在后台执行长时间运行的任务
claude -p "分析大型项目" &
```

```
# 在后台执行长时间运行的任务
claude -p "分析大型项目" &
```

这个命令的工作流程：

True. &：将命令放在后台执行
True. 命令在后台运行，终端可以继续使用

```
&
```

###### 示例：并行执行多个任务

```
bash复制# 并行执行多个独立的任务
claude -p "分析前端代码" &
claude -p "分析后端代码" &
claude -p "分析测试代码" &
wait
```

```
# 并行执行多个独立的任务
claude -p "分析前端代码" &
claude -p "分析后端代码" &
claude -p "分析测试代码" &
wait
```

这个命令的工作流程：

True. 同时启动三个独立的任务
True. 每个任务在后台运行
True. wait：等待所有后台任务完成

```
wait
```

#### 高级组合模式#

##### 1. 函数封装#

将命令组合封装成函数，便于重复使用。

###### 示例：Bash 函数

```
bash复制# 定义一个代码审查函数
code_review() {
  local file=$1
  claude -p "审查 $file 的代码质量、安全性和性能" --output-format json
}

# 使用函数
code_review main.py
code_review utils.js
```

```
# 定义一个代码审查函数
code_review() {
  local file=$1
  claude -p "审查 $file 的代码质量、安全性和性能" --output-format json
}

# 使用函数
code_review main.py
code_review utils.js
```

###### 示例：带参数的函数

```
bash复制# 定义一个带多个参数的函数
analyze_project() {
  local project_dir=$1
  local model=$2
  local output_format=$3
  
  claude --model "$model" \
         --add-dir "$project_dir" \
         -p "分析项目结构和代码质量" \
         --output-format "$output_format"
}

# 使用函数
analyze_project ./myproject sonnet json
```

```
# 定义一个带多个参数的函数
analyze_project() {
  local project_dir=$1
  local model=$2
  local output_format=$3
  
  claude --model "$model" \
         --add-dir "$project_dir" \
         -p "分析项目结构和代码质量" \
         --output-format "$output_format"
}

# 使用函数
analyze_project ./myproject sonnet json
```

##### 2. 循环处理#

使用循环批量处理多个文件或项目。

###### 示例：for 循环

```
bash复制# 批量处理多个文件
for file in *.py; do
  claude -p "优化 $file 的性能" > "${file%.py}.optimized.py"
done
```

```
# 批量处理多个文件
for file in *.py; do
  claude -p "优化 $file 的性能" > "${file%.py}.optimized.py"
done
```

这个命令的工作流程：

True. 遍历所有 .py 文件
True. 对每个文件执行优化任务
True. 将结果保存到 .optimized.py 文件

###### 示例：while 循环

```
bash复制# 持续监控文件变化
while inotifywait -e modify *.py; do
  claude -p "检测到文件变化，重新分析代码"
done
```

```
# 持续监控文件变化
while inotifywait -e modify *.py; do
  claude -p "检测到文件变化，重新分析代码"
done
```

##### 3. 数组处理#

使用数组存储和处理多个项目。

###### 示例：数组遍历

```
bash复制# 定义项目数组
projects=("frontend" "backend" "api" "tests")

# 遍历数组并处理每个项目
for project in "${projects[@]}"; do
  claude --add-dir "./$project" -p "分析 $project 项目"
done
```

```
# 定义项目数组
projects=("frontend" "backend" "api" "tests")

# 遍历数组并处理每个项目
for project in "${projects[@]}"; do
  claude --add-dir "./$project" -p "分析 $project 项目"
done
```

###### 示例：动态数组

```
bash复制# 动态生成数组
files=($(git diff --name-only))

# 处理数组中的每个文件
for file in "${files[@]}"; do
  claude -p "审查 $file 的变更"
done
```

```
# 动态生成数组
files=($(git diff --name-only))

# 处理数组中的每个文件
for file in "${files[@]}"; do
  claude -p "审查 $file 的变更"
done
```

#### 命令组合的最佳实践#

##### 1. 可读性#

- 使用注释：为复杂的命令组合添加注释
- 合理换行：长命令使用反斜杠换行
- 命名变量：使用有意义的变量名

###### 示例：提高可读性

```
bash复制# 定义变量
PROJECT_DIR="./myproject"
MODEL="sonnet"
OUTPUT_FORMAT="json"

# 使用变量和注释
claude \
  --model "$MODEL" \
  --add-dir "$PROJECT_DIR" \
  --add-dir "$PROJECT_DIR/tests" \
  --add-dir "$PROJECT_DIR/docs" \
  -p "分析项目结构和代码质量" \
  --output-format "$OUTPUT_FORMAT"
```

```
# 定义变量
PROJECT_DIR="./myproject"
MODEL="sonnet"
OUTPUT_FORMAT="json"

# 使用变量和注释
claude \
  --model "$MODEL" \
  --add-dir "$PROJECT_DIR" \
  --add-dir "$PROJECT_DIR/tests" \
  --add-dir "$PROJECT_DIR/docs" \
  -p "分析项目结构和代码质量" \
  --output-format "$OUTPUT_FORMAT"
```

##### 2. 错误处理#

- 检查退出码：检查命令是否成功执行
- 捕获错误：使用 trap 捕获错误
- 提供反馈：为用户提供清晰的错误信息

###### 示例：错误处理

```
bash复制# 检查命令是否成功
if claude -p "生成代码"; then
  echo "代码生成成功"
else
  echo "代码生成失败"
  exit 1
fi

# 使用 trap 捕获错误
trap 'echo "发生错误，退出码: $?"' ERR

claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"
```

```
# 检查命令是否成功
if claude -p "生成代码"; then
  echo "代码生成成功"
else
  echo "代码生成失败"
  exit 1
fi

# 使用 trap 捕获错误
trap 'echo "发生错误，退出码: $?"' ERR

claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"
```

##### 3. 性能优化#

- 并行执行：使用后台执行和 wait 提高效率
- 缓存结果：避免重复执行相同的命令
- 增量处理：只处理变化的部分

###### 示例：性能优化

```
bash复制# 并行处理多个文件
for file in *.py; do
  claude -p "分析 $file" > "${file%.py}.analysis.json" &
done
wait

# 使用缓存
CACHE_FILE="analysis.cache"
if [ -f "$CACHE_FILE" ]; then
  echo "使用缓存结果"
  cat "$CACHE_FILE"
else
  claude -p "分析项目" > "$CACHE_FILE"
fi
```

```
# 并行处理多个文件
for file in *.py; do
  claude -p "分析 $file" > "${file%.py}.analysis.json" &
done
wait

# 使用缓存
CACHE_FILE="analysis.cache"
if [ -f "$CACHE_FILE" ]; then
  echo "使用缓存结果"
  cat "$CACHE_FILE"
else
  claude -p "分析项目" > "$CACHE_FILE"
fi
```

##### 4. 可维护性#

- 模块化：将复杂的命令组合拆分成多个函数
- 配置化：使用配置文件管理参数
- 文档化：为命令组合编写文档

###### 示例：模块化

```
bash复制# 定义模块化函数
setup_environment() {
  claude --add-dir ./src --add-dir ./tests --add-dir ./config
}

generate_code() {
  claude -p "生成代码"
}

run_tests() {
  claude -p "运行测试"
}

# 组合函数
main() {
  setup_environment
  generate_code
  run_tests
}

# 执行主函数
main
```

```
# 定义模块化函数
setup_environment() {
  claude --add-dir ./src --add-dir ./tests --add-dir ./config
}

generate_code() {
  claude -p "生成代码"
}

run_tests() {
  claude -p "运行测试"
}

# 组合函数
main() {
  setup_environment
  generate_code
  run_tests
}

# 执行主函数
main
```

#### 常见组合场景#

##### 1. 代码审查工作流#

```
bash复制# 完整的代码审查工作流
claude -p "审查最近的代码变更" \
  --output-format json \
  > review.json && \
  claude -p "根据审查结果生成修复建议" \
  --input-format json \
  < review.json
```

```
# 完整的代码审查工作流
claude -p "审查最近的代码变更" \
  --output-format json \
  > review.json && \
  claude -p "根据审查结果生成修复建议" \
  --input-format json \
  < review.json
```

##### 2. 文档生成工作流#

```
bash复制# 自动生成文档
claude -p "提取所有函数和类的文档注释" \
  --output-format json \
  > docs.json && \
  claude -p "根据提取的信息生成 Markdown 文档" \
  --input-format json \
  < docs.json > README.md
```

```
# 自动生成文档
claude -p "提取所有函数和类的文档注释" \
  --output-format json \
  > docs.json && \
  claude -p "根据提取的信息生成 Markdown 文档" \
  --input-format json \
  < docs.json > README.md
```

##### 3. 测试工作流#

```
bash复制# 自动化测试工作流
claude -p "生成测试用例" > test_cases.txt && \
claude -p "运行测试用例" && \
claude -p "分析测试结果" --output-format json > test_results.json
```

```
# 自动化测试工作流
claude -p "生成测试用例" > test_cases.txt && \
claude -p "运行测试用例" && \
claude -p "分析测试结果" --output-format json > test_results.json
```

##### 4. 部署工作流#

```
bash复制# 自动化部署工作流
claude -p "检查代码质量" && \
claude -p "生成部署清单" && \
claude -p "执行部署脚本" && \
claude -p "验证部署结果"
```

```
# 自动化部署工作流
claude -p "检查代码质量" && \
claude -p "生成部署清单" && \
claude -p "执行部署脚本" && \
claude -p "验证部署结果"
```

#### 总结#

命令组合是发挥 Claude Code 强大功能的关键。通过掌握基本的组合模式（标志组合、管道组合、命令替换、条件执行、后台执行）和高级组合模式（函数封装、循环处理、数组处理），您可以创建强大、高效的自动化工作流。

记住以下要点：

True. 从简单开始：先掌握基本的组合模式
True. 逐步复杂：在掌握基础后尝试高级模式
True. 注重实践：通过实际项目练习命令组合
True. 持续优化：不断改进和优化您的命令组合

在接下来的章节中，我们将学习如何将这些命令组合应用到脚本编写、CI/CD 集成、批处理操作和实际工作流中。

---

## 2 脚本编写

**URL**: https://claudecode.tangshuang.net/course/8.2%20%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99

在上一节中，我们学习了命令组合的基础知识。在本节中，我们将学习如何将这些命令组合封装成可重用的脚本，以便更高效地自动化各种任务。

#### 脚本编写概述#

脚本是将一系列命令和逻辑组合在一起的可执行文件。使用脚本可以：

- 提高效率：自动化重复性任务
- 减少错误：避免手动操作的错误
- 便于维护：集中管理复杂的逻辑
- 易于分享：方便与团队成员共享

#### Bash 脚本基础#

##### 1. 脚本结构#

一个基本的 Bash 脚本包含以下元素：

###### 示例：基本脚本结构

```
bash复制#!/bin/bash

# 脚本描述
```

```
#!/bin/bash

# 脚本描述
```

### 作者：Your Name

### 日期：2026-01-01

### 设置脚本选项

set -e  # 遇到错误立即退出
set -u  # 使用未定义变量时报错
set -o pipefail  # 管道中任何命令失败都导致整个管道失败

### 定义变量

PROJECT_DIR="./myproject"
MODEL="sonnet"

### 定义函数

main() {
echo "开始执行脚本"
setup_environment
generate_code
run_tests
echo "脚本执行完成"
}

### 执行主函数

```
bash复制
#### 脚本元素说明

- `#!/bin/bash`：Shebang 行，指定脚本解释器
- `set -e`：遇到错误立即退出
- `set -u`：使用未定义变量时报错
- `set -o pipefail`：管道中任何命令失败都导致整个管道失败
- `#`：注释符号

### 2. 变量和参数

#### 示例：定义和使用变量

```bash
#!/bin/bash

# 定义变量
PROJECT_DIR="./myproject"
MODEL="sonnet"
OUTPUT_FORMAT="json"
VERBOSE=true

# 使用变量
echo "项目目录: $PROJECT_DIR"
echo "模型: $MODEL"

# 条件使用变量
if [ "$VERBOSE" = true ]; then
  claude --model "$MODEL" -p "分析项目" --verbose
else
  claude --model "$MODEL" -p "分析项目"
fi
```

```
#### 脚本元素说明

- `#!/bin/bash`：Shebang 行，指定脚本解释器
- `set -e`：遇到错误立即退出
- `set -u`：使用未定义变量时报错
- `set -o pipefail`：管道中任何命令失败都导致整个管道失败
- `#`：注释符号

### 2. 变量和参数

#### 示例：定义和使用变量

```bash
#!/bin/bash

# 定义变量
PROJECT_DIR="./myproject"
MODEL="sonnet"
OUTPUT_FORMAT="json"
VERBOSE=true

# 使用变量
echo "项目目录: $PROJECT_DIR"
echo "模型: $MODEL"

# 条件使用变量
if [ "$VERBOSE" = true ]; then
  claude --model "$MODEL" -p "分析项目" --verbose
else
  claude --model "$MODEL" -p "分析项目"
fi
```

###### 示例：使用位置参数

```
bash复制#!/bin/bash

# 使用位置参数
PROJECT_DIR=$1
MODEL=${2:-sonnet}  # 默认值为 sonnet
OUTPUT_FORMAT=${3:-json}

# 检查参数
if [ -z "$PROJECT_DIR" ]; then
  echo "错误：必须指定项目目录"
  echo "用法: $0 <项目目录> [模型] [输出格式]"
  exit 1
fi

# 使用参数
claude --model "$MODEL" \
       --add-dir "$PROJECT_DIR" \
       -p "分析项目" \
       --output-format "$OUTPUT_FORMAT"
```

```
#!/bin/bash

# 使用位置参数
PROJECT_DIR=$1
MODEL=${2:-sonnet}  # 默认值为 sonnet
OUTPUT_FORMAT=${3:-json}

# 检查参数
if [ -z "$PROJECT_DIR" ]; then
  echo "错误：必须指定项目目录"
  echo "用法: $0 <项目目录> [模型] [输出格式]"
  exit 1
fi

# 使用参数
claude --model "$MODEL" \
       --add-dir "$PROJECT_DIR" \
       -p "分析项目" \
       --output-format "$OUTPUT_FORMAT"
```

###### 示例：使用命名参数

```
bash复制#!/bin/bash

# 定义命名参数
while getopts "d:m:f:v" opt; do
  case $opt in
    d) PROJECT_DIR="$OPTARG" ;;
    m) MODEL="$OPTARG" ;;
    f) OUTPUT_FORMAT="$OPTARG" ;;
    v) VERBOSE=true ;;
    \?) echo "无效选项: -$OPTARG" >&2; exit 1 ;;
  esac
done

# 设置默认值
PROJECT_DIR=${PROJECT_DIR:-./myproject}
MODEL=${MODEL:-sonnet}
OUTPUT_FORMAT=${OUTPUT_FORMAT:-json}
VERBOSE=${VERBOSE:-false}

# 使用参数
if [ "$VERBOSE" = true ]; then
  echo "项目目录: $PROJECT_DIR"
  echo "模型: $MODEL"
  echo "输出格式: $OUTPUT_FORMAT"
fi

claude --model "$MODEL" \
       --add-dir "$PROJECT_DIR" \
       -p "分析项目" \
       --output-format "$OUTPUT_FORMAT"
```

```
#!/bin/bash

# 定义命名参数
while getopts "d:m:f:v" opt; do
  case $opt in
    d) PROJECT_DIR="$OPTARG" ;;
    m) MODEL="$OPTARG" ;;
    f) OUTPUT_FORMAT="$OPTARG" ;;
    v) VERBOSE=true ;;
    \?) echo "无效选项: -$OPTARG" >&2; exit 1 ;;
  esac
done

# 设置默认值
PROJECT_DIR=${PROJECT_DIR:-./myproject}
MODEL=${MODEL:-sonnet}
OUTPUT_FORMAT=${OUTPUT_FORMAT:-json}
VERBOSE=${VERBOSE:-false}

# 使用参数
if [ "$VERBOSE" = true ]; then
  echo "项目目录: $PROJECT_DIR"
  echo "模型: $MODEL"
  echo "输出格式: $OUTPUT_FORMAT"
fi

claude --model "$MODEL" \
       --add-dir "$PROJECT_DIR" \
       -p "分析项目" \
       --output-format "$OUTPUT_FORMAT"
```

##### 3. 函数定义#

###### 示例：定义和使用函数

```
bash复制#!/bin/bash

# 定义函数
setup_environment() {
  echo "设置环境..."
  claude --add-dir ./src --add-dir ./tests --add-dir ./config
}

generate_code() {
  echo "生成代码..."
  claude -p "生成代码"
}

run_tests() {
  echo "运行测试..."
  claude -p "运行测试"
}

# 定义主函数
main() {
  setup_environment
  generate_code
  run_tests
}

# 执行主函数
main
```

```
#!/bin/bash

# 定义函数
setup_environment() {
  echo "设置环境..."
  claude --add-dir ./src --add-dir ./tests --add-dir ./config
}

generate_code() {
  echo "生成代码..."
  claude -p "生成代码"
}

run_tests() {
  echo "运行测试..."
  claude -p "运行测试"
}

# 定义主函数
main() {
  setup_environment
  generate_code
  run_tests
}

# 执行主函数
main
```

###### 示例：带参数的函数

```
bash复制#!/bin/bash

# 定义带参数的函数
analyze_file() {
  local file=$1
  local model=${2:-sonnet}
  
  echo "分析文件: $file"
  claude --model "$model" -p "分析 $file 的代码质量"
}

# 使用函数
analyze_file main.py
analyze_file utils.js opus
```

```
#!/bin/bash

# 定义带参数的函数
analyze_file() {
  local file=$1
  local model=${2:-sonnet}
  
  echo "分析文件: $file"
  claude --model "$model" -p "分析 $file 的代码质量"
}

# 使用函数
analyze_file main.py
analyze_file utils.js opus
```

###### 示例：带返回值的函数

```
bash复制#!/bin/bash

# 定义带返回值的函数
get_model() {
  local task_type=$1
  
  case $task_type in
    "code_review")
      echo "sonnet"
      ;;
    "generation")
      echo "opus"
      ;;
    *)
      echo "sonnet"
      ;;
  esac
}

# 使用函数
MODEL=$(get_model "code_review")
echo "使用的模型: $MODEL"
```

```
#!/bin/bash

# 定义带返回值的函数
get_model() {
  local task_type=$1
  
  case $task_type in
    "code_review")
      echo "sonnet"
      ;;
    "generation")
      echo "opus"
      ;;
    *)
      echo "sonnet"
      ;;
  esac
}

# 使用函数
MODEL=$(get_model "code_review")
echo "使用的模型: $MODEL"
```

##### 4. 条件判断#

###### 示例：if 语句

```
bash复制#!/bin/bash

# 检查文件是否存在
if [ -f "config.json" ]; then
  echo "配置文件存在"
  claude -p "使用配置文件"
else
  echo "配置文件不存在"
  claude -p "使用默认配置"
fi

# 检查命令执行结果
if claude -p "检查代码质量"; then
  echo "代码质量检查通过"
else
  echo "代码质量检查失败"
  exit 1
fi

# 多条件判断
if [ -f "config.json" ] && [ -f "settings.json" ]; then
  echo "所有配置文件都存在"
elif [ -f "config.json" ]; then
  echo "只有 config.json 存在"
else
  echo "配置文件不存在"
fi
```

```
#!/bin/bash

# 检查文件是否存在
if [ -f "config.json" ]; then
  echo "配置文件存在"
  claude -p "使用配置文件"
else
  echo "配置文件不存在"
  claude -p "使用默认配置"
fi

# 检查命令执行结果
if claude -p "检查代码质量"; then
  echo "代码质量检查通过"
else
  echo "代码质量检查失败"
  exit 1
fi

# 多条件判断
if [ -f "config.json" ] && [ -f "settings.json" ]; then
  echo "所有配置文件都存在"
elif [ -f "config.json" ]; then
  echo "只有 config.json 存在"
else
  echo "配置文件不存在"
fi
```

###### 示例：case 语句

```
bash复制#!/bin/bash

# 使用 case 语句
TASK_TYPE=$1

case $TASK_TYPE in
  "review")
    echo "执行代码审查"
    claude -p "审查代码"
    ;;
  "test")
    echo "执行测试"
    claude -p "运行测试"
    ;;
  "deploy")
    echo "执行部署"
    claude -p "部署应用"
    ;;
  *)
    echo "未知任务类型: $TASK_TYPE"
    echo "支持的任务类型: review, test, deploy"
    exit 1
    ;;
esac
```

```
#!/bin/bash

# 使用 case 语句
TASK_TYPE=$1

case $TASK_TYPE in
  "review")
    echo "执行代码审查"
    claude -p "审查代码"
    ;;
  "test")
    echo "执行测试"
    claude -p "运行测试"
    ;;
  "deploy")
    echo "执行部署"
    claude -p "部署应用"
    ;;
  *)
    echo "未知任务类型: $TASK_TYPE"
    echo "支持的任务类型: review, test, deploy"
    exit 1
    ;;
esac
```

##### 5. 循环结构#

###### 示例：for 循环

```
bash复制#!/bin/bash

# 遍历文件
for file in *.py; do
  echo "处理文件: $file"
  claude -p "优化 $file 的性能"
done

# 遍历数组
projects=("frontend" "backend" "api")
for project in "${projects[@]}"; do
  echo "处理项目: $project"
  claude --add-dir "./$project" -p "分析项目"
done

# 数字循环
for i in {1..5}; do
  echo "执行第 $i 次迭代"
  claude -p "执行任务 $i"
done
```

```
#!/bin/bash

# 遍历文件
for file in *.py; do
  echo "处理文件: $file"
  claude -p "优化 $file 的性能"
done

# 遍历数组
projects=("frontend" "backend" "api")
for project in "${projects[@]}"; do
  echo "处理项目: $project"
  claude --add-dir "./$project" -p "分析项目"
done

# 数字循环
for i in {1..5}; do
  echo "执行第 $i 次迭代"
  claude -p "执行任务 $i"
done
```

###### 示例：while 循环

```
bash复制#!/bin/bash

# 持续监控文件变化
while inotifywait -e modify *.py; do
  echo "检测到文件变化"
  claude -p "重新分析代码"
done

# 读取文件内容
while IFS= read -r line; do
  echo "处理行: $line"
  claude -p "处理: $line"
done < input.txt

# 条件循环
count=0
while [ $count -lt 5 ]; do
  echo "计数: $count"
  claude -p "执行任务 $count"
  ((count++))
done
```

```
#!/bin/bash

# 持续监控文件变化
while inotifywait -e modify *.py; do
  echo "检测到文件变化"
  claude -p "重新分析代码"
done

# 读取文件内容
while IFS= read -r line; do
  echo "处理行: $line"
  claude -p "处理: $line"
done < input.txt

# 条件循环
count=0
while [ $count -lt 5 ]; do
  echo "计数: $count"
  claude -p "执行任务 $count"
  ((count++))
done
```

##### 6. 错误处理#

###### 示例：基本错误处理

```
bash复制#!/bin/bash

# 设置错误处理
set -e

# 检查命令是否成功
if ! claude -p "生成代码"; then
  echo "错误：代码生成失败"
  exit 1
fi

# 使用 trap 捕获错误
trap 'echo "发生错误，退出码: $?"' ERR

claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"
```

```
#!/bin/bash

# 设置错误处理
set -e

# 检查命令是否成功
if ! claude -p "生成代码"; then
  echo "错误：代码生成失败"
  exit 1
fi

# 使用 trap 捕获错误
trap 'echo "发生错误，退出码: $?"' ERR

claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"
```

###### 示例：高级错误处理

```
bash复制#!/bin/bash

# 定义错误处理函数
handle_error() {
  local exit_code=$1
  local line_number=$2
  echo "错误发生在第 $line_number 行，退出码: $exit_code"
  
  # 清理操作
  cleanup
  
  exit $exit_code
}

# 设置错误处理
trap 'handle_error $? $LINENO' ERR

# 定义清理函数
cleanup() {
  echo "执行清理操作..."
  rm -f temp_files/*
}

# 执行任务
claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"

# 清理
cleanup
```

```
#!/bin/bash

# 定义错误处理函数
handle_error() {
  local exit_code=$1
  local line_number=$2
  echo "错误发生在第 $line_number 行，退出码: $exit_code"
  
  # 清理操作
  cleanup
  
  exit $exit_code
}

# 设置错误处理
trap 'handle_error $? $LINENO' ERR

# 定义清理函数
cleanup() {
  echo "执行清理操作..."
  rm -f temp_files/*
}

# 执行任务
claude -p "执行任务1"
claude -p "执行任务2"
claude -p "执行任务3"

# 清理
cleanup
```

#### 实用脚本示例#

##### 1. 代码审查脚本#

```
bash复制#!/bin/bash

# 代码审查脚本
# 用法: ./code_review.sh [文件或目录] [模型]

set -e

# 参数处理
TARGET=${1:-.}
MODEL=${2:-sonnet}

# 检查目标是否存在
if [ ! -e "$TARGET" ]; then
  echo "错误：目标不存在: $TARGET"
  exit 1
fi

# 检查是文件还是目录
if [ -f "$TARGET" ]; then
  echo "审查文件: $TARGET"
  claude --model "$MODEL" -p "审查 $TARGET 的代码质量、安全性和性能"
elif [ -d "$TARGET" ]; then
  echo "审查目录: $TARGET"
  claude --model "$MODEL" --add-dir "$TARGET" -p "审查目录中的所有文件"
else
  echo "错误：不支持的目标类型"
  exit 1
fi
```

```
#!/bin/bash

# 代码审查脚本
# 用法: ./code_review.sh [文件或目录] [模型]

set -e

# 参数处理
TARGET=${1:-.}
MODEL=${2:-sonnet}

# 检查目标是否存在
if [ ! -e "$TARGET" ]; then
  echo "错误：目标不存在: $TARGET"
  exit 1
fi

# 检查是文件还是目录
if [ -f "$TARGET" ]; then
  echo "审查文件: $TARGET"
  claude --model "$MODEL" -p "审查 $TARGET 的代码质量、安全性和性能"
elif [ -d "$TARGET" ]; then
  echo "审查目录: $TARGET"
  claude --model "$MODEL" --add-dir "$TARGET" -p "审查目录中的所有文件"
else
  echo "错误：不支持的目标类型"
  exit 1
fi
```

##### 2. 自动化测试脚本#

```
bash复制#!/bin/bash

# 自动化测试脚本
# 用法: ./auto_test.sh [测试类型]

set -e

# 参数处理
TEST_TYPE=${1:-all}

# 定义测试函数
run_unit_tests() {
  echo "运行单元测试..."
  claude -p "生成单元测试用例"
  claude -p "运行单元测试"
}

run_integration_tests() {
  echo "运行集成测试..."
  claude -p "生成集成测试用例"
  claude -p "运行集成测试"
}

run_e2e_tests() {
  echo "运行端到端测试..."
  claude -p "生成端到端测试用例"
  claude -p "运行端到端测试"
}

# 根据测试类型执行测试
case $TEST_TYPE in
  "unit")
    run_unit_tests
    ;;
  "integration")
    run_integration_tests
    ;;
  "e2e")
    run_e2e_tests
    ;;
  "all")
    run_unit_tests
    run_integration_tests
    run_e2e_tests
    ;;
  *)
    echo "错误：未知测试类型: $TEST_TYPE"
    echo "支持的测试类型: unit, integration, e2e, all"
    exit 1
    ;;
esac

echo "所有测试完成"
```

```
#!/bin/bash

# 自动化测试脚本
# 用法: ./auto_test.sh [测试类型]

set -e

# 参数处理
TEST_TYPE=${1:-all}

# 定义测试函数
run_unit_tests() {
  echo "运行单元测试..."
  claude -p "生成单元测试用例"
  claude -p "运行单元测试"
}

run_integration_tests() {
  echo "运行集成测试..."
  claude -p "生成集成测试用例"
  claude -p "运行集成测试"
}

run_e2e_tests() {
  echo "运行端到端测试..."
  claude -p "生成端到端测试用例"
  claude -p "运行端到端测试"
}

# 根据测试类型执行测试
case $TEST_TYPE in
  "unit")
    run_unit_tests
    ;;
  "integration")
    run_integration_tests
    ;;
  "e2e")
    run_e2e_tests
    ;;
  "all")
    run_unit_tests
    run_integration_tests
    run_e2e_tests
    ;;
  *)
    echo "错误：未知测试类型: $TEST_TYPE"
    echo "支持的测试类型: unit, integration, e2e, all"
    exit 1
    ;;
esac

echo "所有测试完成"
```

##### 3. 文档生成脚本#

```
bash复制#!/bin/bash

# 文档生成脚本
# 用法: ./generate_docs.sh [输出目录]

set -e

# 参数处理
OUTPUT_DIR=${1:-./docs}

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 提取函数文档
echo "提取函数文档..."
claude -p "提取所有函数的文档注释" --output-format json > functions.json

# 提取类文档
echo "提取类文档..."
claude -p "提取所有类的文档注释" --output-format json > classes.json

# 生成 Markdown 文档
echo "生成 Markdown 文档..."
claude -p "根据提取的信息生成 Markdown 文档" \
  --input-format json \
  --output-format markdown \
  > "$OUTPUT_DIR/API.md"

# 生成 HTML 文档
echo "生成 HTML 文档..."
claude -p "根据提取的信息生成 HTML 文档" \
  --input-format json \
  --output-format html \
  > "$OUTPUT_DIR/API.html"

echo "文档生成完成: $OUTPUT_DIR"
```

```
#!/bin/bash

# 文档生成脚本
# 用法: ./generate_docs.sh [输出目录]

set -e

# 参数处理
OUTPUT_DIR=${1:-./docs}

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 提取函数文档
echo "提取函数文档..."
claude -p "提取所有函数的文档注释" --output-format json > functions.json

# 提取类文档
echo "提取类文档..."
claude -p "提取所有类的文档注释" --output-format json > classes.json

# 生成 Markdown 文档
echo "生成 Markdown 文档..."
claude -p "根据提取的信息生成 Markdown 文档" \
  --input-format json \
  --output-format markdown \
  > "$OUTPUT_DIR/API.md"

# 生成 HTML 文档
echo "生成 HTML 文档..."
claude -p "根据提取的信息生成 HTML 文档" \
  --input-format json \
  --output-format html \
  > "$OUTPUT_DIR/API.html"

echo "文档生成完成: $OUTPUT_DIR"
```

##### 4. 项目分析脚本#

```
bash复制#!/bin/bash

# 项目分析脚本
# 用法: ./analyze_project.sh [项目目录] [输出格式]

set -e

# 参数处理
PROJECT_DIR=${1:-.}
OUTPUT_FORMAT=${2:-json}

# 检查项目目录
if [ ! -d "$PROJECT_DIR" ]; then
  echo "错误：项目目录不存在: $PROJECT_DIR"
  exit 1
fi

# 分析项目结构
echo "分析项目结构..."
claude --add-dir "$PROJECT_DIR" \
       -p "分析项目结构、代码质量和潜在问题" \
       --output-format "$OUTPUT_FORMAT" \
       > "project_analysis.$OUTPUT_FORMAT"

# 生成报告
echo "生成分析报告..."
claude -p "根据分析结果生成详细的报告" \
  --input-format "$OUTPUT_FORMAT" \
  --output-format markdown \
  > "project_report.md"

echo "项目分析完成"
echo "分析结果: project_analysis.$OUTPUT_FORMAT"
echo "分析报告: project_report.md"
```

```
#!/bin/bash

# 项目分析脚本
# 用法: ./analyze_project.sh [项目目录] [输出格式]

set -e

# 参数处理
PROJECT_DIR=${1:-.}
OUTPUT_FORMAT=${2:-json}

# 检查项目目录
if [ ! -d "$PROJECT_DIR" ]; then
  echo "错误：项目目录不存在: $PROJECT_DIR"
  exit 1
fi

# 分析项目结构
echo "分析项目结构..."
claude --add-dir "$PROJECT_DIR" \
       -p "分析项目结构、代码质量和潜在问题" \
       --output-format "$OUTPUT_FORMAT" \
       > "project_analysis.$OUTPUT_FORMAT"

# 生成报告
echo "生成分析报告..."
claude -p "根据分析结果生成详细的报告" \
  --input-format "$OUTPUT_FORMAT" \
  --output-format markdown \
  > "project_report.md"

echo "项目分析完成"
echo "分析结果: project_analysis.$OUTPUT_FORMAT"
echo "分析报告: project_report.md"
```

##### 5. 批量处理脚本#

```
bash复制#!/bin/bash

# 批量处理脚本
# 用法: ./batch_process.sh [文件模式] [处理类型]

set -e

# 参数处理
FILE_PATTERN=${1:-*.py}
PROCESS_TYPE=${2:-optimize}

# 定义处理函数
optimize_files() {
  for file in $FILE_PATTERN; do
    echo "优化文件: $file"
    claude -p "优化 $file 的性能" > "${file%.py}.optimized.py"
  done
}

review_files() {
  for file in $FILE_PATTERN; do
    echo "审查文件: $file"
    claude -p "审查 $file 的代码质量" > "${file%.py}.review.md"
  done
}

refactor_files() {
  for file in $FILE_PATTERN; do
    echo "重构文件: $file"
    claude -p "重构 $file 的代码结构" > "${file%.py}.refactored.py"
  done
}

# 根据处理类型执行处理
case $PROCESS_TYPE in
  "optimize")
    optimize_files
    ;;
  "review")
    review_files
    ;;
  "refactor")
    refactor_files
    ;;
  *)
    echo "错误：未知处理类型: $PROCESS_TYPE"
    echo "支持的处理类型: optimize, review, refactor"
    exit 1
    ;;
esac

echo "批量处理完成"
```

```
#!/bin/bash

# 批量处理脚本
# 用法: ./batch_process.sh [文件模式] [处理类型]

set -e

# 参数处理
FILE_PATTERN=${1:-*.py}
PROCESS_TYPE=${2:-optimize}

# 定义处理函数
optimize_files() {
  for file in $FILE_PATTERN; do
    echo "优化文件: $file"
    claude -p "优化 $file 的性能" > "${file%.py}.optimized.py"
  done
}

review_files() {
  for file in $FILE_PATTERN; do
    echo "审查文件: $file"
    claude -p "审查 $file 的代码质量" > "${file%.py}.review.md"
  done
}

refactor_files() {
  for file in $FILE_PATTERN; do
    echo "重构文件: $file"
    claude -p "重构 $file 的代码结构" > "${file%.py}.refactored.py"
  done
}

# 根据处理类型执行处理
case $PROCESS_TYPE in
  "optimize")
    optimize_files
    ;;
  "review")
    review_files
    ;;
  "refactor")
    refactor_files
    ;;
  *)
    echo "错误：未知处理类型: $PROCESS_TYPE"
    echo "支持的处理类型: optimize, review, refactor"
    exit 1
    ;;
esac

echo "批量处理完成"
```

#### 脚本最佳实践#

##### 1. 脚本组织#

- 模块化：将复杂脚本拆分成多个函数
- 配置化：使用配置文件管理参数
- 文档化：为脚本添加详细的注释和文档

###### 示例：模块化脚本

```
bash复制#!/bin/bash

# 导入配置文件
source config.sh

# 导入函数库
source lib/functions.sh

# 主函数
main() {
  initialize
  execute_tasks
  cleanup
}

# 执行主函数
main
```

```
#!/bin/bash

# 导入配置文件
source config.sh

# 导入函数库
source lib/functions.sh

# 主函数
main() {
  initialize
  execute_tasks
  cleanup
}

# 执行主函数
main
```

##### 2. 错误处理#

- 设置错误处理：使用 set -e 和 trap
- 检查返回值：检查命令的退出码
- 提供清晰的错误信息：为用户提供有用的错误信息

```
set -e
```

```
trap
```

###### 示例：完善的错误处理

```
bash复制#!/bin/bash

# 设置错误处理
set -e
set -u
set -o pipefail

# 定义错误处理函数
error_handler() {
  local exit_code=$1
  local line_number=$2
  echo "错误: 脚本在第 $line_number 行失败，退出码: $exit_code"
  cleanup
  exit $exit_code
}

# 设置错误处理
trap 'error_handler $? $LINENO' ERR

# 定义清理函数
cleanup() {
  echo "执行清理操作..."
  rm -f temp_files/*
}

# 执行任务
main
```

```
#!/bin/bash

# 设置错误处理
set -e
set -u
set -o pipefail

# 定义错误处理函数
error_handler() {
  local exit_code=$1
  local line_number=$2
  echo "错误: 脚本在第 $line_number 行失败，退出码: $exit_code"
  cleanup
  exit $exit_code
}

# 设置错误处理
trap 'error_handler $? $LINENO' ERR

# 定义清理函数
cleanup() {
  echo "执行清理操作..."
  rm -f temp_files/*
}

# 执行任务
main
```

##### 3. 日志记录#

- 记录执行过程：记录脚本的执行过程
- 记录错误信息：记录错误和警告信息
- 记录性能指标：记录执行时间和资源使用情况

###### 示例：日志记录

```
bash复制#!/bin/bash

# 定义日志函数
log() {
  local level=$1
  shift
  local message="$@"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "[$timestamp] [$level] $message" >> script.log
}

# 使用日志函数
log INFO "脚本开始执行"
log INFO "执行任务1"
claude -p "执行任务1"
log INFO "任务1完成"
log INFO "脚本执行完成"
```

```
#!/bin/bash

# 定义日志函数
log() {
  local level=$1
  shift
  local message="$@"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "[$timestamp] [$level] $message" >> script.log
}

# 使用日志函数
log INFO "脚本开始执行"
log INFO "执行任务1"
claude -p "执行任务1"
log INFO "任务1完成"
log INFO "脚本执行完成"
```

##### 4. 性能优化#

- 并行处理：使用后台执行和 wait 提高效率
- 缓存结果：避免重复执行相同的命令
- 增量处理：只处理变化的部分

###### 示例：性能优化

```
bash复制#!/bin/bash

# 并行处理多个文件
for file in *.py; do
  claude -p "分析 $file" > "${file%.py}.analysis.json" &
done
wait

# 使用缓存
CACHE_FILE="analysis.cache"
if [ -f "$CACHE_FILE" ]; then
  log INFO "使用缓存结果"
  cat "$CACHE_FILE"
else
  claude -p "分析项目" > "$CACHE_FILE"
fi
```

```
#!/bin/bash

# 并行处理多个文件
for file in *.py; do
  claude -p "分析 $file" > "${file%.py}.analysis.json" &
done
wait

# 使用缓存
CACHE_FILE="analysis.cache"
if [ -f "$CACHE_FILE" ]; then
  log INFO "使用缓存结果"
  cat "$CACHE_FILE"
else
  claude -p "分析项目" > "$CACHE_FILE"
fi
```

#### 总结#

脚本编写是自动化 Claude Code 任务的关键技能。通过掌握 Bash 脚本的基础知识（变量、函数、条件判断、循环、错误处理）和实用脚本示例，您可以创建强大、可重用的自动化工具。

记住以下要点：

True. 从简单开始：先编写简单的脚本，逐步增加复杂性
True. 注重实践：通过实际项目练习脚本编写
True. 遵循最佳实践：使用错误处理、日志记录和性能优化
True. 持续改进：不断优化和改进您的脚本

在接下来的章节中，我们将学习如何将这些脚本集成到 CI/CD 流程中，以及如何进行批处理操作和实际工作流应用。

---

## 3 CI/CD 集成

**URL**: https://claudecode.tangshuang.net/course/8.3%20CI%2FCD%20%E9%9B%86%E6%88%90

持续集成（CI）和持续部署（CD）是现代软件开发流程的核心组成部分。将 Claude Code 集成到 CI/CD 流程中，可以自动化代码审查、测试、文档生成等任务，显著提高开发效率和代码质量。

#### CI/CD 集成概述#

##### 为什么集成 Claude Code 到 CI/CD#

将 Claude Code 集成到 CI/CD 流程中可以带来以下好处：

- 自动化代码审查：在每次提交时自动进行代码审查
- 智能测试生成：自动生成测试用例和测试代码
- 文档自动生成：自动生成和更新项目文档
- 代码质量检查：自动检查代码质量、安全性和性能问题
- 减少人工干预：减少重复性的人工任务
- 提高开发效率：加快开发和部署流程

##### CI/CD 集成的挑战#

在集成 Claude Code 到 CI/CD 时，需要考虑以下挑战：

- 认证配置：需要配置 Anthropic API 认证
- 环境变量管理：安全地管理敏感信息
- 错误处理：处理 Claude Code 执行失败的情况
- 性能优化：优化 CI/CD 流程的执行时间
- 成本控制：控制 API 调用成本
- 结果展示：将 Claude Code 的结果展示在 CI/CD 界面中

#### GitHub Actions 集成#

##### 1. 基本配置#

###### 示例：GitHub Actions 工作流

```
yaml复制name: Claude Code CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Run code review
        run: |
          claude -p "审查最近的代码变更" \
            --output-format json \
            > review.json

      - name: Upload review results
        uses: actions/upload-artifact@v3
        with:
          name: code-review
          path: review.json
```

```
name: Claude Code CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Run code review
        run: |
          claude -p "审查最近的代码变更" \
            --output-format json \
            > review.json

      - name: Upload review results
        uses: actions/upload-artifact@v3
        with:
          name: code-review
          path: review.json
```

##### 2. 代码审查工作流#

###### 示例：自动代码审查

```
yaml复制name: Automated Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Get changed files
        id: changed-files
        run: |
          git diff --name-only origin/main...HEAD > changed_files.txt
          echo "files=$(cat changed_files.txt)" >> $GITHUB_OUTPUT

      - name: Review changed files
        run: |
          claude -p "审查以下文件的代码质量、安全性和性能：" \
            --input-format text \
            --output-format json \
            < changed_files.txt \
            > review.json

      - name: Post review as comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const review = JSON.parse(fs.readFileSync('review.json', 'utf8'));
            
            let comment = '## 代码审查结果\n\n';
            comment += `**审查时间**: ${new Date().toISOString()}\n\n`;
            comment += '### 审查意见\n\n';
            comment += review.content || '无审查意见';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

```
name: Automated Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Get changed files
        id: changed-files
        run: |
          git diff --name-only origin/main...HEAD > changed_files.txt
          echo "files=$(cat changed_files.txt)" >> $GITHUB_OUTPUT

      - name: Review changed files
        run: |
          claude -p "审查以下文件的代码质量、安全性和性能：" \
            --input-format text \
            --output-format json \
            < changed_files.txt \
            > review.json

      - name: Post review as comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const review = JSON.parse(fs.readFileSync('review.json', 'utf8'));
            
            let comment = '## 代码审查结果\n\n';
            comment += `**审查时间**: ${new Date().toISOString()}\n\n`;
            comment += '### 审查意见\n\n';
            comment += review.content || '无审查意见';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

##### 3. 测试生成和执行#

###### 示例：自动测试生成

```
yaml复制name: Automated Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  generate-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Generate unit tests
        run: |
          claude -p "为所有 Python 文件生成单元测试" \
            --output-format json \
            > unit_tests.json

      - name: Generate integration tests
        run: |
          claude -p "为 API 端点生成集成测试" \
            --output-format json \
            > integration_tests.json

      - name: Save generated tests
        uses: actions/upload-artifact@v3
        with:
          name: generated-tests
          path: |
            unit_tests.json
            integration_tests.json

  run-tests:
    needs: generate-tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download generated tests
        uses: actions/download-artifact@v3
        with:
          name: generated-tests

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install pytest pytest-cov

      - name: Run unit tests
        run: |
          claude -p "运行单元测试" \
            --input-format json \
            < unit_tests.json

      - name: Run integration tests
        run: |
          claude -p "运行集成测试" \
            --input-format json \
            < integration_tests.json

      - name: Generate coverage report
        run: |
          claude -p "生成测试覆盖率报告" \
            --output-format json \
            > coverage.json

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage.json
```

```
name: Automated Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  generate-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Generate unit tests
        run: |
          claude -p "为所有 Python 文件生成单元测试" \
            --output-format json \
            > unit_tests.json

      - name: Generate integration tests
        run: |
          claude -p "为 API 端点生成集成测试" \
            --output-format json \
            > integration_tests.json

      - name: Save generated tests
        uses: actions/upload-artifact@v3
        with:
          name: generated-tests
          path: |
            unit_tests.json
            integration_tests.json

  run-tests:
    needs: generate-tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download generated tests
        uses: actions/download-artifact@v3
        with:
          name: generated-tests

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install pytest pytest-cov

      - name: Run unit tests
        run: |
          claude -p "运行单元测试" \
            --input-format json \
            < unit_tests.json

      - name: Run integration tests
        run: |
          claude -p "运行集成测试" \
            --input-format json \
            < integration_tests.json

      - name: Generate coverage report
        run: |
          claude -p "生成测试覆盖率报告" \
            --output-format json \
            > coverage.json

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage.json
```

##### 4. 文档生成工作流#

###### 示例：自动文档生成

```
yaml复制name: Documentation Generation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Extract API documentation
        run: |
          claude -p "提取所有 API 端点的文档" \
            --output-format json \
            > api_docs.json

      - name: Generate Markdown documentation
        run: |
          claude -p "根据提取的信息生成 Markdown 文档" \
            --input-format json \
            --output-format markdown \
            > API.md

      - name: Generate HTML documentation
        run: |
          claude -p "根据提取的信息生成 HTML 文档" \
            --input-format json \
            --output-format html \
            > API.html

      - name: Commit documentation
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add API.md API.html
          git diff --quiet && git diff --staged --quiet || git commit -m "Update documentation"
          git push
```

```
name: Documentation Generation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude login --api-key $ANTHROPIC_API_KEY

      - name: Extract API documentation
        run: |
          claude -p "提取所有 API 端点的文档" \
            --output-format json \
            > api_docs.json

      - name: Generate Markdown documentation
        run: |
          claude -p "根据提取的信息生成 Markdown 文档" \
            --input-format json \
            --output-format markdown \
            > API.md

      - name: Generate HTML documentation
        run: |
          claude -p "根据提取的信息生成 HTML 文档" \
            --input-format json \
            --output-format html \
            > API.html

      - name: Commit documentation
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add API.md API.html
          git diff --quiet && git diff --staged --quiet || git commit -m "Update documentation"
          git push
```

#### GitLab CI 集成#

##### 1. 基本配置#

###### 示例：GitLab CI 配置

```
yaml复制# .gitlab-ci.yml

stages:
  - review
  - test
  - deploy

variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY

code-review:
  stage: review
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "审查最近的代码变更" --output-format json > review.json
  artifacts:
    paths:
      - review.json
    expire_in: 1 week

automated-testing:
  stage: test
  image: python:3.10
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
    - pip install pytest
  script:
    - claude -p "生成测试用例" --output-format json > tests.json
    - claude -p "运行测试" --input-format json < tests.json
  artifacts:
    paths:
      - tests.json
    expire_in: 1 week

deploy:
  stage: deploy
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "部署应用到生产环境"
  only:
    - main
```

```
# .gitlab-ci.yml

stages:
  - review
  - test
  - deploy

variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY

code-review:
  stage: review
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "审查最近的代码变更" --output-format json > review.json
  artifacts:
    paths:
      - review.json
    expire_in: 1 week

automated-testing:
  stage: test
  image: python:3.10
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
    - pip install pytest
  script:
    - claude -p "生成测试用例" --output-format json > tests.json
    - claude -p "运行测试" --input-format json < tests.json
  artifacts:
    paths:
      - tests.json
    expire_in: 1 week

deploy:
  stage: deploy
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "部署应用到生产环境"
  only:
    - main
```

##### 2. 高级工作流#

###### 示例：多阶段工作流

```
yaml复制# .gitlab-ci.yml

stages:
  - analyze
  - review
  - test
  - document
  - deploy

variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY
  PROJECT_DIR: ./src

code-analysis:
  stage: analyze
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude --add-dir $PROJECT_DIR -p "分析代码质量" --output-format json > analysis.json
  artifacts:
    paths:
      - analysis.json
    expire_in: 1 week

code-review:
  stage: review
  image: node:18
  dependencies:
    - code-analysis
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "根据分析结果进行代码审查" --input-format json < analysis.json > review.json
  artifacts:
    paths:
      - review.json
    expire_in: 1 week

automated-testing:
  stage: test
  image: python:3.10
  dependencies:
    - code-review
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
    - pip install pytest pytest-cov
  script:
    - claude -p "生成测试用例" --output-format json > tests.json
    - claude -p "运行测试" --input-format json < tests.json
    - claude -p "生成覆盖率报告" --output-format json > coverage.json
  artifacts:
    paths:
      - tests.json
      - coverage.json
    expire_in: 1 week

documentation:
  stage: document
  image: node:18
  dependencies:
    - automated-testing
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "生成项目文档" --output-format markdown > README.md
    - claude -p "生成 API 文档" --output-format html > API.html
  artifacts:
    paths:
      - README.md
      - API.html
    expire_in: 1 week

deploy:
  stage: deploy
  image: node:18
  dependencies:
    - documentation
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "部署应用到生产环境"
  only:
    - main
```

```
# .gitlab-ci.yml

stages:
  - analyze
  - review
  - test
  - document
  - deploy

variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY
  PROJECT_DIR: ./src

code-analysis:
  stage: analyze
  image: node:18
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude --add-dir $PROJECT_DIR -p "分析代码质量" --output-format json > analysis.json
  artifacts:
    paths:
      - analysis.json
    expire_in: 1 week

code-review:
  stage: review
  image: node:18
  dependencies:
    - code-analysis
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "根据分析结果进行代码审查" --input-format json < analysis.json > review.json
  artifacts:
    paths:
      - review.json
    expire_in: 1 week

automated-testing:
  stage: test
  image: python:3.10
  dependencies:
    - code-review
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
    - pip install pytest pytest-cov
  script:
    - claude -p "生成测试用例" --output-format json > tests.json
    - claude -p "运行测试" --input-format json < tests.json
    - claude -p "生成覆盖率报告" --output-format json > coverage.json
  artifacts:
    paths:
      - tests.json
      - coverage.json
    expire_in: 1 week

documentation:
  stage: document
  image: node:18
  dependencies:
    - automated-testing
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "生成项目文档" --output-format markdown > README.md
    - claude -p "生成 API 文档" --output-format html > API.html
  artifacts:
    paths:
      - README.md
      - API.html
    expire_in: 1 week

deploy:
  stage: deploy
  image: node:18
  dependencies:
    - documentation
  before_script:
    - npm install -g @anthropic-ai/claude-code
    - claude login --api-key $ANTHROPIC_API_KEY
  script:
    - claude -p "部署应用到生产环境"
  only:
    - main
```

#### Jenkins 集成#

##### 1. 基本配置#

###### 示例：Jenkins Pipeline

```
groovy复制pipeline {
    agent any
    
    environment {
        ANTHROPIC_API_KEY = credentials('anthropic-api-key')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Claude Code') {
            steps {
                sh 'npm install -g @anthropic-ai/claude-code'
            }
        }
        
        stage('Configure') {
            steps {
                sh 'claude login --api-key $ANTHROPIC_API_KEY'
            }
        }
        
        stage('Code Review') {
            steps {
                sh '''
                    claude -p "审查最近的代码变更" \
                        --output-format json \
                        > review.json
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                sh '''
                    claude -p "生成测试用例" \
                        --output-format json \
                        > tests.json
                    
                    claude -p "运行测试" \
                        --input-format json \
                        < tests.json
                '''
            }
        }
        
        stage('Generate Documentation') {
            steps {
                sh '''
                    claude -p "生成项目文档" \
                        --output-format markdown \
                        > README.md
                '''
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: '*.json,*.md', fingerprint: true
        }
    }
}
```

```
pipeline {
    agent any
    
    environment {
        ANTHROPIC_API_KEY = credentials('anthropic-api-key')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Claude Code') {
            steps {
                sh 'npm install -g @anthropic-ai/claude-code'
            }
        }
        
        stage('Configure') {
            steps {
                sh 'claude login --api-key $ANTHROPIC_API_KEY'
            }
        }
        
        stage('Code Review') {
            steps {
                sh '''
                    claude -p "审查最近的代码变更" \
                        --output-format json \
                        > review.json
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                sh '''
                    claude -p "生成测试用例" \
                        --output-format json \
                        > tests.json
                    
                    claude -p "运行测试" \
                        --input-format json \
                        < tests.json
                '''
            }
        }
        
        stage('Generate Documentation') {
            steps {
                sh '''
                    claude -p "生成项目文档" \
                        --output-format markdown \
                        > README.md
                '''
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: '*.json,*.md', fingerprint: true
        }
    }
}
```

##### 2. 高级配置#

###### 示例：多分支 Pipeline

```
groovy复制pipeline {
    agent any
    
    environment {
        ANTHROPIC_API_KEY = credentials('anthropic-api-key')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Claude Code') {
            steps {
                sh 'npm install -g @anthropic-ai/claude-code'
            }
        }
        
        stage('Configure') {
            steps {
                sh 'claude login --api-key $ANTHROPIC_API_KEY'
            }
        }
        
        stage('Analyze') {
            steps {
                sh '''
                    claude --add-dir ./src \
                        -p "分析代码质量" \
                        --output-format json \
                        > analysis.json
                '''
            }
        }
        
        stage('Review') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                sh '''
                    claude -p "进行代码审查" \
                        --input-format json \
                        < analysis.json \
                        > review.json
                '''
            }
        }
        
        stage('Test') {
            steps {
                sh '''
                    claude -p "生成并运行测试" \
                        --output-format json \
                        > test_results.json
                '''
            }
        }
        
        stage('Document') {
            steps {
                sh '''
                    claude -p "生成文档" \
                        --output-format markdown \
                        > docs.md
                '''
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh 'claude -p "部署应用"'
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: '*.json,*.md', fingerprint: true
        }
        success {
            echo 'Pipeline 执行成功'
        }
        failure {
            echo 'Pipeline 执行失败'
        }
    }
}
```

```
pipeline {
    agent any
    
    environment {
        ANTHROPIC_API_KEY = credentials('anthropic-api-key')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Claude Code') {
            steps {
                sh 'npm install -g @anthropic-ai/claude-code'
            }
        }
        
        stage('Configure') {
            steps {
                sh 'claude login --api-key $ANTHROPIC_API_KEY'
            }
        }
        
        stage('Analyze') {
            steps {
                sh '''
                    claude --add-dir ./src \
                        -p "分析代码质量" \
                        --output-format json \
                        > analysis.json
                '''
            }
        }
        
        stage('Review') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                sh '''
                    claude -p "进行代码审查" \
                        --input-format json \
                        < analysis.json \
                        > review.json
                '''
            }
        }
        
        stage('Test') {
            steps {
                sh '''
                    claude -p "生成并运行测试" \
                        --output-format json \
                        > test_results.json
                '''
            }
        }
        
        stage('Document') {
            steps {
                sh '''
                    claude -p "生成文档" \
                        --output-format markdown \
                        > docs.md
                '''
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh 'claude -p "部署应用"'
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: '*.json,*.md', fingerprint: true
        }
        success {
            echo 'Pipeline 执行成功'
        }
        failure {
            echo 'Pipeline 执行失败'
        }
    }
}
```

#### 最佳实践#

##### 1. 安全性#

- 使用 Secrets：使用 CI/CD 平台的 Secrets 功能存储 API 密钥
- 环境变量：使用环境变量传递敏感信息
- 权限控制：限制 Claude Code 的权限范围
- 审计日志：记录所有 Claude Code 的调用

###### 示例：安全配置

```
yaml复制# GitHub Actions
env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

# GitLab CI
variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY

# Jenkins
environment {
    ANTHROPIC_API_KEY = credentials('anthropic-api-key')
}
```

```
# GitHub Actions
env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

# GitLab CI
variables:
  ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY

# Jenkins
environment {
    ANTHROPIC_API_KEY = credentials('anthropic-api-key')
}
```

##### 2. 性能优化#

- 并行执行：并行执行独立的任务
- 缓存依赖：缓存依赖项以减少安装时间
- 增量处理：只处理变更的文件
- 结果缓存：缓存 Claude Code 的结果

###### 示例：性能优化

```
yaml复制# GitHub Actions - 并行执行
jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - name: Code review
        run: claude -p "审查代码"
  
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: claude -p "运行测试"
```

```
# GitHub Actions - 并行执行
jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - name: Code review
        run: claude -p "审查代码"
  
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: claude -p "运行测试"
```

##### 3. 错误处理#

- 失败重试：配置失败重试机制
- 错误通知：配置错误通知
- 回滚机制：配置回滚机制
- 日志记录：记录详细的日志

###### 示例：错误处理

```
yaml复制# GitHub Actions - 失败重试
- name: Run Claude Code
  uses: nick-invision/retry@v2
  with:
    timeout_minutes: 10
    max_attempts: 3
    command: claude -p "执行任务"
```

```
# GitHub Actions - 失败重试
- name: Run Claude Code
  uses: nick-invision/retry@v2
  with:
    timeout_minutes: 10
    max_attempts: 3
    command: claude -p "执行任务"
```

##### 4. 成本控制#

- 限制调用次数：限制 Claude Code 的调用次数
- 使用缓存：使用缓存减少重复调用
- 优化提示：优化提示词以减少 token 使用
- 监控成本：监控 API 调用成本

###### 示例：成本控制

```
yaml复制# 使用缓存
- name: Check cache
  id: cache
  uses: actions/cache@v3
  with:
    path: ~/.claude
    key: ${{ runner.os }}-claude-${{ hashFiles('**/package.json') }}

- name: Run Claude Code
  if: steps.cache.outputs.cache-hit != 'true'
  run: claude -p "执行任务"
```

```
# 使用缓存
- name: Check cache
  id: cache
  uses: actions/cache@v3
  with:
    path: ~/.claude
    key: ${{ runner.os }}-claude-${{ hashFiles('**/package.json') }}

- name: Run Claude Code
  if: steps.cache.outputs.cache-hit != 'true'
  run: claude -p "执行任务"
```

#### 常见问题#

##### Q: 如何处理认证失败？#

A: 检查 API 密钥是否正确配置，确保使用 CI/CD 平台的 Secrets 功能存储密钥。

##### Q: 如何优化 CI/CD 流程的执行时间？#

A: 使用并行执行、缓存依赖、增量处理等技术优化执行时间。

##### Q: 如何处理 Claude Code 执行失败？#

A: 配置失败重试机制、错误通知和回滚机制。

##### Q: 如何控制 API 调用成本？#

A: 限制调用次数、使用缓存、优化提示词、监控成本。

#### 总结#

将 Claude Code 集成到 CI/CD 流程中可以显著提高开发效率和代码质量。通过掌握 GitHub Actions、GitLab CI 和 Jenkins 的集成方法，以及最佳实践（安全性、性能优化、错误处理、成本控制），您可以构建强大、可靠的 CI/CD 流程。

记住以下要点：

True. 从简单开始：先实现基本的集成，逐步增加复杂性
True. 注重安全：使用 Secrets 和环境变量保护敏感信息
True. 优化性能：使用并行执行和缓存提高效率
True. 控制成本：监控和控制 API 调用成本
True. 持续改进：不断优化和改进 CI/CD 流程

在接下来的章节中，我们将学习批处理操作和实际工作流示例。

---

# 第 9 章

## 1 键盘快捷键

**URL**: https://claudecode.tangshuang.net/course/9.1%20%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE

Claude Code 提供了一套丰富的键盘快捷键系统，帮助您在交互式会话中更高效地完成各种操作。掌握这些快捷键可以显著提升您的开发效率，减少鼠标操作，让您专注于代码和思考。

#### 常规控制快捷键#

这些快捷键适用于大多数交互场景，帮助您控制会话流程和终端显示。

```
Ctrl+C
```

```
Ctrl+D
```

```
Ctrl+L
```

```
Ctrl+O
```

```
Ctrl+R
```

```
Ctrl+V
```

```
Alt+V
```

```
Up/Down arrows
```

```
Esc
```

```
Esc
```

```
Tab
```

```
Shift+Tab
```

```
Alt+M
```

#### 快速命令快捷键#

这些快捷键可以帮助您快速执行特定类型的命令，无需完整输入。

```
#
```

```
/
```

```
!
```

```
@
```

#### 代码编辑快捷键#

这些快捷键在代码编辑模式下特别有用，帮助您更高效地处理代码。

```
Ctrl+Left/Right arrows
```

```
Ctrl+Home/End
```

```
Ctrl+Backspace
```

```
Ctrl+Delete
```

```
Alt+Up/Down arrows
```

```
Ctrl+Alt+Up/Down arrows
```

```
Ctrl+Shift+K
```

#### 多光标编辑快捷键#

Claude Code 支持多光标编辑，允许您同时在多个位置进行编辑。

```
Alt+Click
```

```
Ctrl+Alt+Up/Down arrows
```

```
Ctrl+Shift+L
```

```
Esc
```

#### 导航快捷键#

这些快捷键帮助您在长对话和代码中快速导航。

```
Ctrl+F
```

```
Ctrl+G
```

```
Ctrl+Shift+G
```

```
Ctrl+U
```

```
Ctrl+D
```

```
PageUp/PageDown
```

#### 使用示例#

##### 取消当前操作#

当您想要停止正在运行的命令或代码生成时：

```
bash复制正在生成代码...
^C  # 按 Ctrl+C 取消
```

```
正在生成代码...
^C  # 按 Ctrl+C 取消
```

##### 清除屏幕#

清除终端屏幕但保留对话历史：

```
bash复制# 按 Ctrl+L 清除屏幕
[屏幕被清除，对话历史保持不变]
```

```
# 按 Ctrl+L 清除屏幕
[屏幕被清除，对话历史保持不变]
```

##### 搜索命令历史#

使用 Ctrl+R 反向搜索历史命令：

```
bash复制(reverse-i-search)`claude`: claude --model claude-sonnet-4-5
```

```
(reverse-i-search)`claude`: claude --model claude-sonnet-4-5
```

##### 快速执行 Bash 命令#

使用 ! 前缀直接执行 shell 命令：

```
!
```

```
bash复制!ls -la
```

```
!ls -la
```

##### 快速添加文件到内存#

使用 # 前缀快速将文件内容添加到会话内存：

```
#
```

```
bash复制# main.py
```

```
# main.py
```

#### 最佳实践#

##### 1. 学习常用快捷键#

优先掌握以下高频使用的快捷键：

- Ctrl+C：取消操作
- Ctrl+L：清除屏幕
- Ctrl+R：搜索历史
- Tab：切换思考模式
- !：执行 shell 命令

```
Ctrl+C
```

```
Ctrl+L
```

```
Ctrl+R
```

```
Tab
```

```
!
```

##### 2. 自定义快捷键#

如果默认快捷键不符合您的习惯，可以通过 /config 命令自定义快捷键设置。

```
/config
```

##### 3. 多光标编辑#

在处理大量重复代码时，多光标编辑可以显著提高效率。尝试使用 Ctrl+Shift+L 选择所有匹配项并同时编辑。

```
Ctrl+Shift+L
```

##### 结合斜杠命令#

将快捷键与斜杠命令结合使用可以实现更复杂的操作。例如：

```
bash复制/clear  # 清除对话历史
/config # 打开配置界面
```

```
/clear  # 清除对话历史
/config # 打开配置界面
```

##### 5. 键盘导航#

尽量使用键盘导航代替鼠标操作，减少手离开键盘的次数，提高整体效率。

#### 故障排除#

##### 问题：快捷键不工作#

- 终端模拟器不支持某些快捷键
- 快捷键被其他应用程序拦截
- 自定义配置覆盖了默认快捷键

True. 检查终端模拟器的快捷键设置
True. 关闭可能拦截快捷键的应用程序
True. 重置 Claude Code 的快捷键配置

##### 问题：多光标编辑不工作#

- 未进入多光标模式
- 终端不支持多光标编辑

True. 确保使用支持多光标编辑的终端（如 iTerm2、Windows Terminal）
True. 检查是否正确触发了多光标快捷键

##### 问题：斜杠命令补全不工作#

- 未在输入行首使用 /
- 斜杠命令缓存未加载

```
/
```

True. 确保在输入行首使用 /
True. 尝试重新启动 Claude Code 会话

```
/
```

通过掌握这些键盘快捷键，您将能够更高效地与 Claude Code 交互，减少重复操作，专注于创造性的编程工作。建议定期练习这些快捷键，直到它们成为您的自然习惯。

---

## 2 多行输入

**URL**: https://claudecode.tangshuang.net/course/9.2%20%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5

Claude Code 提供了多种灵活的多行输入方式，让您可以轻松编写复杂的提示、代码片段和测试用例。无论您使用哪种终端，都能找到适合自己的多行输入方法。

#### 多行输入方法#

##### 1. 快速转义（通用方法）#

这是适用于所有终端的最通用方法，无需任何配置。在行尾输入反斜杠 \ 然后按 Enter 键：

```
\
```

```
bash复制这是一个多行输入的例子，\
第二行继续，\
第三行结束。
```

```
这是一个多行输入的例子，\
第二行继续，\
第三行结束。
```

```
bash复制
### 2. 系统默认快捷键

#### macOS 默认快捷键
在 macOS 系统中，您可以使用 `Option+Enter` 组合键来换行：

```bash
这是第一行
这是第二行
这是第三行
```

```
### 2. 系统默认快捷键

#### macOS 默认快捷键
在 macOS 系统中，您可以使用 `Option+Enter` 组合键来换行：

```bash
这是第一行
这是第二行
这是第三行
```

###### Windows/Linux 默认快捷键

在 Windows 或 Linux 系统中，通常使用 Alt+Enter 组合键来换行。

```
Alt+Enter
```

##### 3. 终端设置快捷键#

运行 /terminal-setup 命令后，可以使用 Shift+Enter 作为统一的换行快捷键，这在 iTerm2 和 VS Code 终端中效果最佳：

```
/terminal-setup
```

```
Shift+Enter
```

```
bash复制/terminal-setup
```

```
/terminal-setup
```

执行此命令后，您就可以使用 Shift+Enter 来换行：

```
Shift+Enter
```

```
bash复制这是第一行
这是第二行
这是第三行
```

```
这是第一行
这是第二行
这是第三行
```

##### 4. 控制序列#

使用 Ctrl+J 作为换行符，这是一种更底层的控制序列方法：

```
Ctrl+J
```

```
bash复制这是第一行
这是第二行
```

```
这是第一行
这是第二行
```

##### 5. 粘贴模式#

您可以直接粘贴多行文本到 Claude Code 中，无需任何特殊处理。例如：

```
javascript复制function example() {
    console.log("Hello");
    return true;
}
```

```
function example() {
    console.log("Hello");
    return true;
}
```

#### 配置多行输入#

##### 自动配置#

运行 /terminal-setup 命令可以自动为 iTerm2 和 VS Code 终端安装 Shift+Enter 绑定：

```
/terminal-setup
```

```
bash复制/terminal-setup
```

```
/terminal-setup
```

##### 手动配置#

如果您使用其他终端，可以手动配置快捷键：

###### iTerm2 配置

True. 打开 iTerm2 偏好设置
True. 导航到 "Keys" 选项卡
True. 点击 "+" 添加新的快捷键
True. 设置 Shift+Enter 发送   字符

```
Shift+Enter
```

###### VS Code 终端配置

True. 打开 VS Code 设置
True. 搜索 "terminal.integrated.commandsToSkipShell"
True. 添加 "workbench.action.terminal.focus"
True. 在键盘快捷方式中设置 Shift+Enter 为 "workbench.action.terminal.sendSequence"

```
Shift+Enter
```

#### 使用场景#

##### 1. 编写复杂提示#

当您需要向 Claude Code 提供详细的任务说明时，多行输入非常有用：

```
bash复制我需要你帮我完成以下任务：
1. 分析这段代码的性能瓶颈
2. 提出优化建议
3. 提供优化后的代码版本
```

```
我需要你帮我完成以下任务：
1. 分析这段代码的性能瓶颈
2. 提出优化建议
3. 提供优化后的代码版本
```

##### 2. 输入代码片段#

您可以直接输入多行代码片段进行分析或优化：

```
javascript复制请优化这段代码：
function calculateTotal(items) {
    let total = 0;
    for (let i = 0; i < items.length; i++) {
        total += items[i].price;
    }
    return total;
}
```

```
请优化这段代码：
function calculateTotal(items) {
    let total = 0;
    for (let i = 0; i < items.length; i++) {
        total += items[i].price;
    }
    return total;
}
```

##### 3. 编写测试用例#

多行输入让您可以轻松编写完整的测试用例：

```
javascript复制为以下函数编写单元测试：
function add(a, b) {
    return a + b;
}

测试用例应该包括：
- 正数相加
- 负数相加
- 零值测试
- 边界情况
```

```
为以下函数编写单元测试：
function add(a, b) {
    return a + b;
}

测试用例应该包括：
- 正数相加
- 负数相加
- 零值测试
- 边界情况
```

##### 4. 编写文档#

您可以使用多行输入来编写文档或注释：

```
bash复制# 项目文档

## 功能描述
这个函数用于计算购物车中所有商品的总价。

## 参数说明
- items: 包含商品信息的数组
- each item: 包含 price 属性的对象
```

```
# 项目文档

## 功能描述
这个函数用于计算购物车中所有商品的总价。

## 参数说明
- items: 包含商品信息的数组
- each item: 包含 price 属性的对象
```

#### 最佳实践#

True. 选择适合您的方法：根据您使用的终端和个人偏好，选择最适合的多行输入方法
True. 保持代码格式：在输入代码时，保持适当的缩进和格式，便于 Claude Code 理解
True. 使用粘贴模式：对于较长的代码片段，直接粘贴比手动输入更高效
True. 测试快捷键：在开始工作前，测试您选择的多行输入方法是否正常工作
True. 避免混合方法：尽量使用一种多行输入方法，避免在同一个会话中混合使用多种方法

#### 故障排除#

##### 快捷键不工作#

- 确保您已经运行了 /terminal-setup 命令
- 检查终端的快捷键设置，确保没有冲突
- 尝试使用通用的反斜杠转义方法

```
/terminal-setup
```

##### 粘贴格式混乱#

- 确保粘贴的文本格式正确
- 尝试在粘贴前先按 Enter 键
- 检查终端的粘贴设置

##### 输入被截断#

- 确保没有超出 Claude Code 的输入限制
- 尝试将长文本分成多个较短的输入
- 检查终端的行长度设置

```
bash复制### 粘贴格式混乱
1. 使用粘贴模式
2. 检查终端的粘贴设置
3. 尝试使用其他粘贴方法
```

```
### 粘贴格式混乱
1. 使用粘贴模式
2. 检查终端的粘贴设置
3. 尝试使用其他粘贴方法
```

---

## 3 命令历史

**URL**: https://claudecode.tangshuang.net/course/9.3%20%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2

Claude Code 提供了强大的命令历史功能，让您可以轻松重用、搜索和管理之前的输入。命令历史按工作目录独立存储，确保您在不同项目中保持清晰的工作流。

#### 核心特性#

- 按目录存储：每个项目目录有独立的命令历史记录
- 持久化保存：历史记录会自动保存，重启会话后依然可用
- 快速导航：使用箭头键快速浏览历史命令
- 智能搜索：支持反向搜索和模糊匹配
- 历史扩展：默认禁用，可根据需要启用
- 清除功能：可以清除当前会话的所有历史记录

#### 导航命令历史#

##### 1. 使用箭头键#

最基本的导航方式是使用上下箭头键：

```
bash复制# 按 ↑ 向上导航到之前的命令
```

```
# 按 ↑ 向上导航到之前的命令
```

git status
[按 ↑]  # 显示之前执行的 git status 命令

### 按 ↓ 向下导航到较新的命令

git status
[按 ↓]  # 返回到空输入或下一个命令

```
bash复制
### 2. 使用 Ctrl+R 反向搜索

`Ctrl+R` 是最强大的命令历史搜索工具，允许您交互式搜索之前的命令：

#### 使用步骤
1. **激活搜索**：按 `Ctrl+R` 激活反向历史搜索
2. **输入查询**：输入关键词以在历史命令中搜索
3. **浏览匹配**：再次按 `Ctrl+R` 循环浏览更早的匹配项
4. **接受结果**：
   - 按 `Tab` 或 `Esc` 接受当前匹配并继续编辑
   - 按 `Enter` 接受并立即执行命令
5. **取消搜索**：
   - 按 `Ctrl+C` 取消并恢复原始输入
   - 在空搜索上按 `Backspace` 取消

#### 搜索示例

```bash
# 按 Ctrl+R 开始搜索
(reverse-i-search)`git': git commit -m "fix bug"

# 继续输入搜索词以缩小范围
(reverse-i-search)`git commit': git commit -m "add new feature"

# 按 Ctrl+R 查看更早的匹配
(reverse-i-search)`git commit': git commit -m "initial commit"
```

```
### 2. 使用 Ctrl+R 反向搜索

`Ctrl+R` 是最强大的命令历史搜索工具，允许您交互式搜索之前的命令：

#### 使用步骤
1. **激活搜索**：按 `Ctrl+R` 激活反向历史搜索
2. **输入查询**：输入关键词以在历史命令中搜索
3. **浏览匹配**：再次按 `Ctrl+R` 循环浏览更早的匹配项
4. **接受结果**：
   - 按 `Tab` 或 `Esc` 接受当前匹配并继续编辑
   - 按 `Enter` 接受并立即执行命令
5. **取消搜索**：
   - 按 `Ctrl+C` 取消并恢复原始输入
   - 在空搜索上按 `Backspace` 取消

#### 搜索示例

```bash
# 按 Ctrl+R 开始搜索
(reverse-i-search)`git': git commit -m "fix bug"

# 继续输入搜索词以缩小范围
(reverse-i-search)`git commit': git commit -m "add new feature"

# 按 Ctrl+R 查看更早的匹配
(reverse-i-search)`git commit': git commit -m "initial commit"
```

##### 3. 其他导航方式#

- Ctrl+P：等同于向上箭头，显示上一个命令
- Ctrl+N：等同于向下箭头，显示下一个命令
- Alt+.：插入上一个命令的最后一个参数

```
Ctrl+P
```

```
Ctrl+N
```

```
Alt+.
```

#### 管理命令历史#

##### 清除当前会话历史#

使用 /clear 命令清除当前会话的所有命令历史：

```
/clear
```

```
bash复制/clear
```

```
/clear
```

##### 清除特定命令#

Claude Code 不支持直接删除特定命令，但您可以通过以下方式间接实现：

True. 使用 /clear 清除所有历史记录
True. 重新开始会话
True. 或者，忽略不需要的命令，继续使用历史功能

```
/clear
```

##### 历史记录存储#

命令历史按工作目录存储，这意味着：

- 每个项目目录有独立的历史记录
- 切换目录会自动加载该目录的历史记录
- 历史记录持久化保存，不会随会话结束而丢失

###### 历史文件位置

历史文件通常存储在用户主目录的 .claude 文件夹中：

```
.claude
```

```
bash复制~/.claude/history/
```

```
~/.claude/history/
```

#### 使用场景#

##### 1. 重用之前的命令#

当您需要重复执行相同或相似的命令时，命令历史可以节省大量时间：

```
bash复制# 之前执行的命令
npm install --save-dev jest

# 使用箭头键快速重用
[按 ↑]  # 显示 npm install --save-dev jest
[按 Enter]  # 执行该命令
```

```
# 之前执行的命令
npm install --save-dev jest

# 使用箭头键快速重用
[按 ↑]  # 显示 npm install --save-dev jest
[按 Enter]  # 执行该命令
```

##### 2. 搜索特定命令#

当您需要找到之前执行过的特定命令时，反向搜索非常有用：

```
bash复制# 搜索包含 "test" 的命令
(reverse-i-search)`test': npm test -- --coverage

# 搜索包含 "build" 的命令
(reverse-i-search)`build': npm run build
```

```
# 搜索包含 "test" 的命令
(reverse-i-search)`test': npm test -- --coverage

# 搜索包含 "build" 的命令
(reverse-i-search)`build': npm run build
```

##### 3. 修改之前的命令#

您可以找到之前的命令并进行修改，而无需重新输入整个命令：

```
bash复制# 找到之前的部署命令
(reverse-i-search)`deploy': npm run deploy -- --env=production

# 修改环境参数
npm run deploy -- --env=staging  # 直接编辑后执行
```

```
# 找到之前的部署命令
(reverse-i-search)`deploy': npm run deploy -- --env=production

# 修改环境参数
npm run deploy -- --env=staging  # 直接编辑后执行
```

##### 4. 学习和回顾#

命令历史还可以帮助您回顾之前的工作，学习自己的工作模式：

```
bash复制# 查看最近执行的命令历史
history  # 显示命令历史列表
```

```
# 查看最近执行的命令历史
history  # 显示命令历史列表
```

#### 最佳实践#

True. 使用有意义的命令：在输入命令时，尽量使用清晰的描述，便于后续搜索
True. 定期清理：对于不再需要的历史记录，使用 /clear 命令清理
True. 利用反向搜索：Ctrl+R 是提高工作效率的关键工具，熟练掌握它
True. 注意隐私：避免在命令历史中输入敏感信息，如密码或密钥
True. 跨项目工作：利用按目录存储的特性，在不同项目中保持独立的命令历史

```
/clear
```

```
Ctrl+R
```

#### 故障排除#

##### 命令历史不显示#

- 确保您在正确的工作目录中
- 检查历史文件权限是否正确
- 尝试重启 Claude Code 会话

##### 反向搜索不工作#

- 确保没有其他程序占用 Ctrl+R 快捷键
- 检查终端的快捷键设置
- 尝试使用 Ctrl+P 和 Ctrl+N 作为替代

```
Ctrl+R
```

```
Ctrl+P
```

```
Ctrl+N
```

##### 历史记录丢失#

- 检查历史文件是否存在：~/.claude/history/
- 确保有足够的磁盘空间
- 检查文件系统权限

```
~/.claude/history/
```

##### 历史扩展功能#

历史扩展 (!) 默认禁用，如果需要启用，可以通过配置文件进行设置。但请注意，历史扩展可能会带来安全风险，建议谨慎使用。

```
!
```

---

## 4 后台 bash 命令

**URL**: https://claudecode.tangshuang.net/course/9.4%20%E5%90%8E%E5%8F%B0%20bash%20%E5%91%BD%E4%BB%A4

Claude Code 提供了强大的后台命令运行功能，允许您在执行长时间运行的进程时继续与 Claude 交互。这极大地提高了工作效率，特别是在处理构建、测试或开发服务器等耗时任务时。

#### 工作原理#

当您在后台运行命令时，Claude Code 会异步执行该命令，并立即返回一个唯一的后台任务 ID。这意味着您可以在命令继续执行的同时，继续向 Claude 提问或执行其他任务。

##### 核心特性#

- 异步执行：命令在后台运行，不阻塞您的工作流
- 输出缓冲：命令输出会被缓冲，您可以随时检索
- 任务跟踪：每个后台任务都有唯一的 ID，方便管理
- 自动清理：当 Claude Code 退出时，所有后台任务会被自动清理
- 实时监控：可以随时检查任务状态和输出

#### 启动后台命令#

##### 1. 通过提示启动#

最简单的方式是直接在提示中要求 Claude 在后台运行命令：

```
bash复制在后台运行 npm install
[后台任务 ID: task-12345 已启动]
```

```
在后台运行 npm install
[后台任务 ID: task-12345 已启动]
```

##### 2. 使用 Ctrl+B 快捷键#

您可以使用 Ctrl+B 组合键将正在运行的常规 Bash 命令移到后台：

```
Ctrl+B
```

```
bash复制npm test
[按 Ctrl+B]
[任务已移至后台，ID: task-12346]
```

```
npm test
[按 Ctrl+B]
[任务已移至后台，ID: task-12346]
```

注意: Tmux 用户需要按 Ctrl+B 两次，因为 Tmux 默认使用 Ctrl+B 作为前缀键。

```
Ctrl+B
```

```
Ctrl+B
```

##### 3. 使用 /background 命令#

您也可以使用 /background 命令显式地将命令移到后台：

```
/background
```

```
bash复制/background npm run dev
[后台任务 ID: task-12347 已启动]
```

```
/background npm run dev
[后台任务 ID: task-12347 已启动]
```

#### 常见的后台命令场景#

##### 1. 构建工具#

```
bash复制在后台运行 webpack build
[后台任务 ID: task-12348 已启动]
```

```
在后台运行 webpack build
[后台任务 ID: task-12348 已启动]
```

##### 2. 包管理器#

```
bash复制在后台运行 npm install
[后台任务 ID: task-12349 已启动]
```

```
在后台运行 npm install
[后台任务 ID: task-12349 已启动]
```

##### 3. 测试运行器#

```
bash复制在后台运行 jest --watch
[后台任务 ID: task-12350 已启动]
```

```
在后台运行 jest --watch
[后台任务 ID: task-12350 已启动]
```

##### 4. 开发服务器#

```
bash复制在后台运行 npm run dev
[后台任务 ID: task-12351 已启动]
```

```
在后台运行 npm run dev
[后台任务 ID: task-12351 已启动]
```

##### 5. 长时间运行的进程#

```
bash复制在后台运行 docker-compose up
[后台任务 ID: task-12352 已启动]
```

```
在后台运行 docker-compose up
[后台任务 ID: task-12352 已启动]
```

##### 6. 文件监控#

```
bash复制在后台运行 nodemon server.js
[后台任务 ID: task-12353 已启动]
```

```
在后台运行 nodemon server.js
[后台任务 ID: task-12353 已启动]
```

#### 管理后台任务#

##### 1. 查看所有后台任务#

您可以随时查看当前正在运行的后台任务列表：

```
bash复制列出所有后台任务
正在运行的后台任务：
- task-12345: npm install (运行中)
- task-12346: npm test (运行中)
- task-12347: npm run dev (运行中)
```

```
列出所有后台任务
正在运行的后台任务：
- task-12345: npm install (运行中)
- task-12346: npm test (运行中)
- task-12347: npm run dev (运行中)
```

##### 2. 检查任务状态#

您可以检查特定任务的详细状态：

```
bash复制检查任务 task-12345 的状态
任务 task-12345 状态：
- 命令: npm install
- 状态: 运行中
- 运行时间: 2分30秒
- PID: 12345
```

```
检查任务 task-12345 的状态
任务 task-12345 状态：
- 命令: npm install
- 状态: 运行中
- 运行时间: 2分30秒
- PID: 12345
```

##### 3. 获取任务输出#

当命令完成或需要查看中间输出时，您可以获取任务的输出：

```
bash复制获取任务 task-12345 的输出
added 1423 packages in 2m
found 0 vulnerabilities
```

```
获取任务 task-12345 的输出
added 1423 packages in 2m
found 0 vulnerabilities
```

##### 4. 停止后台任务#

如果需要，可以停止正在运行的后台任务：

```
bash复制停止任务 task-12345
任务 task-12345 已停止
```

```
停止任务 task-12345
任务 task-12345 已停止
```

##### 5. 清理已完成的任务#

您可以清理已完成的后台任务，保持任务列表整洁：

```
bash复制清理已完成的任务
已清理 2 个已完成的后台任务
```

```
清理已完成的任务
已清理 2 个已完成的后台任务
```

#### 使用场景#

##### 1. 并行工作#

后台命令最强大的用途之一是允许您在执行耗时任务的同时继续工作。例如：

```
bash复制# 启动后台构建
在后台运行 npm run build

# 同时询问 Claude 问题
请解释这段 React 代码的工作原理：
function App() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

```
# 启动后台构建
在后台运行 npm run build

# 同时询问 Claude 问题
请解释这段 React 代码的工作原理：
function App() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

##### 2. 监控长时间运行的进程#

对于需要持续运行的进程（如开发服务器），后台运行非常有用：

```
bash复制# 启动后台开发服务器
在后台运行 npm run dev

# 查看服务器输出
获取任务 task-12347 的输出
Compiled successfully!
You can now view my-app in the browser.
Local:            http://localhost:3000
```

```
# 启动后台开发服务器
在后台运行 npm run dev

# 查看服务器输出
获取任务 task-12347 的输出
Compiled successfully!
You can now view my-app in the browser.
Local:            http://localhost:3000
```

##### 3. 批量处理#

您可以同时启动多个后台任务，提高工作效率：

```
bash复制# 同时启动多个任务
在后台运行 npm install
在后台运行 npm run lint
在后台运行 npm test

# 查看所有任务状态
列出所有后台任务
```

```
# 同时启动多个任务
在后台运行 npm install
在后台运行 npm run lint
在后台运行 npm test

# 查看所有任务状态
列出所有后台任务
```

#### 最佳实践#

True. 合理命名任务：在启动后台任务时，尽量使用清晰的描述，便于后续管理
True. 定期检查状态：对于长时间运行的任务，定期检查状态以确保它们正常运行
True. 及时清理：任务完成后，及时清理已完成的任务，保持任务列表整洁
True. 注意资源使用：避免同时运行过多的后台任务，以免消耗过多系统资源
True. 监控输出：对于重要任务，定期检查输出以确保它们按预期执行

#### 故障排除#

##### 后台任务不启动#

- 检查命令格式是否正确
- 确保您有足够的权限运行该命令
- 尝试使用 /background 命令显式启动

```
/background
```

##### 无法获取任务输出#

- 确保任务 ID 正确
- 检查任务是否已经完成
- 尝试等待片刻再获取输出

##### 后台任务意外停止#

- 检查命令是否有错误输出
- 查看系统日志以获取更多信息
- 尝试在前台运行命令以调试问题

##### Ctrl+B 快捷键不工作#

- 确保没有其他程序占用 Ctrl+B 快捷键
- 对于 Tmux 用户，尝试按两次 Ctrl+B
- 检查终端的快捷键设置

```
Ctrl+B
```

```
Ctrl+B
```

#### 高级技巧#

##### 1. 任务依赖#

您可以创建任务之间的依赖关系，确保任务按顺序执行：

```
bash复制在后台运行 npm install && npm run build
[后台任务 ID: task-12354 已启动]
```

```
在后台运行 npm install && npm run build
[后台任务 ID: task-12354 已启动]
```

##### 2. 输出重定向#

您可以将任务输出重定向到文件：

```
bash复制在后台运行 npm run build > build.log 2>&1
[后台任务 ID: task-12355 已启动]
```

```
在后台运行 npm run build > build.log 2>&1
[后台任务 ID: task-12355 已启动]
```

##### 3. 定时任务#

您可以结合 cron 或其他定时工具创建定时后台任务：

```
cron
```

```
bash复制在后台运行 "* * * * * /usr/bin/node /path/to/script.js"
[后台任务 ID: task-12356 已启动]
```

```
在后台运行 "* * * * * /usr/bin/node /path/to/script.js"
[后台任务 ID: task-12356 已启动]
```

##### 并行开发#

```
bash复制bash

# 启动开发服务器
在后台运行 npm run dev
[后台任务 ID: task-12352 已启动]

# 同时运行测试
在后台运行 npm test
[后台任务 ID: task-12353 已启动]

# 继续开发
创建一个新的组件

### 长时间构建

# 启动构建
在后台运行 webpack --mode production
[后台任务 ID: task-12354 已启动]
# 在构建时继续工作
编写测试用例
```

```
bash

# 启动开发服务器
在后台运行 npm run dev
[后台任务 ID: task-12352 已启动]

# 同时运行测试
在后台运行 npm test
[后台任务 ID: task-12353 已启动]

# 继续开发
创建一个新的组件

### 长时间构建

# 启动构建
在后台运行 webpack --mode production
[后台任务 ID: task-12354 已启动]
# 在构建时继续工作
编写测试用例
```

##### 监控服务#

```
bash复制bash

# 启动监控
在后台运行 npm run watch
[后台任务 ID: task-12355 已启动]

# 查看输出
获取任务 task-12355 的输出

## Bash 模式

使用 `!` 前缀直接运行 bash 命令：

! npm test
! git status
! ls -la
```

```
bash

# 启动监控
在后台运行 npm run watch
[后台任务 ID: task-12355 已启动]

# 查看输出
获取任务 task-12355 的输出

## Bash 模式

使用 `!` 前缀直接运行 bash 命令：

! npm test
! git status
! ls -la
```

##### Bash 模式特性#

- 将命令及其输出添加到对话上下文
- 显示实时进度和输出
- 支持相同的 Ctrl+B 后台运行
- 不需要 Claude 解释或批准命令

```
Ctrl+B
```

##### Bash 模式示例#

```
bash复制bash

# 快速检查状态
! git status

# 运行测试
! npm test

# 查看文件
! cat package.json

```

## 最佳实践

1. **合理使用**: 对于长时间运行的命令使用后台模式
2. **监控输出**: 定期检查后台任务的输出
3. **清理任务**: 及时停止不再需要的后台任务
4. **任务命名**: 为后台任务添加描述性名称便于识别

## 注意事项

- 后台任务在 Claude Code 退出时会自动清理
- 后台任务的输出是缓冲的，可能不会实时显示
- 太多后台任务可能影响性能
- 某些命令可能不适合在后台运行

## 故障排除

### 后台任务失败

1. 检查任务输出了解错误原因
2. 确认命令语法正确
3. 检查依赖项是否已安装

### 无法停止任务

1. 尝试使用 `pkill` 命令
2. 重启 Claude Code
3. 手动终止进程

### 输出不显示

1. 等待缓冲区填充
2. 手动获取任务输出
3. 检查任务是否仍在运行
```

```
bash

# 快速检查状态
! git status

# 运行测试
! npm test

# 查看文件
! cat package.json

```

## 最佳实践

1. **合理使用**: 对于长时间运行的命令使用后台模式
2. **监控输出**: 定期检查后台任务的输出
3. **清理任务**: 及时停止不再需要的后台任务
4. **任务命名**: 为后台任务添加描述性名称便于识别

## 注意事项

- 后台任务在 Claude Code 退出时会自动清理
- 后台任务的输出是缓冲的，可能不会实时显示
- 太多后台任务可能影响性能
- 某些命令可能不适合在后台运行

## 故障排除

### 后台任务失败

1. 检查任务输出了解错误原因
2. 确认命令语法正确
3. 检查依赖项是否已安装

### 无法停止任务

1. 尝试使用 `pkill` 命令
2. 重启 Claude Code
3. 手动终止进程

### 输出不显示

1. 等待缓冲区填充
2. 手动获取任务输出
3. 检查任务是否仍在运行
```

---

## 5 Vim 编辑器模式

**URL**: https://claudecode.tangshuang.net/course/9.5%20Vim%20%E7%BC%96%E8%BE%91%E5%99%A8%E6%A8%A1%E5%BC%8F

Claude Code 提供了全面的 Vim 编辑器模式支持，让 Vim 用户可以使用熟悉的快捷键进行高效编辑。无论您是 Vim 新手还是资深用户，都能在 Claude Code 中找到舒适的编辑体验。

#### 启用 Vim 模式#

##### 1. 临时启用#

您可以使用 /vim 命令临时启用 Vim 模式：

```
/vim
```

```
bash复制/vim
Vim 模式已启用
```

```
/vim
Vim 模式已启用
```

##### 2. 永久配置#

如果您希望每次启动 Claude Code 都自动启用 Vim 模式，可以通过配置文件进行设置：

```
bash复制/config
# 在配置界面中设置 vim 模式为 true
```

```
/config
# 在配置界面中设置 vim 模式为 true
```

##### 3. 切换回普通模式#

您可以使用 /novim 命令关闭 Vim 模式：

```
/novim
```

```
bash复制/novim
Vim 模式已禁用
```

```
/novim
Vim 模式已禁用
```

#### 模式切换#

Vim 的核心是模式切换，Claude Code 支持所有标准的 Vim 模式：

##### 1. 进入 NORMAL 模式#

从 INSERT 模式按 Esc 键进入 NORMAL 模式：

```
Esc
```

```
bash复制[在 INSERT 模式输入文本]
[按 Esc]
[进入 NORMAL 模式]
```

```
[在 INSERT 模式输入文本]
[按 Esc]
[进入 NORMAL 模式]
```

##### 2. 进入 INSERT 模式#

在 NORMAL 模式下，您可以使用以下命令进入 INSERT 模式：

```
i
```

```
I
```

```
a
```

```
A
```

```
o
```

```
O
```

```
gi
```

###### 示例

```
bash复制# 在 NORMAL 模式
Hello World[光标]

# 按 i 在光标前插入
Hello[光标] World

# 按 A 在行尾插入
Hello World[光标]
```

```
# 在 NORMAL 模式
Hello World[光标]

# 按 i 在光标前插入
Hello[光标] World

# 按 A 在行尾插入
Hello World[光标]
```

##### 3. 进入 VISUAL 模式#

在 NORMAL 模式下，您可以使用以下命令进入 VISUAL 模式：

```
v
```

```
V
```

```
Ctrl+v
```

##### 4. 进入 COMMAND 模式#

在 NORMAL 模式下，按 : 键进入 COMMAND 模式，用于执行各种 Vim 命令。

```
:
```

#### 导航 (NORMAL 模式)#

##### 1. 基本移动#

```
h
```

```
j
```

```
k
```

```
l
```

##### 2. 单词导航#

```
w
```

```
e
```

```
b
```

```
ge
```

```
W
```

```
E
```

```
B
```

##### 3. 行导航#

```
0
```

```
$
```

```
^
```

```
g_
```

##### 4. 文件导航#

```
gg
```

```
G
```

```
nG
```

```
:n
```

##### 5. 屏幕导航#

```
Ctrl+u
```

```
Ctrl+d
```

```
Ctrl+b
```

```
Ctrl+f
```

```
zz
```

```
zt
```

```
zb
```

##### 示例#

```
bash复制# 基本移动
Hello World
[按 l]  # 光标向右移动一个字符
Hello World[光标]

# 单词导航
Hello World
[按 w]  # 移动到下一个单词开头
Hello World[光标]

# 行导航
Hello World
[按 $]  # 移动到行尾
Hello World[光标]

# 文件导航
[按 gg]  # 移动到文件开头
```

```
# 基本移动
Hello World
[按 l]  # 光标向右移动一个字符
Hello World[光标]

# 单词导航
Hello World
[按 w]  # 移动到下一个单词开头
Hello World[光标]

# 行导航
Hello World
[按 $]  # 移动到行尾
Hello World[光标]

# 文件导航
[按 gg]  # 移动到文件开头
```

#### 编辑操作#

##### 1. 删除操作#

```
x
```

```
X
```

```
dw
```

```
de
```

```
d$
```

```
dd
```

```
ndd
```

##### 2. 复制和粘贴#

```
yy
```

```
nyy
```

```
yw
```

```
p
```

```
P
```

##### 3. 撤销和重做#

```
u
```

```
Ctrl+r
```

##### 4. 替换操作#

```
r
```

```
R
```

#### 搜索和替换#

##### 1. 搜索#

```
/pattern
```

```
?pattern
```

```
n
```

```
N
```

##### 2. 替换#

```
:%s/old/new/g
```

```
:%s/old/new/gc
```

```
:n,m s/old/new/g
```

#### 最佳实践#

True. 熟悉基本移动：掌握 h, j, k, l 等基本移动命令是高效使用 Vim 的基础
True. 使用单词导航：w, e, b 等单词导航命令比逐字符移动更高效
True. 善用模式切换：熟练掌握模式切换可以大大提高编辑效率
True. 使用重复命令：很多命令可以通过数字前缀重复执行，如 3dd 删除 3 行
True. 学习组合命令：Vim 的强大之处在于命令组合，如 d2w 删除 2 个单词

```
h
```

```
j
```

```
k
```

```
l
```

```
w
```

```
e
```

```
b
```

```
3dd
```

```
d2w
```

#### 故障排除#

##### Vim 模式不生效#

- 确保您已经运行了 /vim 命令
- 检查配置文件中 Vim 模式是否已启用
- 尝试重启 Claude Code 会话

```
/vim
```

##### 快捷键冲突#

- 如果某些快捷键不工作，可能是与终端快捷键冲突
- 尝试在配置中调整快捷键映射
- 查看终端的快捷键设置

##### 模式切换问题#

- 确保您在正确的模式下执行命令
- 按 Esc 键可以随时回到 NORMAL 模式
- 尝试使用 Ctrl+[ 作为 Esc 的替代

```
Esc
```

```
Ctrl+[
```

```
Esc
```

#### 高级技巧#

##### 1. 标记和跳转#

```
ma
```

```
'a
```

```
`a
```

##### 2. 宏录制#

```
qa
```

```
q
```

```
@a
```

```
@@
```

##### 3. 多文件编辑#

```
:e filename
```

```
:n
```

```
:p
```

```
:ls
```

```
:b filename
```

通过掌握这些 Vim 编辑技巧，您可以在 Claude Code 中享受到高效的编辑体验，充分发挥 Vim 的强大功能。

#### 编辑 (NORMAL 模式)#

##### 删除操作#

```
x
```

```
dd
```

```
D
```

```
dw
```

```
de
```

```
db
```

##### 更改操作#

```
cc
```

```
C
```

```
cw
```

```
ce
```

```
cb
```

##### 重复操作#

```
.
```

##### 示例#

```
bash复制# 删除字符
Hello World
[按 x]
Hllo World

# 删除行
Hello World
[按 dd]
[空行]

# 更改行
Hello World
[按 cc]
[输入新内容]
```

```
# 删除字符
Hello World
[按 x]
Hllo World

# 删除行
Hello World
[按 dd]
[空行]

# 更改行
Hello World
[按 cc]
[输入新内容]
```

#### 常用组合#

##### 数字前缀#

```
bash复制# 删除 3 个字符
Hello World
[按 3x]
lo World

# 删除 2 行
Line 1
Line 2
Line 3
[按 2dd]
Line 3
```

```
# 删除 3 个字符
Hello World
[按 3x]
lo World

# 删除 2 行
Line 1
Line 2
Line 3
[按 2dd]
Line 3
```

##### 删除+插入#

```
bash复制# 删除单词并进入插入模式
Hello World
[按 cw]
[输入新单词]
```

```
# 删除单词并进入插入模式
Hello World
[按 cw]
[输入新单词]
```

#### 使用场景#

##### 快速编辑#

```
bash复制# 快速删除单词
function calculateTotal(items) {
[按 dw]

function (items) {
```

```
# 快速删除单词
function calculateTotal(items) {
[按 dw]

function (items) {
```

##### 精确定位#

```
bash复制# 跳到行尾
const result = calculateTotal(items);
[按 $]
const result = calculateTotal(items);[光标]
```

```
# 跳到行尾
const result = calculateTotal(items);
[按 $]
const result = calculateTotal(items);[光标]
```

##### 批量修改#

```
bash复制# 重复修改
item1, item2, item3
[按 f, 然后 r.)]
item1. item2. item3
```

```
# 重复修改
item1, item2, item3
[按 f, 然后 r.)]
item1. item2. item3
```

---

# 第 10 章

## 1 工具调用概述

**URL**: https://claudecode.tangshuang.net/course/10.1%20%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E6%A6%82%E8%BF%B0

Claude Code 的工具调用系统是其核心功能之一，它允许 Claude 执行各种操作来帮助您完成开发任务。通过工具调用，Claude 可以与外部系统交互，执行文件操作、运行命令、搜索代码库等，极大地扩展了其能力范围。

#### 什么是工具调用#

工具调用是 Claude Code 与外部世界交互的机制。通过工具调用，Claude 可以：

- 读取和写入文件: 查看和修改项目中的代码和配置文件
- 执行命令行操作: 运行 shell 命令、构建工具和其他开发工具
- 搜索代码库: 查找特定模式、函数或类的位置
- 管理项目: 执行 Git 操作、包管理和容器操作
- 与外部服务集成: 连接到 API、数据库和其他服务

#### 工具调用的优势#

True. 自动化: 自动执行重复性任务，提高工作效率
True. 准确性: 减少人为错误，确保操作一致性
True. 效率: 快速完成复杂操作，节省时间
True. 集成: 与各种工具和服务无缝集成，形成完整的开发工作流
True. 可扩展性: 支持自定义工具开发，满足特定需求

#### 工具调用流程#

Claude Code 的工具调用遵循以下流程：

True. 用户请求: 用户提出需求或问题
True. Claude 分析: Claude 理解用户需求，确定需要执行的操作
True. 选择工具: 根据需求选择合适的工具
True. 执行操作: 调用工具执行指定操作
True. 返回结果: 工具返回执行结果
True. 用户确认: 向用户展示结果，等待确认或进一步指示

#### 工具分类#

Claude Code 提供了丰富的工具集，可以分为以下几类：

##### 1. 文件操作工具#

##### 2. 搜索工具#

##### 3. 命令执行工具#

##### 4. 项目管理工具#

##### 5. 集成工具#

#### 工具权限#

Claude Code 提供了多层权限控制，确保工具调用的安全性和可控性。

##### 权限模式#

- 自动接受模式: 自动批准所有工具调用，适合信任环境
- 计划模式: 显示计划但不执行，用于预览操作
- 正常模式: 每次工具调用都需要用户确认，确保安全性

##### 工具白名单/黑名单#

您可以通过命令行参数控制允许或禁止使用的工具：

```
bash复制# 允许特定工具
claude --allowedTools Read,Grep,Glob

# 禁止特定工具
claude --disallowedTools Bash,Write
```

```
# 允许特定工具
claude --allowedTools Read,Grep,Glob

# 禁止特定工具
claude --disallowedTools Bash,Write
```

##### 权限配置文件#

您还可以通过配置文件更精细地控制工具权限：

```
json复制{
  "allowedTools": ["Read", "Grep", "Git"],
  "disallowedTools": ["Write", "Delete"],
  "permissionMode": "normal"
}
```

```
{
  "allowedTools": ["Read", "Grep", "Git"],
  "disallowedTools": ["Write", "Delete"],
  "permissionMode": "normal"
}
```

#### 工具调用示例#

##### 1. 读取文件#

```
bash复制读取 package.json 文件
[Read tool called]
{
  "name": "my-project",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  }
}
```

```
读取 package.json 文件
[Read tool called]
{
  "name": "my-project",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  }
}
```

##### 2. 搜索代码#

```
bash复制搜索所有包含 "TODO" 的文件
[Grep tool called]
Found 5 files with TODO comments:
- src/App.js: // TODO: Add error handling
- src/utils.js: // TODO: Optimize performance
- tests/unit.test.js: // TODO: Write more tests
```

```
搜索所有包含 "TODO" 的文件
[Grep tool called]
Found 5 files with TODO comments:
- src/App.js: // TODO: Add error handling
- src/utils.js: // TODO: Optimize performance
- tests/unit.test.js: // TODO: Write more tests
```

##### 3. 执行命令#

```
bash复制运行 npm install
[Bash tool called]
npm install
added 1423 packages in 2m
found 0 vulnerabilities
```

```
运行 npm install
[Bash tool called]
npm install
added 1423 packages in 2m
found 0 vulnerabilities
```

##### 4. Git 操作#

```
bash复制提交更改
[Git tool called]
git commit -m "Add new feature"
[main 1234567] Add new feature
 2 files changed, 10 insertions(+), 2 deletions(-)
```

```
提交更改
[Git tool called]
git commit -m "Add new feature"
[main 1234567] Add new feature
 2 files changed, 10 insertions(+), 2 deletions(-)
```

#### 工具调用最佳实践#

True. 明确请求: 清楚地说明您需要什么，提供足够的上下文
True. 分步执行: 将复杂任务分解为多个步骤，逐步完成
True. 确认操作: 在执行破坏性操作（如删除文件）前，确认操作的安全性
True. 使用描述性名称: 为文件和变量使用清晰的名称，便于搜索和理解
True. 监控输出: 对于长时间运行的命令，定期检查输出以确保正常执行
True. 限制权限: 根据需要限制工具权限，确保安全性
True. 使用批量操作: 对于相似的操作，使用批量处理提高效率

#### 工具调用限制#

虽然 Claude Code 的工具调用功能强大，但也存在一些限制：

True. 资源限制: 工具调用可能受系统资源限制，如内存、CPU 等
True. 网络限制: 网络操作可能受网络连接和带宽限制
True. 权限限制: 某些操作可能需要特定的系统权限
True. 安全限制: 为了安全，某些危险操作可能被默认禁止
True. 性能限制: 对于大型代码库，搜索和分析可能需要较长时间

#### 未来发展#

Claude Code 的工具调用系统正在不断发展，未来可能会增加以下功能：

True. 更多工具: 增加更多内置工具，覆盖更多开发场景
True. 更好的集成: 与更多开发工具和服务无缝集成
True. 智能推荐: 根据上下文智能推荐合适的工具
True. 自定义工具: 支持用户开发和集成自定义工具
True. 协作功能: 支持多人协作使用工具

通过不断改进和扩展，Claude Code 的工具调用系统将成为开发者不可或缺的助手，帮助您更高效地完成开发任务。

- 某些操作可能需要额外权限
- 工具调用可能受速率限制
- 某些工具可能有使用限制
- 网络操作可能受限

#### 扩展工具调用#

##### 自定义工具#

您可以通过以下方式扩展工具调用：

True. 插件: 创建自定义插件
True. Skills: 开发技能
True. MCP: 集成 MCP 服务器

##### 集成外部服务#

通过 MCP 服务器集成外部服务：

```
bash复制/mcp add github

# 使用 GitHub 工具创建 PR
创建 PR #123
```## 监控工具调用

### 查看工具使用情况

显示最近的工具调用
最近工具调用：
- Read: package.json
- Bash: npm install
- Grep: "TODO"
```

```
/mcp add github

# 使用 GitHub 工具创建 PR
创建 PR #123
```## 监控工具调用

### 查看工具使用情况

显示最近的工具调用
最近工具调用：
- Read: package.json
- Bash: npm install
- Grep: "TODO"
```

##### 调试工具调用#

```
bash复制```bash

claude --verbose

```

## 故障排除

### 工具调用失败

1. 检查权限设置
2. 确认工具可用
3. 查看错误消息
4. 检查日志

### 工具不执行

1. 确认权限模式
2. 检查工具白名单
3. 验证命令语法
4. 查看详细输出
```
```
```

```
```bash

claude --verbose

```

## 故障排除

### 工具调用失败

1. 检查权限设置
2. 确认工具可用
3. 查看错误消息
4. 检查日志

### 工具不执行

1. 确认权限模式
2. 检查工具白名单
3. 验证命令语法
4. 查看详细输出
```
```
```

---

## 2 内置工具介绍

**URL**: https://claudecode.tangshuang.net/course/10.2%20%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D

Claude Code 提供了丰富的内置工具集，涵盖了文件操作、搜索、命令执行、项目管理等多个方面。这些工具可以帮助您高效完成各种开发任务，提高工作效率。

#### 1. 文件操作工具#

##### Read 工具#

Read 工具用于读取文件内容，支持读取整个文件或特定范围的行。

```
bash复制读取文件 [文件路径]
```

```
读取文件 [文件路径]
```

```
bash复制读取 package.json
读取 src/components/Header.tsx
读取 src/utils.js 从第 10 行开始的 20 行
```

```
读取 package.json
读取 src/components/Header.tsx
读取 src/utils.js 从第 10 行开始的 20 行
```

- file_path: 文件路径（必需）
- limit: 读取行数（可选，默认读取整个文件）
- offset: 起始行号（可选，默认从第 1 行开始）

```
file_path
```

```
limit
```

```
offset
```

```
json复制{
  "file_path": "package.json",
  "content": "{\"name\": \"my-project\", \"version\": \"1.0.0\"}",
  "line_count": 10
}
```

```
{
  "file_path": "package.json",
  "content": "{\"name\": \"my-project\", \"version\": \"1.0.0\"}",
  "line_count": 10
}
```

##### Write 工具#

Write 工具用于写入文件内容，可以创建新文件或覆盖现有文件。

```
bash复制写入文件 [文件路径] [内容]
```

```
写入文件 [文件路径] [内容]
```

```
bash复制创建一个新的组件文件: src/components/Button.tsx
更新 README.md: # My Project\n\nThis is my project.
```

```
创建一个新的组件文件: src/components/Button.tsx
更新 README.md: # My Project\n\nThis is my project.
```

注意: Write 工具会覆盖整个文件内容。如果需要修改文件的特定部分，请使用 Edit 工具。

- file_path: 文件路径（必需）
- content: 文件内容（必需）

```
file_path
```

```
content
```

##### Edit 工具#

Edit 工具用于编辑文件的特定部分，支持搜索替换、插入、删除等操作。

```
bash复制编辑文件 [文件路径]
```

```
编辑文件 [文件路径]
```

```
bash复制修改函数签名: 将 function add(a, b) 改为 function add(a: number, b: number): number
更新导入语句: 将 import React from 'react' 改为 import * as React from 'react'
```

```
修改函数签名: 将 function add(a, b) 改为 function add(a: number, b: number): number
更新导入语句: 将 import React from 'react' 改为 import * as React from 'react'
```

- 精确修改: 只修改目标部分，保留文件其他内容
- 安全: 减少意外更改整个文件的风险
- 高效: 无需手动查找和替换

- file_path: 文件路径（必需）
- old_str: 要替换的旧内容（必需）
- new_str: 替换后的新内容（必需）

```
file_path
```

```
old_str
```

```
new_str
```

##### Delete 工具#

Delete 工具用于删除文件或目录。

```
bash复制删除文件 [文件路径]
```

```
删除文件 [文件路径]
```

```
bash复制删除旧的配置文件: .env.old
清理临时文件: tmp/*.log
```

```
删除旧的配置文件: .env.old
清理临时文件: tmp/*.log
```

注意: 删除操作不可逆，请谨慎使用。在删除重要文件前，建议先备份。

- file_path: 文件或目录路径（必需）

```
file_path
```

##### Glob 工具#

Glob 工具用于按模式查找文件，支持通配符匹配。

```
bash复制查找文件 [模式]
```

```
查找文件 [模式]
```

```
bash复制查找所有 JavaScript 文件: *.js
查找所有测试文件: **/*.test.js
```

```
查找所有 JavaScript 文件: *.js
查找所有测试文件: **/*.test.js
```

- pattern: 文件匹配模式（必需）
- path: 搜索路径（可选，默认当前目录）

```
pattern
```

```
path
```

#### 2. 搜索工具#

##### Grep 工具#

Grep 工具用于在文件中搜索文本模式，支持正则表达式。

```
bash复制搜索 [模式] [路径]
```

```
搜索 [模式] [路径]
```

```
bash复制搜索所有 TODO 注释: TODO
查找包含 "error" 的文件: error
搜索特定函数调用: functionName\(\)
```

```
搜索所有 TODO 注释: TODO
查找包含 "error" 的文件: error
搜索特定函数调用: functionName\(\)
```

- pattern: 搜索模式（必需，支持正则表达式）
- path: 搜索路径（可选，默认当前目录）
- glob: 文件模式（可选，限制搜索的文件类型）
- -i: 忽略大小写（可选）
- -v: 反向匹配（可选，显示不匹配的行）

```
pattern
```

```
path
```

```
glob
```

```
-i
```

```
-v
```

```
json复制{
  "matches": [
    {
      "file_path": "src/App.js",
      "line_number": 42,
      "line_content": "// TODO: Add error handling"
    },
    {
      "file_path": "src/utils.js",
      "line_number": 100,
      "line_content": "// TODO: Optimize performance"
    }
  ]
}
```

```
{
  "matches": [
    {
      "file_path": "src/App.js",
      "line_number": 42,
      "line_content": "// TODO: Add error handling"
    },
    {
      "file_path": "src/utils.js",
      "line_number": 100,
      "line_content": "// TODO: Optimize performance"
    }
  ]
}
```

##### SearchCodebase 工具#

SearchCodebase 工具用于语义搜索代码库，查找与查询相关的代码片段。

```
bash复制搜索代码 [查询]
```

```
搜索代码 [查询]
```

```
bash复制搜索代码: 处理用户认证的函数
搜索代码: 实现数据缓存的逻辑
```

```
搜索代码: 处理用户认证的函数
搜索代码: 实现数据缓存的逻辑
```

- 语义理解: 理解代码的含义，而不仅仅是文本匹配
- 跨文件搜索: 搜索整个代码库
- 智能推荐: 提供相关的代码片段

- query: 搜索查询（必需）
- limit: 返回结果数量（可选，默认 10）

```
query
```

```
limit
```

##### Find 工具#

Find 工具用于查找文件和目录，支持复杂的搜索条件。

```
bash复制查找 [条件]
```

```
查找 [条件]
```

```
bash复制查找所有大于 1MB 的文件
查找最近 7 天修改的文件
```

```
查找所有大于 1MB 的文件
查找最近 7 天修改的文件
```

- size: 文件大小条件（可选）
- mtime: 修改时间条件（可选）
- type: 文件类型（可选，f 表示文件，d 表示目录）

```
size
```

```
mtime
```

```
type
```

#### 3. 命令执行工具#

##### Bash 工具#

Bash 工具用于执行 shell 命令。

```
bash复制执行命令 [命令]
```

```
执行命令 [命令]
```

```
bash复制执行命令: npm install
执行命令: git status
执行命令: ls -la
```

```
执行命令: npm install
执行命令: git status
执行命令: ls -la
```

- command: 要执行的 shell 命令（必需）
- cwd: 工作目录（可选，默认当前目录）

```
command
```

```
cwd
```

```
json复制{
  "command": "npm install",
  "exit_code": 0,
  "output": "added 1423 packages in 2m",
  "error": ""
}
```

```
{
  "command": "npm install",
  "exit_code": 0,
  "output": "added 1423 packages in 2m",
  "error": ""
}
```

##### RunCommand 工具#

RunCommand 工具用于运行特定命令或脚本，提供更多的控制选项。

```
bash复制运行命令 [命令]
```

```
运行命令 [命令]
```

```
bash复制运行命令: python script.py
运行命令: ./build.sh
```

```
运行命令: python script.py
运行命令: ./build.sh
```

- command: 要运行的命令（必需）
- env: 环境变量（可选）
- timeout: 超时时间（可选）

```
command
```

```
env
```

```
timeout
```

##### Background 工具#

Background 工具用于在后台运行命令，允许您继续其他操作。

```
bash复制在后台运行 [命令]
```

```
在后台运行 [命令]
```

```
bash复制在后台运行: npm run dev
在后台运行: webpack --watch
```

```
在后台运行: npm run dev
在后台运行: webpack --watch
```

- command: 要在后台运行的命令（必需）
- task_id: 任务 ID（可选，用于后续管理）

```
command
```

```
task_id
```

#### 4. 项目管理工具#

##### Git 工具#

Git 工具用于执行 Git 操作，如提交、推送、拉取等。

```
bash复制Git [操作]
```

```
Git [操作]
```

```
bash复制Git 提交: git commit -m "Add new feature"
Git 推送: git push origin main
Git 拉取: git pull origin main
```

```
Git 提交: git commit -m "Add new feature"
Git 推送: git push origin main
Git 拉取: git pull origin main
```

- operation: Git 操作（必需）

```
operation
```

##### NPM 工具#

NPM 工具用于执行 NPM 操作，如安装、更新、构建等。

```
bash复制NPM [操作]
```

```
NPM [操作]
```

```
bash复制NPM 安装: npm install react
NPM 更新: npm update
NPM 构建: npm run build
```

```
NPM 安装: npm install react
NPM 更新: npm update
NPM 构建: npm run build
```

- operation: NPM 操作（必需）

```
operation
```

##### Docker 工具#

Docker 工具用于执行 Docker 操作，如构建、运行、推送等。

```
bash复制Docker [操作]
```

```
Docker [操作]
```

```
bash复制Docker 构建: docker build -t my-image .
Docker 运行: docker run -p 8080:80 my-image
Docker 推送: docker push my-image
```

```
Docker 构建: docker build -t my-image .
Docker 运行: docker run -p 8080:80 my-image
Docker 推送: docker push my-image
```

- operation: Docker 操作（必需）

```
operation
```

#### 5. 集成工具#

##### MCP 工具#

MCP（模型上下文协议）工具用于与外部服务交互，扩展 Claude 的能力。

```
bash复制MCP [服务] [操作]
```

```
MCP [服务] [操作]
```

```
bash复制MCP 数据库 查询: SELECT * FROM users
MCP API 调用: GET /api/data
```

```
MCP 数据库 查询: SELECT * FROM users
MCP API 调用: GET /api/data
```

- service: 要交互的服务（必需）
- operation: 要执行的操作（必需）

```
service
```

```
operation
```

##### Plugins 工具#

Plugins 工具用于加载和管理插件，扩展 Claude 的功能。

```
bash复制插件 [操作]
```

```
插件 [操作]
```

```
bash复制插件 安装: my-plugin
插件 启用: my-plugin
插件 禁用: my-plugin
```

```
插件 安装: my-plugin
插件 启用: my-plugin
插件 禁用: my-plugin
```

- operation: 插件操作（必需）

```
operation
```

##### Skills 工具#

Skills 工具用于加载和使用技能，提供特定领域的专业知识。

```
bash复制技能 [名称]
```

```
技能 [名称]
```

```
bash复制技能 前端开发
技能 数据分析
技能 机器学习
```

```
技能 前端开发
技能 数据分析
技能 机器学习
```

- name: 技能名称（必需）

```
name
```

#### 工具选择指南#

选择合适的工具可以提高工作效率，以下是一些选择建议：

True. 文件操作: 使用 Read、Write、Edit、Delete 工具
True. 文本搜索: 使用 Grep 工具
True. 代码搜索: 使用 SearchCodebase 工具
True. 命令执行: 使用 Bash 或 RunCommand 工具
True. 后台任务: 使用 Background 工具
True. 项目管理: 使用 Git、NPM、Docker 工具
True. 外部集成: 使用 MCP 工具

通过熟练掌握这些内置工具，您可以充分发挥 Claude Code 的能力，高效完成各种开发任务。

---

## 3 自定义工具开发

**URL**: https://claudecode.tangshuang.net/course/10.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91

Claude Code 提供了灵活的扩展机制，允许您开发自定义工具来满足特定需求。通过自定义工具，您可以扩展 Claude 的功能，集成外部服务，自动化工作流，提高开发效率。

#### 自定义工具的方式#

Claude Code 支持两种主要的自定义工具开发方式：插件工具和技能工具。

##### 1. 插件工具#

插件工具是一种功能强大的扩展方式，允许您创建复杂的、可分享的工具。

- 可分享和分发: 插件可以打包并分享给团队成员或社区
- 支持复杂功能: 可以实现复杂的业务逻辑和工作流
- 可集成外部服务: 可以与各种外部服务和 API 集成
- 完整的生命周期管理: 支持安装、更新、卸载等操作

- 团队共享工具和工作流
- 复杂的业务逻辑实现
- 外部服务集成
- 需要频繁使用的工具

##### 2. 技能工具#

技能工具是一种轻量级的扩展方式，适合快速创建简单的功能。

- 简单易用: 无需复杂的开发和配置
- 快速创建: 可以在短时间内创建并使用
- 灵活配置: 支持通过配置文件自定义行为
- 低学习成本: 无需学习复杂的开发框架

- 个人工作流自动化
- 简单任务的快速实现
- 快速原型验证
- 临时工具的创建

#### 创建插件工具#

##### 插件结构#

一个典型的 Claude Code 插件具有以下结构：

```
bash复制my-plugin/
├── plugin.json          # 插件配置文件
├── commands/            # 自定义命令目录
│   └── my-command.md    # 自定义命令定义
├── skills/              # 自定义技能目录
│   └── my-skill/        # 技能目录
│       └── SKILL.md     # 技能定义文件
├── tools/               # 自定义工具目录
│   └── my-tool.ts       # 工具实现代码
├── assets/              # 静态资源目录
│   └── logo.png         # 插件图标
└── README.md            # 插件文档
```

```
my-plugin/
├── plugin.json          # 插件配置文件
├── commands/            # 自定义命令目录
│   └── my-command.md    # 自定义命令定义
├── skills/              # 自定义技能目录
│   └── my-skill/        # 技能目录
│       └── SKILL.md     # 技能定义文件
├── tools/               # 自定义工具目录
│   └── my-tool.ts       # 工具实现代码
├── assets/              # 静态资源目录
│   └── logo.png         # 插件图标
└── README.md            # 插件文档
```

##### plugin.json 配置#

plugin.json 是插件的核心配置文件，定义了插件的基本信息和功能。

```
json复制{
  "name": "my-plugin",
  "version": "1.0.0",
  "description": "My custom plugin for Claude Code",
  "author": "John Doe",
  "license": "MIT",
  "homepage": "https://github.com/johndoe/my-plugin",
  "commands": [
    {
      "name": "my-command",
      "description": "My custom command",
      "usage": "/my-command [options]",
      "aliases": ["mc"]
```

```
{
  "name": "my-plugin",
  "version": "1.0.0",
  "description": "My custom plugin for Claude Code",
  "author": "John Doe",
  "license": "MIT",
  "homepage": "https://github.com/johndoe/my-plugin",
  "commands": [
    {
      "name": "my-command",
      "description": "My custom command",
      "usage": "/my-command [options]",
      "aliases": ["mc"]
```

```
bash复制}
```

```
}
```

],
"skills": [
{
"name": "my-skill",
"description": "A custom skill for specific tasks",
"category": "development"
}
],
"tools": [
{
"name": "my-tool",
"description": "A custom tool for advanced operations",
"type": "command-line"
}
],
"dependencies": {
"axios": "^1.0.0",
"lodash": "^4.0.0"
}
}

```
bash复制
### 创建自定义命令

自定义命令允许您创建新的 Claude 命令，扩展其功能。

**命令定义文件 (my-command.md)**:

```markdown
# My Custom Command

This is a custom command for my plugin.

## Usage

```bash
/my-command [options] [arguments]
```

```
### 创建自定义命令

自定义命令允许您创建新的 Claude 命令，扩展其功能。

**命令定义文件 (my-command.md)**:

```markdown
# My Custom Command

This is a custom command for my plugin.

## Usage

```bash
/my-command [options] [arguments]
```

#### Options#

```
--help
```

```
--verbose
```

```
--output <file>
```

```
--timeout <ms>
```

#### Examples#

```
bash复制# Basic usage
/my-command

# Verbose output
/my-command --verbose

# Save output to file
/my-command --output result.txt

# With timeout
/my-command --timeout 10000
```

```
# Basic usage
/my-command

# Verbose output
/my-command --verbose

# Save output to file
/my-command --output result.txt

# With timeout
/my-command --timeout 10000
```

#### Implementation#

```
typescript复制import axios from 'axios';

export async function run(options: any) {
  if (options.help) {
    return showHelp();
  }

  try {
    const result = await axios.get('https://api.example.com/data');

    if (options.verbose) {
      console.log('Request successful:', result.data);
    }

    return result.data;
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}
```

```
import axios from 'axios';

export async function run(options: any) {
  if (options.help) {
    return showHelp();
  }

  try {
    const result = await axios.get('https://api.example.com/data');

    if (options.verbose) {
      console.log('Request successful:', result.data);
    }

    return result.data;
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}
```

##### 创建自定义技能#

技能是一种轻量级的扩展方式，适合定义特定任务的处理流程。

技能定义文件 (SKILL.md):

```
yaml复制---
name: my-skill
description: A custom skill for specific tasks
category: development
author: John Doe
version: 1.0.0
---

# My Skill

## Instructions

1. **Analyze the input**: Understand the user's request and extract key information
2. **Process the data**: Perform necessary transformations and calculations
3. **Generate output**: Create the final result based on the processed data
4. **Review and refine**: Check the output for quality and accuracy

## Examples

### Example 1: Simple task

**Input**: "Convert this JSON to CSV"
**Output**: "Here's the CSV version of your data..."

### Example 2: Complex task

**Input**: "Analyze this code and suggest improvements"
**Output**: "I've analyzed your code. Here are my suggestions..."

## Constraints

- Do not share sensitive information
- Keep responses concise and focused
- Follow best practices for the target language
- Provide clear explanations for all recommendations

## Tools to Use

- **Read**: To read code files
- **Grep**: To search for specific patterns
- **Edit**: To make code changes
- **Bash**: To run tests and validations

## Success Criteria

- The output meets the user's requirements
- The solution is efficient and optimal
- The explanation is clear and understandable
- The code follows best practices
```

```
---
name: my-skill
description: A custom skill for specific tasks
category: development
author: John Doe
version: 1.0.0
---

# My Skill

## Instructions

1. **Analyze the input**: Understand the user's request and extract key information
2. **Process the data**: Perform necessary transformations and calculations
3. **Generate output**: Create the final result based on the processed data
4. **Review and refine**: Check the output for quality and accuracy

## Examples

### Example 1: Simple task

**Input**: "Convert this JSON to CSV"
**Output**: "Here's the CSV version of your data..."

### Example 2: Complex task

**Input**: "Analyze this code and suggest improvements"
**Output**: "I've analyzed your code. Here are my suggestions..."

## Constraints

- Do not share sensitive information
- Keep responses concise and focused
- Follow best practices for the target language
- Provide clear explanations for all recommendations

## Tools to Use

- **Read**: To read code files
- **Grep**: To search for specific patterns
- **Edit**: To make code changes
- **Bash**: To run tests and validations

## Success Criteria

- The output meets the user's requirements
- The solution is efficient and optimal
- The explanation is clear and understandable
- The code follows best practices
```

##### 创建自定义工具#

自定义工具允许您创建功能强大的扩展，实现复杂的业务逻辑。

工具实现文件 (my-tool.ts):

```
typescript复制import { Tool } from '@claude-code/plugin-api';

export class MyTool implements Tool {
  name = 'my-tool';
  description = 'A custom tool for advanced operations';

  async run(args: string[], options: any) {
    // 解析参数
    const [inputFile, outputFile] = args;

    // 执行操作
    const result = await this.processFile(inputFile);

    // 保存结果
    if (outputFile) {
      await this.saveResult(outputFile, result);
    }

    return result;
  }

  private async processFile(filePath: string) {
    // 实现文件处理逻辑
    const content = await this.readFile(filePath);
    const processed = this.transformContent(content);
    return processed;
  }

  private async readFile(filePath: string) {
    // 实现文件读取逻辑
    const fs = require('fs').promises;
    return await fs.readFile(filePath, 'utf8');
  }

  private transformContent(content: string) {
    // 实现内容转换逻辑
    return content.toUpperCase();
  }

  private async saveResult(filePath: string, content: string) {
    // 实现结果保存逻辑
    const fs = require('fs').promises;
    await fs.writeFile(filePath, content, 'utf8');
  }
}
```

```
import { Tool } from '@claude-code/plugin-api';

export class MyTool implements Tool {
  name = 'my-tool';
  description = 'A custom tool for advanced operations';

  async run(args: string[], options: any) {
    // 解析参数
    const [inputFile, outputFile] = args;

    // 执行操作
    const result = await this.processFile(inputFile);

    // 保存结果
    if (outputFile) {
      await this.saveResult(outputFile, result);
    }

    return result;
  }

  private async processFile(filePath: string) {
    // 实现文件处理逻辑
    const content = await this.readFile(filePath);
    const processed = this.transformContent(content);
    return processed;
  }

  private async readFile(filePath: string) {
    // 实现文件读取逻辑
    const fs = require('fs').promises;
    return await fs.readFile(filePath, 'utf8');
  }

  private transformContent(content: string) {
    // 实现内容转换逻辑
    return content.toUpperCase();
  }

  private async saveResult(filePath: string, content: string) {
    // 实现结果保存逻辑
    const fs = require('fs').promises;
    await fs.writeFile(filePath, content, 'utf8');
  }
}
```

#### 技能工具开发#

##### 技能文件结构#

技能文件采用 YAML 格式，包含元数据和技能定义。

```
yaml复制---
name: data-analyzer
description: Analyze and visualize data
author: Jane Smith
version: 1.0.0
category: data-science
---

# Data Analyzer Skill

## Purpose

This skill helps users analyze and visualize data from various sources.

## Capabilities

- Import data from CSV, JSON, and Excel files
- Clean and preprocess data
- Perform statistical analysis
- Generate visualizations (charts, graphs)
- Export results to various formats

## Workflow

1. **Data Import**: Read data from input files
2. **Data Cleaning**: Handle missing values, remove duplicates
3. **Analysis**: Perform descriptive and inferential statistics
4. **Visualization**: Create charts and graphs
5. **Export**: Save results to files

## Tools to Use

- **Read**: To read data files
- **Bash**: To run data processing commands
- **Write**: To save results
- **MCP**: To integrate with data analysis services

## Examples

### Example 1: Basic data analysis

**User Request**: "Analyze this CSV file and show me the summary statistics"
**Action**: Read the CSV file, perform statistical analysis, show summary

### Example 2: Data visualization

**User Request**: "Create a bar chart from this JSON data"
**Action**: Read the JSON data, generate bar chart, display results

## Best Practices

- Always validate input data
- Provide clear explanations for results
- Use appropriate visualization types
- Optimize performance for large datasets
- Handle errors gracefully
```

```
---
name: data-analyzer
description: Analyze and visualize data
author: Jane Smith
version: 1.0.0
category: data-science
---

# Data Analyzer Skill

## Purpose

This skill helps users analyze and visualize data from various sources.

## Capabilities

- Import data from CSV, JSON, and Excel files
- Clean and preprocess data
- Perform statistical analysis
- Generate visualizations (charts, graphs)
- Export results to various formats

## Workflow

1. **Data Import**: Read data from input files
2. **Data Cleaning**: Handle missing values, remove duplicates
3. **Analysis**: Perform descriptive and inferential statistics
4. **Visualization**: Create charts and graphs
5. **Export**: Save results to files

## Tools to Use

- **Read**: To read data files
- **Bash**: To run data processing commands
- **Write**: To save results
- **MCP**: To integrate with data analysis services

## Examples

### Example 1: Basic data analysis

**User Request**: "Analyze this CSV file and show me the summary statistics"
**Action**: Read the CSV file, perform statistical analysis, show summary

### Example 2: Data visualization

**User Request**: "Create a bar chart from this JSON data"
**Action**: Read the JSON data, generate bar chart, display results

## Best Practices

- Always validate input data
- Provide clear explanations for results
- Use appropriate visualization types
- Optimize performance for large datasets
- Handle errors gracefully
```

#### 插件发布和分发#

##### 打包插件#

```
bash复制# 打包插件
claude plugin package my-plugin

# 生成插件包
my-plugin-1.0.0.claude-plugin
```

```
# 打包插件
claude plugin package my-plugin

# 生成插件包
my-plugin-1.0.0.claude-plugin
```

##### 发布插件#

```
bash复制# 发布到 Claude 插件市场
claude plugin publish my-plugin-1.0.0.claude-plugin
```

```
# 发布到 Claude 插件市场
claude plugin publish my-plugin-1.0.0.claude-plugin
```

##### 安装插件#

```
bash复制# 从本地文件安装
claude plugin install my-plugin-1.0.0.claude-plugin

# 从市场安装
claude plugin install my-plugin
```

```
# 从本地文件安装
claude plugin install my-plugin-1.0.0.claude-plugin

# 从市场安装
claude plugin install my-plugin
```

#### 调试和测试#

##### 调试插件#

```
bash复制# 启动调试模式
claude plugin debug my-plugin

# 查看日志
claude plugin logs my-plugin
```

```
# 启动调试模式
claude plugin debug my-plugin

# 查看日志
claude plugin logs my-plugin
```

##### 测试插件#

```
bash复制# 运行单元测试
claude plugin test my-plugin

# 运行集成测试
claude plugin test --integration my-plugin
```

```
# 运行单元测试
claude plugin test my-plugin

# 运行集成测试
claude plugin test --integration my-plugin
```

#### 性能优化#

##### 代码优化#

- 使用异步操作提高响应速度
- 缓存频繁使用的数据
- 避免不必要的计算
- 使用高效的算法和数据结构

##### 资源管理#

- 及时释放资源
- 限制并发请求数量
- 优化内存使用
- 压缩静态资源

#### 安全考虑#

##### 输入验证#

- 对所有用户输入进行验证
- 防止 SQL 注入和 XSS 攻击
- 限制文件访问范围
- 验证外部 API 响应

##### 权限管理#

- 最小权限原则
- 细粒度的权限控制
- 安全的配置管理
- 审计和日志记录

#### 未来发展#

##### 趋势#

- 更强大的插件 API
- 更好的开发工具和调试支持
- 更丰富的插件市场
- 更好的性能和扩展性

##### 建议#

- 关注官方文档和更新
- 参与社区讨论和贡献
- 学习最佳实践
- 持续改进和优化

通过自定义工具开发，您可以充分发挥 Claude Code 的潜力，创建适合自己和团队需求的工具和工作流。
git push

True. 团队成员安装:
git pull

### 技能自动可用

```
bash复制## 高级功能
### 工具链
创建工具链完成复杂任务：
```

```
## 高级功能
### 工具链
创建工具链完成复杂任务：
```

#### name: data-pipeline
description: Complete data processing pipeline from extraction to analysis#

### Data Pipeline

#### Instructions#

True. Extract data from source
True. Transform and clean
True. Load to destination
True. Generate report

##### 条件逻辑#

在技能中添加条件逻辑：

#### Instructions#

If the file is CSV:

True. Use pandas to read
True. Process with pandas
If the file is JSON:
True. Use json module
True. Process with json

```
bash复制### 错误处理
添加错误处理指导：
```

```
### 错误处理
添加错误处理指导：
```

markdown

#### Error Handling#

If file not found:

True. Check file path
True. Suggest similar files
True. Ask for confirmation

If format invalid:

True. Identify format issue
True. Suggest fixes
True. Provide example

#### 维护和更新#

##### 版本管理#

使用语义化版本：

{
"version": "1.2.3"
}

```
bash复制### 更新日志
维护 CHANGELOG.md：
```

```
### 更新日志
维护 CHANGELOG.md：
```

markdown

#### [1.2.3] - 2024-01-15#

##### Added#

- New feature X

##### Fixed#

- Bug Y

##### 文档更新#

保持文档同步：

#### Documentation#

- SKILL.md: Main documentation
- README.md: User guide
- API.md: API reference

---

## 4 工具集成最佳实践

**URL**: https://claudecode.tangshuang.net/course/10.4%20%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5

工具集成是提高开发效率的关键。通过合理的工具集成，您可以自动化工作流，减少重复劳动，提高开发质量。本节介绍工具集成的最佳实践。

#### 设计原则#

##### 1. 单一职责#

每个工具应该专注于一个特定功能，遵循单一职责原则。

```
yaml复制name: pdf-extractor
description: Extract text from PDF files
```

```
name: pdf-extractor
description: Extract text from PDF files
```

不好的设计:

```
yaml复制name: document-tool
description: Handle all document operations
```

```
name: document-tool
description: Handle all document operations
```

- 单一职责的工具更容易维护和扩展
- 更容易测试和调试
- 提高工具的可重用性

##### 2. 可组合性#

工具应该能够轻松组合使用，形成更复杂的工作流。

```
bash复制# 1. 提取数据
使用 data-extractor 提取数据

# 2. 处理数据
使用 data-processor 处理数据

# 3. 生成报告
使用 report-generator 生成报告
```

```
# 1. 提取数据
使用 data-extractor 提取数据

# 2. 处理数据
使用 data-processor 处理数据

# 3. 生成报告
使用 report-generator 生成报告
```

- 设计工具时考虑与其他工具的兼容性
- 提供标准化的输入输出格式
- 支持管道操作

##### 3. 可重用性#

工具应该在不同场景下都能使用，提高投资回报率。

```
yaml复制name: file-validator
description: Validate files against schema
```

```
name: file-validator
description: Validate files against schema
```

- 配置文件验证
- 数据文件验证
- 文档文件验证

- 设计通用接口
- 支持配置参数
- 避免硬编码

##### 4. 错误处理#

提供清晰的错误信息和恢复建议，帮助用户快速解决问题。

```
yaml复制---
name: data-validator
description: Validate data against schema
---

## Error Handling

If validation fails:

1. **Identify the issue**: Show the specific validation error
2. **Provide context**: Show the line number and field name
3. **Suggest fix**: Provide examples of valid values
4. **Offer help**: Explain how to fix the issue
```

```
---
name: data-validator
description: Validate data against schema
---

## Error Handling

If validation fails:

1. **Identify the issue**: Show the specific validation error
2. **Provide context**: Show the line number and field name
3. **Suggest fix**: Provide examples of valid values
4. **Offer help**: Explain how to fix the issue
```

- 提供具体的错误信息
- 给出明确的解决建议
- 保持错误信息简洁明了
- 避免技术术语过载

##### 5. 性能优化#

工具应该具有良好的性能，特别是处理大量数据时。

- 异步处理
- 缓存机制
- 批量处理
- 资源限制

##### 6. 安全性#

工具应该遵循安全最佳实践，保护用户数据和系统安全。

- 输入验证
- 权限控制
- 数据加密
- 安全审计

#### 工具组合模式#

##### 顺序模式#

按顺序执行多个工具，前一个工具的输出作为后一个工具的输入。

```
bash复制# 数据处理管道

# 1. 读取数据
使用 file-reader 读取 data.csv

# 2. 转换格式
使用 csv-to-json 转换格式

# 3. 验证数据
使用 json-validator 验证数据

# 4. 保存结果
使用 file-writer 保存 output.json
```

```
# 数据处理管道

# 1. 读取数据
使用 file-reader 读取 data.csv

# 2. 转换格式
使用 csv-to-json 转换格式

# 3. 验证数据
使用 json-validator 验证数据

# 4. 保存结果
使用 file-writer 保存 output.json
```

- 数据处理工作流
- 构建和部署流程
- 文档转换流程

##### 并行模式#

同时执行多个独立工具，提高处理效率。

```
bash复制# 并行运行测试
在后台运行单元测试
在后台运行集成测试
在后台运行端到端测试
```

```
# 并行运行测试
在后台运行单元测试
在后台运行集成测试
在后台运行端到端测试
```

- 并行测试
- 多数据源处理
- 并发任务执行

##### 条件模式#

根据条件选择不同的工具执行。

```
bash复制# 根据文件类型选择工具
如果是 PDF，使用 pdf-processor
如果是 Word，使用 word-processor
如果是 Excel，使用 excel-processor
```

```
# 根据文件类型选择工具
如果是 PDF，使用 pdf-processor
如果是 Word，使用 word-processor
如果是 Excel，使用 excel-processor
```

- 多格式处理
- 分支工作流
- 动态决策

##### 循环模式#

对多个项目重复使用工具，实现批量处理。

```
bash复制# 批量处理文件
对所有 .csv 文件使用 data-processor
```

```
# 批量处理文件
对所有 .csv 文件使用 data-processor
```

- 批量数据处理
- 多文件转换
- 批量测试

##### 递归模式#

递归地应用工具到子项目或子目录。

```
bash复制# 递归处理目录
对所有子目录使用 code-analyzer
```

```
# 递归处理目录
对所有子目录使用 code-analyzer
```

- 代码库分析
- 目录结构处理
- 递归搜索

#### 集成策略#

##### 1. MCP 集成#

通过 MCP 服务器集成外部服务，扩展 Claude 的功能。

```
bash复制# 集成 GitHub
使用 mcp github get-repo octocat/Hello-World
```

```
# 集成 GitHub
使用 mcp github get-repo octocat/Hello-World
```

- 使用标准 MCP 协议
- 实现错误处理
- 提供清晰的文档
- 支持配置参数

##### 2. API 集成#

直接集成外部 API，实现功能扩展。

```
typescript复制import axios from 'axios';

export async function fetchWeather(city: string) {
  const response = await axios.get(`https://api.weather.com/v1/current/${city}`);
  return response.data;
}
```

```
import axios from 'axios';

export async function fetchWeather(city: string) {
  const response = await axios.get(`https://api.weather.com/v1/current/${city}`);
  return response.data;
}
```

- 使用异步操作
- 实现重试机制
- 处理 API 限制
- 缓存 API 响应

##### 3. 命令行集成#

集成命令行工具，利用现有生态系统。

```
bash复制# 使用 git 命令
在后台运行 git clone https://github.com/octocat/Hello-World
```

```
# 使用 git 命令
在后台运行 git clone https://github.com/octocat/Hello-World
```

- 处理命令行输出
- 实现错误处理
- 支持参数传递
- 提供进度反馈

##### 4. 插件集成#

通过插件系统集成第三方工具。

```
bash复制# 安装插件
claude plugin install weather-plugin

# 使用插件
使用 weather-plugin get-weather Beijing
```

```
# 安装插件
claude plugin install weather-plugin

# 使用插件
使用 weather-plugin get-weather Beijing
```

- 遵循插件开发规范
- 提供清晰的文档
- 支持版本管理
- 实现插件间通信

#### 性能优化#

##### 1. 缓存策略#

```
typescript复制const cache = new Map();

export async function fetchData(key: string) {
  if (cache.has(key)) {
    return cache.get(key);
  }

  const data = await fetchFromAPI(key);
  cache.set(key, data);
  return data;
}
```

```
const cache = new Map();

export async function fetchData(key: string) {
  if (cache.has(key)) {
    return cache.get(key);
  }

  const data = await fetchFromAPI(key);
  cache.set(key, data);
  return data;
}
```

##### 2. 批量处理#

```
bash复制# 批量处理文件
使用 data-processor 处理 *.csv
```

```
# 批量处理文件
使用 data-processor 处理 *.csv
```

##### 3. 异步处理#

```
typescript复制export async function processFiles(files: string[]) {
  const promises = files.map(file => processFile(file));
  return await Promise.all(promises);
}
```

```
export async function processFiles(files: string[]) {
  const promises = files.map(file => processFile(file));
  return await Promise.all(promises);
}
```

#### 安全最佳实践#

##### 1. 输入验证#

```
typescript复制export function validateInput(input: string) {
  if (!input || input.length > 1000) {
    throw new Error('Invalid input');
  }
  return input;
}
```

```
export function validateInput(input: string) {
  if (!input || input.length > 1000) {
    throw new Error('Invalid input');
  }
  return input;
}
```

##### 2. 权限控制#

```
yaml复制---
name: admin-tool
description: Admin operations
---

## Permissions

- Requires admin role
- Can only be used by authorized users
- Logs all operations
```

```
---
name: admin-tool
description: Admin operations
---

## Permissions

- Requires admin role
- Can only be used by authorized users
- Logs all operations
```

##### 3. 数据加密#

```
typescript复制import crypto from 'crypto';

export function encryptData(data: string, key: string) {
  const cipher = crypto.createCipher('aes192', key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}
```

```
import crypto from 'crypto';

export function encryptData(data: string, key: string) {
  const cipher = crypto.createCipher('aes192', key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}
```

#### 文档和支持#

##### 1. 文档规范#

- 提供清晰的使用说明
- 包含示例代码
- 解释参数和返回值
- 提供故障排除指南

##### 2. 支持渠道#

- 提供 GitHub Issues
- 创建 Discord/Slack 社区
- 提供邮件支持
- 定期更新文档

#### 监控和维护#

##### 1. 监控工具#

```
typescript复制export function monitorTool(toolName: string) {
  const startTime = Date.now();

  return {
    start: () => startTime,
    end: () => {
      const duration = Date.now() - startTime;
      console.log(`${toolName} took ${duration}ms`);
    }
  };
}
```

```
export function monitorTool(toolName: string) {
  const startTime = Date.now();

  return {
    start: () => startTime,
    end: () => {
      const duration = Date.now() - startTime;
      console.log(`${toolName} took ${duration}ms`);
    }
  };
}
```

##### 2. 维护策略#

- 定期更新依赖
- 修复安全漏洞
- 优化性能
- 添加新功能

#### 案例研究#

##### 案例 1: 数据处理管道#

需求: 处理大量 CSV 数据，生成报告

```
bash复制# 1. 批量读取 CSV 文件
使用 file-reader 读取 *.csv

# 2. 转换为 JSON
使用 csv-to-json 转换格式

# 3. 验证数据
使用 json-validator 验证

# 4. 分析数据
使用 data-analyzer 分析

# 5. 生成报告
使用 report-generator 生成报告
```

```
# 1. 批量读取 CSV 文件
使用 file-reader 读取 *.csv

# 2. 转换为 JSON
使用 csv-to-json 转换格式

# 3. 验证数据
使用 json-validator 验证

# 4. 分析数据
使用 data-analyzer 分析

# 5. 生成报告
使用 report-generator 生成报告
```

结果: 自动化处理流程，提高效率 10 倍

##### 案例 2: 自动化测试#

需求: 自动化测试流程

```
bash复制# 1. 并行运行测试
在后台运行单元测试
在后台运行集成测试
在后台运行端到端测试

# 2. 收集测试结果
使用 test-results 收集结果

# 3. 生成测试报告
使用 report-generator 生成报告
```

```
# 1. 并行运行测试
在后台运行单元测试
在后台运行集成测试
在后台运行端到端测试

# 2. 收集测试结果
使用 test-results 收集结果

# 3. 生成测试报告
使用 report-generator 生成报告
```

结果: 测试时间减少 70%

#### 未来趋势#

##### 1. AI 驱动的集成#

- 自动发现工具
- 智能推荐组合
- 自动生成工作流

##### 2. 标准化接口#

- 统一的工具接口
- 互操作性增强
- 跨平台支持

##### 3. 云原生集成#

- 云服务集成
- 容器化部署
- 微服务架构

通过遵循这些最佳实践，您可以创建高效、可靠、安全的工具集成，提高开发效率，减少错误，提升整体开发体验。

#### Error Recovery#

If download fails:

```
bash复制## 安全考虑
### 1. 权限控制
限制工具访问权限。
```

```
## 安全考虑
### 1. 权限控制
限制工具访问权限。
```

allowed-tools: Read, Grep, Glob

##### 2. 输入验证#

验证工具输入。

#### Validation#

Check input:

```
bash复制### 3. 输出清理
清理工具输出。
```

```
### 3. 输出清理
清理工具输出。
```

### 移除敏感信息

清理日志中的密码

#### 监控和调试#

##### 1. 日志记录#

记录工具执行。

### 启用详细日志

claude --verbose

```
bash复制### 2. 性能监控
监控工具性能。
```

```
### 2. 性能监控
监控工具性能。
```

### 测量执行时间

记录工具执行时间

##### 3. 错误跟踪#

跟踪工具错误。

### 记录错误

记录所有工具错误到日志文件

```
bash复制## 文档和示例
### 1. 清晰的文档
提供详细的工具文档。
```

```
## 文档和示例
### 1. 清晰的文档
提供详细的工具文档。
```

markdown

### Tool Name

#### Description#

Brief description of what the tool does.

#### Usage#

How to use the tool.

#### Examples#

Concrete examples.

#### Parameters#

Tool parameters.

#### Error Handling#

How errors are handled.

##### 2. 丰富的示例#

提供多种使用示例。

#### Examples#

##### Example 1: Basic usage#

Basic example

##### Example 2: Advanced usage#

Advanced example

##### Example 3: Edge case#

Edge case example

```
bash复制### 3. 最佳实践指南
提供使用指南。
```

```
### 3. 最佳实践指南
提供使用指南。
```

markdown

#### Best Practices#

#### 测试策略#

##### 1. 单元测试#

测试单个工具。

### 测试工具功能

测试 pdf-extractor 的提取功能

```
bash复制### 2. 集成测试
测试工具组合。
```

```
### 2. 集成测试
测试工具组合。
```

### 测试工具链

测试完整的数据处理管道

##### 3. 端到端测试#

测试完整工作流。

### 测试完整流程

从数据提取到报告生成

```
bash复制## 维护和更新
### 1. 版本管理
使用语义化版本。
```

```
## 维护和更新
### 1. 版本管理
使用语义化版本。
```

{
"version": "1.2.3"
}

##### 2. 向后兼容#

保持向后兼容性。

#### Migration Guide#

How to migrate from version 1.0 to 2.0.

```
bash复制### 3. 弃用策略
提供弃用警告。
```

```
### 3. 弃用策略
提供弃用警告。
```

markdown

#### Deprecation#

This tool will be deprecated in version 2.0.
Use new-tool instead.

#### 团队协作#

##### 1. 代码审查#

审查工具代码。

### 代码审查

审查新工具的代码

```
bash复制### 2. 文档共享
共享工具文档。
```

```
### 2. 文档共享
共享工具文档。
```

### 共享文档

将工具文档添加到团队知识库

##### 3. 最佳实践#

建立团队最佳实践。

#### Team Guidelines#

True. Follow naming conventions
True. Write clear descriptions
True. Provide examples

```
bash复制~~~
```

```
~~~
```

---

## 5 工具调用案例分析

**URL**: https://claudecode.tangshuang.net/course/10.5%20%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90

通过实际案例学习如何有效使用工具调用，解决实际开发中的问题。

#### 案例 1: 代码重构#

##### 场景#

需要将一个大型 Node.js 项目中的回调风格代码重构为 async/await，提高代码可读性和可维护性。

##### 工具调用流程#

###### 步骤 1: 搜索目标文件

```
bash复制# 搜索包含回调模式的文件
搜索包含 "function.*callback" 的 .js 文件
```

```
# 搜索包含回调模式的文件
搜索包含 "function.*callback" 的 .js 文件
```

```
bash复制Found: src/auth.js, src/db.js, src/api.js, src/utils.js
```

```
Found: src/auth.js, src/db.js, src/api.js, src/utils.js
```

###### 步骤 2: 读取文件内容

```
bash复制# 读取第一个目标文件
读取 src/auth.js
```

```
# 读取第一个目标文件
读取 src/auth.js
```

```
javascript复制function authenticate(callback) {
  db.query('SELECT * FROM users', (err, result) => {
    if (err) return callback(err);
```

```
function authenticate(callback) {
  db.query('SELECT * FROM users', (err, result) => {
    if (err) return callback(err);
```

```
bash复制callback(null, result);
```

```
callback(null, result);
```

function createUser(userData, callback) {
db.insert('users', userData, (err, result) => {
if (err) return callback(err);
callback(null, result);
});
}

```
bash复制
#### 步骤 3: 重构代码

```bash
# 将 authenticate 函数重构为 async/await
编辑 src/auth.js
```

```
#### 步骤 3: 重构代码

```bash
# 将 authenticate 函数重构为 async/await
编辑 src/auth.js
```

重构后代码:

```
javascript复制async function authenticate() {
  const result = await db.query('SELECT * FROM users');
  return result;
}

async function createUser(userData) {
  const result = await db.insert('users', userData);
  return result;
}
```

```
async function authenticate() {
  const result = await db.query('SELECT * FROM users');
  return result;
}

async function createUser(userData) {
  const result = await db.insert('users', userData);
  return result;
}
```

###### 步骤 4: 更新调用处

```
bash复制# 查找所有调用 authenticate 的地方
搜索包含 "authenticate(" 的 .js 文件
```

```
# 查找所有调用 authenticate 的地方
搜索包含 "authenticate(" 的 .js 文件
```

```
bash复制Found: src/login.js, src/register.js, src/admin.js
```

```
Found: src/login.js, src/register.js, src/admin.js
```

```
bash复制# 更新调用处
编辑 src/login.js
```

```
# 更新调用处
编辑 src/login.js
```

```
javascript复制authenticate((err, result) => {
  if (err) console.error(err);
  console.log(result);
});
```

```
authenticate((err, result) => {
  if (err) console.error(err);
  console.log(result);
});
```

```
javascript复制const result = await authenticate();
console.log(result);
```

```
const result = await authenticate();
console.log(result);
```

##### 使用的工具#

- Grep: 搜索目标文件和调用处
- Read: 读取文件内容
- Edit: 编辑代码

##### 关键点#

True. 先理解代码结构: 全面了解项目中的回调模式
True. 逐步重构: 先重构核心函数，再更新调用处
True. 更新所有调用处: 确保所有使用该函数的地方都更新
True. 验证功能: 重构后测试确保功能正常
True. 批量处理: 对多个文件进行批量重构

#### 案例 2: 批量文件处理#

##### 场景#

需要批量处理多个 CSV 文件，提取数据并生成销售报告。

##### 工具调用流程#

###### 步骤 1: 查找所有 CSV 文件

```
bash复制# 查找所有 .csv 文件
查找所有 .csv 文件
```

```
# 查找所有 .csv 文件
查找所有 .csv 文件
```

```
bash复制Found: data/sales_2024_01.csv, data/sales_2024_02.csv, data/sales_2024_03.csv
```

```
Found: data/sales_2024_01.csv, data/sales_2024_02.csv, data/sales_2024_03.csv
```

###### 步骤 2: 创建处理脚本

```
bash复制# 创建 Python 脚本处理 CSV 文件
创建 process_csv.py
```

```
# 创建 Python 脚本处理 CSV 文件
创建 process_csv.py
```

```
python复制import pandas as pd
import glob
import os

# 创建输出目录
os.makedirs('output', exist_ok=True)

# 查找所有 CSV 文件
files = glob.glob('data/*.csv')
all_data = []

# 读取并合并所有 CSV 文件
for file in files:
    df = pd.read_csv(file)
    all_data.append(df)

# 合并数据
combined = pd.concat(all_data)

# 保存合并后的数据
combined.to_csv('output/combined.csv', index=False)

# 生成统计信息
stats = combined.describe()
stats.to_csv('output/stats.csv')

# 计算总销售额
total_sales = combined['amount'].sum()
print(f"Total sales: ${total_sales:.2f}")
```

```
import pandas as pd
import glob
import os

# 创建输出目录
os.makedirs('output', exist_ok=True)

# 查找所有 CSV 文件
files = glob.glob('data/*.csv')
all_data = []

# 读取并合并所有 CSV 文件
for file in files:
    df = pd.read_csv(file)
    all_data.append(df)

# 合并数据
combined = pd.concat(all_data)

# 保存合并后的数据
combined.to_csv('output/combined.csv', index=False)

# 生成统计信息
stats = combined.describe()
stats.to_csv('output/stats.csv')

# 计算总销售额
total_sales = combined['amount'].sum()
print(f"Total sales: ${total_sales:.2f}")
```

###### 步骤 3: 运行脚本

```
bash复制# 运行 Python 脚本
运行 python process_csv.py
```

```
# 运行 Python 脚本
运行 python process_csv.py
```

```
bash复制Processing data/sales_2024_01.csv...
Processing data/sales_2024_02.csv...
Processing data/sales_2024_03.csv...
Combined data saved to output/combined.csv
Statistics saved to output/stats.csv
Total sales: $1,234,567.89
```

```
Processing data/sales_2024_01.csv...
Processing data/sales_2024_02.csv...
Processing data/sales_2024_03.csv...
Combined data saved to output/combined.csv
Statistics saved to output/stats.csv
Total sales: $1,234,567.89
```

###### 步骤 4: 生成报告

```
bash复制# 生成数据分析报告
创建 report.md
```

```
# 生成数据分析报告
创建 report.md
```

```
markdown复制# Sales Data Analysis Report

## Overview

- **Total Files Processed**: 3
- **Total Records**: 12,345
- **Total Sales**: $1,234,567.89

## Monthly Breakdown

| Month | Sales | Records |
| :--- | :--- | :--- |
| January | $456,789.00 | 4,567 |
| February | $321,098.00 | 3,210 |
| March | $456,680.89 | 4,568 |

## Top Products

| Product | Sales | Units |
| :--- | :--- | :--- |
| Product A | $567,890.00 | 1,234 |
| Product B | $345,678.00 | 890 |
| Product C | $234,567.00 | 567 |

## Recommendations

1. Increase stock for Product A
2. Promote Product B in March
3. Analyze Product C performance
```

```
# Sales Data Analysis Report

## Overview

- **Total Files Processed**: 3
- **Total Records**: 12,345
- **Total Sales**: $1,234,567.89

## Monthly Breakdown

| Month | Sales | Records |
| :--- | :--- | :--- |
| January | $456,789.00 | 4,567 |
| February | $321,098.00 | 3,210 |
| March | $456,680.89 | 4,568 |

## Top Products

| Product | Sales | Units |
| :--- | :--- | :--- |
| Product A | $567,890.00 | 1,234 |
| Product B | $345,678.00 | 890 |
| Product C | $234,567.00 | 567 |

## Recommendations

1. Increase stock for Product A
2. Promote Product B in March
3. Analyze Product C performance
```

##### 使用的工具#

- Glob: 查找文件
- Write: 创建脚本和报告
- Bash: 运行脚本
- Read: 读取处理结果

##### 关键点#

True. 自动化处理: 使用脚本批量处理文件
True. 数据整合: 合并多个数据源
True. 可视化: 生成统计信息和报告
True. 可扩展性: 脚本可以轻松处理更多文件

#### 案例 3: 代码质量检查#

##### 场景#

需要对一个 Python 项目进行代码质量检查，发现并修复潜在问题。

##### 工具调用流程#

###### 步骤 1: 安装代码质量工具

```
bash复制# 安装 flake8 和 pylint
运行 pip install flake8 pylint
```

```
# 安装 flake8 和 pylint
运行 pip install flake8 pylint
```

###### 步骤 2: 运行代码检查

```
bash复制# 运行 flake8 检查
运行 flake8 src/
```

```
# 运行 flake8 检查
运行 flake8 src/
```

```
bash复制src/main.py:12:5: E302 expected 2 blank lines, found 1
src/utils.py:45:10: F821 undefined name 'print_debug'
src/api.py:78:15: W292 no newline at end of file
```

```
src/main.py:12:5: E302 expected 2 blank lines, found 1
src/utils.py:45:10: F821 undefined name 'print_debug'
src/api.py:78:15: W292 no newline at end of file
```

###### 步骤 3: 修复问题

```
bash复制# 修复 src/main.py 中的空白行问题
编辑 src/main.py
```

```
# 修复 src/main.py 中的空白行问题
编辑 src/main.py
```

```
bash复制# 修复 src/utils.py 中的未定义变量
编辑 src/utils.py
```

```
# 修复 src/utils.py 中的未定义变量
编辑 src/utils.py
```

```
bash复制# 修复 src/api.py 中的换行问题
编辑 src/api.py
```

```
# 修复 src/api.py 中的换行问题
编辑 src/api.py
```

###### 步骤 4: 运行 pylint 检查

```
bash复制# 运行 pylint 检查
运行 pylint src/
```

```
# 运行 pylint 检查
运行 pylint src/
```

```
bash复制Your code has been rated at 9.50/10
```

```
Your code has been rated at 9.50/10
```

##### 使用的工具#

- Bash: 安装和运行代码质量工具
- Edit: 修复代码问题
- Read: 查看检查结果

##### 关键点#

True. 自动化检查: 使用工具发现潜在问题
True. 持续改进: 定期运行代码质量检查
True. 团队协作: 统一代码质量标准
True. 预防为主: 在开发早期发现问题

#### 案例 4: 自动化部署#

##### 场景#

需要自动化部署一个 Node.js 应用到生产环境。

##### 工具调用流程#

###### 步骤 1: 创建部署脚本

```
bash复制# 创建部署脚本
创建 deploy.sh
```

```
# 创建部署脚本
创建 deploy.sh
```

```
bash复制#!/bin/bash

# 拉取最新代码
git pull origin main

# 安装依赖
npm install

# 构建项目
npm run build

# 测试
npm test

# 停止旧服务
pm2 stop app

# 启动新服务
pm2 start app

# 查看状态
pm2 status
```

```
#!/bin/bash

# 拉取最新代码
git pull origin main

# 安装依赖
npm install

# 构建项目
npm run build

# 测试
npm test

# 停止旧服务
pm2 stop app

# 启动新服务
pm2 start app

# 查看状态
pm2 status
```

###### 步骤 2: 运行部署脚本

```
bash复制# 运行部署脚本
运行 bash deploy.sh
```

```
# 运行部署脚本
运行 bash deploy.sh
```

```
bash复制Already up to date.
npm WARN deprecated some-package@1.0.0
added 234 packages in 12s

> build
> webpack --mode production

Hash: abc123
Version: webpack 5.89.0
Time: 12345ms

> test
> jest

Test Suites: 12 passed, 12 total
Tests:       123 passed, 123 total

[PM2] Applying action stopProcessId on app [app](ids: [0])
[PM2] [app](0) ✓

[PM2] Starting /path/to/app.js in fork_mode (1 instance)
[PM2] Done.

┌─────┬──────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┐
│ id  │ name     │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │
├─────┼──────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┤
│ 0   │ app      │ default     │ 1.0.0   │ fork    │ 12345    │ 0s     │ 0    │ online    │ 0%       │
└─────┴──────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┘
```

```
Already up to date.
npm WARN deprecated some-package@1.0.0
added 234 packages in 12s

> build
> webpack --mode production

Hash: abc123
Version: webpack 5.89.0
Time: 12345ms

> test
> jest

Test Suites: 12 passed, 12 total
Tests:       123 passed, 123 total

[PM2] Applying action stopProcessId on app [app](ids: [0])
[PM2] [app](0) ✓

[PM2] Starting /path/to/app.js in fork_mode (1 instance)
[PM2] Done.

┌─────┬──────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┐
│ id  │ name     │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │
├─────┼──────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┤
│ 0   │ app      │ default     │ 1.0.0   │ fork    │ 12345    │ 0s     │ 0    │ online    │ 0%       │
└─────┴──────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┘
```

##### 使用的工具#

- Write: 创建部署脚本
- Bash: 运行部署脚本
- Read: 查看部署结果

##### 关键点#

True. 自动化: 减少手动部署错误
True. 可重复性: 确保每次部署一致
True. 回滚机制: 部署失败时能够回滚
True. 监控: 部署后检查服务状态

#### 案例 5: 数据可视化#

##### 场景#

需要将 JSON 数据转换为可视化图表。

##### 工具调用流程#

###### 步骤 1: 读取 JSON 数据

```
bash复制# 读取 JSON 数据
读取 data.json
```

```
# 读取 JSON 数据
读取 data.json
```

```
json复制{
  "month": ["Jan", "Feb", "Mar", "Apr"],
  "sales": [123, 456, 789, 321],
  "expenses": [98, 76, 54, 32]
}
```

```
{
  "month": ["Jan", "Feb", "Mar", "Apr"],
  "sales": [123, 456, 789, 321],
  "expenses": [98, 76, 54, 32]
}
```

###### 步骤 2: 创建可视化脚本

```
bash复制# 创建 Python 可视化脚本
创建 visualize.py
```

```
# 创建 Python 可视化脚本
创建 visualize.py
```

```
python复制import json
import matplotlib.pyplot as plt

# 读取数据
with open('data.json', 'r') as f:
    data = json.load(f)

# 创建图表
fig, ax = plt.subplots()

# 绘制销售数据
ax.plot(data['month'], data['sales'], label='Sales', marker='o')

# 绘制支出数据
ax.plot(data['month'], data['expenses'], label='Expenses', marker='s')

# 添加标签和标题
ax.set_xlabel('Month')
ax.set_ylabel('Amount')
ax.set_title('Sales vs Expenses')
ax.legend()

# 保存图表
plt.savefig('output/chart.png')
print("Chart saved to output/chart.png")
```

```
import json
import matplotlib.pyplot as plt

# 读取数据
with open('data.json', 'r') as f:
    data = json.load(f)

# 创建图表
fig, ax = plt.subplots()

# 绘制销售数据
ax.plot(data['month'], data['sales'], label='Sales', marker='o')

# 绘制支出数据
ax.plot(data['month'], data['expenses'], label='Expenses', marker='s')

# 添加标签和标题
ax.set_xlabel('Month')
ax.set_ylabel('Amount')
ax.set_title('Sales vs Expenses')
ax.legend()

# 保存图表
plt.savefig('output/chart.png')
print("Chart saved to output/chart.png")
```

###### 步骤 3: 运行可视化脚本

```
bash复制# 运行可视化脚本
运行 python visualize.py
```

```
# 运行可视化脚本
运行 python visualize.py
```

```
bash复制Chart saved to output/chart.png
```

```
Chart saved to output/chart.png
```

##### 使用的工具#

- Read: 读取数据
- Write: 创建可视化脚本
- Bash: 运行脚本
- Read: 查看结果

##### 关键点#

True. 数据转换: 将原始数据转换为可视化格式
True. 可视化选择: 选择合适的图表类型
True. 自动化: 脚本可以轻松处理不同数据
True. 可扩展性: 可以添加更多可视化功能

#### 案例总结#

##### 通用最佳实践#

True. 自动化优先: 使用脚本和工具自动化重复任务
True. 工具组合: 结合多个工具解决复杂问题
True. 可重复性: 确保流程可以重复执行
True. 错误处理: 实现良好的错误处理机制
True. 文档化: 记录工具使用流程和参数

##### 工具选择原则#

True. 适合性: 选择最适合任务的工具
True. 易用性: 选择学习成本低的工具
True. 可扩展性: 选择可以扩展的工具
True. 社区支持: 选择有活跃社区的工具

##### 未来趋势#

True. AI 辅助: AI 将帮助选择和使用工具
True. 自动化工作流: 更复杂的自动化流程
True. 跨平台: 工具将支持更多平台
True. 集成度: 工具将更加集成

通过这些案例，您可以学习如何在实际开发中有效使用工具调用，提高开发效率，解决复杂问题。

- Bash: 执行 git 命令
- Read: 读取文件
- Grep: 搜索测试
- Bash: 运行测试
- Write: 生成报告

##### 关键点#

True. 查看完整的变更
True. 分析代码质量
True. 验证测试覆盖
True. 提供建设性反馈

#### 案例 4: 性能优化#

##### 场景#

优化慢查询性能。

##### 工具调用流程#

```
bash复制bash

# 1. 搜索慢查询
搜索包含 "SELECT" 的文件
[Grep tool called]
Found: src/db.js

# 2. 读取查询代码
读取 src/db.js
[Read tool called]
async function getUsers() {
  const query = 'SELECT * FROM users WHERE status = "active"';
  return await db.query(query);
}

# 3. 分析性能
分析查询性能
[Bash tool called]
EXPLAIN SELECT * FROM users WHERE status = "active";
+----+-------------+-------+------+---------------+
| id | select_type | table | type | possible_keys |
+----+-------------+-------+------+---------------+
|  1 | SIMPLE      | users | ALL  | NULL          |
+----+-------------+-------+------+---------------+

# 4. 添加索引
在 status 列上添加索引
[Edit tool called]
CREATE INDEX idx_users_status ON users(status);

# 5. 优化查询
优化查询只选择需要的列
[Edit tool called]
async function getUsers() {
  const query = 'SELECT id, name, email FROM users WHERE status = "active"';
  return await db.query(query);
}

# 6. 验证性能
验证性能改进
[Bash tool called]
Before: 2.5s
After: 0.05s
Improvement: 50x faster

### 使用的工具

> - **Grep**: 搜索代码
> - **Read**: 读取文件
> - **Bash**: 分析性能
> - **Edit**: 优化代码
> - **Bash**: 验证改进

### 关键点

## 案例 5: 自动化部署

### 场景

自动化部署流程。

### 工具调用流程

# 1. 检查代码
运行代码检查
[Bash tool called]
npm run lint
✅ No linting errors
# 2. 运行测试
运行所有测试
[Bash tool called]
npm test
✅ All tests passing
# 3. 构建项目
构建项目
[Bash tool called]
npm run build
✅ Build successful
# 4. 创建 Docker 镜像
构建 Docker 镜像
[Bash tool called]
docker build -t myapp:latest .
✅ Image built successfully
# 5. 推送镜像
推送镜像到 registry
[Bash tool called]
docker push myapp:latest
✅ Image pushed successfully
# 6. 更新部署
更新 Kubernetes 部署
[Bash tool called]
kubectl set image deployment/myapp myapp=myapp:latest
✅ Deployment updated
# 7. 验证部署
检查部署状态
[Bash tool called]
kubectl get pods
NAME                      READY   STATUS
myapp-7d6f8b5c9d-abc12   1/1     Running
✅ Deployment successful
```

```
bash

# 1. 搜索慢查询
搜索包含 "SELECT" 的文件
[Grep tool called]
Found: src/db.js

# 2. 读取查询代码
读取 src/db.js
[Read tool called]
async function getUsers() {
  const query = 'SELECT * FROM users WHERE status = "active"';
  return await db.query(query);
}

# 3. 分析性能
分析查询性能
[Bash tool called]
EXPLAIN SELECT * FROM users WHERE status = "active";
+----+-------------+-------+------+---------------+
| id | select_type | table | type | possible_keys |
+----+-------------+-------+------+---------------+
|  1 | SIMPLE      | users | ALL  | NULL          |
+----+-------------+-------+------+---------------+

# 4. 添加索引
在 status 列上添加索引
[Edit tool called]
CREATE INDEX idx_users_status ON users(status);

# 5. 优化查询
优化查询只选择需要的列
[Edit tool called]
async function getUsers() {
  const query = 'SELECT id, name, email FROM users WHERE status = "active"';
  return await db.query(query);
}

# 6. 验证性能
验证性能改进
[Bash tool called]
Before: 2.5s
After: 0.05s
Improvement: 50x faster

### 使用的工具

> - **Grep**: 搜索代码
> - **Read**: 读取文件
> - **Bash**: 分析性能
> - **Edit**: 优化代码
> - **Bash**: 验证改进

### 关键点

## 案例 5: 自动化部署

### 场景

自动化部署流程。

### 工具调用流程

# 1. 检查代码
运行代码检查
[Bash tool called]
npm run lint
✅ No linting errors
# 2. 运行测试
运行所有测试
[Bash tool called]
npm test
✅ All tests passing
# 3. 构建项目
构建项目
[Bash tool called]
npm run build
✅ Build successful
# 4. 创建 Docker 镜像
构建 Docker 镜像
[Bash tool called]
docker build -t myapp:latest .
✅ Image built successfully
# 5. 推送镜像
推送镜像到 registry
[Bash tool called]
docker push myapp:latest
✅ Image pushed successfully
# 6. 更新部署
更新 Kubernetes 部署
[Bash tool called]
kubectl set image deployment/myapp myapp=myapp:latest
✅ Deployment updated
# 7. 验证部署
检查部署状态
[Bash tool called]
kubectl get pods
NAME                      READY   STATUS
myapp-7d6f8b5c9d-abc12   1/1     Running
✅ Deployment successful
```

##### 使用的工具#

- Bash: 执行命令
- Bash: 运行测试
- Bash: 构建项目
- Bash: Docker 操作
- Bash: Kubernetes 操作

##### 关键点#

True. 自动化所有步骤
True. 每步验证成功
True. 使用后台任务
True. 监控部署状态
True. 快速回滚能力

#### 案例 6: 数据迁移#

##### 场景#

将数据从旧系统迁移到新系统。

##### 工具调用流程#

```
bash复制bash

# 1. 分析源数据
分析旧数据库结构
[Read tool called]
读取 schema.sql

# 2. 创建迁移脚本
创建数据迁移脚本
[Write tool called]
# migrate.py
import psycopg2
import pymongo

# Connect to old database
old_conn = psycopg2.connect("old_db")
old_cursor = old_conn.cursor()

# Connect to new database
new_client = pymongo.MongoClient("new_db")
new_db = new_client["app"]

# Migrate users
old_cursor.execute("SELECT * FROM users")
for row in old_cursor.fetchall():
    user = {
        "id": row[0],
        "name": row[1],
        "email": row[2],
        "created_at": row[3]
    }
    new_db.users.insert_one(user)

print("Migration completed")

# 3. 运行迁移
在后台运行迁移
[Bash tool called]
python migrate.py
[后台任务 ID: task-12345]

# 4. 监控进度
检查迁移进度
[Bash tool called]
检查任务输出
Migrating users: 1000/5000 (20%)

# 5. 验证数据
验证迁移的数据
[Bash tool called]
python verify.py
✅ All data migrated correctly

```

### 使用的工具

- **Read**: 读取结构
- **Write**: 创建脚本
- **Bash**: 执行迁移
- **Bash**: 监控进度
- **Bash**: 验证数据

### 关键点

1. 先分析源数据
2. 创建可靠脚本
3. 后台运行迁移
4. 实时监控进度
5. 验证数据完整性

## 总结

### 工具调用模式

1. **搜索 → 读取 → 分析 → 修改 → 验证**
2. **批量处理**: Glob → 脚本 → 执行 → 报告
3. **代码审查**: Diff → 分析 → 测试 → 反馈
4. **性能优化**: 识别 → 分析 → 优化 → 验证
5. **自动化部署**: 检查 → 测试 → 构建 → 部署
6. **数据迁移**: 分析 → 脚本 → 迁移 → 验证

### 最佳实践

1. **逐步执行**: 将复杂任务分解为步骤
2. **验证每步**: 确保每步成功后再继续
3. **使用后台任务**: 对长时间运行的任务
4. **生成报告**: 记录过程和结果
5. **错误处理**: 处理可能的错误情况
6. **文档化**: 记录工具使用和决策
```

```
bash

# 1. 分析源数据
分析旧数据库结构
[Read tool called]
读取 schema.sql

# 2. 创建迁移脚本
创建数据迁移脚本
[Write tool called]
# migrate.py
import psycopg2
import pymongo

# Connect to old database
old_conn = psycopg2.connect("old_db")
old_cursor = old_conn.cursor()

# Connect to new database
new_client = pymongo.MongoClient("new_db")
new_db = new_client["app"]

# Migrate users
old_cursor.execute("SELECT * FROM users")
for row in old_cursor.fetchall():
    user = {
        "id": row[0],
        "name": row[1],
        "email": row[2],
        "created_at": row[3]
    }
    new_db.users.insert_one(user)

print("Migration completed")

# 3. 运行迁移
在后台运行迁移
[Bash tool called]
python migrate.py
[后台任务 ID: task-12345]

# 4. 监控进度
检查迁移进度
[Bash tool called]
检查任务输出
Migrating users: 1000/5000 (20%)

# 5. 验证数据
验证迁移的数据
[Bash tool called]
python verify.py
✅ All data migrated correctly

```

### 使用的工具

- **Read**: 读取结构
- **Write**: 创建脚本
- **Bash**: 执行迁移
- **Bash**: 监控进度
- **Bash**: 验证数据

### 关键点

1. 先分析源数据
2. 创建可靠脚本
3. 后台运行迁移
4. 实时监控进度
5. 验证数据完整性

## 总结

### 工具调用模式

1. **搜索 → 读取 → 分析 → 修改 → 验证**
2. **批量处理**: Glob → 脚本 → 执行 → 报告
3. **代码审查**: Diff → 分析 → 测试 → 反馈
4. **性能优化**: 识别 → 分析 → 优化 → 验证
5. **自动化部署**: 检查 → 测试 → 构建 → 部署
6. **数据迁移**: 分析 → 脚本 → 迁移 → 验证

### 最佳实践

1. **逐步执行**: 将复杂任务分解为步骤
2. **验证每步**: 确保每步成功后再继续
3. **使用后台任务**: 对长时间运行的任务
4. **生成报告**: 记录过程和结果
5. **错误处理**: 处理可能的错误情况
6. **文档化**: 记录工具使用和决策
```

---

# 第 11 章

## 1 MCP 基本概念

**URL**: https://claudecode.tangshuang.net/course/11.1%20MCP%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5

Model Context Protocol (MCP) 是一个用于 AI 工具集成的开源标准，允许 Claude Code 连接到数百个外部工具和数据源，极大扩展了 AI 助手的能力边界。

#### 什么是 MCP#

MCP 是一个开放协议，定义了 AI 助手如何与外部工具和数据源进行交互。通过 MCP，Claude Code 可以突破自身能力限制，实现以下功能：

- 访问外部 API 和服务，如 GitHub、Slack、AWS 等
- 查询各种数据库系统，包括 SQL 和 NoSQL 数据库
- 操作本地和远程文件系统
- 与开发工具深度集成，如 VS Code、Git、Docker 等
- 自动化复杂工作流程，实现 DevOps 自动化

#### MCP 的核心价值#

##### 1. 统一接口#

MCP 为不同的工具和数据源提供统一的接口，使 Claude Code 能够以一致的方式与各种服务交互。这意味着无论使用哪种工具，用户都可以通过相同的语法和模式进行调用，大大降低了学习成本。

##### 2. 可扩展性#

通过 MCP，您可以轻松添加新的工具和数据源，无需修改 Claude Code 的核心代码。这种插件式架构使得系统可以快速适应新的技术和需求。

##### 3. 安全性#

MCP 提供标准化的安全机制，包括身份验证、权限控制和数据隔离。所有工具调用都经过严格的安全检查，确保敏感数据不会泄露。

##### 4. 开放性#

MCP 是开源协议，任何人都可以创建 MCP 服务器或客户端。这意味着开发者可以自由扩展 MCP 生态系统，为 Claude Code 带来更多功能。

#### MCP 架构#

##### 客户端-服务器模型#

MCP 采用客户端-服务器架构：

- 客户端: Claude Code 作为 MCP 客户端，负责接收用户请求并转发给 MCP 服务器
- 服务器: 提供工具和数据源的服务，负责处理客户端请求并返回结果

##### 通信方式#

MCP 支持多种通信方式：

True. HTTP: 通过 HTTP 协议通信，这是最常用的方式
True. SSE: 通过 Server-Sent Events 通信（已弃用，不建议使用）
True. stdio: 通过标准输入输出通信，适用于本地工具集成

##### 数据流#

```
bash复制用户请求 → Claude Code → MCP 服务器 → 外部服务
          ↓              ↓
      MCP 工具调用     工具执行
          ↓              ↓
      返回结果         结果返回
```

```
用户请求 → Claude Code → MCP 服务器 → 外部服务
          ↓              ↓
      MCP 工具调用     工具执行
          ↓              ↓
      返回结果         结果返回
```

MCP 数据流分为以下几个阶段：

True. 用户向 Claude Code 发送请求
True. Claude Code 将请求转换为 MCP 工具调用
True. MCP 服务器接收请求并调用相应的外部服务
True. 外部服务执行操作并返回结果
True. MCP 服务器将结果返回给 Claude Code
True. Claude Code 将结果呈现给用户

---

## 2 MCP 核心功能

**URL**: https://claudecode.tangshuang.net/course/11.2%20MCP%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD

MCP 提供丰富的核心功能，使 Claude Code 能够与外部工具和数据源无缝集成，极大扩展了 AI 助手的能力边界。

#### 工具调用#

##### 基本工具调用#

MCP 服务器提供可调用的工具，Claude Code 可以像使用内置工具一样使用它们。这些工具可以是任何类型的服务或应用，从简单的 API 调用到复杂的工作流自动化。

```
bash复制# 使用 MCP 工具的示例
使用 GitHub 工具创建 PR
使用 Sentry 工具查询最近的错误
使用数据库工具查询用户数据
使用 Docker 工具管理容器
```

```
# 使用 MCP 工具的示例
使用 GitHub 工具创建 PR
使用 Sentry 工具查询最近的错误
使用数据库工具查询用户数据
使用 Docker 工具管理容器
```

##### 工具发现#

Claude Code 会自动发现 MCP 服务器提供的所有工具，并将其集成到用户界面中。用户可以通过简单的命令查看所有可用工具：

```
bash复制# 查看可用的 MCP 工具
/mcp

# 输出示例
MCP 服务器：
- github: 提供 PR、issue、代码搜索等工具
- sentry: 提供错误查询、监控等工具
- database: 提供数据库查询工具
- docker: 提供容器管理工具
```

```
# 查看可用的 MCP 工具
/mcp

# 输出示例
MCP 服务器：
- github: 提供 PR、issue、代码搜索等工具
- sentry: 提供错误查询、监控等工具
- database: 提供数据库查询工具
- docker: 提供容器管理工具
```

##### 工具参数#

MCP 工具可以接受参数，使调用更加灵活和精确。参数可以是位置参数或命名参数：

```
bash复制# 带参数的工具调用
使用 GitHub 工具查看 PR #123
使用数据库工具查询用户 ID 为 456 的信息
使用 Docker 工具启动名为 "web-server" 的容器
```

```
# 带参数的工具调用
使用 GitHub 工具查看 PR #123
使用数据库工具查询用户 ID 为 456 的信息
使用 Docker 工具启动名为 "web-server" 的容器
```

```
bash复制
## 资源访问

### 资源类型

MCP 服务器可以提供多种类型的资源，让 Claude Code 能够直接访问和操作：

- **数据库表**: 可查询和操作的数据表
- **文件系统**: 可访问的文件和目录
- **API 端点**: 可调用的 REST API
- **配置文件**: 可读取和修改的配置
- **监控数据**: 可查看的系统监控指标

### 资源发现

Claude Code 自动发现 MCP 服务器提供的所有资源，并以直观的方式展示给用户：

```bash
# 查看可用的 MCP 资源
/mcp

# 输出示例
MCP 资源：
- database.users: 用户表
- database.orders: 订单表
- filesystem.logs: 日志目录
- api.metrics: 系统监控 API
```

```
## 资源访问

### 资源类型

MCP 服务器可以提供多种类型的资源，让 Claude Code 能够直接访问和操作：

- **数据库表**: 可查询和操作的数据表
- **文件系统**: 可访问的文件和目录
- **API 端点**: 可调用的 REST API
- **配置文件**: 可读取和修改的配置
- **监控数据**: 可查看的系统监控指标

### 资源发现

Claude Code 自动发现 MCP 服务器提供的所有资源，并以直观的方式展示给用户：

```bash
# 查看可用的 MCP 资源
/mcp

# 输出示例
MCP 资源：
- database.users: 用户表
- database.orders: 订单表
- filesystem.logs: 日志目录
- api.metrics: 系统监控 API
```

##### 资源访问#

用户可以通过自然语言命令直接访问 MCP 资源：

```
bash复制# 访问 MCP 资源的示例
查询数据库中的用户表
读取日志文件 /var/log/app.log
获取系统配置信息
查看最近 24 小时的 CPU 使用率
```

```
# 访问 MCP 资源的示例
查询数据库中的用户表
读取日志文件 /var/log/app.log
获取系统配置信息
查看最近 24 小时的 CPU 使用率
```

#### 提示模板#

##### 提示模板定义#

MCP 服务器可以提供预定义的提示模板，帮助用户快速完成常见任务。这些模板包含最佳实践和标准化格式，确保输出质量。

```
bash复制# 使用 MCP 提示模板的示例
使用 GitHub 的 PR 审查模板
使用 Sentry 的错误分析模板
使用 Jira 的 bug 报告模板
```

```
# 使用 MCP 提示模板的示例
使用 GitHub 的 PR 审查模板
使用 Sentry 的错误分析模板
使用 Jira 的 bug 报告模板
```

##### 提示模板优势#

提示模板带来以下优势：

- 标准化: 统一的提示格式，确保输出质量
- 高效: 快速开始任务，减少重复工作
- 一致性: 确保团队成员使用相同的标准
- 可扩展性: 可以轻松创建和共享新模板

#### 身份验证#

##### OAuth 2.0#

MCP 支持 OAuth 2.0 身份验证，允许 Claude Code 安全地访问受保护的资源：

```
bash复制# 使用 /mcp 进行身份验证
/mcp
# 选择需要身份验证的服务器
# 按照提示完成 OAuth 流程
```

```
# 使用 /mcp 进行身份验证
/mcp
# 选择需要身份验证的服务器
# 按照提示完成 OAuth 流程
```

##### API 密钥#

MCP 支持 API 密钥身份验证，适用于服务之间的通信：

```
bash复制# 添加带 API 密钥的服务器
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer your-api-key"
```

```
# 添加带 API 密钥的服务器
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer your-api-key"
```

##### 环境变量#

MCP 支持通过环境变量传递凭证，提高安全性和配置灵活性：

```
bash复制# 使用环境变量添加服务器
claude mcp add --transport stdio db --env DB_URL=your-db-url \
-- npx -y @bytebase/dbhub
```

```
# 使用环境变量添加服务器
claude mcp add --transport stdio db --env DB_URL=your-db-url \
-- npx -y @bytebase/dbhub
```

#### 权限管理#

##### 工具权限#

MCP 提供细粒度的工具级权限控制，确保用户只能访问他们需要的工具：

```
bash复制# 限制工具访问
claude --allowedTools "Read,Grep,Glob,mcp__github"
```

```
# 限制工具访问
claude --allowedTools "Read,Grep,Glob,mcp__github"
```

##### 资源权限#

MCP 支持资源级权限控制，允许管理员限制对特定资源的访问：

```
bash复制# 限制资源访问示例
只允许访问 database.users 表
禁止修改配置文件
```

```
# 限制资源访问示例
只允许访问 database.users 表
禁止修改配置文件
```

##### 操作权限#

MCP 提供操作级权限控制，允许管理员限制用户可以执行的操作类型：

```
bash复制# 限制操作类型示例
只允许只读操作
禁止删除数据库记录
```

```
# 限制操作类型示例
只允许只读操作
禁止删除数据库记录
```

#### 数据流控制#

##### 输出限制#

MCP 工具输出有默认限制，防止返回过多数据影响性能：

```
bash复制# 默认限制：10,000 令牌
# 增加限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
```

```
# 默认限制：10,000 令牌
# 增加限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
```

##### 超时控制#

MCP 服务器启动有超时限制，防止长时间运行的任务阻塞系统：

```
bash复制# 默认超时：30 秒
# 设置超时
MCP_TIMEOUT=10000 claude
```

```
# 默认超时：30 秒
# 设置超时
MCP_TIMEOUT=10000 claude
```

##### 流式输出#

MCP 支持流式输出，允许处理大型数据集而不会占用过多内存：

```
bash复制# 流式输出大结果
使用数据库工具导出所有用户数据
使用日志工具实时监控系统日志
```

```
# 流式输出大结果
使用数据库工具导出所有用户数据
使用日志工具实时监控系统日志
```

#### 错误处理#

##### 错误捕获#

MCP 提供详细的错误信息，帮助用户快速定位和解决问题：

```
bash复制# 错误示例
使用 GitHub 工具创建 PR
错误：无法创建 PR - 权限不足
```

```
# 错误示例
使用 GitHub 工具创建 PR
错误：无法创建 PR - 权限不足
```

##### 错误恢复#

MCP 提供错误恢复机制，包括自动重试和替代方案建议：

```
bash复制# 自动重试失败的操作
重试失败的数据库查询
# 提供替代方案
使用其他工具完成相同任务
```

```
# 自动重试失败的操作
重试失败的数据库查询
# 提供替代方案
使用其他工具完成相同任务
```

##### 错误日志#

MCP 记录详细的错误日志，方便管理员排查问题：

```
bash复制# 查看错误日志
claude --verbose
```

```
# 查看错误日志
claude --verbose
```

#### 性能优化#

##### 缓存#

MCP 支持结果缓存：

### 缓存查询结果

使用数据库工具查询用户数据

### 相同查询会使用缓存

```
bash复制### 批处理
MCP 支持批量操作：

```bash
# 批量查询
批量查询多个用户
```

### 并行处理

MCP 支持并行处理：

```bash
# 并行执行多个 MCP 工具
同时查询多个数据源
```

## 监控和调试

### 工具使用监控

```bash
# 查看工具使用情况
显示 MCP 工具使用统计
```

### 性能监控

```bash
# 查看性能指标
显示 MCP 工具执行时间
```

### 调试模式

```bash
# 启用调试模式
claude --verbose
```

## 扩展功能

### 自定义工具

MCP 服务器可以提供自定义工具：

```bash
# 使用自定义工具
使用自定义工具处理数据
```

### 插件集成

MCP 可以通过插件集成：

```bash
# 安装带 MCP 的插件
/plugin install my-plugin@claude
```

MCP 提供多种性能优化功能，确保工具调用高效可靠：

### 缓存机制

MCP 支持结果缓存，避免重复调用相同的工具：

```bash
# 启用缓存
claude mcp add --transport http api https://api.example.com/mcp \
  --cache-ttl 300
```

### 并行调用

MCP 支持并行调用多个工具，提高处理效率：

```bash
# 并行调用示例
同时使用 GitHub 工具和 Sentry 工具
```

### 插件集成

MCP 可以与插件系统集成，进一步扩展功能：

```bash
# 安装 MCP 插件
/plugin install my-plugin@claude
```

### 技能集成

MCP 可以与技能系统深度集成，实现更复杂的自动化任务：

```bash
# 使用技能调用 MCP 工具
使用数据处理技能调用数据库工具
使用自动化技能执行 DevOps 流程
```

## 安全功能
### 数据加密

MCP 支持数据加密传输，确保敏感信息不被泄露：

```bash
# 加密传输
claude mcp add --transport http secure https://api.example.com/mcp \
  --header "Authorization: Bearer encrypted-token"
```

### 审计日志

MCP 记录详细的审计日志，便于追踪和合规检查：

```bash
# 查看审计日志
显示 MCP 工具使用历史
导出审计报告
```

### 访问控制

MCP 提供细粒度的访问控制，确保只有授权用户可以使用特定工具：

```bash
# 控制访问权限
限制特定用户访问 MCP 工具
基于角色的权限分配
```

## 最佳实践

### 1. 合理配置

根据实际需求配置 MCP 服务器，确保最佳性能和安全性：

```bash
# 配置建议
选择合适的传输方式（HTTP 用于远程，stdio 用于本地）
设置适当的超时时间（根据工具响应时间调整）
配置最小权限原则的权限设置
```

### 2. 监控使用

定期监控 MCP 工具使用情况，识别性能瓶颈和优化机会：

```bash
# 监控建议
查看使用统计数据
分析性能指标（响应时间、成功率）
识别高频使用的工具和资源
```

### 3. 安全第一

确保 MCP 配置安全，保护敏感数据和资源：

```bash
# 安全建议
使用强身份验证机制（OAuth 2.0 优于 API 密钥）
限制权限范围，遵循最小权限原则
定期更新凭证和密钥
```

### 4. 错误处理

妥善处理错误，提高系统可靠性和用户体验：

```bash
# 错误处理建议
捕获并记录所有错误
提供清晰的错误信息和恢复方案
实现自动重试机制
```
```

```
### 批处理
MCP 支持批量操作：

```bash
# 批量查询
批量查询多个用户
```

### 并行处理

MCP 支持并行处理：

```bash
# 并行执行多个 MCP 工具
同时查询多个数据源
```

## 监控和调试

### 工具使用监控

```bash
# 查看工具使用情况
显示 MCP 工具使用统计
```

### 性能监控

```bash
# 查看性能指标
显示 MCP 工具执行时间
```

### 调试模式

```bash
# 启用调试模式
claude --verbose
```

## 扩展功能

### 自定义工具

MCP 服务器可以提供自定义工具：

```bash
# 使用自定义工具
使用自定义工具处理数据
```

### 插件集成

MCP 可以通过插件集成：

```bash
# 安装带 MCP 的插件
/plugin install my-plugin@claude
```

MCP 提供多种性能优化功能，确保工具调用高效可靠：

### 缓存机制

MCP 支持结果缓存，避免重复调用相同的工具：

```bash
# 启用缓存
claude mcp add --transport http api https://api.example.com/mcp \
  --cache-ttl 300
```

### 并行调用

MCP 支持并行调用多个工具，提高处理效率：

```bash
# 并行调用示例
同时使用 GitHub 工具和 Sentry 工具
```

### 插件集成

MCP 可以与插件系统集成，进一步扩展功能：

```bash
# 安装 MCP 插件
/plugin install my-plugin@claude
```

### 技能集成

MCP 可以与技能系统深度集成，实现更复杂的自动化任务：

```bash
# 使用技能调用 MCP 工具
使用数据处理技能调用数据库工具
使用自动化技能执行 DevOps 流程
```

## 安全功能
### 数据加密

MCP 支持数据加密传输，确保敏感信息不被泄露：

```bash
# 加密传输
claude mcp add --transport http secure https://api.example.com/mcp \
  --header "Authorization: Bearer encrypted-token"
```

### 审计日志

MCP 记录详细的审计日志，便于追踪和合规检查：

```bash
# 查看审计日志
显示 MCP 工具使用历史
导出审计报告
```

### 访问控制

MCP 提供细粒度的访问控制，确保只有授权用户可以使用特定工具：

```bash
# 控制访问权限
限制特定用户访问 MCP 工具
基于角色的权限分配
```

## 最佳实践

### 1. 合理配置

根据实际需求配置 MCP 服务器，确保最佳性能和安全性：

```bash
# 配置建议
选择合适的传输方式（HTTP 用于远程，stdio 用于本地）
设置适当的超时时间（根据工具响应时间调整）
配置最小权限原则的权限设置
```

### 2. 监控使用

定期监控 MCP 工具使用情况，识别性能瓶颈和优化机会：

```bash
# 监控建议
查看使用统计数据
分析性能指标（响应时间、成功率）
识别高频使用的工具和资源
```

### 3. 安全第一

确保 MCP 配置安全，保护敏感数据和资源：

```bash
# 安全建议
使用强身份验证机制（OAuth 2.0 优于 API 密钥）
限制权限范围，遵循最小权限原则
定期更新凭证和密钥
```

### 4. 错误处理

妥善处理错误，提高系统可靠性和用户体验：

```bash
# 错误处理建议
捕获并记录所有错误
提供清晰的错误信息和恢复方案
实现自动重试机制
```
```

---

## 3 热门 MCP 服务器

**URL**: https://claudecode.tangshuang.net/course/11.3%20%E7%83%AD%E9%97%A8%20MCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8

MCP 生态系统中有许多流行的服务器，可以扩展 Claude Code 的功能，让 AI 助手能够与各种工具和服务无缝集成。

#### 开发工具#

##### GitHub#

功能: 代码托管和协作平台集成

```
bash复制claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

```
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

- 创建和管理 Pull Requests
- 查看和创建 Issues
- 代码搜索和审查
- 仓库管理
- 团队协作

```
bash复制审查 PR #456
创建新问题：修复登录 bug
查看我的所有打开的 PR
搜索仓库中包含 "authentication" 的代码
```

```
审查 PR #456
创建新问题：修复登录 bug
查看我的所有打开的 PR
搜索仓库中包含 "authentication" 的代码
```

##### GitLab#

功能: 代码托管和 CI/CD 平台集成

```
bash复制claude mcp add --transport http gitlab https://gitlab.com/api/mcp
```

```
claude mcp add --transport http gitlab https://gitlab.com/api/mcp
```

- 管理 Merge Requests
- CI/CD 管道管理
- 项目管理
- 代码审查
- 自动化部署

##### VS Code#

功能: 代码编辑器集成

```
bash复制claude mcp add --transport stdio vscode -- npx -y @vscode/mcp-server
```

```
claude mcp add --transport stdio vscode -- npx -y @vscode/mcp-server
```

- 编辑器操作
- 文件管理
- 扩展管理
- 代码调试
- 工作区管理

#### 数据库#

##### PostgreSQL#

功能: PostgreSQL 数据库查询和操作

```
bash复制claude mcp add --transport stdio postgres -- npx -y @bytebase/dbhub \
--dsn "postgresql://user:pass@localhost:5432/db"
```

```
claude mcp add --transport stdio postgres -- npx -y @bytebase/dbhub \
--dsn "postgresql://user:pass@localhost:5432/db"
```

- 查询数据库
- 分析数据
- 生成报告
- 数据可视化
- 数据库管理

```
bash复制查询本月总收入
显示订单表结构
查找 90 天未购买的用户
分析用户购买行为
```

```
查询本月总收入
显示订单表结构
查找 90 天未购买的用户
分析用户购买行为
```

##### MySQL#

功能: MySQL 数据库查询和操作

```
bash复制claude mcp add --transport stdio mysql -- npx -y mysql-mcp-server \
--connection-string "mysql://user:pass@localhost:3306/db"
```

```
claude mcp add --transport stdio mysql -- npx -y mysql-mcp-server \
--connection-string "mysql://user:pass@localhost:3306/db"
```

```
bash复制
**用途**:
- 查询 MySQL 数据库
- 数据分析
- 报表生成
- 数据导入导出
- 数据库维护

### MongoDB

**功能**: MongoDB 数据库操作

**安装**:
```bash
claude mcp add --transport stdio mongodb -- npx -y mongodb-mcp-server \
  --connection-string "mongodb://localhost:27017/db"
```

```
**用途**:
- 查询 MySQL 数据库
- 数据分析
- 报表生成
- 数据导入导出
- 数据库维护

### MongoDB

**功能**: MongoDB 数据库操作

**安装**:
```bash
claude mcp add --transport stdio mongodb -- npx -y mongodb-mcp-server \
  --connection-string "mongodb://localhost:27017/db"
```

- 查询 MongoDB
- 聚合操作
- 数据分析
- 文档管理
- 数据库备份

#### 云服务#

##### AWS#

功能: AWS 云服务集成

```
bash复制claude mcp add --transport stdio aws -- npx -y @anthropic-aws/mcp-server \
--env AWS_ACCESS_KEY_ID=your-key \
--env AWS_SECRET_ACCESS_KEY=your-secret
```

```
claude mcp add --transport stdio aws -- npx -y @anthropic-aws/mcp-server \
--env AWS_ACCESS_KEY_ID=your-key \
--env AWS_SECRET_ACCESS_KEY=your-secret
```

- EC2 实例管理
- S3 存储桶操作
- Lambda 函数部署
- CloudWatch 监控
- IAM 权限管理

##### Google Cloud#

功能: Google Cloud 服务集成

```
bash复制claude mcp add --transport stdio gcp -- npx -y @anthropic-gcp/mcp-server \
  --env GOOGLE_CREDENTIALS=path/to/credentials.json
```

```
claude mcp add --transport stdio gcp -- npx -y @anthropic-gcp/mcp-server \
  --env GOOGLE_CREDENTIALS=path/to/credentials.json
```

- Compute Engine 管理
- Cloud Storage 操作
- BigQuery 数据分析
- Cloud Functions 部署
- Stackdriver 监控

##### Azure#

功能: Azure 云服务集成

```
bash复制claude mcp add --transport stdio azure -- npx -y @anthropic-azure/mcp-server \
--env AZURE_SUBSCRIPTION_ID=your-id
```

```
claude mcp add --transport stdio azure -- npx -y @anthropic-azure/mcp-server \
--env AZURE_SUBSCRIPTION_ID=your-id
```

- 虚拟机管理
- 存储操作
- 数据库管理
- Azure Functions 部署
- 监控和告警

#### 监控和日志#

##### Sentry#

功能: 错误监控和性能追踪

```
bash复制claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
```

```
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
```

- 查看错误
- 性能分析
- 问题追踪
- 错误分组
- 版本关联

```
bash复制过去 24 小时最常见的错误
显示错误 ID abc123 的堆栈跟踪
哪个部署引入了这些新错误
分析错误趋势
```

```
过去 24 小时最常见的错误
显示错误 ID abc123 的堆栈跟踪
哪个部署引入了这些新错误
分析错误趋势
```

##### Datadog#

功能: 监控和分析平台集成

```
bash复制claude mcp add --transport http datadog https://mcp.datadoghq.com/mcp
```

```
claude mcp add --transport http datadog https://mcp.datadoghq.com/mcp
```

- 指标监控
- 日志分析
- 告警管理
- 性能可视化
- APM 追踪

##### Prometheus#

功能: 指标收集和监控

```
bash复制claude mcp add --transport stdio prometheus -- npx -y prometheus-mcp-server \
--url http://localhost:9090
```

```
claude mcp add --transport stdio prometheus -- npx -y prometheus-mcp-server \
--url http://localhost:9090
```

- 查询指标
- 创建图表
- 监控系统
- 告警配置
- 数据导出

#### 项目管理#

##### JIRA#

功能: 问题跟踪和项目管理

```
bash复制claude mcp add --transport http jira https://mcp.atlassian.com/jira \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http jira https://mcp.atlassian.com/jira \
  --header "Authorization: Bearer your-token"
```

- 创建和管理问题
- 查看项目状态
- 生成报告

示例:
创建 JIRA 问题 ENG-4521
查看我的所有分配的任务
生成项目进度报告

##### Asana#

功能: 项目和任务管理

```
bash复制claude mcp add --transport http asana https://mcp.asana.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http asana https://mcp.asana.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 任务管理
- 项目跟踪
- 团队协作

##### Trello#

功能: 看板和任务管理

```
bash复制claude mcp add --transport http trello https://mcp.trello.com/mcp \
--header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http trello https://mcp.trello.com/mcp \
--header "Authorization: Bearer your-token"
```

- 看板管理
- 卡片操作
- 团队协作

#### 文档和知识#

##### Notion#

功能: 文档和知识管理

```
bash复制claude mcp add --transport http notion https://mcp.notion.com/mcp
```

```
claude mcp add --transport http notion https://mcp.notion.com/mcp
```

- 读取和编辑文档
- 知识库查询
- 页面管理

示例:
读取项目文档
更新 API 文档
查询知识库

##### Confluence#

功能: 企业文档管理

```
bash复制claude mcp add --transport http confluence https://mcp.atlassian.com/confluence \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http confluence https://mcp.atlassian.com/confluence \
  --header "Authorization: Bearer your-token"
```

- 文档管理
- 知识共享
- 团队协作

##### Google Drive#

功能: 云存储和文档

```
bash复制claude mcp add --transport http gdrive https://mcp.google.com/drive \
--header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http gdrive https://mcp.google.com/drive \
--header "Authorization: Bearer your-token"
```

- 文件访问
- 文档编辑
- 文件共享

#### 通信#

##### Slack#

功能: 团队沟通

```
bash复制claude mcp add --transport http slack https://mcp.slack.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http slack https://mcp.slack.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 发送消息
- 查看频道
- 文件分享

示例:
发送消息到 #general 频道
查看未读消息
分享文件到 Slack

##### Discord#

功能: 社区沟通

```
bash复制claude mcp add --transport http discord https://mcp.discord.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http discord https://mcp.discord.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 发送消息
- 查看频道
- 服务器管理

##### Microsoft Teams#

功能: 企业沟通

```
bash复制claude mcp add --transport http teams https://mcp.microsoft.com/teams \
--header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http teams https://mcp.microsoft.com/teams \
--header "Authorization: Bearer your-token"
```

- 团队沟通
- 会议管理
- 文件共享

#### 设计和原型#

##### Figma#

功能: UI/UX 设计协作平台

```
bash复制claude mcp add --transport http figma https://mcp.figma.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http figma https://mcp.figma.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 设计查看和评论
- 组件库管理
- 设计导出
- 团队协作
- 根据设计生成代码

##### Sketch#

功能: UI/UX 设计工具

```
bash复制claude mcp add --transport http sketch https://mcp.sketch.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http sketch https://mcp.sketch.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 设计管理
- 资源导出
- 团队协作
- 版本控制
- 设计系统管理

#### 测试和自动化#

##### Playwright#

功能: 浏览器自动化和测试

```
bash复制claude mcp add --transport stdio playwright -- npx -y @playwright/mcp@latest
```

```
claude mcp add --transport stdio playwright -- npx -y @playwright/mcp@latest
```

- 浏览器测试
- 自动化操作
- 截图和录制
- 性能测试
- 跨浏览器测试

```
bash复制测试登录流程
截取结账页面
验证搜索功能
生成测试报告
```

```
测试登录流程
截取结账页面
验证搜索功能
生成测试报告
```

##### Selenium#

功能: Web 应用测试框架

```
bash复制claude mcp add --transport stdio selenium -- npx -y selenium-mcp-server
```

```
claude mcp add --transport stdio selenium -- npx -y selenium-mcp-server
```

- 自动化测试
- 浏览器操作
- 回归测试
- 兼容性测试
- 测试套件管理

##### Cypress#

功能: 端到端测试框架

```
bash复制claude mcp add --transport stdio cypress -- npx -y cypress-mcp-server
```

```
claude mcp add --transport stdio cypress -- npx -y cypress-mcp-server
```

- E2E 测试
- 测试运行
- 结果分析
- 测试录制
- 持续集成

#### 其他实用工具#

##### Airtable#

功能: 在线数据库和电子表格

```
bash复制claude mcp add --transport stdio airtable -- npx -y airtable-mcp-server \
--env AIRTABLE_API_KEY=your-key
```

```
claude mcp add --transport stdio airtable -- npx -y airtable-mcp-server \
--env AIRTABLE_API_KEY=your-key
```

- 数据管理
- 表格操作
- 自动化工作流
- 团队协作
- 报告生成

##### Zapier#

功能: 自动化工作流平台

```
bash复制claude mcp add --transport http zapier https://mcp.zapier.com/mcp \
  --header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http zapier https://mcp.zapier.com/mcp \
  --header "Authorization: Bearer your-token"
```

- 工作流自动化
- 应用集成
- 任务调度
- 数据同步
- 通知管理

##### IFTTT#

功能: 自动化触发器平台

```
bash复制claude mcp add --transport http ifttt https://mcp.ifttt.com/mcp \
--header "Authorization: Bearer your-token"
```

```
claude mcp add --transport http ifttt https://mcp.ifttt.com/mcp \
--header "Authorization: Bearer your-token"
```

---

## 4 MCP 工作原理

**URL**: https://claudecode.tangshuang.net/course/11.4%20MCP%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86

了解 MCP 的工作原理有助于更好地使用和调试 MCP 服务器，充分发挥其扩展能力。

#### MCP 架构#

##### 客户端-服务器模型#

MCP 采用标准的客户端-服务器架构，实现了 Claude Code 与外部工具的解耦和通信：

```
bash复制┌─────────────────┐         ┌─────────────────┐
│   Claude Code   │         │  MCP 服务器     │
│   (客户端)      │◄──────►│   (服务器)       │
└─────────────────┘         └─────────────────┘
│                           │
│                           │
└─────────┬─────────────────┘
│
▼
┌──────────────┐
│  外部服务    │
└──────────────┘
```

```
┌─────────────────┐         ┌─────────────────┐
│   Claude Code   │         │  MCP 服务器     │
│   (客户端)      │◄──────►│   (服务器)       │
└─────────────────┘         └─────────────────┘
│                           │
│                           │
└─────────┬─────────────────┘
│
▼
┌──────────────┐
│  外部服务    │
└──────────────┘
```

##### 组件说明#

True. Claude Code (客户端):

发起工具调用请求
处理服务器响应
管理服务器连接
提供用户界面
True. 发起工具调用请求
True. 处理服务器响应
True. 管理服务器连接
True. 提供用户界面
True. MCP 服务器:

提供工具和资源
执行工具调用
返回结果
处理错误
True. 提供工具和资源
True. 执行工具调用
True. 返回结果
True. 处理错误
True. 外部服务:

数据库（PostgreSQL、MySQL、MongoDB 等）
API（GitHub、AWS、Slack 等）
文件系统（本地和远程）
其他服务（CI/CD、监控、测试等）
True. 数据库（PostgreSQL、MySQL、MongoDB 等）
True. API（GitHub、AWS、Slack 等）
True. 文件系统（本地和远程）
True. 其他服务（CI/CD、监控、测试等）

Claude Code (客户端):

- 发起工具调用请求
- 处理服务器响应
- 管理服务器连接
- 提供用户界面

MCP 服务器:

- 提供工具和资源
- 执行工具调用
- 返回结果
- 处理错误

- 数据库（PostgreSQL、MySQL、MongoDB 等）
- API（GitHub、AWS、Slack 等）
- 文件系统（本地和远程）
- 其他服务（CI/CD、监控、测试等）

#### 通信流程#

##### 初始化流程#

True. 用户启动 Claude Code
True. Claude Code 加载配置
True. 自动连接已配置的 MCP 服务器
True. 发现可用工具和资源
True. 准备接收用户请求

##### 工具调用流程#

```
bash复制1. 用户发起请求
↓
2. Claude Code 分析请求
↓
3. 选择合适的 MCP 工具
↓
4. 构建工具调用请求
↓
5. 发送到 MCP 服务器
↓
6. MCP 服务器执行工具
↓
7. 返回执行结果
↓
8. Claude Code 处理结果
↓
9. 返回给用户
```

```
1. 用户发起请求
↓
2. Claude Code 分析请求
↓
3. 选择合适的 MCP 工具
↓
4. 构建工具调用请求
↓
5. 发送到 MCP 服务器
↓
6. MCP 服务器执行工具
↓
7. 返回执行结果
↓
8. Claude Code 处理结果
↓
9. 返回给用户
```

##### 错误处理流程#

```
bash复制1. 工具调用失败
↓
2. MCP 服务器捕获错误
↓
3. 构建错误响应
↓
4. 返回给 Claude Code
↓
5. Claude Code 显示错误
↓
6. 提供恢复建议
```

```
1. 工具调用失败
↓
2. MCP 服务器捕获错误
↓
3. 构建错误响应
↓
4. 返回给 Claude Code
↓
5. Claude Code 显示错误
↓
6. 提供恢复建议
```

#### 传输方式#

##### HTTP 传输#

- 基于 HTTP 协议
- 支持远程服务器
- 适合云服务
- 易于监控和调试

```
bash复制Claude Code → HTTP 请求 → MCP 服务器
          ↓              ↓
      HTTP 响应 ←      工具执行
```

```
Claude Code → HTTP 请求 → MCP 服务器
          ↓              ↓
      HTTP 响应 ←      工具执行
```

```
bash复制claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

```
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

- 易于部署和扩展
- 支持负载均衡
- 适合云服务集成
- 跨平台兼容性好

- 需要稳定的网络连接
- 可能存在网络延迟
- 需要处理超时和重试

##### SSE 传输#

- 基于 Server-Sent Events
- 支持实时更新
- 已弃用，不建议使用

注意: SSE 传输已弃用，建议使用 HTTP 传输替代。

##### stdio 传输#

- 基于标准输入输出
- 本地进程通信
- 适合本地工具集成

```
bash复制Claude Code → stdout → MCP 服务器
          ↓              ↓
      stdin ←          工具执行
```

```
Claude Code → stdout → MCP 服务器
          ↓              ↓
      stdin ←          工具执行
```

```
bash复制claude mcp add --transport stdio db -- npx -y @bytebase/dbhub
```

```
claude mcp add --transport stdio db -- npx -y @bytebase/dbhub
```

- 无需网络连接
- 低延迟响应
- 安全性高（本地通信）
- 适合敏感数据操作

- 仅限本地使用
- 需要进程管理
- 资源占用较高
- 不适合分布式系统

#### 数据格式#

##### JSON-RPC#

MCP 使用 JSON-RPC 2.0 协议进行通信，这是一种轻量级的远程过程调用协议。

```
json复制{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "tool_name",
    "arguments": {
      "param1": "value1"
    }
  }
}
```

```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "tool_name",
    "arguments": {
      "param1": "value1"
    }
  }
}
```

```
json复制{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Tool result"
      }
    ]
  }
}
```

```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Tool result"
      }
    ]
  }
}
```

```
json复制{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method not found"
  }
}
```

```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method not found"
  }
}
```

```
bash复制### 工具定义
MCP 服务器提供工具定义：
```

```
### 工具定义
MCP 服务器提供工具定义：
```

{
"tools": [
{
"name": "query_database",
"description": "Query the database",
"inputSchema": {
"type": "object",
"properties": {
"query": {
"type": "string",
"description": "SQL query"
}
},
"required": ["query"]
}
}
]
}

MCP 服务器提供资源定义：

```
json复制{
  "resources": [
    {
      "uri": "database://users",
      "name": "Users Table",
      "description": "User data",
      "mimeType": "application/json"
    }
  ]
}
```

```
{
  "resources": [
    {
      "uri": "database://users",
      "name": "Users Table",
      "description": "User data",
      "mimeType": "application/json"
    }
  ]
}
```

#### 状态管理#

##### 连接状态#

MCP 服务器有多种连接状态：

```
bash复制# 检查 MCP 服务器状态
/mcp

# 输出示例
MCP 服务器状态：
- github: 已连接
- sentry: 已连接
- database: 连接错误
```

```
# 检查 MCP 服务器状态
/mcp

# 输出示例
MCP 服务器状态：
- github: 已连接
- sentry: 已连接
- database: 连接错误
```

MCP 服务器支持自动重连：

```
bash复制连接断开
↓
等待重试间隔
↓
尝试重连
↓
成功 → 已连接
失败 → 继续重试
```

```
连接断开
↓
等待重试间隔
↓
尝试重连
↓
成功 → 已连接
失败 → 继续重试
```

#### 性能优化#

##### 连接池#

MCP 使用连接池提高性能：

```
bash复制┌─────────────────┐
│   连接池        │
├─────────────────┤
│ 连接 1         │
│ 连接 2         │
│ 连接 3         │
└─────────────────┘
```

```
┌─────────────────┐
│   连接池        │
├─────────────────┤
│ 连接 1         │
│ 连接 2         │
│ 连接 3         │
└─────────────────┘
```

- 减少连接开销
- 提高响应速度
- 支持并发请求

##### 缓存机制#

MCP 支持结果缓存：

```
bash复制请求 → 检查缓存
↓
命中 → 返回缓存
未命中 → 执行请求
↓
缓存结果
↓
返回结果
```

```
请求 → 检查缓存
↓
命中 → 返回缓存
未命中 → 执行请求
↓
缓存结果
↓
返回结果
```

- 基于时间的过期
- 基于大小的限制
- 基于键的失效

##### 批处理#

MCP 支持批量操作：

```
json复制{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "batch_query",
    "arguments": {
      "queries": [
        "SELECT * FROM users LIMIT 10",
        "SELECT * FROM orders LIMIT 10"
      ]
    }
  }
}
```

```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "batch_query",
    "arguments": {
      "queries": [
        "SELECT * FROM users LIMIT 10",
        "SELECT * FROM orders LIMIT 10"
      ]
    }
  }
}
```

#### 安全机制#

##### 身份验证#

MCP 支持多种身份验证方式：

True. OAuth 2.0:

```
bash复制Claude Code → OAuth 流程 → 访问令牌
↓
使用令牌访问
```

```
Claude Code → OAuth 流程 → 访问令牌
↓
使用令牌访问
```

True. API 密钥:

```
bash复制Claude Code → API 密钥 → 服务器
```

```
Claude Code → API 密钥 → 服务器
```

True. 证书:

```
bash复制Claude Code → 证书 → 服务器
```

```
Claude Code → 证书 → 服务器
```

##### 加密传输#

MCP 支持加密传输：

```
bash复制Claude Code → 加密数据 → MCP 服务器
↓
解密数据
```

```
Claude Code → 加密数据 → MCP 服务器
↓
解密数据
```

支持的加密:

- TLS/SSL
- 自定义加密

##### 权限控制#

MCP 提供细粒度权限控制：

```
json复制{
  "permissions": {
    "tools": ["read", "write"],
    "resources": ["database://users"],
    "operations": ["query", "update"]
  }
}
```

```
{
  "permissions": {
    "tools": ["read", "write"],
    "resources": ["database://users"],
    "operations": ["query", "update"]
  }
}
```

#### 调试和监控#

##### 日志记录#

MCP 服务器记录详细日志：

```
bash复制# 启用详细日志
claude --verbose

# 日志示例
[INFO] MCP server connected: github
[DEBUG] Tool call: query_database
[INFO] Tool result: 10 rows
```

```
# 启用详细日志
claude --verbose

# 日志示例
[INFO] MCP server connected: github
[DEBUG] Tool call: query_database
[INFO] Tool result: 10 rows
```

#### 性能监控#

MCP 提供性能监控功能，帮助用户了解工具调用的效率和质量。

```
bash复制# 查看性能指标
显示 MCP 性能统计

# 输出示例
MCP 性能统计：
- github: 平均响应时间 100ms，成功率 98%
- database: 平均响应时间 50ms，成功率 99.5%
- sentry: 平均响应时间 200ms，成功率 95%
```

```
# 查看性能指标
显示 MCP 性能统计

# 输出示例
MCP 性能统计：
- github: 平均响应时间 100ms，成功率 98%
- database: 平均响应时间 50ms，成功率 99.5%
- sentry: 平均响应时间 200ms，成功率 95%
```

#### 错误追踪#

MCP 提供详细的错误追踪功能，帮助用户定位和解决问题。

```
bash复制# 查看错误日志
显示 MCP 错误日志

# 输出示例
MCP 错误日志：
- database: 连接超时 (3 次)，最后一次 5 分钟前
- github: API 限流 (1 次)，最后一次 10 分钟前
- sentry: 认证失败 (2 次)，最后一次 15 分钟前
```

```
# 查看错误日志
显示 MCP 错误日志

# 输出示例
MCP 错误日志：
- database: 连接超时 (3 次)，最后一次 5 分钟前
- github: API 限流 (1 次)，最后一次 10 分钟前
- sentry: 认证失败 (2 次)，最后一次 15 分钟前
```

#### 调试技巧#

##### 启用调试模式#

```
bash复制# 启用调试模式
claude --debug-mcp
```

```
# 启用调试模式
claude --debug-mcp
```

##### 查看详细日志#

```
bash复制# 查看详细 MCP 日志
claude --verbose
```

```
# 查看详细 MCP 日志
claude --verbose
```

##### 测试服务器连接#

```
bash复制# 测试 MCP 服务器连接
/mcp test
```

```
# 测试 MCP 服务器连接
/mcp test
```

---

# 第 12 章

## 1 添加 MCP 服务器

**URL**: https://claudecode.tangshuang.net/course/12.1%20%E6%B7%BB%E5%8A%A0%20MCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8

学习如何添加不同类型的 MCP 服务器到 Claude Code。

#### 添加远程 HTTP 服务器#

HTTP 服务器是连接到远程 MCP 服务器的推荐选项。

##### 基本语法#

```
bash复制claude mcp add --transport http <name> <url>
```

```
claude mcp add --transport http <name> <url>
```

##### 示例：连接到 Notion#

```
bash复制claude mcp add --transport http notion https://mcp.notion.com/mcp
```

```
claude mcp add --transport http notion https://mcp.notion.com/mcp
```

##### 带身份验证的示例#

```
bash复制# Bearer 令牌
claude mcp add --transport http secure-api https://api.example.com/mcp \
--header "Authorization: Bearer your-token"

# API 密钥
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-API-Key: your-api-key"
```

```
# Bearer 令牌
claude mcp add --transport http secure-api https://api.example.com/mcp \
--header "Authorization: Bearer your-token"

# API 密钥
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-API-Key: your-api-key"
```

##### 带多个标头的示例#

```
bash复制claude mcp add --transport http custom-api https://api.example.com/mcp \
  --header "Authorization: Bearer your-token" \
  --header "X-Custom-Header: custom-value"
```

```
claude mcp add --transport http custom-api https://api.example.com/mcp \
  --header "Authorization: Bearer your-token" \
  --header "X-Custom-Header: custom-value"
```

#### 添加远程 SSE 服务器#

SSE（Server-Sent Events）传输已弃用，请在可用的地方使用 HTTP 服务器。

##### 基本语法#

```
bash复制claude mcp add --transport sse <name> <url>
```

```
claude mcp add --transport sse <name> <url>
```

##### 示例：连接到 Asana#

```
bash复制claude mcp add --transport sse asana https://mcp.asana.com/sse
```

```
claude mcp add --transport sse asana https://mcp.asana.com/sse
```

##### 带身份验证的示例#

```
bash复制claude mcp add --transport sse private-api https://api.company.com/sse \
--header "X-API-Key: your-key-here"
```

```
claude mcp add --transport sse private-api https://api.company.com/sse \
--header "X-API-Key: your-key-here"
```

#### 添加本地 stdio 服务器#

Stdio 服务器作为本地进程在您的计算机上运行。

##### 基本语法#

```
bash复制claude mcp add --transport stdio <name> <command> [args...]
```

```
claude mcp add --transport stdio <name> <command> [args...]
```

##### 示例：添加 Airtable 服务器#

```
bash复制claude mcp add --transport stdio airtable --env AIRTABLE_API_KEY=YOUR_KEY \
-- npx -y airtable-mcp-server
```

```
claude mcp add --transport stdio airtable --env AIRTABLE_API_KEY=YOUR_KEY \
-- npx -y airtable-mcp-server
```

##### 示例：添加数据库服务器#

```
bash复制claude mcp add --transport stdio db -- npx -y @bytebase/dbhub \
  --dsn "postgresql://readonly:pass@prod.db.com:5432/analytics"
```

```
claude mcp add --transport stdio db -- npx -y @bytebase/dbhub \
  --dsn "postgresql://readonly:pass@prod.db.com:5432/analytics"
```

##### 示例：添加 Python 服务器#

```
bash复制claude mcp add --transport stdio python-server -- python server.py
```

```
claude mcp add --transport stdio python-server -- python server.py
```

##### 使用 -- 参数#

```
--
```

--（双破折号）将 Claude 自己的 CLI 标志与传递给 MCP 服务器的命令和参数分开。

```
--
```

```
bash复制# 运行 npx server
claude mcp add --transport stdio myserver -- npx server

# 运行 python server.py --port 8080
claude mcp add --transport stdio myserver --env KEY=value -- python server.py --port 8080
```

```
# 运行 npx server
claude mcp add --transport stdio myserver -- npx server

# 运行 python server.py --port 8080
claude mcp add --transport stdio myserver --env KEY=value -- python server.py --port 8080
```

##### Windows 用户注意事项#

在本机 Windows（不是 WSL）上，使用 npx 的本地 MCP 服务器需要 cmd /c 包装器：

```
npx
```

```
cmd /c
```

```
bash复制claude mcp add --transport stdio my-server -- cmd /c npx -y @some/package
```

```
claude mcp add --transport stdio my-server -- cmd /c npx -y @some/package
```

#### 配置选项#

##### 环境变量#

使用 --env 标志设置环境变量：

```
--env
```

```
bash复制claude mcp add --transport stdio db \
  --env DB_URL=postgresql://user:pass@localhost/db \
  --env DB_TIMEOUT=30 \
  -- npx -y db-server
```

```
claude mcp add --transport stdio db \
  --env DB_URL=postgresql://user:pass@localhost/db \
  --env DB_TIMEOUT=30 \
  -- npx -y db-server
```

##### 作用域#

使用 --scope 标志指定配置的存储位置：

```
--scope
```

```
bash复制# 本地范围（默认）
claude mcp add --transport http github https://api.github.com/mcp/

# 项目范围
claude mcp add --transport http github --scope project https://api.github.com/mcp/

# 用户范围
claude mcp add --transport http github --scope user https://api.github.com/mcp/
```

```
# 本地范围（默认）
claude mcp add --transport http github https://api.github.com/mcp/

# 项目范围
claude mcp add --transport http github --scope project https://api.github.com/mcp/

# 用户范围
claude mcp add --transport http github --scope user https://api.github.com/mcp/
```

##### 超时设置#

使用 MCP_TIMEOUT 环境变量配置 MCP 服务器启动超时：

```
MCP_TIMEOUT
```

```
bash复制# 设置 10 秒超时
MCP_TIMEOUT=10000 claude
```

```
# 设置 10 秒超时
MCP_TIMEOUT=10000 claude
```

##### 输出限制#

使用 MAX_MCP_OUTPUT_TOKENS 环境变量增加输出限制：

```
MAX_MCP_OUTPUT_TOKENS
```

```
bash复制# 设置 50,000 令牌限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
```

```
# 设置 50,000 令牌限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
```

#### 身份验证#

##### OAuth 2.0#

许多基于云的 MCP 服务器需要 OAuth 2.0 身份验证：

```
bash复制# 1. 添加服务器
claude mcp add --transport http github https://api.github.com/mcp/

# 2. 在 Claude Code 中进行身份验证
/mcp

# 3. 选择需要身份验证的服务器
# 4. 按照 OAuth 流程完成身份验证
```

```
# 1. 添加服务器
claude mcp add --transport http github https://api.github.com/mcp/

# 2. 在 Claude Code 中进行身份验证
/mcp

# 3. 选择需要身份验证的服务器
# 4. 按照 OAuth 流程完成身份验证
```

##### API 密钥#

使用 API 密钥进行身份验证：

```
bash复制claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"
```

```
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"
```

##### 环境变量#

使用环境变量传递凭证：

```
bash复制claude mcp add --transport stdio db \
  --env API_KEY=your-key \
  -- npx -y db-server
```

```
claude mcp add --transport stdio db \
  --env API_KEY=your-key \
  -- npx -y db-server
```

#### 验证安装#

##### 检查服务器状态#

```
bash复制# 列出所有已配置的服务器
claude mcp list

# 获取特定服务器的详细信息
claude mcp get github

# 在 Claude Code 中检查服务器状态
/mcp
```

```
# 列出所有已配置的服务器
claude mcp list

# 获取特定服务器的详细信息
claude mcp get github

# 在 Claude Code 中检查服务器状态
/mcp
```

##### 测试服务器连接#

```
bash复制# 测试服务器连接
测试 MCP 服务器连接

# 使用服务器工具
使用 GitHub 工具查看 PR
```

```
# 测试服务器连接
测试 MCP 服务器连接

# 使用服务器工具
使用 GitHub 工具查看 PR
```

#### 常见问题#

##### 连接失败#

问题: 无法连接到 MCP 服务器

##### 身份验证错误#

问题: 身份验证失败

##### 超时错误#

问题: 服务器启动超时

##### Windows 执行错误#

问题: Windows 上无法执行 npx 命令

```
npx
```

```
bash复制# 使用 cmd /c 包装器
claude mcp add --transport stdio my-server -- cmd /c npx -y @some/package
```

```
# 使用 cmd /c 包装器
claude mcp add --transport stdio my-server -- cmd /c npx -y @some/package
```

#### 最佳实践#

##### 1. 选择合适的传输方式#

- HTTP: 适合远程服务器和云服务
- stdio: 适合本地工具和脚本
- SSE: 已弃用，使用 HTTP 替代

##### 2. 安全配置#

- 使用强身份验证
- 限制权限范围
- 使用环境变量管理凭证
- 定期更新凭证

##### 3. 性能优化#

- 设置适当的超时
- 配置输出限制
- 使用连接池
- 启用缓存

##### 4. 错误处理#

- 捕获和处理错误
- 提供恢复方案
- 记录错误日志
- 监控服务器状态

#### 删除服务器#

如果不再需要服务器，可以删除它：

```
bash复制# 删除服务器
claude mcp remove github

# 确认删除
# 服务器已成功删除
```

```
# 删除服务器
claude mcp remove github

# 确认删除
# 服务器已成功删除
```

#### 重置配置#

如果需要重置项目范围的选择：

```
bash复制# 重置项目选择
claude mcp reset-project-choices
```

```
# 重置项目选择
claude mcp reset-project-choices
```

---

## 2 MCP 安装范围

**URL**: https://claudecode.tangshuang.net/course/12.2%20MCP%20%E5%AE%89%E8%A3%85%E8%8C%83%E5%9B%B4

MCP 服务器可以在三个不同的范围级别进行配置，每个级别都用于管理服务器可访问性和共享的不同目的。

#### 本地范围#

##### 概述#

本地范围的服务器代表默认配置级别，存储在您的项目特定用户设置中。这些服务器对您保持私密，仅在当前项目目录中工作时可访问。

##### 适用场景#

- 个人开发服务器
- 实验配置
- 包含敏感凭证的服务器
- 特定于一个项目的工具

##### 添加本地范围服务器#

```
bash复制# 默认添加（本地范围）
claude mcp add --transport http stripe https://mcp.stripe.com

# 显式指定本地范围
claude mcp add --transport http stripe --scope local https://mcp.stripe.com
```

```
# 默认添加（本地范围）
claude mcp add --transport http stripe https://mcp.stripe.com

# 显式指定本地范围
claude mcp add --transport http stripe --scope local https://mcp.stripe.com
```

##### 存储位置#

本地范围的服务器配置存储在：

```
json复制~/.claude/projects/<project-id>/mcp.json
```

```
~/.claude/projects/<project-id>/mcp.json
```

##### 特点#

- 私密性: 仅对您可用
- 项目特定: 仅在当前项目中工作
- 不共享: 不会与其他开发者共享
- 优先级: 最高优先级

#### 项目范围#

##### 概述#

项目范围的服务器通过在项目根目录中存储配置到 .mcp.json 文件来启用团队协作。此文件设计为检入版本控制，确保所有团队成员都可以访问相同的 MCP 工具和服务。

```
.mcp.json
```

##### 适用场景#

- 团队共享服务器
- 项目特定工具
- 协作所需的服务
- 标准化开发环境

##### 添加项目范围服务器#

claude mcp add --transport http paypal --scope project https://mcp.paypal.com/mcp

```
bash复制### 配置文件格式

生成的 `.mcp.json` 文件遵循标准化格式：

~~~json
```json

{
  "mcpServers": {
    "shared-server": {
      "command": "/path/to/server",
      "args": [],
      "env": {}
    }
  }
}

```### HTTP 服务器配置

{
"mcpServers": {
"api-server": {
"type": "http",
"url": "https://api.example.com/mcp",
"headers": {
"Authorization": "Bearer ${API_KEY}"
}
}
}
}
```

```
### 配置文件格式

生成的 `.mcp.json` 文件遵循标准化格式：

~~~json
```json

{
  "mcpServers": {
    "shared-server": {
      "command": "/path/to/server",
      "args": [],
      "env": {}
    }
  }
}

```### HTTP 服务器配置

{
"mcpServers": {
"api-server": {
"type": "http",
"url": "https://api.example.com/mcp",
"headers": {
"Authorization": "Bearer ${API_KEY}"
}
}
}
}
```

##### stdio 服务器配置#

```
json复制```json

{
  "mcpServers": {
    "database-tools": {
      "command": "npx",
      "args": ["-y", "@bytebase/dbhub"],
      "env": {
        "DB_URL": "${DB_URL:-postgresql://localhost/db}"
      }
    }
  }
}

```### 环境变量扩展

Claude Code 支持 `.mcp.json` 文件中的环境变量扩展：

> **支持的语法**:
> - `${VAR}` - 扩展为环境变量 `VAR` 的值
> - `${VAR:-default}` - 如果设置了 `VAR`，则扩展为 `VAR`，否则使用 `default`

> **扩展位置**:
> - `command` - 服务器可执行文件路径
> - `args` - 命令行参数
> - `env` - 传递给服务器的环境变量
> - `url` - 对于 HTTP 服务器类型
> - `headers` - 对于 HTTP 服务器身份验证

> **示例**:

{
"mcpServers": {
"api-server": {
"type": "http",
"url": "${API_BASE_URL:-https://api.example.com}/mcp",
"headers": {
"Authorization": "Bearer ${API_KEY}"
}
}
}
}

```
### 安全提示

出于安全原因，Claude Code 在使用来自 `.mcp.json` 文件的项目范围服务器之前会提示批准。

### 重置批准选择

如果需要重置这些批准选择：

~~~bash
```bash

claude mcp reset-project-choices

```## 用户范围

### 概述

用户范围的服务器提供跨项目可访问性，使其在您计算机上的所有项目中可用，同时对您的用户帐户保持私密。

### 适用场景

> - 个人实用程序服务器
> - 开发工具
> - 在不同项目中经常使用的服务
> - 个人工作流自动化

### 添加用户范围服务器

claude mcp add --transport http hubspot --scope user https://mcp.hubspot.com/anthropic

```
### 存储位置

用户范围的服务器配置存储在：

```> ~/.claude/mcp.json
```

```
```json

{
  "mcpServers": {
    "database-tools": {
      "command": "npx",
      "args": ["-y", "@bytebase/dbhub"],
      "env": {
        "DB_URL": "${DB_URL:-postgresql://localhost/db}"
      }
    }
  }
}

```### 环境变量扩展

Claude Code 支持 `.mcp.json` 文件中的环境变量扩展：

> **支持的语法**:
> - `${VAR}` - 扩展为环境变量 `VAR` 的值
> - `${VAR:-default}` - 如果设置了 `VAR`，则扩展为 `VAR`，否则使用 `default`

> **扩展位置**:
> - `command` - 服务器可执行文件路径
> - `args` - 命令行参数
> - `env` - 传递给服务器的环境变量
> - `url` - 对于 HTTP 服务器类型
> - `headers` - 对于 HTTP 服务器身份验证

> **示例**:

{
"mcpServers": {
"api-server": {
"type": "http",
"url": "${API_BASE_URL:-https://api.example.com}/mcp",
"headers": {
"Authorization": "Bearer ${API_KEY}"
}
}
}
}

```
### 安全提示

出于安全原因，Claude Code 在使用来自 `.mcp.json` 文件的项目范围服务器之前会提示批准。

### 重置批准选择

如果需要重置这些批准选择：

~~~bash
```bash

claude mcp reset-project-choices

```## 用户范围

### 概述

用户范围的服务器提供跨项目可访问性，使其在您计算机上的所有项目中可用，同时对您的用户帐户保持私密。

### 适用场景

> - 个人实用程序服务器
> - 开发工具
> - 在不同项目中经常使用的服务
> - 个人工作流自动化

### 添加用户范围服务器

claude mcp add --transport http hubspot --scope user https://mcp.hubspot.com/anthropic

```
### 存储位置

用户范围的服务器配置存储在：

```> ~/.claude/mcp.json
```

##### 特点#

- 跨项目: 在所有项目中可用
- 用户特定: 仅对您的用户帐户可用
- 持久化: 配置持久保存
- 优先级: 最低优先级

#### 范围层次结构和优先级#

##### 优先级顺序#

MCP 服务器配置遵循明确的优先级层次结构：

##### 冲突解决#

当具有相同名称的服务器存在于多个范围时，系统按优先级解决冲突：

### 用户范围

claude mcp add --transport http github --scope user https://api.github.com/mcp

### 项目范围

claude mcp add --transport http github --scope project https://api.github.com/mcp

### 本地范围

claude mcp add --transport http github --scope local https://api.github.com/mcp

### 使用时，本地范围的 github 服务器将被使用

```
bash复制### 查看有效配置
```

```
### 查看有效配置
```

### 查看所有已配置的服务器

claude mcp list

### 查看特定服务器的详细信息

claude mcp get github

#### 选择正确的范围#

##### 决策树#

需要与团队共享？
是 → 项目范围
否 →
需要在多个项目中使用？
是 → 用户范围
否 → 本地范围

```
bash复制### 场景示例
#### 场景 1: 个人实验
~~~bash
bash

# 本地范围
claude mcp add --transport http experimental https://api.example.com/experimental

```#### 场景 2: 团队数据库

# 项目范围
claude mcp add --transport stdio db --scope project \
--env DB_URL=${DB_URL} \
-- npx -y @bytebase/dbhub

```
#### 场景 3: 个人工具

~~~bash
```bash

# 用户范围
claude mcp add --transport stdio formatter --scope user \
  -- npx -y @my/formatter

```## 最佳实践

### 1. 敏感凭证使用本地范围

# 包含 API 密钥的配置
claude mcp add --transport http private-api --scope local \
https://api.example.com/mcp \
--header "Authorization: Bearer your-secret-key"

```
### 2. 团队共享使用项目范围

~~~bash
```bash

# 团队共享的数据库配置
claude mcp add --transport stdio team-db --scope project \
  --env DB_URL=${TEAM_DB_URL} \
  -- npx -y @bytebase/dbhub

```### 3. 个人工具使用用户范围

# 个人开发工具
claude mcp add --transport stdio my-tools --scope user \
-- npx -y @my/tools

```
### 4. 使用环境变量

~~~json
```json

{
  "mcpServers": {
    "api-server": {
      "type": "http",
      "url": "${API_BASE_URL:-https://api.example.com}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}

```## 迁移配置

### 从本地迁移到项目

# 1. 查看本地配置
claude mcp get my-server
# 2. 添加到项目范围
claude mcp add --transport http my-server --scope project <url>
# 3. 删除本地配置
claude mcp remove my-server

```
### 从用户迁移到项目

~~~bash
```bash

# 1. 查看用户配置
claude mcp get my-server

# 2. 添加到项目范围
claude mcp add --transport http my-server --scope project <url>

# 3. 删除用户配置
claude mcp remove my-server

```

## 故障排除

### 配置未生效

**问题**: 配置更改未生效

**解决方案**:
1. 重启 Claude Code
2. 检查配置文件语法
3. 验证环境变量
4. 查看错误日志

### 环境变量未扩展

**问题**: 环境变量未正确扩展

**解决方案**:
1. 验证环境变量语法
2. 确认环境变量已设置
3. 检查默认值设置
4. 查看配置文件

### 权限问题

**问题**: 无法访问项目范围服务器

**解决方案**:
1. 检查文件权限
2. 验证 `.mcp.json` 存在
3. 确认项目目录正确
4. 重置批准选择
```
```
```

```
### 场景示例
#### 场景 1: 个人实验
~~~bash
bash

# 本地范围
claude mcp add --transport http experimental https://api.example.com/experimental

```#### 场景 2: 团队数据库

# 项目范围
claude mcp add --transport stdio db --scope project \
--env DB_URL=${DB_URL} \
-- npx -y @bytebase/dbhub

```
#### 场景 3: 个人工具

~~~bash
```bash

# 用户范围
claude mcp add --transport stdio formatter --scope user \
  -- npx -y @my/formatter

```## 最佳实践

### 1. 敏感凭证使用本地范围

# 包含 API 密钥的配置
claude mcp add --transport http private-api --scope local \
https://api.example.com/mcp \
--header "Authorization: Bearer your-secret-key"

```
### 2. 团队共享使用项目范围

~~~bash
```bash

# 团队共享的数据库配置
claude mcp add --transport stdio team-db --scope project \
  --env DB_URL=${TEAM_DB_URL} \
  -- npx -y @bytebase/dbhub

```### 3. 个人工具使用用户范围

# 个人开发工具
claude mcp add --transport stdio my-tools --scope user \
-- npx -y @my/tools

```
### 4. 使用环境变量

~~~json
```json

{
  "mcpServers": {
    "api-server": {
      "type": "http",
      "url": "${API_BASE_URL:-https://api.example.com}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}

```## 迁移配置

### 从本地迁移到项目

# 1. 查看本地配置
claude mcp get my-server
# 2. 添加到项目范围
claude mcp add --transport http my-server --scope project <url>
# 3. 删除本地配置
claude mcp remove my-server

```
### 从用户迁移到项目

~~~bash
```bash

# 1. 查看用户配置
claude mcp get my-server

# 2. 添加到项目范围
claude mcp add --transport http my-server --scope project <url>

# 3. 删除用户配置
claude mcp remove my-server

```

## 故障排除

### 配置未生效

**问题**: 配置更改未生效

**解决方案**:
1. 重启 Claude Code
2. 检查配置文件语法
3. 验证环境变量
4. 查看错误日志

### 环境变量未扩展

**问题**: 环境变量未正确扩展

**解决方案**:
1. 验证环境变量语法
2. 确认环境变量已设置
3. 检查默认值设置
4. 查看配置文件

### 权限问题

**问题**: 无法访问项目范围服务器

**解决方案**:
1. 检查文件权限
2. 验证 `.mcp.json` 存在
3. 确认项目目录正确
4. 重置批准选择
```
```
```

---

## 3 MCP 服务器管理

**URL**: https://claudecode.tangshuang.net/course/12.3%20MCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86

学习如何管理已配置的 MCP 服务器，包括列出、查看详情、删除和检查状态。

#### 列出服务器#

##### 列出所有服务器#

claude mcp list

```
bash复制已配置的 MCP 服务器：

本地范围：
- github: https://api.githubcopilot.com/mcp/
- sentry: https://mcp.sentry.dev/mcp

项目范围：
- database: stdio server
- api: http server

用户范围：
```

```
已配置的 MCP 服务器：

本地范围：
- github: https://api.githubcopilot.com/mcp/
- sentry: https://mcp.sentry.dev/mcp

项目范围：
- database: stdio server
- api: http server

用户范围：
```

- formatter: stdio server

```
bash复制### 列出特定范围的服务器

# 列出本地范围服务器
claude mcp list --scope local
# 列出项目范围服务器
claude mcp list --scope project
# 列出用户范围服务器
claude mcp list --scope user
```

```
### 列出特定范围的服务器

# 列出本地范围服务器
claude mcp list --scope local
# 列出项目范围服务器
claude mcp list --scope project
# 列出用户范围服务器
claude mcp list --scope user
```

#### 获取服务器详情#

##### 基本用法#

claude mcp get <server-name>

```
bash复制
### 示例：查看 GitHub 服务器详情

```bash
claude mcp get github
```

```
### 示例：查看 GitHub 服务器详情

```bash
claude mcp get github
```

```
bash复制服务器名称: github
传输方式: http
URL: https://api.githubcopilot.com/mcp/
范围: local
状态: 已连接
工具: 15
资源: 5
```

```
服务器名称: github
传输方式: http
URL: https://api.githubcopilot.com/mcp/
范围: local
状态: 已连接
工具: 15
资源: 5
```

##### 示例：查看数据库服务器详情#

```
bash复制claude mcp get database
```

```
claude mcp get database
```

```
bash复制服务器名称: database
传输方式: stdio
命令: npx -y @bytebase/dbhub
参数: --dsn "postgresql://readonly:pass@prod.db.com:5432/analytics"
范围: project
状态: 已连接
工具: 8
资源: 3
```

```
服务器名称: database
传输方式: stdio
命令: npx -y @bytebase/dbhub
参数: --dsn "postgresql://readonly:pass@prod.db.com:5432/analytics"
范围: project
状态: 已连接
工具: 8
资源: 3
```

#### 删除服务器#

##### 基本用法#

```
bash复制claude mcp remove <server-name>
```

```
claude mcp remove <server-name>
```

##### 示例：删除 GitHub 服务器#

```
bash复制claude mcp remove github
```

```
claude mcp remove github
```

```
bash复制确认删除服务器 github? (y/n): y
服务器 github 已成功删除
```

```
确认删除服务器 github? (y/n): y
服务器 github 已成功删除
```

##### 删除特定范围的服务器#

```
bash复制# 删除本地范围服务器
claude mcp remove github --scope local

# 删除项目范围服务器
claude mcp remove database --scope project

# 删除用户范围服务器
claude mcp remove formatter --scope user
```

```
# 删除本地范围服务器
claude mcp remove github --scope local

# 删除项目范围服务器
claude mcp remove database --scope project

# 删除用户范围服务器
claude mcp remove formatter --scope user
```

##### 批量删除#

```
bash复制# 删除多个服务器
claude mcp remove github sentry database
```

```
# 删除多个服务器
claude mcp remove github sentry database
```

#### 检查服务器状态#

##### 在 Claude Code 中检查#

```
bash复制/mcp
```

```
/mcp
```

```
bash复制MCP 服务器状态：
本地范围：
✅ github: 已连接 (15 工具, 5 资源)
✅ sentry: 已连接 (10 工具, 3 资源)
项目范围：
✅ database: 已连接 (8 工具, 3 资源)
❌ api: 连接错误
用户范围：
✅ formatter: 已连接 (5 工具, 0 资源)
```

```
MCP 服务器状态：
本地范围：
✅ github: 已连接 (15 工具, 5 资源)
✅ sentry: 已连接 (10 工具, 3 资源)
项目范围：
✅ database: 已连接 (8 工具, 3 资源)
❌ api: 连接错误
用户范围：
✅ formatter: 已连接 (5 工具, 0 资源)
```

##### 检查特定服务器状态#

```
bash复制# 检查 GitHub 服务器状态
claude mcp get github
```

```
# 检查 GitHub 服务器状态
claude mcp get github
```

```
bash复制GitHub 服务器状态：
- 状态: 已连接
- 响应时间: 100ms
- 最后检查: 2 分钟前
- 工具数量: 15
- 资源数量: 5
```

```
GitHub 服务器状态：
- 状态: 已连接
- 响应时间: 100ms
- 最后检查: 2 分钟前
- 工具数量: 15
- 资源数量: 5
```

#### 测试服务器连接#

##### 测试所有服务器#

```
bash复制# 测试所有 MCP 服务器连接
claude mcp list
```

```
# 测试所有 MCP 服务器连接
claude mcp list
```

```
bash复制测试 MCP 服务器连接：
✅ github: 连接成功 (50ms)
✅ sentry: 连接成功 (80ms)
✅ database: 连接成功 (30ms)
❌ api: 连接失败 - 超时
```

```
测试 MCP 服务器连接：
✅ github: 连接成功 (50ms)
✅ sentry: 连接成功 (80ms)
✅ database: 连接成功 (30ms)
❌ api: 连接失败 - 超时
```

##### 测试特定服务器#

```
bash复制# 测试 GitHub 服务器连接
claude mcp get github
```

```
# 测试 GitHub 服务器连接
claude mcp get github
```

```
bash复制测试 GitHub 服务器连接：
✅ 连接成功
响应时间: 50ms
服务器版本: 1.2.3
```

```
测试 GitHub 服务器连接：
✅ 连接成功
响应时间: 50ms
服务器版本: 1.2.3
```

#### 更新服务器配置#

##### 更新 HTTP 服务器#

```
bash复制# 删除旧配置
claude mcp remove github

# 添加新配置
claude mcp add --transport http github https://api.githubcopilot.com/mcp/v2
```

```
# 删除旧配置
claude mcp remove github

# 添加新配置
claude mcp add --transport http github https://api.githubcopilot.com/mcp/v2
```

##### 更新 stdio 服务器#

```
bash复制# 删除旧配置
claude mcp remove database

# 添加新配置
claude mcp add --transport stdio database \
--env DB_URL=new-db-url \
-- npx -y @bytebase/dbhub
```

```
# 删除旧配置
claude mcp remove database

# 添加新配置
claude mcp add --transport stdio database \
--env DB_URL=new-db-url \
-- npx -y @bytebase/dbhub
```

##### 更新环境变量#

```
bash复制# 对于项目范围服务器，编辑 .mcp.json
vim .mcp.json
```

```
# 对于项目范围服务器，编辑 .mcp.json
vim .mcp.json
```

```
json复制{
  "mcpServers": {
    "database": {
      "command": "npx",
      "args": ["-y", "@bytebase/dbhub"],
      "env": {
        "DB_URL": "${NEW_DB_URL:-postgresql://localhost/db}"
      }
    }
  }
}
```

```
{
  "mcpServers": {
    "database": {
      "command": "npx",
      "args": ["-y", "@bytebase/dbhub"],
      "env": {
        "DB_URL": "${NEW_DB_URL:-postgresql://localhost/db}"
      }
    }
  }
}
```

#### 重置配置#

##### 重置项目选择#

```
bash复制claude mcp reset-project-choices
```

```
claude mcp reset-project-choices
```

此命令将清除所有项目范围 MCP 服务器的批准选择。

##### 重置所有配置#

```
bash复制# 删除所有本地范围服务器
claude mcp list --scope local | awk '{print $1}' | xargs claude mcp remove

# 删除所有用户范围服务器
claude mcp list --scope user | awk '{print $1}' | xargs claude mcp remove
```

```
# 删除所有本地范围服务器
claude mcp list --scope local | awk '{print $1}' | xargs claude mcp remove

# 删除所有用户范围服务器
claude mcp list --scope user | awk '{print $1}' | xargs claude mcp remove
```

#### 监控服务器性能#

##### 查看性能统计#

```
bash复制# 显示 MCP 服务器性能统计
claude mcp list
```

```
# 显示 MCP 服务器性能统计
claude mcp list
```

```
bash复制MCP 服务器性能统计：

github:
- 平均响应时间: 100ms
- 总调用次数: 150
- 成功率: 99.3%
- 最后调用: 1 分钟前

sentry:
- 平均响应时间: 200ms
- 总调用次数: 50
- 成功率: 100%
- 最后调用: 5 分钟前

database:
- 平均响应时间: 50ms
- 总调用次数: 300
- 成功率: 98.7%
- 最后调用: 30 秒前
```

```
MCP 服务器性能统计：

github:
- 平均响应时间: 100ms
- 总调用次数: 150
- 成功率: 99.3%
- 最后调用: 1 分钟前

sentry:
- 平均响应时间: 200ms
- 总调用次数: 50
- 成功率: 100%
- 最后调用: 5 分钟前

database:
- 平均响应时间: 50ms
- 总调用次数: 300
- 成功率: 98.7%
- 最后调用: 30 秒前
```

##### 查看错误日志#

```
bash复制# 显示 MCP 服务器错误日志
claude --verbose
```

```
# 显示 MCP 服务器错误日志
claude --verbose
```

```
bash复制MCP 服务器错误日志：

api:
- [2024-01-15 10:30:00] 连接超时
- [2024-01-15 10:35:00] API 限流

database:
- [2024-01-15 10:20:00] 查询超时
- [2024-01-15 10:25:00] 连接失败
```

```
MCP 服务器错误日志：

api:
- [2024-01-15 10:30:00] 连接超时
- [2024-01-15 10:35:00] API 限流

database:
- [2024-01-15 10:20:00] 查询超时
- [2024-01-15 10:25:00] 连接失败
```

#### 故障排除#

##### 服务器连接失败#

问题: 服务器无法连接

```
bash复制# 1. 检查服务器状态
/mcp

# 2. 测试连接
claude mcp list

# 3. 查看错误日志
claude --verbose

# 4. 验证配置
claude mcp get server-name

# 5. 重新配置服务器
claude mcp remove server-name
claude mcp add --transport http server-name <url>
```

```
# 1. 检查服务器状态
/mcp

# 2. 测试连接
claude mcp list

# 3. 查看错误日志
claude --verbose

# 4. 验证配置
claude mcp get server-name

# 5. 重新配置服务器
claude mcp remove server-name
claude mcp add --transport http server-name <url>
```

##### 服务器响应缓慢#

问题: 服务器响应时间过长

```
bash复制# 1. 查看性能统计
claude mcp list

# 2. 检查网络连接
ping api.example.com

# 3. 增加超时设置
MCP_TIMEOUT=30000 claude

# 4. 优化服务器配置
# 考虑使用更快的传输方式
```

```
# 1. 查看性能统计
claude mcp list

# 2. 检查网络连接
ping api.example.com

# 3. 增加超时设置
MCP_TIMEOUT=30000 claude

# 4. 优化服务器配置
# 考虑使用更快的传输方式
```

##### 工具调用失败#

问题: MCP 工具调用失败

```
bash复制# 1. 检查服务器状态
/mcp

# 2. 验证工具参数
# 检查工具参数

# 3. 查看错误日志
claude --verbose

# 4. 重试工具调用
# 重试工具调用
```

```
# 1. 检查服务器状态
/mcp

# 2. 验证工具参数
# 检查工具参数

# 3. 查看错误日志
claude --verbose

# 4. 重试工具调用
# 重试工具调用
```

##### 配置文件错误#

问题: .mcp.json 配置文件有错误

```
.mcp.json
```

```
bash复制# 1. 验证 JSON 语法
cat .mcp.json | jq .

# 2. 检查环境变量
echo $API_KEY

# 3. 查看错误日志
claude --verbose

# 4. 修复配置文件
vim .mcp.json
```

```
# 1. 验证 JSON 语法
cat .mcp.json | jq .

# 2. 检查环境变量
echo $API_KEY

# 3. 查看错误日志
claude --verbose

# 4. 修复配置文件
vim .mcp.json
```

#### 最佳实践#

##### 1. 定期检查服务器状态#

```
bash复制# 每天检查一次
/mcp
```

```
# 每天检查一次
/mcp
```

##### 2. 监控性能#

```
bash复制# 定期查看性能统计
claude mcp list

# 识别慢速服务器
# 优化配置或更换服务器
```

```
# 定期查看性能统计
claude mcp list

# 识别慢速服务器
# 优化配置或更换服务器
```

##### 3. 及时删除不需要的服务器#

```
bash复制# 定期清理不使用的服务器
claude mcp list
claude mcp remove unused-server
```

```
# 定期清理不使用的服务器
claude mcp list
claude mcp remove unused-server
```

##### 4. 备份配置#

```
bash复制# 备份 .mcp.json
cp .mcp.json .mcp.json.backup

# 备份用户配置
cp ~/.claude/mcp.json ~/.claude/mcp.json.backup
```

```
# 备份 .mcp.json
cp .mcp.json .mcp.json.backup

# 备份用户配置
cp ~/.claude/mcp.json ~/.claude/mcp.json.backup
```

##### 5. 文档化配置#

```
bash复制# 创建配置文档
echo "MCP 服务器配置说明" > MCP_CONFIG.md
echo "- github: 用于代码审查" >> MCP_CONFIG.md
echo "- database: 用于数据查询" >> MCP_CONFIG.md
```

```
# 创建配置文档
echo "MCP 服务器配置说明" > MCP_CONFIG.md
echo "- github: 用于代码审查" >> MCP_CONFIG.md
echo "- database: 用于数据查询" >> MCP_CONFIG.md
```

#### 自动化管理#

##### 使用脚本管理#

```
bash复制#!/bin/bash
# mcp-manager.sh

# 列出服务器
list_servers() {
    claude mcp list
}

# 添加服务器
add_server() {
    claude mcp add "$@"
}

# 删除服务器
remove_server() {
    claude mcp remove "$@"
}

# 检查状态
check_status() {
    echo "> /mcp" | claude
}

# 主函数
case "$1" in
    list) list_servers ;;
    add) shift; add_server "$@" ;;
    remove) shift; remove_server "$@" ;;
    status) check_status ;;
    *) echo "用法: $0 {list|add|remove|status}" ;;
esac
```

```
#!/bin/bash
# mcp-manager.sh

# 列出服务器
list_servers() {
    claude mcp list
}

# 添加服务器
add_server() {
    claude mcp add "$@"
}

# 删除服务器
remove_server() {
    claude mcp remove "$@"
}

# 检查状态
check_status() {
    echo "> /mcp" | claude
}

# 主函数
case "$1" in
    list) list_servers ;;
    add) shift; add_server "$@" ;;
    remove) shift; remove_server "$@" ;;
    status) check_status ;;
    *) echo "用法: $0 {list|add|remove|status}" ;;
esac
```

##### 定期维护#

```
bash复制#!/bin/bash
# mcp-maintenance.sh

# 检查所有服务器状态
echo "检查 MCP 服务器状态..."
claude mcp list

# 测试连接
echo "测试服务器连接..."
claude mcp list

# 查看性能统计
echo "查看性能统计..."
claude mcp list

# 备份配置
echo "备份配置..."
cp ~/.claude/mcp.json ~/.claude/mcp.json.backup.$(date +%Y%m%d)
```

```
#!/bin/bash
# mcp-maintenance.sh

# 检查所有服务器状态
echo "检查 MCP 服务器状态..."
claude mcp list

# 测试连接
echo "测试服务器连接..."
claude mcp list

# 查看性能统计
echo "查看性能统计..."
claude mcp list

# 备份配置
echo "备份配置..."
cp ~/.claude/mcp.json ~/.claude/mcp.json.backup.$(date +%Y%m%d)
```

##### 设置定时任务#

```
bash复制# 添加到 crontab
crontab -e

# 每天凌晨 2 点运行维护脚本
0 2 * * * /path/to/mcp-maintenance.sh
```

```
# 添加到 crontab
crontab -e

# 每天凌晨 2 点运行维护脚本
0 2 * * * /path/to/mcp-maintenance.sh
```

---

# 第 13 章

## 1 使用 MCP 资源

**URL**: https://claudecode.tangshuang.net/course/13.1%20%E4%BD%BF%E7%94%A8%20MCP%20%E8%B5%84%E6%BA%90

MCP 资源是服务器提供的数据源，包括数据库表、文件系统、API 端点等。

#### 资源类型#

##### 数据库资源#

数据库表和视图：

```
bash复制# 查看可用的数据库资源
/mcp
```

```
# 查看可用的数据库资源
/mcp
```

```
bash复制
**输出示例**:
```

```
**输出示例**:
```

MCP 资源：

- database://users: 用户表
- database://orders: 订单表
- database://products: 产品表

```
bash复制
## 访问资源

### 基本访问

```bash
# 访问数据库资源
查询数据库中的用户表

# 访问文件系统资源
读取日志目录中的文件

# 访问 API 资源
调用用户 API

# 访问配置资源
读取应用配置
```

```
## 访问资源

### 基本访问

```bash
# 访问数据库资源
查询数据库中的用户表

# 访问文件系统资源
读取日志目录中的文件

# 访问 API 资源
调用用户 API

# 访问配置资源
读取应用配置
```

##### 资源查询#

```
bash复制# 查询数据库资源
查询用户表中所有活跃用户

# 查询文件系统资源
查找日志目录中的错误日志

# 查询 API 资源
获取用户 ID 为 123 的信息

# 查询配置资源
获取数据库配置中的连接字符串
```

```
# 查询数据库资源
查询用户表中所有活跃用户

# 查询文件系统资源
查找日志目录中的错误日志

# 查询 API 资源
获取用户 ID 为 123 的信息

# 查询配置资源
获取数据库配置中的连接字符串
```

##### 资源过滤#

```
bash复制# 过滤数据库资源
查询用户表中年龄大于 18 的用户

# 过滤文件系统资源
查找日志目录中今天的日志文件

# 过滤 API 资源
获取用户表中状态为活跃的用户

# 过滤配置资源
获取配置中的生产环境设置
```

```
# 过滤数据库资源
查询用户表中年龄大于 18 的用户

# 过滤文件系统资源
查找日志目录中今天的日志文件

# 过滤 API 资源
获取用户表中状态为活跃的用户

# 过滤配置资源
获取配置中的生产环境设置
```

#### 资源操作#

##### 读取资源#

```
bash复制# 读取数据库资源
读取用户表的前 10 条记录

# 读取文件系统资源
读取日志目录中的最新日志

# 读取 API 资源
获取用户 ID 为 123 的详细信息

# 读取配置资源
读取应用配置中的数据库设置
```

```
# 读取数据库资源
读取用户表的前 10 条记录

# 读取文件系统资源
读取日志目录中的最新日志

# 读取 API 资源
获取用户 ID 为 123 的详细信息

# 读取配置资源
读取应用配置中的数据库设置
```

##### 写入资源#

```
bash复制# 写入数据库资源
向用户表插入新用户

# 写入文件系统资源
将日志写入日志目录

# 写入 API 资源
更新用户 ID 为 123 的信息

# 写入配置资源
更新应用配置中的数据库设置
```

```
# 写入数据库资源
向用户表插入新用户

# 写入文件系统资源
将日志写入日志目录

# 写入 API 资源
更新用户 ID 为 123 的信息

# 写入配置资源
更新应用配置中的数据库设置
```

##### 更新资源#

```
bash复制# 更新数据库资源
更新用户表中 ID 为 123 的用户信息

# 更新文件系统资源
更新日志目录中的日志文件

# 更新 API 资源
更新用户 ID 为 123 的状态

# 更新配置资源
更新应用配置中的超时设置
```

```
# 更新数据库资源
更新用户表中 ID 为 123 的用户信息

# 更新文件系统资源
更新日志目录中的日志文件

# 更新 API 资源
更新用户 ID 为 123 的状态

# 更新配置资源
更新应用配置中的超时设置
```

##### 删除资源#

```
bash复制# 删除数据库资源
删除用户表中 ID 为 123 的用户

# 删除文件系统资源
删除日志目录中的旧日志文件

# 删除 API 资源
删除用户 ID 为 123 的记录

# 删除配置资源
删除应用配置中的过时设置
```

```
# 删除数据库资源
删除用户表中 ID 为 123 的用户

# 删除文件系统资源
删除日志目录中的旧日志文件

# 删除 API 资源
删除用户 ID 为 123 的记录

# 删除配置资源
删除应用配置中的过时设置
```

#### 资源元数据#

##### 查看资源信息#

```
bash复制# 查看资源详细信息
显示用户表的详细信息
```

```
# 查看资源详细信息
显示用户表的详细信息
```

```
bash复制资源：database://users
类型：数据库表
列：
- id: INTEGER, PRIMARY KEY
- name: VARCHAR(255)
- email: VARCHAR(255)
- created_at: TIMESTAMP
索引：
- idx_email: email
- idx_created_at: created_at
```

```
资源：database://users
类型：数据库表
列：
- id: INTEGER, PRIMARY KEY
- name: VARCHAR(255)
- email: VARCHAR(255)
- created_at: TIMESTAMP
索引：
- idx_email: email
- idx_created_at: created_at
```

##### 资源统计#

```
bash复制# 查看资源统计信息
显示用户表的统计信息
```

```
# 查看资源统计信息
显示用户表的统计信息
```

```
bash复制资源：database://users
总记录数：10,000
活跃记录数：8,500
最后更新：2024-01-15 10:30:00
```

```
资源：database://users
总记录数：10,000
活跃记录数：8,500
最后更新：2024-01-15 10:30:00
```

#### 资源权限#

##### 检查权限#

```
bash复制# 检查资源访问权限
检查用户表的访问权限
```

```
# 检查资源访问权限
检查用户表的访问权限
```

```
bash复制资源：database://users
权限：
- 读取：允许
- 写入：允许
- 更新：允许
- 删除：拒绝
```

```
资源：database://users
权限：
- 读取：允许
- 写入：允许
- 更新：允许
- 删除：拒绝
```

##### 请求权限#

```
bash复制# 请求资源访问权限
请求用户表的删除权限
```

```
# 请求资源访问权限
请求用户表的删除权限
```

##### 资源缓存#

##### 缓存策略#

MCP 支持资源缓存以提高性能：

```
bash复制# 启用资源缓存
启用用户表缓存

# 查看缓存状态
显示资源缓存状态
```

```
# 启用资源缓存
启用用户表缓存

# 查看缓存状态
显示资源缓存状态
```

```
bash复制资源缓存状态：
- database://users: 已缓存 (1000 条记录)
- database://orders: 未缓存
- filesystem://logs: 已缓存 (50 个文件)
```

```
资源缓存状态：
- database://users: 已缓存 (1000 条记录)
- database://orders: 未缓存
- filesystem://logs: 已缓存 (50 个文件)
```

##### 清除缓存#

```
bash复制# 清除特定资源缓存
清除用户表缓存

# 清除所有资源缓存
清除所有资源缓存
```

```
# 清除特定资源缓存
清除用户表缓存

# 清除所有资源缓存
清除所有资源缓存
```

#### 资源监控#

##### 监控资源使用#

```
bash复制# 查看资源使用统计
显示资源使用统计
```

```
# 查看资源使用统计
显示资源使用统计
```

```
bash复制资源使用统计：
- database://users:
  - 读取次数：150
  - 写入次数：20
  - 更新次数：30
  - 删除次数：5
- database://orders:
  - 读取次数：200
  - 写入次数：50
  - 更新次数：40
  - 删除次数：10
```

```
资源使用统计：
- database://users:
  - 读取次数：150
  - 写入次数：20
  - 更新次数：30
  - 删除次数：5
- database://orders:
  - 读取次数：200
  - 写入次数：50
  - 更新次数：40
  - 删除次数：10
```

##### 监控资源性能#

```
bash复制# 查看资源性能指标
显示资源性能指标
```

```
# 查看资源性能指标
显示资源性能指标
```

```
bash复制资源性能指标：
- database://users:
  - 平均响应时间：50ms
  - 最大响应时间：200ms
  - 成功率：99.5%
- database://orders:
  - 平均响应时间：80ms
  - 最大响应时间：300ms
  - 成功率：98.7%
```

```
资源性能指标：
- database://users:
  - 平均响应时间：50ms
  - 最大响应时间：200ms
  - 成功率：99.5%
- database://orders:
  - 平均响应时间：80ms
  - 最大响应时间：300ms
  - 成功率：98.7%
```

#### 资源安全#

##### 数据加密#

```
bash复制# 加密资源数据
加密用户表中的敏感数据
```

```
# 加密资源数据
加密用户表中的敏感数据
```

##### 访问控制#

```
bash复制# 设置资源访问控制
限制用户表只能被特定用户访问
```

```
# 设置资源访问控制
限制用户表只能被特定用户访问
```

##### 审计日志#

```
bash复制# 查看资源访问日志
显示用户表的访问日志
```

```
# 查看资源访问日志
显示用户表的访问日志
```

```
bash复制资源访问日志：
- 2024-01-15 10:00:00 - 用户 user1 读取用户表
- 2024-01-15 10:05:00 - 用户 user2 写入用户表
- 2024-01-15 10:10:00 - 用户 user1 更新用户表
```

```
资源访问日志：
- 2024-01-15 10:00:00 - 用户 user1 读取用户表
- 2024-01-15 10:05:00 - 用户 user2 写入用户表
- 2024-01-15 10:10:00 - 用户 user1 更新用户表
```

#### 资源最佳实践#

##### 1. 合理使用资源#

```
bash复制# 只查询需要的列
查询用户表的 ID 和姓名

# 使用过滤条件
查询用户表中活跃的用户

# 限制结果数量
查询用户表的前 100 条记录
```

```
# 只查询需要的列
查询用户表的 ID 和姓名

# 使用过滤条件
查询用户表中活跃的用户

# 限制结果数量
查询用户表的前 100 条记录
```

##### 2. 缓存常用资源#

```
bash复制# 缓存频繁访问的资源
启用用户表缓存

# 定期更新缓存
更新用户表缓存
```

```
# 缓存频繁访问的资源
启用用户表缓存

# 定期更新缓存
更新用户表缓存
```

##### 3. 监控资源使用#

```
bash复制# 定期查看资源使用统计
显示资源使用统计

# 识别性能瓶颈
显示资源性能指标
```

```
# 定期查看资源使用统计
显示资源使用统计

# 识别性能瓶颈
显示资源性能指标
```

##### 4. 保护敏感资源#

```
bash复制# 加密敏感数据
加密用户表中的密码字段

# 限制访问权限
限制用户表只能被管理员访问

# 记录访问日志
显示用户表的访问日志
```

```
# 加密敏感数据
加密用户表中的密码字段

# 限制访问权限
限制用户表只能被管理员访问

# 记录访问日志
显示用户表的访问日志
```

#### 故障排除#

##### 资源访问失败#

问题: 无法访问资源

```
bash复制# 1. 检查资源是否存在
/mcp

# 2. 检查权限
检查资源访问权限

# 3. 查看错误日志
显示错误日志

# 4. 重新连接服务器
重新连接 MCP 服务器
```

```
# 1. 检查资源是否存在
/mcp

# 2. 检查权限
检查资源访问权限

# 3. 查看错误日志
显示错误日志

# 4. 重新连接服务器
重新连接 MCP 服务器
```

##### 资源性能问题#

问题: 资源响应缓慢

```
bash复制# 1. 查看性能指标
显示资源性能指标

# 2. 启用缓存
启用资源缓存

# 3. 优化查询
优化资源查询

# 4. 增加超时设置
MCP_TIMEOUT=30000 claude
```

```
# 1. 查看性能指标
显示资源性能指标

# 2. 启用缓存
启用资源缓存

# 3. 优化查询
优化资源查询

# 4. 增加超时设置
MCP_TIMEOUT=30000 claude
```

##### 资源权限错误#

问题: 没有资源访问权限

```
bash复制# 1. 检查权限
检查资源访问权限

# 2. 请求权限
请求资源访问权限

# 3. 联系管理员
联系管理员获取权限
```

```
# 1. 检查权限
检查资源访问权限

# 2. 请求权限
请求资源访问权限

# 3. 联系管理员
联系管理员获取权限
```

---

## 2 MCP 提示与斜杠命令

**URL**: https://claudecode.tangshuang.net/course/13.2%20MCP%20%E6%8F%90%E7%A4%BA%E4%B8%8E%E6%96%9C%E6%9D%A0%E5%91%BD%E4%BB%A4

MCP 提示和斜杠命令可以增强 Claude Code 的功能，提供更高效的交互方式。

#### MCP 提示#

##### 什么是 MCP 提示#

MCP 提示是预定义的提示模板，由 MCP 服务器提供，用于常见任务。

##### 提示类型#

###### 1. 工具提示

提供特定工具的使用指导：

```
bash复制# 使用 GitHub PR 审查提示
使用 GitHub 的 PR 审查模板

# 输出
正在使用 GitHub PR 审查提示...
请提供 PR 编号进行审查
```

```
# 使用 GitHub PR 审查提示
使用 GitHub 的 PR 审查模板

# 输出
正在使用 GitHub PR 审查提示...
请提供 PR 编号进行审查
```

###### 2. 资源提示

提供资源访问的指导：

```
bash复制# 使用数据库查询提示
使用数据库的查询模板

# 输出
正在使用数据库查询模板...
请提供 SQL 查询
```

```
# 使用数据库查询提示
使用数据库的查询模板

# 输出
正在使用数据库查询模板...
请提供 SQL 查询
```

###### 3. 工作流提示

提供完整工作流的指导：

```
bash复制# 使用代码审查工作流提示
使用代码审查工作流

# 输出
正在使用代码审查工作流...
步骤 1: 查看代码变更
步骤 2: 分析代码质量
步骤 3: 提供改进建议
```

```
# 使用代码审查工作流提示
使用代码审查工作流

# 输出
正在使用代码审查工作流...
步骤 1: 查看代码变更
步骤 2: 分析代码质量
步骤 3: 提供改进建议
```

##### 使用 MCP 提示#

###### 基本用法

```
bash复制# 查看可用的提示
/mcp

# 输出示例
MCP 提示：
- github:pr-review: PR 审查模板
- database:query: 数据库查询模板
- code:review: 代码审查工作流
```

```
# 查看可用的提示
/mcp

# 输出示例
MCP 提示：
- github:pr-review: PR 审查模板
- database:query: 数据库查询模板
- code:review: 代码审查工作流
```

###### 使用提示

```
bash复制# 使用 GitHub PR 审查提示
使用 github:pr-review 提示审查 PR #123

# 使用数据库查询提示
使用 database:query 提示查询用户数据

# 使用代码审查工作流提示
使用 code:review 提示审查代码
```

```
# 使用 GitHub PR 审查提示
使用 github:pr-review 提示审查 PR #123

# 使用数据库查询提示
使用 database:query 提示查询用户数据

# 使用代码审查工作流提示
使用 code:review 提示审查代码
```

##### 自定义提示#

###### 创建提示模板

在 MCP 服务器中创建提示模板：

```
json复制{
  "prompts": {
    "custom-review": {
      "name": "自定义代码审查",
      "description": "自定义的代码审查流程",
      "template": "请审查以下代码：\n\n1. 检查代码风格\n2. 分析代码逻辑\n3. 识别潜在问题\n4. 提供改进建议"
    }
  }
}
```

```
{
  "prompts": {
    "custom-review": {
      "name": "自定义代码审查",
      "description": "自定义的代码审查流程",
      "template": "请审查以下代码：\n\n1. 检查代码风格\n2. 分析代码逻辑\n3. 识别潜在问题\n4. 提供改进建议"
    }
  }
}
```

###### 使用自定义提示

```
bash复制# 使用自定义提示
使用 custom-review 提示审查代码
```

```
# 使用自定义提示
使用 custom-review 提示审查代码
```

#### 斜杠命令#

##### 什么是斜杠命令#

斜杠命令是 Claude Code 提供的快捷命令，用于快速执行常见操作。

##### 内置斜杠命令#

###### /init

初始化项目：

```
bash复制/init
```

```
/init
```

###### /plugin

```
bash复制/plugin install formatter@claude
/plugin enable formatter
/plugin disable formatter
/plugin uninstall formatter
```

```
/plugin install formatter@claude
/plugin enable formatter
/plugin disable formatter
/plugin uninstall formatter
```

###### /mcp

管理 MCP 服务器：

```
bash复制/mcp
```

```
/mcp
```

###### /agents

管理子代理：

```
bash复制/agents
```

```
/agents
```

###### /config

配置 Claude Code：

```
bash复制/config
```

```
/config
```

###### /clear

清除对话历史：

```
bash复制/clear
```

```
/clear
```

###### /vim

启用 Vim 编辑器模式：

```
bash复制/vim
```

```
/vim
```

###### /memory

管理内存文件：

```
bash复制/memory
```

```
/memory
```

###### /hooks

```
bash复制/hooks
```

```
/hooks
```

###### /terminal-setup

配置终端设置：

```
bash复制/terminal-setup
```

```
/terminal-setup
```

###### /sandbox

启用沙箱隔离：

```
bash复制/sandbox
```

```
/sandbox
```

###### /login

登录到 Claude Code：

```
bash复制/login
```

```
/login
```

###### /ide

IDE 相关命令：

```
bash复制/ide
```

```
/ide
```

#### MCP 斜杠命令#

##### MCP 服务器提供的斜杠命令#

某些 MCP 服务器可以提供自定义斜杠命令：

```
bash复制# 查看可用的 MCP 斜杠命令
/mcp

# 输出示例
MCP 斜杠命令：
- /github-pr: 创建 GitHub PR
- /db-query: 查询数据库
- /sentry-error: 查询 Sentry 错误
```

```
# 查看可用的 MCP 斜杠命令
/mcp

# 输出示例
MCP 斜杠命令：
- /github-pr: 创建 GitHub PR
- /db-query: 查询数据库
- /sentry-error: 查询 Sentry 错误
```

#### 创建自定义斜杠命令#

##### 个人斜杠命令#

创建个人斜杠命令：

```
bash复制# 创建命令目录
mkdir -p ~/.claude/commands

# 创建命令文件
echo "Review this code for security vulnerabilities:" > ~/.claude/commands/security-review.md

# 使用命令
/security-review
```

```
# 创建命令目录
mkdir -p ~/.claude/commands

# 创建命令文件
echo "Review this code for security vulnerabilities:" > ~/.claude/commands/security-review.md

# 使用命令
/security-review
```

##### 项目斜杠命令#

创建项目斜杠命令：

```
bash复制# 创建命令目录
mkdir -p .claude/commands

# 创建命令文件
echo "Review this code according to our coding standards:" > .claude/commands/team-review.md

# 使用命令
/team-review
```

```
# 创建命令目录
mkdir -p .claude/commands

# 创建命令文件
echo "Review this code according to our coding standards:" > .claude/commands/team-review.md

# 使用命令
/team-review
```

##### 命令参数#

```
bash复制# 创建带参数的命令
cat > ~/.claude/commands/test.md << 'EOF'
Run tests for $ARGUMENTS
EOF

# 使用命令
/test --coverage
```

```
# 创建带参数的命令
cat > ~/.claude/commands/test.md << 'EOF'
Run tests for $ARGUMENTS
EOF

# 使用命令
/test --coverage
```

#### 提示和命令的组合#

##### 组合使用#

```
bash复制# 使用 MCP 提示和斜杠命令
/github-pr #123
使用 github:pr-review 提示审查 PR #123
```

```
# 使用 MCP 提示和斜杠命令
/github-pr #123
使用 github:pr-review 提示审查 PR #123
```

##### 工作流自动化#

```
bash复制# 创建自动化工作流
cat > ~/.claude/commands/deploy.md << 'EOF'
部署工作流：
1. 运行测试
2. 构建应用
3. 部署到生产环境
EOF

# 使用工作流
/deploy
```

```
# 创建自动化工作流
cat > ~/.claude/commands/deploy.md << 'EOF'
部署工作流：
1. 运行测试
2. 构建应用
3. 部署到生产环境
EOF

# 使用工作流
/deploy
```

#### 最佳实践#

##### 1. 合理使用提示#

```
bash复制# 选择合适的提示
使用 github:pr-review 提示审查 PR

# 提供清晰的上下文
使用 github:pr-review 提示审查 PR #123，重点关注安全性
```

```
# 选择合适的提示
使用 github:pr-review 提示审查 PR

# 提供清晰的上下文
使用 github:pr-review 提示审查 PR #123，重点关注安全性
```

##### 2. 创建有用的命令#

```
bash复制# 创建常用任务的命令
cat > ~/.claude/commands/lint.md << 'EOF'
Run linter and fix all issues
EOF

# 创建团队标准命令
cat > .claude/commands/team-lint.md << 'EOF'
Run team linter with our coding standards
EOF
```

```
# 创建常用任务的命令
cat > ~/.claude/commands/lint.md << 'EOF'
Run linter and fix all issues
EOF

# 创建团队标准命令
cat > .claude/commands/team-lint.md << 'EOF'
Run team linter with our coding standards
EOF
```

##### 3. 参数化命令#

```
bash复制# 使用参数使命令更灵活
cat > ~/.claude/commands/test.md << 'EOF'
Run tests for $ARGUMENTS
EOF

# 使用命令
/test --coverage --watch
```

```
# 使用参数使命令更灵活
cat > ~/.claude/commands/test.md << 'EOF'
Run tests for $ARGUMENTS
EOF

# 使用命令
/test --coverage --watch
```

##### 4. 文档化命令#

```
bash复制# 添加文档注释
cat > ~/.claude/commands/review.md << 'EOF'
<!--
Usage: /review [file]
Description: Review code file for quality and security
-->
Review this code file:
EOF
```

```
# 添加文档注释
cat > ~/.claude/commands/review.md << 'EOF'
<!--
Usage: /review [file]
Description: Review code file for quality and security
-->
Review this code file:
EOF
```

#### 故障排除#

##### 提示不工作#

问题: MCP 提示无法使用

```
bash复制# 1. 检查 MCP 服务器状态
/mcp

# 2. 查看可用提示
列出所有 MCP 提示

# 3. 重新连接服务器
重新连接 MCP 服务器

# 4. 查看错误日志
显示错误日志
```

```
# 1. 检查 MCP 服务器状态
/mcp

# 2. 查看可用提示
列出所有 MCP 提示

# 3. 重新连接服务器
重新连接 MCP 服务器

# 4. 查看错误日志
显示错误日志
```

##### 斜杠命令不工作#

问题: 斜杠命令无法使用

```
bash复制# 1. 检查命令文件
ls ~/.claude/commands/
ls .claude/commands/

# 2. 验证命令语法
cat ~/.claude/commands/command-name.md

# 3. 重启 Claude Code
# 退出并重新启动

# 4. 查看错误日志
claude --verbose
```

```
# 1. 检查命令文件
ls ~/.claude/commands/
ls .claude/commands/

# 2. 验证命令语法
cat ~/.claude/commands/command-name.md

# 3. 重启 Claude Code
# 退出并重新启动

# 4. 查看错误日志
claude --verbose
```

##### 参数不传递#

问题: 命令参数未正确传递

```
bash复制# 1. 检查命令模板
cat ~/.claude/commands/command-name.md

# 2. 验证参数语法
# 确保使用 $ARGUMENTS

# 3. 测试命令
/command-name test-argument

# 4. 查看输出
# 检查参数是否正确传递
```

```
# 1. 检查命令模板
cat ~/.claude/commands/command-name.md

# 2. 验证参数语法
# 确保使用 $ARGUMENTS

# 3. 测试命令
/command-name test-argument

# 4. 查看输出
# 检查参数是否正确传递
```

#### 高级用法#

##### 条件命令#

```
bash复制# 创建条件命令
cat > ~/.claude/commands/deploy.md << 'EOF'
If environment is production:
  部署到生产环境
Else:
  部署到测试环境
EOF
```

```
# 创建条件命令
cat > ~/.claude/commands/deploy.md << 'EOF'
If environment is production:
  部署到生产环境
Else:
  部署到测试环境
EOF
```

##### 循环命令#

```
bash复制# 创建循环命令
cat > ~/.claude/commands/batch-test.md << 'EOF'
For each test file:
  1. Run tests
  2. Collect results
  3. Report failures
EOF
```

```
# 创建循环命令
cat > ~/.claude/commands/batch-test.md << 'EOF'
For each test file:
  1. Run tests
  2. Collect results
  3. Report failures
EOF
```

##### 嵌套命令#

```
bash复制# 创建嵌套命令
cat > ~/.claude/commands/full-review.md << 'EOF'
1. Run /lint
2. Run /test
3. Run /security-review
4. Generate report
EOF
```

```
# 创建嵌套命令
cat > ~/.claude/commands/full-review.md << 'EOF'
1. Run /lint
2. Run /test
3. Run /security-review
4. Generate report
EOF
```

---

## 3 MCP 身份验证

**URL**: https://claudecode.tangshuang.net/course/13.3%20MCP%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81

MCP 支持多种身份验证方式，确保安全地连接到 MCP 服务器。

#### OAuth 2.0#

##### OAuth 2.0 流程#

MCP 服务器可以使用 OAuth 2.0 进行身份验证：

True. Claude Code 发起 OAuth 请求
True. 用户重定向到授权页面
True. 用户授权应用
True. 授权服务器返回访问令牌
True. Claude Code 使用令牌访问 MCP 服务器

##### 配置 OAuth 2.0#

###### 添加 OAuth 服务器

```
bash复制# 添加需要 OAuth 的服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

```
# 添加需要 OAuth 的服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

###### 进行身份验证

```
bash复制# 在 Claude Code 中进行身份验证
/mcp
# 选择需要身份验证的服务器
# 选择 "github"
```

```
# 在 Claude Code 中进行身份验证
/mcp
# 选择需要身份验证的服务器
# 选择 "github"
```

###### OAuth 流程

```
bash复制# 1. Claude Code 显示授权 URL
# 请访问以下 URL 进行授权：
```

```
# 1. Claude Code 显示授权 URL
# 请访问以下 URL 进行授权：
```

### https://github.com/login/oauth/authorize?client_id=...

### 2. 用户访问 URL 并授权

### 3. 授权服务器返回访问令牌

### 4. Claude Code 保存令牌

```
bash复制
### OAuth 2.0 作用域

#### 定义作用域

OAuth 2.0 使用作用域限制权限：

```bash
# 添加带作用域的服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
--scope "repo,user"
```

```
### OAuth 2.0 作用域

#### 定义作用域

OAuth 2.0 使用作用域限制权限：

```bash
# 添加带作用域的服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
--scope "repo,user"
```

###### 常见作用域

- repo: 仓库访问权限
- user: 用户信息访问权限
- admin: 管理员权限
- read: 只读权限
- write: 读写权限

##### 令牌管理#

###### 查看令牌

```
bash复制# 查看已保存的令牌
显示 OAuth 令牌
```

```
# 查看已保存的令牌
显示 OAuth 令牌
```

###### 刷新令牌

```
bash复制# 刷新访问令牌
刷新 GitHub 令牌
```

```
# 刷新访问令牌
刷新 GitHub 令牌
```

###### 撤销令牌

```
bash复制# 撤销访问令牌
撤销 GitHub 令牌
```

```
# 撤销访问令牌
撤销 GitHub 令牌
```

#### API 密钥#

##### 使用 API 密钥#

###### 添加带 API 密钥的服务器

```
bash复制# Bearer 令牌
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"

# API 密钥
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-API-Key: your-api-key"

# 自定义标头
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-Custom-Auth: your-custom-key"
```

```
# Bearer 令牌
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"

# API 密钥
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-API-Key: your-api-key"

# 自定义标头
claude mcp add --transport http api https://api.example.com/mcp \
--header "X-Custom-Auth: your-custom-key"
```

###### 环境变量

使用环境变量传递 API 密钥：

```
bash复制# 设置环境变量
export API_KEY="your-api-key"

# 使用环境变量
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer ${API_KEY}"
```

```
# 设置环境变量
export API_KEY="your-api-key"

# 使用环境变量
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer ${API_KEY}"
```

##### 密钥安全#

###### 加密存储

Claude Code 加密存储 API 密钥：

```
bash复制# 密钥自动加密存储
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"
```

```
# 密钥自动加密存储
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer your-api-key"
```

###### 密钥轮换

定期轮换 API 密钥：

```
bash复制# 1. 生成新密钥
# 2. 更新服务器配置
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer new-api-key"

# 3. 撤销旧密钥
```

```
# 1. 生成新密钥
# 2. 更新服务器配置
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer new-api-key"

# 3. 撤销旧密钥
```

#### 证书身份验证#

##### 使用证书#

###### 添加带证书的服务器

```
bash复制# 使用客户端证书
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cert /path/to/cert.pem \
--key /path/to/key.pem

# 使用 CA 证书
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cacert /path/to/ca.pem
```

```
# 使用客户端证书
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cert /path/to/cert.pem \
--key /path/to/key.pem

# 使用 CA 证书
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cacert /path/to/ca.pem
```

###### 证书格式

支持的证书格式：

- PEM: 最常用的格式
- DER: 二进制格式
- PKCS12: 包含私钥和证书

##### 证书管理#

###### 查看证书

```
bash复制# 查看证书信息
openssl x509 -in /path/to/cert.pem -text -noout
```

```
# 查看证书信息
openssl x509 -in /path/to/cert.pem -text -noout
```

###### 验证证书

```
bash复制# 验证证书
openssl verify -CAfile /path/to/ca.pem /path/to/cert.pem
```

```
# 验证证书
openssl verify -CAfile /path/to/ca.pem /path/to/cert.pem
```

###### 更新证书

```
bash复制# 1. 获取新证书
# 2. 更新服务器配置
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --cert /path/to/new-cert.pem \
  --key /path/to/new-key.pem
```

```
# 1. 获取新证书
# 2. 更新服务器配置
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --cert /path/to/new-cert.pem \
  --key /path/to/new-key.pem
```

#### 自定义身份验证#

##### 自定义认证头#

```
bash复制# 使用自定义认证头
claude mcp add --transport http custom-api https://api.example.com/mcp \
--header "X-Custom-Auth: custom-value"
```

```
# 使用自定义认证头
claude mcp add --transport http custom-api https://api.example.com/mcp \
--header "X-Custom-Auth: custom-value"
```

##### 多因素认证#

```
bash复制# 使用多因素认证
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --header "X-Auth-Token: token" \
  --header "X-Auth-Code: code"
```

```
# 使用多因素认证
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --header "X-Auth-Token: token" \
  --header "X-Auth-Code: code"
```

##### 签名请求#

```
bash复制# 使用签名请求
claude mcp add --transport http signed-api https://api.example.com/mcp \
--header "X-Signature: signature" \
--header "X-Timestamp: timestamp"
```

```
# 使用签名请求
claude mcp add --transport http signed-api https://api.example.com/mcp \
--header "X-Signature: signature" \
--header "X-Timestamp: timestamp"
```

#### 身份验证最佳实践#

##### 1. 使用最小权限原则#

```
bash复制# 只请求必要的权限
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
  --scope "repo:read"
```

```
# 只请求必要的权限
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
  --scope "repo:read"
```

##### 2. 定期轮换凭证#

```
bash复制# 每 90 天轮换一次 API 密钥
# 设置提醒
```

```
# 每 90 天轮换一次 API 密钥
# 设置提醒
```

##### 3. 使用环境变量#

```
bash复制# 使用环境变量存储敏感信息
export API_KEY="your-api-key"
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer ${API_KEY}"
```

```
# 使用环境变量存储敏感信息
export API_KEY="your-api-key"
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer ${API_KEY}"
```

##### 4. 加密存储#

```
bash复制# 使用加密存储
# Claude Code 自动加密存储敏感信息
```

```
# 使用加密存储
# Claude Code 自动加密存储敏感信息
```

##### 5. 审计访问#

```
bash复制# 定期审计访问日志
显示身份验证日志
```

```
# 定期审计访问日志
显示身份验证日志
```

#### 故障排除#

##### OAuth 2.0 问题#

###### 授权失败

问题: OAuth 授权失败

```
bash复制# 1. 检查授权 URL
/mcp

# 2. 确认用户授权
# 确保用户完成了授权流程

# 3. 检查作用域
# 确认请求的作用域正确

# 4. 重新授权
撤销 GitHub 令牌
/mcp
# 重新进行授权
```

```
# 1. 检查授权 URL
/mcp

# 2. 确认用户授权
# 确保用户完成了授权流程

# 3. 检查作用域
# 确认请求的作用域正确

# 4. 重新授权
撤销 GitHub 令牌
/mcp
# 重新进行授权
```

###### 令牌过期

问题: 访问令牌过期

```
bash复制# 1. 刷新令牌
刷新 GitHub 令牌

# 2. 如果刷新失败，重新授权
撤销 GitHub 令牌
/mcp
# 重新进行授权
```

```
# 1. 刷新令牌
刷新 GitHub 令牌

# 2. 如果刷新失败，重新授权
撤销 GitHub 令牌
/mcp
# 重新进行授权
```

##### API 密钥问题#

###### 密钥无效

问题: API 密钥无效

```
bash复制# 1. 验证密钥
# 检查密钥是否正确

# 2. 检查密钥权限
# 确认密钥有足够的权限

# 3. 更新密钥
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer new-api-key"
```

```
# 1. 验证密钥
# 检查密钥是否正确

# 2. 检查密钥权限
# 确认密钥有足够的权限

# 3. 更新密钥
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
--header "Authorization: Bearer new-api-key"
```

###### 密钥过期

问题: API 密钥过期

```
bash复制# 1. 生成新密钥
# 2. 更新服务器配置
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer new-api-key"
```

```
# 1. 生成新密钥
# 2. 更新服务器配置
claude mcp remove api
claude mcp add --transport http api https://api.example.com/mcp \
  --header "Authorization: Bearer new-api-key"
```

##### 证书问题#

###### 证书无效

问题: 证书无效

```
bash复制# 1. 验证证书
openssl verify -CAfile /path/to/ca.pem /path/to/cert.pem

# 2. 检查证书有效期
openssl x509 -in /path/to/cert.pem -text -noout | grep "Not After"

# 3. 更新证书
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cert /path/to/new-cert.pem \
--key /path/to/new-key.pem
```

```
# 1. 验证证书
openssl verify -CAfile /path/to/ca.pem /path/to/cert.pem

# 2. 检查证书有效期
openssl x509 -in /path/to/cert.pem -text -noout | grep "Not After"

# 3. 更新证书
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
--cert /path/to/new-cert.pem \
--key /path/to/new-key.pem
```

###### 证书过期

问题: 证书过期

```
bash复制# 1. 获取新证书
# 2. 更新服务器配置
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --cert /path/to/new-cert.pem \
  --key /path/to/new-key.pem
```

```
# 1. 获取新证书
# 2. 更新服务器配置
claude mcp remove secure-api
claude mcp add --transport http secure-api https://api.example.com/mcp \
  --cert /path/to/new-cert.pem \
  --key /path/to/new-key.pem
```

#### 安全建议#

##### 1. 保护凭证#

```
bash复制# 不要在代码中硬编码凭证
# 使用环境变量
export API_KEY="your-api-key"

# 不要在版本控制中提交凭证
# 添加到 .gitignore
echo ".env" >> .gitignore
```

```
# 不要在代码中硬编码凭证
# 使用环境变量
export API_KEY="your-api-key"

# 不要在版本控制中提交凭证
# 添加到 .gitignore
echo ".env" >> .gitignore
```

##### 2. 使用强凭证#

```
bash复制# 使用强密码
# 使用长随机字符串作为 API 密钥
# 定期轮换凭证
```

```
# 使用强密码
# 使用长随机字符串作为 API 密钥
# 定期轮换凭证
```

##### 3. 限制权限#

```
bash复制# 使用最小权限原则
# 只授予必要的权限
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
--scope "repo:read"
```

```
# 使用最小权限原则
# 只授予必要的权限
claude mcp add --transport http github https://api.githubcopilot.com/mcp/ \
--scope "repo:read"
```

##### 4. 监控使用#

```
bash复制# 定期监控 API 使用
显示 API 使用统计

# 检查异常活动
显示异常访问日志
```

```
# 定期监控 API 使用
显示 API 使用统计

# 检查异常活动
显示异常访问日志
```

##### 5. 及时撤销#

```
bash复制# 及时撤销不需要的凭证
撤销 GitHub 令牌
撤销 API 密钥
```

```
# 及时撤销不需要的凭证
撤销 GitHub 令牌
撤销 API 密钥
```

---

## 4 MCP 企业配置

**URL**: https://claudecode.tangshuang.net/course/13.4%20MCP%20%E4%BC%81%E4%B8%9A%E9%85%8D%E7%BD%AE

在企业环境中配置和管理 MCP 服务器需要考虑安全、合规和可扩展性。

#### 企业安全#

##### 安全策略#

###### 1. 集中身份验证

使用企业身份提供者：

```
bash复制# 使用企业 SSO
claude mcp add --transport http enterprise-api https://api.enterprise.com/mcp \
 --header "Authorization: Bearer ${ENTERPRISE_TOKEN}"
```

```
# 使用企业 SSO
claude mcp add --transport http enterprise-api https://api.enterprise.com/mcp \
 --header "Authorization: Bearer ${ENTERPRISE_TOKEN}"
```

###### 2. 网络隔离

限制 MCP 服务器访问：

```
bash复制# 使用内部 MCP 服务器
claude mcp add --transport http internal-api https://internal.api.com/mcp
```

```
# 使用内部 MCP 服务器
claude mcp add --transport http internal-api https://internal.api.com/mcp
```

###### 3. 审计日志

启用详细的审计日志：

```
bash复制# 启用审计日志
claude --audit-log /var/log/claude-audit.log
```

```
# 启用审计日志
claude --audit-log /var/log/claude-audit.log
```

##### 访问控制#

###### 1. 基于角色的访问

为不同角色配置不同的 MCP 服务器：

```
bash复制# 开发者角色
```

```
# 开发者角色
```

claude mcp add --transport http dev-tools https://dev-tools.internal.com/mcp

### 运维角色

claude mcp add --transport http ops-tools https://ops-tools.internal.com/mcp

### 管理员角色

claude mcp add --transport http admin-tools https://admin-tools.internal.com/mcp

```
bash复制
#### 2. 权限限制

限制 MCP 工具权限：

```bash
# 限制只读访问
claude --allowedTools "Read,Grep,Glob,mcp__github"

# 禁止写操作
claude --disallowedTools "Write,Delete,Bash"
```

```
#### 2. 权限限制

限制 MCP 工具权限：

```bash
# 限制只读访问
claude --allowedTools "Read,Grep,Glob,mcp__github"

# 禁止写操作
claude --disallowedTools "Write,Delete,Bash"
```

###### 3. 资源隔离

隔离不同团队的资源：

```
bash复制# 团队 A 的服务器
claude mcp add --transport http team-a-db https://team-a-db.internal.com/mcp

# 团队 B 的服务器
claude mcp add --transport http team-b-db https://team-b-db.internal.com/mcp
```

```
# 团队 A 的服务器
claude mcp add --transport http team-a-db https://team-a-db.internal.com/mcp

# 团队 B 的服务器
claude mcp add --transport http team-b-db https://team-b-db.internal.com/mcp
```

#### 企业部署#

##### 集中配置#

###### 1. 配置管理

使用配置管理工具：

```
bash复制# 使用 Ansible
ansible-playbook mcp-servers.yml

# 使用 Chef
chef-client -o recipe[mcp_servers]

# 使用 Puppet
puppet agent -t mcp_servers
```

```
# 使用 Ansible
ansible-playbook mcp-servers.yml

# 使用 Chef
chef-client -o recipe[mcp_servers]

# 使用 Puppet
puppet agent -t mcp_servers
```

###### 2. 配置模板

创建配置模板：

```
json复制{
  "mcpServers": {
    "${SERVER_NAME}": {
      "type": "${SERVER_TYPE}",
      "url": "${SERVER_URL}",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}
```

```
{
  "mcpServers": {
    "${SERVER_NAME}": {
      "type": "${SERVER_TYPE}",
      "url": "${SERVER_URL}",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}
```

###### 3. 环境变量

使用环境变量管理配置：

```
bash复制# 设置企业环境变量
export ENTERPRISE_API_URL="https://api.enterprise.com"
export ENTERPRISE_API_KEY="${ENTERPRISE_TOKEN}"

# 使用环境变量
claude mcp add --transport http enterprise-api ${ENTERPRISE_API_URL}/mcp \
--header "Authorization: Bearer ${ENTERPRISE_API_KEY}"
```

```
# 设置企业环境变量
export ENTERPRISE_API_URL="https://api.enterprise.com"
export ENTERPRISE_API_KEY="${ENTERPRISE_TOKEN}"

# 使用环境变量
claude mcp add --transport http enterprise-api ${ENTERPRISE_API_URL}/mcp \
--header "Authorization: Bearer ${ENTERPRISE_API_KEY}"
```

##### 自动化部署#

###### 1. CI/CD 集成

在 CI/CD 流程中配置 MCP 服务器：

```
yaml复制# GitHub Actions
- name: Configure MCP servers
  run: |
    claude mcp add --transport http ci-cd https://ci-cd.internal.com/mcp \
      --header "Authorization: Bearer ${{ secrets.MCP_TOKEN }}"
```

```
# GitHub Actions
- name: Configure MCP servers
  run: |
    claude mcp add --transport http ci-cd https://ci-cd.internal.com/mcp \
      --header "Authorization: Bearer ${{ secrets.MCP_TOKEN }}"
```

###### 2. 容器化部署

在容器中部署 MCP 服务器：

```
dockerfile复制FROM node:18

# 安装 MCP 服务器
RUN npm install -g @enterprise/mcp-server

# 配置环境变量
ENV MCP_SERVER_URL=https://api.enterprise.com
ENV MCP_SERVER_TOKEN=${MCP_TOKEN}

# 启动服务器
CMD ["mcp-server"]
```

```
FROM node:18

# 安装 MCP 服务器
RUN npm install -g @enterprise/mcp-server

# 配置环境变量
ENV MCP_SERVER_URL=https://api.enterprise.com
ENV MCP_SERVER_TOKEN=${MCP_TOKEN}

# 启动服务器
CMD ["mcp-server"]
```

###### 3. 编排部署

使用 Kubernetes 编排 MCP 服务器：

```
yaml复制apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: enterprise/mcp-server:latest
        env:
        - name: MCP_SERVER_URL
          value: "https://api.enterprise.com"
        - name: MCP_SERVER_TOKEN
          valueFrom:
            secretKeyRef:
              name: mcp-secrets
              key: token
```

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: enterprise/mcp-server:latest
        env:
        - name: MCP_SERVER_URL
          value: "https://api.enterprise.com"
        - name: MCP_SERVER_TOKEN
          valueFrom:
            secretKeyRef:
              name: mcp-secrets
              key: token
```

#### 企业监控#

##### 性能监控#

###### 1. 指标收集

收集 MCP 服务器性能指标：

```
bash复制# 使用 Prometheus
claude mcp add --transport stdio prometheus -- npx -y @prometheus/mcp-server \
--url http://prometheus:9090

# 使用 Datadog
claude mcp add --transport http datadog https://mcp.datadoghq.com/mcp \
--header "Authorization: Bearer ${DATADOG_TOKEN}"
```

```
# 使用 Prometheus
claude mcp add --transport stdio prometheus -- npx -y @prometheus/mcp-server \
--url http://prometheus:9090

# 使用 Datadog
claude mcp add --transport http datadog https://mcp.datadoghq.com/mcp \
--header "Authorization: Bearer ${DATADOG_TOKEN}"
```

###### 2. 日志聚合

聚合 MCP 服务器日志：

```
bash复制# 使用 ELK Stack
claude mcp add --transport stdio elk -- npx -y @elk/mcp-server \
  --url http://elk:9200

# 使用 Splunk
claude mcp add --transport http splunk https://splunk.internal.com/mcp \
  --header "Authorization: Bearer ${SPLUNK_TOKEN}"
```

```
# 使用 ELK Stack
claude mcp add --transport stdio elk -- npx -y @elk/mcp-server \
  --url http://elk:9200

# 使用 Splunk
claude mcp add --transport http splunk https://splunk.internal.com/mcp \
  --header "Authorization: Bearer ${SPLUNK_TOKEN}"
```

###### 3. 告警设置

设置性能告警：

```
bash复制# 配置告警规则
cat > mcp-alerts.yml << 'EOF'
alerts:
- name: mcp_server_slow
condition: response_time > 5000
action: notify_team
- name: mcp_server_down
condition: status != "connected"
action: page_on_call
EOF
```

```
# 配置告警规则
cat > mcp-alerts.yml << 'EOF'
alerts:
- name: mcp_server_slow
condition: response_time > 5000
action: notify_team
- name: mcp_server_down
condition: status != "connected"
action: page_on_call
EOF
```

##### 安全监控#

###### 1. 访问监控

监控 MCP 服务器访问：

```
bash复制# 记录所有访问
claude --access-log /var/log/claude-access.log

# 分析访问日志
分析 MCP 服务器访问日志
```

```
# 记录所有访问
claude --access-log /var/log/claude-access.log

# 分析访问日志
分析 MCP 服务器访问日志
```

###### 2. 异常检测

检测异常行为：

```
bash复制# 设置异常检测规则
cat > mcp-anomaly.yml << 'EOF'
anomaly_detection:
- name: unusual_access_pattern
condition: access_rate > threshold
action: alert_security
- name: data_exfiltration
condition: data_transfer > limit
action: block_access
EOF
```

```
# 设置异常检测规则
cat > mcp-anomaly.yml << 'EOF'
anomaly_detection:
- name: unusual_access_pattern
condition: access_rate > threshold
action: alert_security
- name: data_exfiltration
condition: data_transfer > limit
action: block_access
EOF
```

###### 3. 合规监控

监控合规性：

```
bash复制# 检查合规性
检查 MCP 服务器合规性

# 生成合规报告
生成合规报告
```

```
# 检查合规性
检查 MCP 服务器合规性

# 生成合规报告
生成合规报告
```

#### 企业备份#

##### 配置备份#

###### 1. 备份 MCP 配置

定期备份 MCP 配置：

```
bash复制# 备份配置
#!/bin/bash
BACKUP_DIR="/backup/mcp-configs"
DATE=$(date +%Y%m%d)

# 备份本地配置
cp -r ~/.claude/projects ${BACKUP_DIR}/local-${DATE}

# 备份用户配置
cp ~/.claude/mcp.json ${BACKUP_DIR}/user-${DATE}.json

# 备份项目配置
find . -name ".mcp.json" -exec cp {} ${BACKUP_DIR}/project-${DATE}/ \;
```

```
# 备份配置
#!/bin/bash
BACKUP_DIR="/backup/mcp-configs"
DATE=$(date +%Y%m%d)

# 备份本地配置
cp -r ~/.claude/projects ${BACKUP_DIR}/local-${DATE}

# 备份用户配置
cp ~/.claude/mcp.json ${BACKUP_DIR}/user-${DATE}.json

# 备份项目配置
find . -name ".mcp.json" -exec cp {} ${BACKUP_DIR}/project-${DATE}/ \;
```

###### 2. 自动化备份

设置自动备份：

```
bash复制# 添加到 crontab
crontab -e

# 每天凌晨 2 点备份
0 2 * * * /path/to/backup-mcp-configs.sh
```

```
# 添加到 crontab
crontab -e

# 每天凌晨 2 点备份
0 2 * * * /path/to/backup-mcp-configs.sh
```

##### 恢复配置#

###### 1. 恢复本地配置

```
bash复制# 恢复本地配置
cp -r /backup/mcp-configs/local-20240115 ~/.claude/projects
```

```
# 恢复本地配置
cp -r /backup/mcp-configs/local-20240115 ~/.claude/projects
```

###### 2. 恢复用户配置

```
bash复制# 恢复用户配置
cp /backup/mcp-configs/user-20240115.json ~/.claude/mcp.json
```

```
# 恢复用户配置
cp /backup/mcp-configs/user-20240115.json ~/.claude/mcp.json
```

###### 3. 恢复项目配置

```
bash复制# 恢复项目配置
cp /backup/mcp-configs/project-20240115/.mcp.json .mcp.json
```

```
# 恢复项目配置
cp /backup/mcp-configs/project-20240115/.mcp.json .mcp.json
```

#### 企业最佳实践#

##### 1. 标准化配置#

```
bash复制# 使用标准配置模板
# 确保所有团队使用相同的配置
```

```
# 使用标准配置模板
# 确保所有团队使用相同的配置
```

##### 2. 版本控制#

```
bash复制# 将配置纳入版本控制
git add .mcp.json
git commit -m "Add MCP server configuration"
git push
```

```
# 将配置纳入版本控制
git add .mcp.json
git commit -m "Add MCP server configuration"
git push
```

##### 3. 文档化#

```
bash复制# 创建配置文档
cat > MCP_CONFIG.md << 'EOF'
# MCP 服务器配置

## 本地服务器
- github: 用于代码审查
- sentry: 用于错误监控

## 项目服务器
- database: 用于数据查询
- api: 用于 API 调用

## 用户服务器
- formatter: 用于代码格式化
EOF
```

```
# 创建配置文档
cat > MCP_CONFIG.md << 'EOF'
# MCP 服务器配置

## 本地服务器
- github: 用于代码审查
- sentry: 用于错误监控

## 项目服务器
- database: 用于数据查询
- api: 用于 API 调用

## 用户服务器
- formatter: 用于代码格式化
EOF
```

##### 4. 定期审计#

```
bash复制# 定期审计配置
审计 MCP 服务器配置

# 检查合规性
检查 MCP 服务器合规性
```

```
# 定期审计配置
审计 MCP 服务器配置

# 检查合规性
检查 MCP 服务器合规性
```

##### 5. 培训团队#

```
bash复制# 提供培训
# 创建培训文档
# 组织培训会议
```

```
# 提供培训
# 创建培训文档
# 组织培训会议
```

#### 企业故障排除#

##### 配置同步问题#

问题: 配置不同步

```
bash复制# 1. 检查配置版本
git log .mcp.json

# 2. 拉取最新配置
git pull

# 3. 合并配置
git merge origin/main

# 4. 推送配置
git push
```

```
# 1. 检查配置版本
git log .mcp.json

# 2. 拉取最新配置
git pull

# 3. 合并配置
git merge origin/main

# 4. 推送配置
git push
```

##### 性能问题#

问题: MCP 服务器性能差

```
bash复制# 1. 检查性能指标
显示 MCP 服务器性能统计

# 2. 识别瓶颈
识别性能瓶颈

# 3. 优化配置
# 调整超时设置
# 启用缓存

# 4. 扩展服务器
# 增加服务器实例
# 使用负载均衡
```

```
# 1. 检查性能指标
显示 MCP 服务器性能统计

# 2. 识别瓶颈
识别性能瓶颈

# 3. 优化配置
# 调整超时设置
# 启用缓存

# 4. 扩展服务器
# 增加服务器实例
# 使用负载均衡
```

##### 安全问题#

问题: 安全事件

```
bash复制# 1. 立即隔离
隔离受影响的 MCP 服务器

# 2. 调查事件
调查安全事件

# 3. 修复漏洞
修复安全漏洞

# 4. 恢复服务
恢复 MCP 服务器服务
```

```
# 1. 立即隔离
隔离受影响的 MCP 服务器

# 2. 调查事件
调查安全事件

# 3. 修复漏洞
修复安全漏洞

# 4. 恢复服务
恢复 MCP 服务器服务
```

#### 企业合规#

##### GDPR 合规#

```
bash复制# 1. 数据最小化
# 只收集必要的数据

# 2. 数据保护
# 加密敏感数据

# 3. 访问控制
# 限制数据访问

# 4. 审计追踪
# 记录所有访问
```

```
# 1. 数据最小化
# 只收集必要的数据

# 2. 数据保护
# 加密敏感数据

# 3. 访问控制
# 限制数据访问

# 4. 审计追踪
# 记录所有访问
```

##### SOC 2 合规#

```
bash复制# 1. 安全控制
# 实施安全措施

# 2. 访问管理
# 管理访问权限

# 3. 监控和日志
# 监控和记录活动

# 4. 变更管理
# 管理配置变更
```

```
# 1. 安全控制
# 实施安全措施

# 2. 访问管理
# 管理访问权限

# 3. 监控和日志
# 监控和记录活动

# 4. 变更管理
# 管理配置变更
```

##### HIPAA 合规#

```
bash复制# 1. 保护 PHI
# 保护受保护的健康信息

# 2. 访问控制
# 限制访问 PHI

# 3. 审计日志
# 记录所有 PHI 访问

# 4. 风险分析
# 分析安全风险
```

```
# 1. 保护 PHI
# 保护受保护的健康信息

# 2. 访问控制
# 限制访问 PHI

# 3. 审计日志
# 记录所有 PHI 访问

# 4. 风险分析
# 分析安全风险
```

#### 企业支持#

##### 技术支持#

```
bash复制# 联系技术支持
联系企业技术支持

# 提交支持请求
提交支持请求
```

```
# 联系技术支持
联系企业技术支持

# 提交支持请求
提交支持请求
```

##### 培训资源#

```
bash复制# 访问培训资源
访问企业培训资源

# 查看文档
查看企业文档
```

```
# 访问培训资源
访问企业培训资源

# 查看文档
查看企业文档
```

##### 社区支持#

```
bash复制# 加入企业社区
加入企业社区

# 参与讨论
参与企业讨论
```

```
# 加入企业社区
加入企业社区

# 参与讨论
参与企业讨论
```

---

## 5 MCP 实际应用示例

**URL**: https://claudecode.tangshuang.net/course/13.5%20MCP%20%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B

通过实际示例学习如何有效使用 MCP 服务器。

#### 示例 1: 代码审查工作流#

##### 场景#

使用 GitHub MCP 服务器自动化代码审查流程。

##### 配置#

```
bash复制# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

```
# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

##### 工作流程#

```
bash复制# 1. 查看 PR
使用 GitHub 工具查看 PR #456

# 2. 分析代码变更
分析 PR #456 的代码变更

# 3. 运行测试
运行 PR #456 的测试

# 4. 生成审查报告
生成 PR #456 的审查报告
```

```
# 1. 查看 PR
使用 GitHub 工具查看 PR #456

# 2. 分析代码变更
分析 PR #456 的代码变更

# 3. 运行测试
运行 PR #456 的测试

# 4. 生成审查报告
生成 PR #456 的审查报告
```

##### 使用的 MCP 工具#

- github.get_pr: 获取 PR 信息
- github.get_diff: 获取代码差异
- github.run_tests: 运行测试
- github.create_review_comment: 创建审查评论

```
github.get_pr
```

```
github.get_diff
```

```
github.run_tests
```

```
github.create_review_comment
```

##### 结果#

```
bash复制# PR #456 审查报告
## 代码变更
- 修改文件：15
- 新增代码：500 行
- 删除代码：200 行
## 测试结果
- 单元测试：通过 (100/100)
- 集成测试：通过 (50/50)
- 覆盖率：85%
## 建议

## 结论
✅ 批准 PR
```

```
# PR #456 审查报告
## 代码变更
- 修改文件：15
- 新增代码：500 行
- 删除代码：200 行
## 测试结果
- 单元测试：通过 (100/100)
- 集成测试：通过 (50/50)
- 覆盖率：85%
## 建议

## 结论
✅ 批准 PR
```

#### 示例 2: 错误监控和调试#

##### 场景#

使用 Sentry MCP 服务器监控和调试生产错误。

##### 配置#

```
bash复制# 添加 Sentry MCP 服务器
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp

# 进行身份验证
/mcp
# 选择 "sentry"
# 完成 OAuth 流程
```

```
# 添加 Sentry MCP 服务器
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp

# 进行身份验证
/mcp
# 选择 "sentry"
# 完成 OAuth 流程
```

##### 工作流程#

```
bash复制# 1. 查看最近的错误
使用 Sentry 工具查看过去 24 小时的错误

# 2. 分析错误模式
分析错误模式

# 3. 查看特定错误详情
查看错误 ID abc123 的详细信息

# 4. 识别根本原因
识别错误的根本原因

# 5. 生成修复建议
生成修复建议
```

```
# 1. 查看最近的错误
使用 Sentry 工具查看过去 24 小时的错误

# 2. 分析错误模式
分析错误模式

# 3. 查看特定错误详情
查看错误 ID abc123 的详细信息

# 4. 识别根本原因
识别错误的根本原因

# 5. 生成修复建议
生成修复建议
```

##### 使用的 MCP 工具#

- sentry.get_errors: 获取错误列表
- sentry.get_error_details: 获取错误详情
- sentry.get_stacktrace: 获取堆栈跟踪
- sentry.get_events: 获取相关事件

```
sentry.get_errors
```

```
sentry.get_error_details
```

```
sentry.get_stacktrace
```

```
sentry.get_events
```

##### 结果#

```
bash复制# 错误分析报告

## 错误摘要
- 总错误数：150
- 独特错误数：45
- 影响用户：1,200

## 主要错误

   - 发生次数：50
   - 影响用户：500
   - 最后出现：2 小时前

   - 发生次数：30
   - 影响用户：300
   - 最后出现：1 小时前

## 根本原因

## 修复建议
```

```
# 错误分析报告

## 错误摘要
- 总错误数：150
- 独特错误数：45
- 影响用户：1,200

## 主要错误

   - 发生次数：50
   - 影响用户：500
   - 最后出现：2 小时前

   - 发生次数：30
   - 影响用户：300
   - 最后出现：1 小时前

## 根本原因

## 修复建议
```

#### 示例 3: 数据分析和报告#

##### 场景#

使用数据库 MCP 服务器分析销售数据并生成报告。

##### 配置#

```
bash复制# 添加数据库 MCP 服务器
claude mcp add --transport stdio sales-db -- npx -y @bytebase/dbhub \
--dsn "postgresql://readonly:pass@prod.db.com:5432/sales"
```

```
# 添加数据库 MCP 服务器
claude mcp add --transport stdio sales-db -- npx -y @bytebase/dbhub \
--dsn "postgresql://readonly:pass@prod.db.com:5432/sales"
```

##### 工作流程#

```
bash复制# 1. 查询销售数据
使用数据库工具查询本月销售额

# 2. 分析销售趋势
分析销售趋势

# 3. 识别热门产品
识别最畅销的产品

# 4. 生成报告
生成销售分析报告
```

```
# 1. 查询销售数据
使用数据库工具查询本月销售额

# 2. 分析销售趋势
分析销售趋势

# 3. 识别热门产品
识别最畅销的产品

# 4. 生成报告
生成销售分析报告
```

##### 使用的 MCP 工具#

- database.query: 执行 SQL 查询
- database.get_schema: 获取数据库架构
- database.analyze: 分析数据

```
database.query
```

```
database.get_schema
```

```
database.analyze
```

##### 结果#

```
bash复制# 销售分析报告
## 总体统计
- 总销售额：$2,345,678
- 订单数量：15,432
- 平均订单金额：$152.00
## 销售趋势
- 周一：$345,678
- 周二：$423,456
- 周三：$378,901
- 周四：$456,789
- 周五：$512,345
- 周六：$234,567
- 周日：$189,942
## 热门产品

## 建议
```

```
# 销售分析报告
## 总体统计
- 总销售额：$2,345,678
- 订单数量：15,432
- 平均订单金额：$152.00
## 销售趋势
- 周一：$345,678
- 周二：$423,456
- 周三：$378,901
- 周四：$456,789
- 周五：$512,345
- 周六：$234,567
- 周日：$189,942
## 热门产品

## 建议
```

#### 示例 4: 自动化部署#

##### 场景#

使用 GitHub 和 CI/CD MCP 服务器自动化部署流程。

##### 配置#

```
bash复制# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# 添加 CI/CD MCP 服务器
claude mcp add --transport http cicd https://cicd.internal.com/mcp \
  --header "Authorization: Bearer ${CICD_TOKEN}"
```

```
# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# 添加 CI/CD MCP 服务器
claude mcp add --transport http cicd https://cicd.internal.com/mcp \
  --header "Authorization: Bearer ${CICD_TOKEN}"
```

##### 工作流程#

```
bash复制# 1. 创建发布分支
使用 GitHub 工具创建发布分支

# 2. 更新版本号
更新 package.json 中的版本号

# 3. 运行测试
使用 CI/CD 工具运行测试

# 4. 构建项目
使用 CI/CD 工具构建项目

# 5. 部署到生产环境
使用 CI/CD 工具部署到生产环境

# 6. 创建 Release
使用 GitHub 工具创建 Release
```

```
# 1. 创建发布分支
使用 GitHub 工具创建发布分支

# 2. 更新版本号
更新 package.json 中的版本号

# 3. 运行测试
使用 CI/CD 工具运行测试

# 4. 构建项目
使用 CI/CD 工具构建项目

# 5. 部署到生产环境
使用 CI/CD 工具部署到生产环境

# 6. 创建 Release
使用 GitHub 工具创建 Release
```

##### 使用的 MCP 工具#

- github.create_branch: 创建分支
- github.update_file: 更新文件
- cicd.run_tests: 运行测试
- cicd.build: 构建项目
- cicd.deploy: 部署项目
- github.create_release: 创建 Release

```
github.create_branch
```

```
github.update_file
```

```
cicd.run_tests
```

```
cicd.build
```

```
cicd.deploy
```

```
github.create_release
```

##### 结果#

```
bash复制# 部署报告

## 部署信息
- 分支：release/v2.1.0
- 版本：2.1.0
- 环境：production
- 时间：2024-01-15 10:30:00

## 测试结果
- 单元测试：通过 (100/100)
- 集成测试：通过 (50/50)
- E2E 测试：通过 (20/20)

## 构建结果
- 构建时间：5 分钟
- 构建状态：成功
- 构建产物：dist/

## 部署结果
- 部署状态：成功
- 部署时间：2 分钟
- 健康检查：通过

## Release
- Release URL：https://github.com/user/repo/releases/tag/v2.1.0
- Release 说明：包含新功能和修复
```

```
# 部署报告

## 部署信息
- 分支：release/v2.1.0
- 版本：2.1.0
- 环境：production
- 时间：2024-01-15 10:30:00

## 测试结果
- 单元测试：通过 (100/100)
- 集成测试：通过 (50/50)
- E2E 测试：通过 (20/20)

## 构建结果
- 构建时间：5 分钟
- 构建状态：成功
- 构建产物：dist/

## 部署结果
- 部署状态：成功
- 部署时间：2 分钟
- 健康检查：通过

## Release
- Release URL：https://github.com/user/repo/releases/tag/v2.1.0
- Release 说明：包含新功能和修复
```

#### 示例 5: 客户支持工作流#

##### 场景#

使用 JIRA 和 Slack MCP 服务器自动化客户支持工作流。

##### 配置#

```
bash复制# 添加 JIRA MCP 服务器
claude mcp add --transport http jira https://mcp.atlassian.com/jira \
--header "Authorization: Bearer ${JIRA_TOKEN}"

# 添加 Slack MCP 服务器
claude mcp add --transport http slack https://mcp.slack.com/mcp \
--header "Authorization: Bearer ${SLACK_TOKEN}"
```

```
# 添加 JIRA MCP 服务器
claude mcp add --transport http jira https://mcp.atlassian.com/jira \
--header "Authorization: Bearer ${JIRA_TOKEN}"

# 添加 Slack MCP 服务器
claude mcp add --transport http slack https://mcp.slack.com/mcp \
--header "Authorization: Bearer ${SLACK_TOKEN}"
```

##### 工作流程#

```
bash复制# 1. 查看新问题
使用 JIRA 工具查看新问题

# 2. 分析问题优先级
分析问题优先级

# 3. 分配问题
分配问题给合适的团队

# 4. 通知团队
使用 Slack 工具通知团队

# 5. 跟踪进度
跟踪问题进度
```

```
# 1. 查看新问题
使用 JIRA 工具查看新问题

# 2. 分析问题优先级
分析问题优先级

# 3. 分配问题
分配问题给合适的团队

# 4. 通知团队
使用 Slack 工具通知团队

# 5. 跟踪进度
跟踪问题进度
```

##### 使用的 MCP 工具#

- jira.get_issues: 获取问题列表
- jira.update_issue: 更新问题
- jira.assign_issue: 分配问题
- slack.send_message: 发送消息
- slack.create_channel: 创建频道

```
jira.get_issues
```

```
jira.update_issue
```

```
jira.assign_issue
```

```
slack.send_message
```

```
slack.create_channel
```

##### 结果#

```
bash复制# 客户支持报告
## 新问题
- 总数：25
- 高优先级：5
- 中优先级：10
- 低优先级：10
## 问题分配
- 开发团队：15
- 运维团队：5
- 产品团队：5
## 团队通知
- 已通知团队：3
- 通知渠道：#support, #dev, #ops
## 进度跟踪
- 已解决：10
- 进行中：10
- 待处理：5
```

```
# 客户支持报告
## 新问题
- 总数：25
- 高优先级：5
- 中优先级：10
- 低优先级：10
## 问题分配
- 开发团队：15
- 运维团队：5
- 产品团队：5
## 团队通知
- 已通知团队：3
- 通知渠道：#support, #dev, #ops
## 进度跟踪
- 已解决：10
- 进行中：10
- 待处理：5
```

#### 示例 6: 文档生成工作流#

##### 场景#

使用 Notion 和 GitHub MCP 服务器自动化文档生成。

##### 配置#

```
bash复制# 添加 Notion MCP 服务器
claude mcp add --transport http notion https://mcp.notion.com/mcp

# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

```
# 添加 Notion MCP 服务器
claude mcp add --transport http notion https://mcp.notion.com/mcp

# 添加 GitHub MCP 服务器
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
```

##### 工作流程#

```
bash复制# 1. 获取代码变更
使用 GitHub 工具获取最近的代码变更

# 2. 分析代码功能
分析代码功能

# 3. 生成文档
生成 API 文档

# 4. 更新 Notion
使用 Notion 工具更新文档页面

# 5. 通知团队
使用 Slack 工具通知团队文档已更新
```

```
# 1. 获取代码变更
使用 GitHub 工具获取最近的代码变更

# 2. 分析代码功能
分析代码功能

# 3. 生成文档
生成 API 文档

# 4. 更新 Notion
使用 Notion 工具更新文档页面

# 5. 通知团队
使用 Slack 工具通知团队文档已更新
```

##### 使用的 MCP 工具#

- github.get_commits: 获取提交
- github.get_diff: 获取代码差异
- notion.get_page: 获取页面
- notion.update_page: 更新页面
- slack.send_message: 发送消息

```
github.get_commits
```

```
github.get_diff
```

```
notion.get_page
```

```
notion.update_page
```

```
slack.send_message
```

##### 结果#

```
bash复制# 文档更新报告

## 代码变更
- 提交数：50
- 修改文件：20
- 新功能：5

## 生成的文档
- API 文档：已更新
- 用户指南：已更新
- 开发者文档：已更新

## Notion 更新
- 更新页面：10
- 新增页面：5
- 更新时间：2024-01-15 10:30:00

## 团队通知
- 通知频道：#docs, #dev
- 通知时间：2024-01-15 10:35:00
```

```
# 文档更新报告

## 代码变更
- 提交数：50
- 修改文件：20
- 新功能：5

## 生成的文档
- API 文档：已更新
- 用户指南：已更新
- 开发者文档：已更新

## Notion 更新
- 更新页面：10
- 新增页面：5
- 更新时间：2024-01-15 10:30:00

## 团队通知
- 通知频道：#docs, #dev
- 通知时间：2024-01-15 10:35:00
```

#### 最佳实践#

##### 1. 组合多个 MCP 服务器#

```
bash复制# 使用多个 MCP 服务器
使用 GitHub 工具创建 PR
使用 Sentry 工具检查错误
使用数据库工具验证数据
```

```
# 使用多个 MCP 服务器
使用 GitHub 工具创建 PR
使用 Sentry 工具检查错误
使用数据库工具验证数据
```

##### 2. 自动化工作流#

```
bash复制# 创建自动化工作流
cat > ~/.claude/commands/deploy.md << 'EOF'

EOF
```

```
# 创建自动化工作流
cat > ~/.claude/commands/deploy.md << 'EOF'

EOF
```

##### 3. 错误处理#

```
bash复制# 处理 MCP 错误
如果 MCP 工具失败，重试 3 次
如果仍然失败，通知团队
```

```
# 处理 MCP 错误
如果 MCP 工具失败，重试 3 次
如果仍然失败，通知团队
```

##### 4. 监控和日志#

```
bash复制# 监控 MCP 使用
显示 MCP 使用统计

# 记录日志
显示 MCP 日志
```

```
# 监控 MCP 使用
显示 MCP 使用统计

# 记录日志
显示 MCP 日志
```

##### 5. 性能优化#

```
bash复制# 优化 MCP 性能
启用 MCP 缓存
批量处理请求
使用并行处理
```

```
# 优化 MCP 性能
启用 MCP 缓存
批量处理请求
使用并行处理
```

---

## 6 MCP 输出限制与管理

**URL**: https://claudecode.tangshuang.net/course/13.6%20MCP%20%E8%BE%93%E5%87%BA%E9%99%90%E5%88%B6%E4%B8%8E%E7%AE%A1%E7%90%86

了解和管理 MCP 服务器的输出限制，确保高效使用。

#### 输出限制#

##### 默认限制#

MCP 工具输出有默认限制：

- 令牌限制: 10,000 令牌
- 字符限制: 约 40,000 字符
- 响应时间: 30 秒超时

##### 增加输出限制#

使用 MAX_MCP_OUTPUT_TOKENS 环境变量增加限制：

```
MAX_MCP_OUTPUT_TOKENS
```

### 设置 50,000 令牌限制

MAX_MCP_OUTPUT_TOKENS=50000 claude

### 设置 100,000 令牌限制

MAX_MCP_OUTPUT_TOKENS=100000 claude

##### 超时设置#

使用 MCP_TIMEOUT 环境变量设置超时：

```
MCP_TIMEOUT
```

```
bash复制# 设置 10 秒超时
MCP_TIMEOUT=10000 claude

# 设置 60 秒超时
MCP_TIMEOUT=60000 claude
```

```
# 设置 10 秒超时
MCP_TIMEOUT=10000 claude

# 设置 60 秒超时
MCP_TIMEOUT=60000 claude
```

#### 输出管理#

##### 分页处理#

当输出超过限制时，使用分页：

### 第 1 页

查询用户表的前 100 条记录

### 第 2 页

查询用户表的第 101-200 条记录

### 第 3 页

查询用户表的第 201-300 条记录

```
bash复制### 流式输出
使用流式输出处理大结果：
```

```
### 流式输出
使用流式输出处理大结果：
```

### 流式输出

流式输出所有用户数据

### 输出到文件

将用户数据输出到文件 users.json

##### 批处理#

##### 批处理#

使用批处理处理大量数据：

```
bash复制# 批量处理
批量处理用户数据，每批 100 条
```

```
# 批量处理
批量处理用户数据，每批 100 条
```

#### 输出优化#

##### 查询优化#

优化查询以减少输出：

```
bash复制# 只查询需要的列
查询用户表的 ID 和姓名

# 使用过滤条件
查询用户表中活跃的用户

# 限制结果数量
查询用户表的前 100 条记录
```

```
# 只查询需要的列
查询用户表的 ID 和姓名

# 使用过滤条件
查询用户表中活跃的用户

# 限制结果数量
查询用户表的前 100 条记录
```

##### 数据聚合#

聚合数据以减少输出：

### 聚合数据

查询用户表的总数和平均年龄

### 分组统计

按部门统计用户数量

```
bash复制### 缓存结果

缓存结果以减少重复查询：

```bash
# 启用缓存
启用用户表缓存

# 查看缓存
显示缓存状态

# 清除缓存
清除用户表缓存
```

## 输出监控

### 监控输出大小

```bash
# 查看输出统计
显示 MCP 输出统计
```

**输出示例**:
```
MCP 输出统计：

github:
> - 平均输出：5,000 令牌
> - 最大输出：15,000 令牌
> - 超限次数：5

database:
> - 平均输出：8,000 令牌
> - 最大输出：25,000 令牌
> - 超限次数：10
```

### 监控响应时间

# 查看响应时间
显示 MCP 响应时间

```
> **输出示例**:

```> MCP 响应时间：

github:
> - 平均响应：100ms
> - 最大响应：500ms
> - 超时次数：2

database:
> - 平均响应：50ms
> - 最大响应：200ms
> - 超时次数：1

## 输出警告

### 警告类型

#### 1. 输出超限警告

警告：MCP 工具输出超过 10,000 令牌限制
建议：增加 MAX_MCP_OUTPUT_TOKENS 或优化查询

#### 2. 响应超时警告

警告：MCP 工具响应超过 30 秒超时
建议：增加 MCP_TIMEOUT 或优化查询

#### 3. 输出截断警告

警告：MCP 工具输出被截断
建议：使用分页或流式输出

### 处理警告

```bash
# 处理输出超限警告
增加 MAX_MCP_OUTPUT_TOKENS 到 50,000

# 处理响应超时警告
增加 MCP_TIMEOUT 到 60 秒

# 处理输出截断警告
使用分页查询
```

## 输出格式化

### JSON 格式

```bash
# 输出为 JSON
查询用户表，输出为 JSON
```

### CSV 格式

```bash
# 输出为 CSV
查询用户表，输出为 CSV
```

### Markdown 格式

```bash
# 输出为 Markdown
查询用户表，输出为 Markdown 表格
```

## 输出存储

## 输出存储

### 保存到文件

```bash
# 保存到文件
将用户数据保存到 users.json

# 追加到文件
将用户数据追加到 users.json
```

### 导出到数据库

```bash
# 导出到数据库
将用户数据导出到数据库
```

### 上传到云存储

```bash
# 上传到 S3
将用户数据上传到 S3
```

## 输出安全

### 敏感数据过滤

```bash
# 过滤敏感数据
查询用户表，过滤密码字段
```

### 数据脱敏

```bash
# 脱敏数据
查询用户表，脱敏邮箱地址
```

### 访问控制

```bash
# 限制输出访问
限制用户表输出只能被管理员访问
```

## 最佳实践

### 1. 合理设置限制

```bash
# 根据需求设置限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
MCP_TIMEOUT=30000 claude
```

### 2. 优化查询

```bash
# 只查询需要的数据
查询用户表的 ID 和姓名
# 使用过滤条件
查询用户表中活跃的用户
# 限制结果数量
查询用户表的前 100 条记录
```

### 3. 使用分页

```bash
# 使用分页处理大数据
查询用户表，每页 100 条
```

### 4. 启用缓存

```bash
# 启用缓存减少重复查询
启用用户表缓存
```

### 5. 监控输出

```bash
# 定期监控输出统计
显示 MCP 输出统计

# 识别超限情况
显示超限次数
```

## 故障排除

### 输出超限

> **问题**: 输出超过限制

> **解决方案**:
```bash
# 1. 增加限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
# 2. 优化查询
只查询需要的列
# 3. 使用分页
分页查询数据
# 4. 使用流式输出
流式输出数据
```

### 响应超时

> **问题**: 响应超时

> **解决方案**:
```bash
# 1. 增加超时
MCP_TIMEOUT=60000 claude

# 2. 优化查询
使用索引优化查询

# 3. 减少数据量
限制查询结果数量

# 4. 使用后台任务
在后台运行长时间查询
```

### 输出截断

> **问题**: 输出被截断

> **解决方案**:
```bash
# 1. 使用分页
分页查询数据
# 2. 使用流式输出
流式输出数据
# 3. 保存到文件
将数据保存到文件
# 4. 增加限制
MAX_MCP_OUTPUT_TOKENS=100000 claude
```
```

```
### 缓存结果

缓存结果以减少重复查询：

```bash
# 启用缓存
启用用户表缓存

# 查看缓存
显示缓存状态

# 清除缓存
清除用户表缓存
```

## 输出监控

### 监控输出大小

```bash
# 查看输出统计
显示 MCP 输出统计
```

**输出示例**:
```
MCP 输出统计：

github:
> - 平均输出：5,000 令牌
> - 最大输出：15,000 令牌
> - 超限次数：5

database:
> - 平均输出：8,000 令牌
> - 最大输出：25,000 令牌
> - 超限次数：10
```

### 监控响应时间

# 查看响应时间
显示 MCP 响应时间

```
> **输出示例**:

```> MCP 响应时间：

github:
> - 平均响应：100ms
> - 最大响应：500ms
> - 超时次数：2

database:
> - 平均响应：50ms
> - 最大响应：200ms
> - 超时次数：1

## 输出警告

### 警告类型

#### 1. 输出超限警告

警告：MCP 工具输出超过 10,000 令牌限制
建议：增加 MAX_MCP_OUTPUT_TOKENS 或优化查询

#### 2. 响应超时警告

警告：MCP 工具响应超过 30 秒超时
建议：增加 MCP_TIMEOUT 或优化查询

#### 3. 输出截断警告

警告：MCP 工具输出被截断
建议：使用分页或流式输出

### 处理警告

```bash
# 处理输出超限警告
增加 MAX_MCP_OUTPUT_TOKENS 到 50,000

# 处理响应超时警告
增加 MCP_TIMEOUT 到 60 秒

# 处理输出截断警告
使用分页查询
```

## 输出格式化

### JSON 格式

```bash
# 输出为 JSON
查询用户表，输出为 JSON
```

### CSV 格式

```bash
# 输出为 CSV
查询用户表，输出为 CSV
```

### Markdown 格式

```bash
# 输出为 Markdown
查询用户表，输出为 Markdown 表格
```

## 输出存储

## 输出存储

### 保存到文件

```bash
# 保存到文件
将用户数据保存到 users.json

# 追加到文件
将用户数据追加到 users.json
```

### 导出到数据库

```bash
# 导出到数据库
将用户数据导出到数据库
```

### 上传到云存储

```bash
# 上传到 S3
将用户数据上传到 S3
```

## 输出安全

### 敏感数据过滤

```bash
# 过滤敏感数据
查询用户表，过滤密码字段
```

### 数据脱敏

```bash
# 脱敏数据
查询用户表，脱敏邮箱地址
```

### 访问控制

```bash
# 限制输出访问
限制用户表输出只能被管理员访问
```

## 最佳实践

### 1. 合理设置限制

```bash
# 根据需求设置限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
MCP_TIMEOUT=30000 claude
```

### 2. 优化查询

```bash
# 只查询需要的数据
查询用户表的 ID 和姓名
# 使用过滤条件
查询用户表中活跃的用户
# 限制结果数量
查询用户表的前 100 条记录
```

### 3. 使用分页

```bash
# 使用分页处理大数据
查询用户表，每页 100 条
```

### 4. 启用缓存

```bash
# 启用缓存减少重复查询
启用用户表缓存
```

### 5. 监控输出

```bash
# 定期监控输出统计
显示 MCP 输出统计

# 识别超限情况
显示超限次数
```

## 故障排除

### 输出超限

> **问题**: 输出超过限制

> **解决方案**:
```bash
# 1. 增加限制
MAX_MCP_OUTPUT_TOKENS=50000 claude
# 2. 优化查询
只查询需要的列
# 3. 使用分页
分页查询数据
# 4. 使用流式输出
流式输出数据
```

### 响应超时

> **问题**: 响应超时

> **解决方案**:
```bash
# 1. 增加超时
MCP_TIMEOUT=60000 claude

# 2. 优化查询
使用索引优化查询

# 3. 减少数据量
限制查询结果数量

# 4. 使用后台任务
在后台运行长时间查询
```

### 输出截断

> **问题**: 输出被截断

> **解决方案**:
```bash
# 1. 使用分页
分页查询数据
# 2. 使用流式输出
流式输出数据
# 3. 保存到文件
将数据保存到文件
# 4. 增加限制
MAX_MCP_OUTPUT_TOKENS=100000 claude
```
```

---

# 第 14 章

## 1 Skills 基本概念

**URL**: https://claudecode.tangshuang.net/course/14.1%20Skills%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5

#### 什么是 Skills#

Skills（技能）是 Claude Code 中一种用于封装特定任务和知识的高级机制。它允许用户将复杂的工作流程、最佳实践和领域知识打包成可重用的组件，从而显著提高开发效率和代码质量。

Skills 本质上是一组预定义的指令、工具调用模式和上下文信息，它们可以被 Claude Code 的主代理调用，以执行特定的任务。与传统的脚本或插件不同，Skills 是通过自然语言描述和示例来定义的，这使得它们更加灵活和易于理解，即使是非专业开发者也能快速上手。

#### Skills 的核心特征#

##### 1. 任务导向#

Skills 围绕特定任务设计，每个 Skill 都有明确的目标和预期输出。例如：

- 代码审查 Skill：专注于检查代码质量、安全性和最佳实践
- 文档生成 Skill：专注于从代码生成高质量文档
- 测试生成 Skill：专注于为代码生成全面的测试用例
- 性能优化 Skill：专注于识别和修复性能瓶颈

##### 2. 上下文感知#

Skills 可以访问和利用项目的上下文信息，包括：

- 文件系统结构
- 代码库内容
- 配置文件
- 依赖关系
- 项目架构
- 历史变更记录

这种上下文感知能力使得 Skills 能够生成更加准确和相关的结果，避免了通用解决方案的局限性。

##### 3. 可组合性#

Skills 可以相互调用和组合，形成更复杂的工作流程。例如：

- 一个"部署 Skill"可以调用"测试 Skill"来验证代码
- 一个"重构 Skill"可以调用"文档更新 Skill"来保持文档同步
- 一个"CI/CD Skill"可以组合多个 Skills 完成完整的持续集成流程

##### 4. 自适应性#

Skills 可以根据不同的输入和上下文调整其行为。这种自适应性来自于：

- 大语言模型的理解能力
- 预定义的示例和模式
- 动态的上下文分析
- 机器学习模型的持续改进

##### 5. 可扩展性#

Skills 可以通过插件和 MCP 服务器进行扩展，访问外部工具和资源。例如：

- 调用 GitHub API 获取项目信息
- 连接数据库执行查询
- 集成 CI/CD 系统

#### Skills 与其他概念的区别#

##### Skills vs. 插件#

##### Skills vs. MCP 服务器#

##### Skills vs. 传统脚本#

#### Skills 的类型#

##### 1. 代码生成 Skills#

专注于生成特定类型的代码，例如：

- API 端点生成
- 数据模型定义
- UI 组件创建
- 配置文件生成
- 测试用例生成

##### 2. 代码分析 Skills#

专注于分析和理解代码，例如：

- 代码审查
- 性能分析
- 安全审计
- 依赖分析
- 架构分析

##### 3. 文档 Skills#

专注于文档相关的任务，例如：

- API 文档生成
- README 创建
- 代码注释添加
- 技术文档翻译
- 文档格式转换

##### 4. 测试 Skills#

专注于测试相关的任务，例如：

- 单元测试生成
- 集成测试创建
- 测试覆盖率分析
- 测试报告生成
- 测试用例优化

##### 5. 重构 Skills#

专注于代码重构，例如：

- 代码简化
- 模式应用
- 架构改进
- 代码迁移
- 性能优化

##### 6. DevOps Skills#

专注于 DevOps 相关任务，例如：

- CI/CD 配置
- 部署自动化
- 监控设置
- 日志分析
- 容器化配置

##### 7. 安全 Skills#

专注于安全相关任务，例如：

- 漏洞扫描
- 代码安全审计
- 依赖安全检查
- 加密配置
- 访问控制

#### Skills 的价值主张#

##### 1. 提高效率#

通过封装常见任务和最佳实践，Skills 可以显著减少重复性工作：

- 自动化重复性任务
- 加速开发流程
- 减少人为错误
- 提高团队生产力

##### 2. 知识传承#

Skills 是组织知识和最佳实践的有效载体：

- 捕捉专家知识
- 标准化工作流程
- 促进团队协作
- 减少知识流失

##### 3. 质量保证#

Skills 可以内置质量检查和标准：

- 强制执行编码规范
- 自动化代码审查
- 确保一致性
- 提高代码质量

##### 4. 快速上手#

新团队成员可以通过 Skills 快速了解项目规范和工作流程：

- 降低学习曲线
- 提供明确指导
- 减少培训时间
- 提高团队协作效率

##### 5. 创新加速#

Skills 可以帮助团队快速尝试新想法和技术：

- 快速原型开发
- 技术评估
- 实验性项目
- 创新解决方案

#### Skills 的基本组成#

一个完整的 Skill 通常包含以下组成部分：

##### 1. 描述#

清晰描述 Skill 的目的、功能和适用场景：

```
markdown复制## Skill: 代码审查

本 Skill 用于审查代码质量，检查安全性、性能和最佳实践。
适用于 Python、JavaScript 和 TypeScript 代码。
```

```
## Skill: 代码审查

本 Skill 用于审查代码质量，检查安全性、性能和最佳实践。
适用于 Python、JavaScript 和 TypeScript 代码。
```

##### 2. 输入规范#

定义 Skill 需要的输入信息：

```
markdown复制### 输入
- 代码文件或代码片段
- 编程语言
- 审查标准（可选）
- 代码上下文（可选）
```

```
### 输入
- 代码文件或代码片段
- 编程语言
- 审查标准（可选）
- 代码上下文（可选）
```

##### 3. 输出规范#

定义 Skill 产生的输出：

```
markdown复制### 输出
- 审查报告
- 问题列表
- 改进建议
- 代码示例
```

```
### 输出
- 审查报告
- 问题列表
- 改进建议
- 代码示例
```

##### 4. 执行步骤#

详细说明 Skill 的执行流程：

```
markdown复制### 执行步骤
1. 分析输入代码
2. 检查代码质量
3. 识别潜在问题
4. 生成改进建议
5. 格式化输出结果
```

```
### 执行步骤
1. 分析输入代码
2. 检查代码质量
3. 识别潜在问题
4. 生成改进建议
5. 格式化输出结果
```

##### 5. 示例#

提供使用示例和预期结果：

```
markdown复制### 示例
输入：
```python
def calculate_sum(numbers):
    total = 0
    for n in numbers:
        total += n
    return total
```

```
### 示例
输入：
```python
def calculate_sum(numbers):
    total = 0
    for n in numbers:
        total += n
    return total
```

- ✅ 代码结构清晰
- ✅ 变量命名合理
- 💡 建议使用内置 sum() 函数
- 📝 优化后的代码：return sum(numbers)

```
return sum(numbers)
```

```
bash复制
### 6. 最佳实践

提供使用该 Skill 的最佳实践：

```markdown
### 最佳实践
1. 定期运行代码审查 Skill
2. 结合团队编码规范使用
3. 优先修复高优先级问题
4. 记录审查结果以便追踪
```

```
### 6. 最佳实践

提供使用该 Skill 的最佳实践：

```markdown
### 最佳实践
1. 定期运行代码审查 Skill
2. 结合团队编码规范使用
3. 优先修复高优先级问题
4. 记录审查结果以便追踪
```

#### Skills 的使用场景#

##### 1. 新项目初始化#

使用 Skills 快速设置新项目：

- 创建项目结构
- 生成配置文件
- 设置开发环境

##### 2. 代码审查流程#

集成到 CI/CD 流程中：

- 自动化代码审查
- 生成审查报告
- 提供改进建议

##### 3. 文档维护#

保持文档与代码同步：

- 自动更新 API 文档
- 生成变更日志
- 创建使用示例

##### 4. 测试生成#

加速测试开发：

- 为新功能生成测试
- 提高测试覆盖率
- 生成边界测试用例

##### 5. 重构辅助#

安全地进行代码重构：

- 识别重构机会
- 生成重构方案
- 验证重构结果

#### Skills 的局限性#

虽然 Skills 提供了许多优势，但也存在一些局限性：

##### 1. 上下文限制#

Skills 的理解能力受限于输入的上下文信息：

- 无法访问外部系统
- 上下文窗口有限
- 可能遗漏全局信息

##### 2. 确定性问题#

由于基于大语言模型，Skills 的输出可能不完全确定：

- 相同输入可能产生不同输出
- 需要验证和调整结果
- 不适用于需要精确控制的任务

##### 3. 性能考虑#

Skills 的执行可能需要额外的计算资源：

- 大语言模型调用开销
- 上下文处理时间
- 可能影响整体性能

##### 4. 维护成本#

Skills 需要持续维护和更新：

- 随项目演进需要调整
- 需要验证和测试
- 版本管理挑战

#### 最佳实践#

##### 1. 明确定义#

为每个 Skill 提供清晰、详细的定义：

- 明确的目的和范围
- 清晰的输入输出规范
- 详细的执行步骤

##### 2. 提供示例#

包含丰富的示例来指导使用：

- 正面示例展示预期行为
- 反面示例说明避免事项
- 覆盖常见使用场景

##### 3. 持续改进#

定期评估和改进 Skills：

- 收集用户反馈
- 分析使用数据
- 优化性能和准确性

##### 4. 版本控制#

对 Skills 进行版本管理：

- 记录变更历史
- 保持向后兼容
- 提供迁移指南

##### 5. 文档完善#

为 Skills 提供完整的文档：

- 使用说明
- 参数说明
- 常见问题解答

#### 总结#

Skills 是 Claude Code 中一个强大而灵活的功能，它通过自然语言定义和示例驱动的方式，为开发者提供了一种封装知识和自动化任务的有效手段。理解 Skills 的基本概念、特征和适用场景，是充分利用这一功能的第一步。

在接下来的章节中，我们将深入探讨 Skills 的工作原理、创建方法、开发技巧以及实际应用，帮助您全面掌握这一强大的工具。

---

## 2 Skills 核心功能

**URL**: https://claudecode.tangshuang.net/course/14.2%20Skills%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD

#### Skills 功能概览#

Skills 提供了一系列强大的功能，使开发者能够高效地封装和执行特定任务。本节将详细介绍 Skills 的核心功能及其应用方式。

#### 1. 任务封装#

##### 功能描述#

Skills 最基本的功能是封装特定的任务和工作流程。通过将复杂任务分解为可重用的组件，Skills 可以显著提高开发效率，减少重复劳动。

##### 实现方式#

###### 自然语言描述

使用清晰的自然语言描述任务目标和执行步骤：

```
markdown复制## Skill: API 端点生成

### 目标
根据数据模型自动生成 REST API 端点

### 执行步骤
1. 分析数据模型结构
2. 确定必要的 CRUD 操作
3. 生成路由定义
4. 创建控制器逻辑
5. 添加输入验证
6. 生成响应格式
7. 编写文档注释
```

```
## Skill: API 端点生成

### 目标
根据数据模型自动生成 REST API 端点

### 执行步骤
1. 分析数据模型结构
2. 确定必要的 CRUD 操作
3. 生成路由定义
4. 创建控制器逻辑
5. 添加输入验证
6. 生成响应格式
7. 编写文档注释
```

###### 示例驱动

通过提供输入输出示例来定义预期行为：

```
markdown复制### 示例

输入：
```python
from datetime import datetime
```

```
### 示例

输入：
```python
from datetime import datetime
```

class User:
id: int
name: str
email: str
created_at: datetime

```
bash复制
输出：
```python
# 路由定义
@app.get("/users")
def get_users():
    pass

@app.get("/users/{id}")
def get_user(id: int):
    pass

@app.post("/users")
def create_user(user: UserCreate):
    pass

@app.put("/users/{id}")
def update_user(id: int, user: UserUpdate):
    pass

@app.delete("/users/{id}")
def delete_user(id: int):
    pass
```

```
输出：
```python
# 路由定义
@app.get("/users")
def get_users():
    pass

@app.get("/users/{id}")
def get_user(id: int):
    pass

@app.post("/users")
def create_user(user: UserCreate):
    pass

@app.put("/users/{id}")
def update_user(id: int, user: UserUpdate):
    pass

@app.delete("/users/{id}")
def delete_user(id: int):
    pass
```

##### 应用场景#

- 重复性任务：自动化需要重复执行的任务
- 标准化流程：确保团队遵循一致的工作流程
- 知识传递：将专家经验封装为可重用的组件
- 快速原型：加速原型开发和验证

#### 2. 上下文管理#

##### 功能描述#

Skills 具备强大的上下文管理能力，可以访问和分析项目的各种信息，包括文件系统、代码库、配置等。这种能力使得 Skills 能够生成更加准确和相关的结果。

##### 上下文类型#

###### 项目结构上下文

Skills 可以理解项目的目录结构和组织方式：

```
markdown复制## Skill: 项目结构分析

### 功能
分析项目结构，识别关键目录和文件

### 上下文信息
- 根目录结构
- 源代码目录
- 配置文件位置
- 测试目录
- 文档目录
- 依赖管理文件
```

```
## Skill: 项目结构分析

### 功能
分析项目结构，识别关键目录和文件

### 上下文信息
- 根目录结构
- 源代码目录
- 配置文件位置
- 测试目录
- 文档目录
- 依赖管理文件
```

###### 代码库上下文

Skills 可以访问和分析代码库内容：

```
markdown复制## Skill: 代码依赖分析

### 功能
分析代码之间的依赖关系

### 上下文信息
- 导入语句
- 函数调用关系
- 类继承关系
- 模块依赖图
- 接口实现关系
```

```
## Skill: 代码依赖分析

### 功能
分析代码之间的依赖关系

### 上下文信息
- 导入语句
- 函数调用关系
- 类继承关系
- 模块依赖图
- 接口实现关系
```

###### 配置上下文

Skills 可以读取和解析配置文件：

```
markdown复制## Skill: 配置验证

### 功能
验证项目配置的正确性

### 上下文信息
- package.json / requirements.txt
- tsconfig.json / pyproject.toml
- .env 文件
- CI/CD 配置
- 环境变量
```

```
## Skill: 配置验证

### 功能
验证项目配置的正确性

### 上下文信息
- package.json / requirements.txt
- tsconfig.json / pyproject.toml
- .env 文件
- CI/CD 配置
- 环境变量
```

##### 上下文访问机制#

###### 文件系统工具

使用内置的文件系统工具：

- Read：读取文件内容
- SearchCodebase：搜索代码库
- Glob：查找文件模式
- LS：列出目录内容
- Grep：搜索文件内容

```
Read
```

```
SearchCodebase
```

```
Glob
```

```
LS
```

```
Grep
```

###### 智能分析

利用大语言模型的理解能力：

- 语义理解代码结构
- 识别设计模式
- 推断代码意图
- 分析最佳实践
- 检测潜在问题

##### 应用场景#

- 代码理解：深入理解代码库的结构和逻辑
- 影响分析：评估代码变更的影响范围
- 重构规划：规划重构策略和步骤
- 项目评估：快速了解新项目的结构和技术栈

#### 3. 工具调用集成#

##### 功能描述#

Skills 可以调用各种工具来完成特定任务，包括文件操作、代码搜索、命令执行等。这种集成能力使得 Skills 能够与外部系统无缝协作。

##### 工具类型#

###### 文件系统工具

```
markdown复制## Skill: 文件组织

### 可用工具
- Read：读取文件
- Write：写入文件
- Edit：编辑文件
- Delete：删除文件
- Move：移动文件
- Copy：复制文件
```

```
## Skill: 文件组织

### 可用工具
- Read：读取文件
- Write：写入文件
- Edit：编辑文件
- Delete：删除文件
- Move：移动文件
- Copy：复制文件
```

###### 搜索工具

```
markdown复制## Skill: 代码搜索

### 可用工具
- SearchCodebase：搜索代码库
- Grep：正则表达式搜索
- Find：查找文件
```

```
## Skill: 代码搜索

### 可用工具
- SearchCodebase：搜索代码库
- Grep：正则表达式搜索
- Find：查找文件
```

##### 可用工具#

- SearchCodebase：语义搜索
- Grep：正则表达式搜索
- Find：文件查找

###### 命令执行工具

```
markdown复制## Skill: 构建自动化

### 可用工具
- RunCommand：执行命令
- CheckCommandStatus：检查命令状态
- StopCommand：停止命令
```

```
## Skill: 构建自动化

### 可用工具
- RunCommand：执行命令
- CheckCommandStatus：检查命令状态
- StopCommand：停止命令
```

##### 工具调用模式#

###### 顺序调用

按顺序执行多个工具：

```
markdown复制### 执行流程
1. 执行工具 A
2. 执行工具 B
3. 执行工具 C
```

```
### 执行流程
1. 执行工具 A
2. 执行工具 B
3. 执行工具 C
```

###### 条件调用

根据条件选择不同的工具：

```
markdown复制### 执行流程
1. 评估条件
2. 根据条件选择工具
3. 执行选定的工具
```

```
### 执行流程
1. 评估条件
2. 根据条件选择工具
3. 执行选定的工具
```

###### 循环调用

###### 循环调用

对多个文件执行相同操作：

```
markdown复制### 执行流程
1. 使用 Glob 查找所有匹配文件
2. 对每个文件：
   - Read 文件内容
   - 应用转换逻辑
   - Write 修改后的内容
```

```
### 执行流程
1. 使用 Glob 查找所有匹配文件
2. 对每个文件：
   - Read 文件内容
   - 应用转换逻辑
   - Write 修改后的内容
```

##### 应用场景#

- 批量处理：对多个文件执行相同操作
- 自动化工作流：创建复杂的多步骤工作流
- 系统集成：与外部系统和工具集成

#### 4. 参数化与定制#

##### 功能描述#

Skills 支持参数化，允许用户根据具体需求定制 Skill 的行为。

##### 参数类型#

###### 必需参数

```
bash复制````markdown

## Skill: 代码生成

### 必需参数
> - `language`: 编程语言
> - `description`: 功能描述

```#### 可选参数
```

```
````markdown

## Skill: 代码生成

### 必需参数
> - `language`: 编程语言
> - `description`: 功能描述

```#### 可选参数
```

markdown

##### 可选参数#

- framework: 使用的框架（默认：无）
- style: 代码风格（默认：PEP8）
- include_tests: 是否包含测试（默认：true）

```
framework
```

```
style
```

```
include_tests
```

###### 参数验证

```
bash复制````markdown

### 参数验证
> - `language`: 必须是支持的编程语言之一
> - `style`: 必须是有效的代码风格
> - `include_tests`: 必须是布尔值

```### 参数使用方式

#### 命令行参数
```

```
````markdown

### 参数验证
> - `language`: 必须是支持的编程语言之一
> - `style`: 必须是有效的代码风格
> - `include_tests`: 必须是布尔值

```### 参数使用方式

#### 命令行参数
```

claude --skill code-gen --language python --framework flask

###### 交互式输入

```
bash复制````markdown

请提供以下信息：
1. 编程语言：[python]
2. 框架：[flask]
3. 是否包含测试：[y/n]

```#### 配置文件
```

```
````markdown

请提供以下信息：
1. 编程语言：[python]
2. 框架：[flask]
3. 是否包含测试：[y/n]

```#### 配置文件
```

skills:
code-gen:
language: python
framework: flask
include_tests: true

##### 应用场景#

- 灵活定制：根据不同需求调整 Skill 行为
- 模板化：创建可配置的代码模板
- 多环境支持：支持不同开发环境的配置

#### 5. 错误处理与恢复#

##### 功能描述#

Skills 具备完善的错误处理机制，能够识别、报告和恢复各种错误情况。

##### 错误类型#

###### 输入错误

```
markdown复制## Skill: 数据验证

### 输入错误
- 缺少必需参数
- 参数类型不正确
- 参数值超出范围
```

```
## Skill: 数据验证

### 输入错误
- 缺少必需参数
- 参数类型不正确
- 参数值超出范围
```

###### 执行错误

```
markdown复制## Skill: 文件操作

### 执行错误
- 文件不存在
- 权限不足
- 磁盘空间不足
```

```
## Skill: 文件操作

### 执行错误
- 文件不存在
- 权限不足
- 磁盘空间不足
```

###### 逻辑错误

```
markdown复制## Skill: 代码分析

### 逻辑错误
- 无法解析代码
- 检测到不一致
- 无法推断意图
```

```
## Skill: 代码分析

### 逻辑错误
- 无法解析代码
- 检测到不一致
- 无法推断意图
```

##### 错误处理策略#

###### 错误检测

```
markdown复制### 错误检测
- 输入验证
- 状态检查
- 资源验证
```

```
### 错误检测
- 输入验证
- 状态检查
- 资源验证
```

###### 错误报告

```
markdown复制### 错误报告
- 清晰的错误消息
- 错误位置信息
- 建议的修复方案
- 相关文档链接
```

```
### 错误报告
- 清晰的错误消息
- 错误位置信息
- 建议的修复方案
- 相关文档链接
```

###### 错误恢复

```
markdown复制### 错误恢复
1. 尝试自动修复
2. 提供恢复选项
3. 保存中间状态
4. 支持断点续传
```

```
### 错误恢复
1. 尝试自动修复
2. 提供恢复选项
3. 保存中间状态
4. 支持断点续传
```

##### 应用场景#

- 健壮性：确保 Skill 在各种情况下都能正常运行
- 用户体验：提供清晰的错误信息和恢复建议
- 调试支持：帮助开发者快速定位和解决问题

#### 6. 性能优化#

##### 功能描述#

Skills 包含多种性能优化机制，确保高效执行和资源利用。

##### 优化策略#

###### 缓存机制

```
markdown复制## Skill: 代码分析

### 缓存策略
- 缓存解析结果
- 缓存依赖图
- 缓存分析报告
- 设置合理的过期时间
```

```
## Skill: 代码分析

### 缓存策略
- 缓存解析结果
- 缓存依赖图
- 缓存分析报告
- 设置合理的过期时间
```

###### 增量处理

```
markdown复制## Skill: 文档生成

### 增量处理
- 只处理变更的文件
- 跟踪文件修改时间
- 复用之前的分析结果
```

```
## Skill: 文档生成

### 增量处理
- 只处理变更的文件
- 跟踪文件修改时间
- 复用之前的分析结果
```

###### 并行执行

```
markdown复制## Skill: 批量处理

### 并行执行
- 并行处理独立文件
- 使用多线程/多进程
- 合理分配资源
```

```
## Skill: 批量处理

### 并行执行
- 并行处理独立文件
- 使用多线程/多进程
- 合理分配资源
```

###### 资源管理

```
markdown复制## Skill: 大型代码库处理

### 资源管理
- 限制内存使用
- 控制并发数
- 及时释放资源
- 监控性能指标
```

```
## Skill: 大型代码库处理

### 资源管理
- 限制内存使用
- 控制并发数
- 及时释放资源
- 监控性能指标
```

##### 性能监控#

```
markdown复制### 性能监控
- 执行时间统计
- 资源使用监控
- 瓶颈识别
- 优化建议
```

```
### 性能监控
- 执行时间统计
- 资源使用监控
- 瓶颈识别
- 优化建议
```

##### 应用场景#

- 大规模项目：处理大型代码库时的性能优化
- 频繁执行：优化频繁执行的 Skills
- 资源受限：在资源受限环境下的优化

#### 7. 日志与调试#

##### 功能描述#

Skills 提供详细的日志记录和调试支持，帮助开发者理解和优化 Skill 的行为。

##### 日志级别#

```
markdown复制## 日志级别

### DEBUG
详细的调试信息，包括：
- 每个步骤的详细信息
- 中间结果
- 变量值

### INFO
一般信息，包括：
- 执行开始/结束
- 主要步骤
- 关键决策

### WARNING
警告信息，包括：
- 潜在问题
- 非最佳实践
- 性能警告

### ERROR
错误信息，包括：
- 错误详情
- 堆栈跟踪
- 恢复建议
```

```
## 日志级别

### DEBUG
详细的调试信息，包括：
- 每个步骤的详细信息
- 中间结果
- 变量值

### INFO
一般信息，包括：
- 执行开始/结束
- 主要步骤
- 关键决策

### WARNING
警告信息，包括：
- 潜在问题
- 非最佳实践
- 性能警告

### ERROR
错误信息，包括：
- 错误详情
- 堆栈跟踪
- 恢复建议
```

##### 调试功能#

###### 步骤跟踪

```
markdown复制### 步骤跟踪
- 记录每个执行步骤
- 显示输入输出
- 标记决策点
```

```
### 步骤跟踪
- 记录每个执行步骤
- 显示输入输出
- 标记决策点
```

###### 断点支持

```
bash复制markdown

### 断点支持
- 在关键位置设置断点
- 检查变量状态
- 单步执行

#### 性能分析

~~~`markdown
````markdown

### 性能分析
> - 记录执行时间
> - 识别性能瓶颈
> - 提供优化建议

```### 应用场景

> - **问题诊断**：快速定位和解决问题
> - **性能优化**：识别和优化性能瓶颈
> - **学习理解**：帮助理解 Skill 的执行过程

## 8. 版本管理

### 功能描述

Skills 支持版本管理，允许跟踪变更、管理不同版本和进行升级。

### 版本控制

#### 版本号规范
```

```
markdown

### 断点支持
- 在关键位置设置断点
- 检查变量状态
- 单步执行

#### 性能分析

~~~`markdown
````markdown

### 性能分析
> - 记录执行时间
> - 识别性能瓶颈
> - 提供优化建议

```### 应用场景

> - **问题诊断**：快速定位和解决问题
> - **性能优化**：识别和优化性能瓶颈
> - **学习理解**：帮助理解 Skill 的执行过程

## 8. 版本管理

### 功能描述

Skills 支持版本管理，允许跟踪变更、管理不同版本和进行升级。

### 版本控制

#### 版本号规范
```

markdown

##### 版本号格式#

主版本号.次版本号.修订号

- 1.0.0：初始版本
- 1.1.0：添加新功能
- 1.1.1：修复 bug
- 2.0.0：重大变更

###### 变更日志

```
bash复制````markdown

## 变更日志

### [1.2.0] - 2024-01-15
### 新增
> - 支持新的编程语言
> - 添加性能优化

### 改进
> - 改进错误处理
> - 优化日志输出

### 修复
> - 修复参数验证 bug

```### 版本管理功能

#### 版本切换
```

```
````markdown

## 变更日志

### [1.2.0] - 2024-01-15
### 新增
> - 支持新的编程语言
> - 添加性能优化

### 改进
> - 改进错误处理
> - 优化日志输出

### 修复
> - 修复参数验证 bug

```### 版本管理功能

#### 版本切换
```

markdown

##### 版本切换#

- 查看可用版本
- 切换到指定版本
- 比较版本差异

###### 向后兼容

```
bash复制````markdown

### 向后兼容
> - 保持 API 稳定
> - 提供迁移指南
> - 支持旧版本参数

```#### 升级路径
```

```
````markdown

### 向后兼容
> - 保持 API 稳定
> - 提供迁移指南
> - 支持旧版本参数

```#### 升级路径
```

markdown

##### 升级路径#

- 自动检测新版本
- 提供升级建议
- 备份当前配置

```
bash复制~~~
```

```
~~~
```

---

## 3 Skills 与其他功能的关系

**URL**: https://claudecode.tangshuang.net/course/14.3%20Skills%20%E4%B8%8E%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD%E7%9A%84%E5%85%B3%E7%B3%BB

#### Claude Code 功能生态系统#

Claude Code 提供了多种功能来增强开发体验，Skills 是其中的重要组成部分。理解 Skills 与其他功能的关系，有助于更好地利用整个生态系统。

#### Skills 与主代理#

##### 关系概述#

Skills 是主代理（Main Agent）的可调用组件，主代理负责协调和调用 Skills 来完成特定任务。主代理作为核心协调者，管理 Skills 的生命周期、上下文传递和结果整合。

##### 交互模式#

###### 1. 主动调用

主代理根据任务需求主动选择和调用 Skills：

```
markdown复制## 场景：代码审查

### 主代理决策流程
1. 识别任务：需要审查代码
2. 选择 Skill：调用"代码审查 Skill"
3. 传递上下文：提供代码文件和审查标准
4. 接收结果：获取审查报告
5. 整合输出：将结果呈现给用户
```

```
## 场景：代码审查

### 主代理决策流程
1. 识别任务：需要审查代码
2. 选择 Skill：调用"代码审查 Skill"
3. 传递上下文：提供代码文件和审查标准
4. 接收结果：获取审查报告
5. 整合输出：将结果呈现给用户
```

###### 2. 被动调用

用户明确指定使用某个 Skill：

```
bash复制claude --skill code-review src/main.py
```

```
claude --skill code-review src/main.py
```

###### 3. 嵌套调用

Skills 可以调用其他 Skills，形成复杂的任务执行链：

```
markdown复制## 场景：部署流程
### 部署 Skill 调用链

└─> 测试 Skill
    └─> 代码分析 Skill
        └─> 文档检查 Skill
```

```
## 场景：部署流程
### 部署 Skill 调用链

└─> 测试 Skill
    └─> 代码分析 Skill
        └─> 文档检查 Skill
```

##### 协作机制#

###### 上下文共享

主代理和 Skills 共享上下文信息，确保任务执行的连贯性：

```
markdown复制### 共享的上下文
- 用户请求
- 项目结构
- 文件内容
- 配置信息
- 执行历史
```

```
### 共享的上下文
- 用户请求
- 项目结构
- 文件内容
- 配置信息
- 执行历史
```

###### 结果整合

主代理整合多个 Skills 的结果，形成统一的输出：

```
markdown复制### 结果整合示例
任务：生成完整的 API 文档

1. 调用"API 文档生成 Skill"
2. 调用"代码分析 Skill"获取接口定义
3. 调用"文档格式检查 Skill"
4. 整合所有结果生成最终文档
```

```
### 结果整合示例
任务：生成完整的 API 文档

1. 调用"API 文档生成 Skill"
2. 调用"代码分析 Skill"获取接口定义
3. 调用"文档格式检查 Skill"
4. 整合所有结果生成最终文档
```

###### 错误处理

主代理处理 Skills 的错误，确保任务的鲁棒性：

```
markdown复制### 错误处理流程
1. 捕获 Skill 执行错误
2. 记录错误信息
3. 尝试备用 Skill 或回退策略
4. 向用户报告错误
```

```
### 错误处理流程
1. 捕获 Skill 执行错误
2. 记录错误信息
3. 尝试备用 Skill 或回退策略
4. 向用户报告错误
```

#### Skills 与插件#

##### 关系概述#

Skills 和插件都是扩展 Claude Code 功能的方式，但它们有不同的设计理念和应用场景。Skills 注重灵活性和快速开发，而插件注重性能和精确控制。

##### 主要区别#

###### 1. 定义方式

###### 2. 执行方式

```
markdown复制## Skills 执行
- 通过主代理调用
- 基于自然语言理解
- 动态解释和执行
- 上下文感知

## 插件执行
- 通过插件系统加载
- 编译后的代码
- 直接执行
- 性能优化
```

```
## Skills 执行
- 通过主代理调用
- 基于自然语言理解
- 动态解释和执行
- 上下文感知

## 插件执行
- 通过插件系统加载
- 编译后的代码
- 直接执行
- 性能优化
```

###### 3. 性能特征

```
markdown复制## Skills 性能
- 解释执行
- 需要大语言模型调用
- 适合复杂逻辑和灵活任务
- 响应时间：100-500ms

## 插件性能
- 编译执行
- 直接调用
- 适合性能敏感任务
- 响应时间：10-100ms
```

```
## Skills 性能
- 解释执行
- 需要大语言模型调用
- 适合复杂逻辑和灵活任务
- 响应时间：100-500ms

## 插件性能
- 编译执行
- 直接调用
- 适合性能敏感任务
- 响应时间：10-100ms
```

##### 协作场景#

###### 1. 互补使用

Skills 和插件可以协同工作，发挥各自优势：

```
markdown复制## 场景：代码格式化
### 组合使用

1. Skill：代码分析（理解代码结构）
2. 插件：格式化工具（快速执行）
3. Skill：结果验证（确保格式正确）
```

```
## 场景：代码格式化
### 组合使用

1. Skill：代码分析（理解代码结构）
2. 插件：格式化工具（快速执行）
3. Skill：结果验证（确保格式正确）
```

###### 2. 插件提供工具

插件可以为 Skills 提供额外的工具：

```
markdown复制## 插件为 Skills 提供工具

### 插件：数据库工具
- 提供 `query_database` 工具
- 高性能数据访问

### Skill：数据迁移
- 调用插件的 `query_database` 工具
- 执行数据迁移逻辑
- 处理复杂业务规则
```

```
## 插件为 Skills 提供工具

### 插件：数据库工具
- 提供 `query_database` 工具
- 高性能数据访问

### Skill：数据迁移
- 调用插件的 `query_database` 工具
- 执行数据迁移逻辑
- 处理复杂业务规则
```

###### 3. Skills 调用插件

Skills 可以调用插件的功能，实现复杂任务：

```
markdown复制## Skill: 部署应用
### 执行步骤
1. 调用插件：代码打包
2. 调用插件：镜像构建
3. 调用插件：部署到服务器
4. Skill：验证部署结果
```

```
## Skill: 部署应用
### 执行步骤
1. 调用插件：代码打包
2. 调用插件：镜像构建
3. 调用插件：部署到服务器
4. Skill：验证部署结果
```

##### 选择指南#

###### 使用 Skills 的情况

- 需要灵活性和适应性
- 任务逻辑复杂且多变
- 需要理解自然语言
- 快速原型开发
- 知识封装和传递
- 业务规则经常变化

###### 使用插件的情况

- 性能要求高
- 需要精确控制
- 与外部系统集成
- 复杂的数据处理
- 长期维护的功能
- 性能敏感的操作

#### Skills 与 MCP 服务器#

##### 关系概述#

MCP（Model Context Protocol）服务器为 Skills 提供外部数据和工具访问能力，使 Skills 能够与各种外部系统集成。

##### 交互模式#

###### 1. 数据访问

Skills 通过 MCP 服务器访问外部数据：

```
markdown复制## 场景：代码审查（使用 GitHub MCP）

### Skill: 代码审查

### 执行流程
1. 调用 GitHub MCP 获取代码仓库信息
2. 分析代码提交历史
3. 识别潜在问题
4. 生成审查报告
```

```
## 场景：代码审查（使用 GitHub MCP）

### Skill: 代码审查

### 执行流程
1. 调用 GitHub MCP 获取代码仓库信息
2. 分析代码提交历史
3. 识别潜在问题
4. 生成审查报告
```

###### 2. 工具调用

Skills 通过 MCP 服务器调用外部工具：

```
markdown复制## 场景：错误监控（使用 Sentry MCP）
### Skill: 错误分析
### 执行流程
1. 调用 Sentry MCP 获取错误数据
2. 分析错误模式
3. 识别根本原因
4. 提供修复建议
```

```
## 场景：错误监控（使用 Sentry MCP）
### Skill: 错误分析
### 执行流程
1. 调用 Sentry MCP 获取错误数据
2. 分析错误模式
3. 识别根本原因
4. 提供修复建议
```

###### 3. 资源利用

Skills 利用 MCP 服务器的资源：

```
markdown复制## 场景：数据分析（使用数据库 MCP）

### Skill: 数据分析

### 执行流程
1. 调用数据库 MCP 执行查询
2. 处理查询结果
3. 生成可视化报告
4. 提供业务洞察
```

```
## 场景：数据分析（使用数据库 MCP）

### Skill: 数据分析

### 执行流程
1. 调用数据库 MCP 执行查询
2. 处理查询结果
3. 生成可视化报告
4. 提供业务洞察
```

##### 集成优势#

###### 1. 扩展能力

MCP 服务器扩展了 Skills 的能力范围，使其能够访问各种外部系统和服务。

###### 2. 标准化接口

MCP 提供标准化的接口，使 Skills 能够以统一的方式与不同的外部系统交互。

###### 3. 安全性

MCP 服务器处理身份验证和授权，确保 Skills 安全地访问外部资源。

###### 4. 性能优化

MCP 服务器优化了数据传输和处理，提高了 Skills 的执行效率。

###### 5. 可扩展性

通过 MCP 服务器，Skills 可以轻松集成新的外部系统和服务。

#### Skills 与工具调用#

##### 关系概述#

Skills 是工具调用的组织和编排者，通过组合和协调多个工具调用来完成复杂任务。Skills 将低级工具调用封装为高级业务逻辑。

##### 工具调用层次#

###### 1. 基础工具

Claude Code 提供的基础工具：

```
markdown复制## 基础工具
- Read：读取文件
- Write：写入文件
- Edit：编辑文件
- SearchCodebase：搜索代码
- RunCommand：执行命令
- ...
```

```
## 基础工具
- Read：读取文件
- Write：写入文件
- Edit：编辑文件
- SearchCodebase：搜索代码
- RunCommand：执行命令
- ...
```

###### 2. 工具组合

Skills 组合多个基础工具完成复杂任务：

```
markdown复制## Skill: 重构代码
### 工具组合

1. Read：读取原始代码
2. SearchCodebase：查找相关代码
3. Edit：修改代码
4. RunCommand：运行测试
5. Write：保存结果
```

```
## Skill: 重构代码
### 工具组合

1. Read：读取原始代码
2. SearchCodebase：查找相关代码
3. Edit：修改代码
4. RunCommand：运行测试
5. Write：保存结果
```

###### 3. 高级抽象

Skills 提供高级抽象，隐藏底层工具调用细节：

```
markdown复制## 高级抽象

### 用户视角
"重构这个函数"

### Skill 视角
1. 分析函数结构
2. 查找相关依赖
3. 应用重构模式
4. 验证重构结果
```

```
## 高级抽象

### 用户视角
"重构这个函数"

### Skill 视角
1. 分析函数结构
2. 查找相关依赖
3. 应用重构模式
4. 验证重构结果
```

##### 工具调用模式#

###### 1. 顺序调用

按顺序执行多个工具调用：

```
markdown复制## 场景：创建新功能
### 顺序调用

1. Read：读取现有代码
2. SearchCodebase：查找类似功能
3. Write：创建新文件
4. Edit：添加功能
5. RunCommand：运行测试
```

```
## 场景：创建新功能
### 顺序调用

1. Read：读取现有代码
2. SearchCodebase：查找类似功能
3. Write：创建新文件
4. Edit：添加功能
5. RunCommand：运行测试
```

###### 2. 条件调用

根据条件决定是否执行工具调用：

```
markdown复制## 场景：代码检查

### 条件调用
1. RunCommand：运行测试
2. 如果测试失败：
   - Read：读取错误信息
   - Edit：修复代码
   - RunCommand：重新测试
3. 如果测试成功：
   - 继续下一步
```

```
## 场景：代码检查

### 条件调用
1. RunCommand：运行测试
2. 如果测试失败：
   - Read：读取错误信息
   - Edit：修复代码
   - RunCommand：重新测试
3. 如果测试成功：
   - 继续下一步
```

###### 3. 循环调用

重复执行工具调用直到满足条件：

```
markdown复制## 场景：批量更新
### 循环调用

1. Read：读取文件列表
2. 对于每个文件：
   - Read：读取内容
   - Apply：应用转换
   - Write：写入结果
```

```
## 场景：批量更新
### 循环调用

1. Read：读取文件列表
2. 对于每个文件：
   - Read：读取内容
   - Apply：应用转换
   - Write：写入结果
```

###### 4. 并行调用

同时执行多个工具调用提高效率：

```
markdown复制## 场景：多文件分析

### 并行调用

1. 同时读取多个文件
2. 并行分析文件内容
3. 合并分析结果
```

```
## 场景：多文件分析

### 并行调用

1. 同时读取多个文件
2. 并行分析文件内容
3. 合并分析结果
```

#### Skills 与斜杠命令#

##### 关系概述#

斜杠命令提供快速访问 Skills 的方式，简化用户交互。斜杠命令是 Skills 的快捷方式。

##### 命令映射#

###### 1. 直接映射

斜杠命令直接映射到 Skill：

```
bash复制# 斜杠命令调用 Skill
/skill code-review

# 等价于
claude --skill code-review
```

```
# 斜杠命令调用 Skill
/skill code-review

# 等价于
claude --skill code-review
```

###### 2. 参数传递

斜杠命令可以传递参数给 Skill：

```
bash复制# 带参数的斜杠命令
/skill code-review --file src/main.py --standard PEP8

# 等价于
claude --skill code-review --file src/main.py --standard PEP8
```

```
# 带参数的斜杠命令
/skill code-review --file src/main.py --standard PEP8

# 等价于
claude --skill code-review --file src/main.py --standard PEP8
```

###### 3. 命令别名

斜杠命令支持别名，简化调用：

```
bash复制# 使用别名调用 Skill
/code-review src/main.py

# 等价于
/skill code-review src/main.py
```

```
# 使用别名调用 Skill
/code-review src/main.py

# 等价于
/skill code-review src/main.py
```

##### 交互优势#

```
markdown复制## 斜杠命令的优势
- 快速访问：无需完整命令
- 简化交互：减少输入
- 上下文感知：自动获取当前上下文
- 历史记录：快速重复调用
```

```
## 斜杠命令的优势
- 快速访问：无需完整命令
- 简化交互：减少输入
- 上下文感知：自动获取当前上下文
- 历史记录：快速重复调用
```

###### 3. 交互式调用

斜杠命令支持交互式调用：

```
bash复制# 交互式调用
/skill code-review
# 提示输入参数
# 输入：src/main.py
# 输入：PEP8
# 执行审查
```

```
# 交互式调用
/skill code-review
# 提示输入参数
# 输入：src/main.py
# 输入：PEP8
# 执行审查
```

##### 命令别名#

斜杠命令支持别名，简化调用：

```
markdown复制## 常用别名

### 代码审查
/skill cr → /skill code-review

### 文档生成
/skill doc → /skill generate-docs

### 测试生成
/skill test → /skill generate-tests
```

```
## 常用别名

### 代码审查
/skill cr → /skill code-review

### 文档生成
/skill doc → /skill generate-docs

### 测试生成
/skill test → /skill generate-tests
```

##### 命令补全#

斜杠命令支持自动补全：

```
markdown复制## 命令补全功能
### 输入
/skill co<TAB>
### 补全为
/skill code-review
```

```
## 命令补全功能
### 输入
/skill co<TAB>
### 补全为
/skill code-review
```

#### Skills 与配置系统#

##### 关系概述#

Skills 可以读取和利用配置系统中的设置，实现个性化的行为。配置系统允许用户自定义 Skills 的行为。

##### 配置类型#

###### 1. 全局配置

全局配置适用于所有项目：

```
yaml复制# .claude/config.yaml
skills:
  code-review:
    strictness: high
    include_security: true
    max_issues: 100
```

```
# .claude/config.yaml
skills:
  code-review:
    strictness: high
    include_security: true
    max_issues: 100
```

###### 2. 项目配置

项目配置仅适用于当前项目：

```
yaml复制# .claude/project.yaml
skills:
  code-review:
    custom_rules:
      - no_print_statements
      - type_hints_required
    ignore_patterns:
      - "*/tests/*"
      - "*/migrations/*"
```

```
# .claude/project.yaml
skills:
  code-review:
    custom_rules:
      - no_print_statements
      - type_hints_required
    ignore_patterns:
      - "*/tests/*"
      - "*/migrations/*"
```

###### 3. 用户配置

用户配置适用于特定用户：

```
yaml复制# ~/.claude/user.yaml
skills:
  code-review:
    preferred_style: pep8
    output_format: markdown
    auto_fix: false
```

```
# ~/.claude/user.yaml
skills:
  code-review:
    preferred_style: pep8
    output_format: markdown
    auto_fix: false
```

##### 配置优先级#

配置优先级从高到低：

```
markdown复制## 配置优先级（从高到低）
1. 命令行参数
2. 项目配置
3. 用户配置
4. 全局配置
```

```
## 配置优先级（从高到低）
1. 命令行参数
2. 项目配置
3. 用户配置
4. 全局配置
```

##### 配置使用#

Skills 可以读取和应用配置：

```
markdown复制## Skill: 代码审查

### 配置读取
1. 读取全局配置
2. 读取用户配置
3. 读取项目配置
4. 应用命令行参数
5. 合并配置
```

```
## Skill: 代码审查

### 配置读取
1. 读取全局配置
2. 读取用户配置
3. 读取项目配置
4. 应用命令行参数
5. 合并配置
```

#### Skills 与记忆系统#

##### 关系概述#

Skills 可以利用记忆系统存储和检索信息，实现跨会话的知识积累。记忆系统使 Skills 能够学习和适应用户的工作方式。

##### 记忆类型#

###### 1. 项目记忆

存储与项目相关的信息：

```
markdown复制## 项目记忆内容
- 项目结构
- 代码风格
- 常用模式
- 技术栈
- 团队规范
```

```
## 项目记忆内容
- 项目结构
- 代码风格
- 常用模式
- 技术栈
- 团队规范
```

###### 2. 用户记忆

存储与用户相关的信息：

```
markdown复制## 用户记忆内容
- 偏好设置
- 历史操作
- 常用命令
- 学习进度
- 问题记录
```

```
## 用户记忆内容
- 偏好设置
- 历史操作
- 常用命令
- 学习进度
- 问题记录
```

###### 3. Skill 记忆

存储与 Skill 执行相关的信息：

```
markdown复制## Skill 记忆内容
- 执行历史
- 性能数据
- 错误记录
- 优化建议
- 使用统计
```

```
## Skill 记忆内容
- 执行历史
- 性能数据
- 错误记录
- 优化建议
- 使用统计
```

##### 记忆使用#

###### 1. 学习模式

Skills 可以通过记忆系统学习用户的工作方式：

```
markdown复制## Skill: 代码生成

### 学习模式
1. 记录用户的代码风格
2. 分析常用模式
3. 生成符合用户习惯的代码
4. 持续优化建议
```

```
## Skill: 代码生成

### 学习模式
1. 记录用户的代码风格
2. 分析常用模式
3. 生成符合用户习惯的代码
4. 持续优化建议
```

###### 2. 上下文恢复

Skills 可以恢复之前的工作上下文：

```
markdown复制## Skill: 继续工作
### 上下文恢复
1. 读取项目记忆
2. 恢复之前的工作状态
3. 继续未完成的任务
4. 保持工作连续性
```

```
## Skill: 继续工作
### 上下文恢复
1. 读取项目记忆
2. 恢复之前的工作状态
3. 继续未完成的任务
4. 保持工作连续性
```

###### 3. 智能建议

Skills 可以基于记忆提供智能建议：

```
markdown复制## Skill: 代码建议

### 智能建议
1. 分析历史操作
2. 识别常见问题
3. 提供个性化建议
4. 预测用户需求
```

```
## Skill: 代码建议

### 智能建议
1. 分析历史操作
2. 识别常见问题
3. 提供个性化建议
4. 预测用户需求
```

#### Skills 与钩子系统#

##### 关系概述#

Skills 可以与钩子系统集成，在特定事件触发时自动执行。钩子系统使 Skills 能够实现自动化工作流。

##### 钩子类型#

###### 1. 前置钩子

在事件发生前执行：

```
markdown复制## 前置钩子示例
### 事件：文件保存
### 钩子：代码格式化
### Skill: 自动格式化
### 执行流程
1. 用户保存文件
2. 触发前置钩子
3. 执行格式化 Skill
4. 保存格式化后的文件
```

```
## 前置钩子示例
### 事件：文件保存
### 钩子：代码格式化
### Skill: 自动格式化
### 执行流程
1. 用户保存文件
2. 触发前置钩子
3. 执行格式化 Skill
4. 保存格式化后的文件
```

###### 2. 后置钩子

在事件发生后执行：

```
markdown复制## 后置钩子示例

### 事件：代码提交
### 钩子：文档更新
### Skill: 更新文档

### 执行流程
1. 用户提交代码
2. 触发后置钩子
3. 执行文档更新 Skill
4. 提交更新后的文档
```

```
## 后置钩子示例

### 事件：代码提交
### 钩子：文档更新
### Skill: 更新文档

### 执行流程
1. 用户提交代码
2. 触发后置钩子
3. 执行文档更新 Skill
4. 提交更新后的文档
```

###### 3. 错误钩子

在发生错误时执行：

```
markdown复制## 错误钩子示例
### 事件：测试失败
### 钩子：错误分析
### Skill: 错误诊断
### 执行流程
1. 测试失败
2. 触发错误钩子
3. 执行错误诊断 Skill
4. 提供修复建议
```

```
## 错误钩子示例
### 事件：测试失败
### 钩子：错误分析
### Skill: 错误诊断
### 执行流程
1. 测试失败
2. 触发错误钩子
3. 执行错误诊断 Skill
4. 提供修复建议
```

##### 钩子配置#

钩子系统可以通过配置文件进行自定义：

```
yaml复制# .claude/hooks.yaml
hooks:
  pre-commit:
    - skill: code-review
      args:
        strict: true
    - skill: format-code

  post-commit:
    - skill: update-changelog
    - skill: notify-team

  test-failure:
    - skill: diagnose-error
    - skill: suggest-fix
```

```
# .claude/hooks.yaml
hooks:
  pre-commit:
    - skill: code-review
      args:
        strict: true
    - skill: format-code

  post-commit:
    - skill: update-changelog
    - skill: notify-team

  test-failure:
    - skill: diagnose-error
    - skill: suggest-fix
```

#### 总结#

Skills 与 Claude Code 的其他功能紧密集成，形成了一个强大的开发生态系统。理解这些关系有助于：

True. 功能选择：根据任务需求选择合适的功能组合
True. 系统集成：将 Skills 无缝集成到现有工作流
True. 效率提升：通过功能协同提高开发效率
True. 能力扩展：利用集成关系扩展 Skills 的能力

在下一节中，我们将探讨 Skills 的实际应用场景，展示如何在不同开发场景中使用 Skills 来提高效率。

---

## 4 Skills 应用场景

**URL**: https://claudecode.tangshuang.net/course/14.4%20Skills%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF

#### Skills 应用场景概览#

Skills 在软件开发的各个阶段都有广泛的应用。本节将详细介绍 Skills 在不同场景下的具体应用，帮助您理解如何在实际项目中使用 Skills。

#### 1. 新项目初始化#

##### 场景描述#

在开始新项目时，需要创建项目结构、配置文件、基础代码等。使用 Skills 可以快速完成这些重复性工作，确保项目从一开始就遵循最佳实践。

##### 应用示例#

###### Skill: 项目初始化

```
markdown复制## Skill: 项目初始化

### 功能
根据项目类型自动创建项目结构和基础文件

### 输入
- 项目类型（Web 应用、CLI 工具、库等）
- 编程语言
- 框架选择
- 项目名称

### 执行步骤
```

```
## Skill: 项目初始化

### 功能
根据项目类型自动创建项目结构和基础文件

### 输入
- 项目类型（Web 应用、CLI 工具、库等）
- 编程语言
- 框架选择
- 项目名称

### 执行步骤
```

True. 创建项目目录结构
True. 生成配置文件（package.json, requirements.txt 等）
True. 创建基础代码文件
True. 生成 README.md
True. 创建 .gitignore
True. 初始化版本控制
True. 生成开发环境配置

```
bash复制
### 使用示例

```bash
# 初始化一个 Flask Web 应用
claude --skill init-project --type web --language python --framework flask --name myapp

# 初始化一个 Node.js CLI 工具
claude --skill init-project --type cli --language javascript --framework commander --name mytool
```

```
### 使用示例

```bash
# 初始化一个 Flask Web 应用
claude --skill init-project --type web --language python --framework flask --name myapp

# 初始化一个 Node.js CLI 工具
claude --skill init-project --type cli --language javascript --framework commander --name mytool
```

##### 优势#

- 快速启动：几分钟内完成项目初始化
- 一致性：确保所有项目遵循相同的结构
- 最佳实践：内置行业最佳实践
- 可定制：根据团队需求定制模板
- 减少重复：避免手动创建相同的文件结构

#### 2. 代码审查#

##### 场景描述#

代码审查是保证代码质量的重要环节。Skills 可以自动化大部分审查工作，提高审查效率和质量，减少人工审查的主观性和遗漏。

##### 应用示例#

###### Skill: 代码审查

```
markdown复制## Skill: 代码审查
### 功能
自动审查代码，检查质量、安全性和最佳实践
### 输入
- 代码文件或 PR
- 审查标准（可选）
- 严格程度

### 执行步骤
1. 分析代码结构
2. 检查代码质量
3. 检测安全漏洞
4. 评估性能影响
5. 验证最佳实践
6. 生成审查报告
7. 提供改进建议
```

```
## Skill: 代码审查
### 功能
自动审查代码，检查质量、安全性和最佳实践
### 输入
- 代码文件或 PR
- 审查标准（可选）
- 严格程度

### 执行步骤
1. 分析代码结构
2. 检查代码质量
3. 检测安全漏洞
4. 评估性能影响
5. 验证最佳实践
6. 生成审查报告
7. 提供改进建议
```

##### 使用示例#

```
bash复制# 审查单个文件
claude --skill code-review --file src/main.py --strict

# 审查整个 PR
claude --skill code-review --pr 123 --strictness high

# 审查特定目录
claude --skill code-review --dir src/api --include-security
```

```
# 审查单个文件
claude --skill code-review --file src/main.py --strict

# 审查整个 PR
claude --skill code-review --pr 123 --strictness high

# 审查特定目录
claude --skill code-review --dir src/api --include-security
```

##### 审查内容#

```
markdown复制### 审查维度
#### 代码质量
- 复杂度分析
- 代码重复
- 命名规范
- 注释质量

#### 安全性
- SQL 注入
- XSS 攻击
- 敏感信息泄露
- 权限检查

#### 性能
- 算法效率
- 资源使用
- 缓存策略
- 并发处理

#### 最佳实践
- 设计模式
- SOLID 原则
- 错误处理
- 日志记录
```

```
### 审查维度
#### 代码质量
- 复杂度分析
- 代码重复
- 命名规范
- 注释质量

#### 安全性
- SQL 注入
- XSS 攻击
- 敏感信息泄露
- 权限检查

#### 性能
- 算法效率
- 资源使用
- 缓存策略
- 并发处理

#### 最佳实践
- 设计模式
- SOLID 原则
- 错误处理
- 日志记录
```

##### 优势#

- 全面性：覆盖多个审查维度
- 一致性：统一审查标准
- 效率：自动化大部分审查工作
- 可学习：从审查中学习最佳实践
- 客观性：减少人为因素的影响

#### 3. 文档生成#

##### 场景描述#

文档编写是开发中重要但容易被忽视的工作。Skills 可以自动生成各种类型的文档，确保文档与代码同步，减少手动编写的工作量。

##### 应用示例#

###### Skill: API 文档生成

```
markdown复制## Skill: API 文档生成

### 功能
从代码自动生成 API 文档

### 输入
- API 路由文件
- 数据模型定义
- 输出格式（Markdown, HTML, OpenAPI 等）

### 执行步骤
1. 分析代码结构
2. 提取 API 定义
3. 生成文档内容
4. 应用模板格式
5. 输出最终文档
```

```
## Skill: API 文档生成

### 功能
从代码自动生成 API 文档

### 输入
- API 路由文件
- 数据模型定义
- 输出格式（Markdown, HTML, OpenAPI 等）

### 执行步骤
1. 分析代码结构
2. 提取 API 定义
3. 生成文档内容
4. 应用模板格式
5. 输出最终文档
```

##### 使用示例#

```
bash复制# 生成 Markdown 文档
claude --skill generate-api-docs --format markdown --output docs/api.md

# 生成 OpenAPI 规范
claude --skill generate-api-docs --format openapi --output openapi.json

# 生成 HTML 文档
claude --skill generate-api-docs --format html --output docs/api.html
```

```
# 生成 Markdown 文档
claude --skill generate-api-docs --format markdown --output docs/api.md

# 生成 OpenAPI 规范
claude --skill generate-api-docs --format openapi --output openapi.json

# 生成 HTML 文档
claude --skill generate-api-docs --format html --output docs/api.html
```

##### 文档类型#

```
markdown复制### 可生成的文档类型

#### API 文档
- 端点列表
- 请求/响应格式
- 参数说明
- 认证方式
- 示例代码

#### README 文档
- 项目介绍
- 安装说明
- 使用指南
- 配置说明
- 常见问题

#### 代码文档
- 函数说明
- 类文档
- 模块文档
- 示例代码

#### 架构文档
- 系统架构
- 组件关系
- 数据流
- 部署方案
```

```
### 可生成的文档类型

#### API 文档
- 端点列表
- 请求/响应格式
- 参数说明
- 认证方式
- 示例代码

#### README 文档
- 项目介绍
- 安装说明
- 使用指南
- 配置说明
- 常见问题

#### 代码文档
- 函数说明
- 类文档
- 模块文档
- 示例代码

#### 架构文档
- 系统架构
- 组件关系
- 数据流
- 部署方案
```

##### 优势#

- 自动化：减少手动编写工作
- 同步性：保持文档与代码同步
- 标准化：统一文档格式和风格
- 多格式：支持多种输出格式
- 一致性：确保文档风格统一

#### 4. 测试生成#

##### 场景描述#

测试是保证代码质量的关键，但编写测试耗时耗力。Skills 可以自动生成测试用例，提高测试覆盖率，确保代码的正确性和稳定性。

##### 应用示例#

###### Skill: 单元测试生成

```
markdown复制## Skill: 单元测试生成
### 功能
为代码自动生成单元测试
### 输入
- 源代码文件
- 测试框架
- 覆盖率要求

### 执行步骤
1. 分析代码结构
2. 识别测试点
3. 生成测试用例
4. 应用测试框架
5. 验证测试覆盖
```

```
## Skill: 单元测试生成
### 功能
为代码自动生成单元测试
### 输入
- 源代码文件
- 测试框架
- 覆盖率要求

### 执行步骤
1. 分析代码结构
2. 识别测试点
3. 生成测试用例
4. 应用测试框架
5. 验证测试覆盖
```

##### 使用示例#

```
bash复制# 为单个文件生成测试
claude --skill generate-tests --file src/utils.py --framework pytest

# 为整个模块生成测试
claude --skill generate-tests --module src/api --framework jest --coverage 80

# 生成边界测试
claude --skill generate-tests --file src/validator.py --include-edge-cases
```

```
# 为单个文件生成测试
claude --skill generate-tests --file src/utils.py --framework pytest

# 为整个模块生成测试
claude --skill generate-tests --module src/api --framework jest --coverage 80

# 生成边界测试
claude --skill generate-tests --file src/validator.py --include-edge-cases
```

##### 测试类型#

```
markdown复制### 可生成的测试类型
#### 单元测试
- 函数测试
- 类方法测试
- 边界条件测试
- 异常处理测试

#### 集成测试
- API 测试
- 数据库测试
- 外部服务测试
- 端到端测试

#### 性能测试
- 压力测试
- 负载测试
- 响应时间测试
- 并发测试

#### 安全测试
- 输入验证测试
- 权限测试
- 注入攻击测试
- 加密测试
```

```
### 可生成的测试类型
#### 单元测试
- 函数测试
- 类方法测试
- 边界条件测试
- 异常处理测试

#### 集成测试
- API 测试
- 数据库测试
- 外部服务测试
- 端到端测试

#### 性能测试
- 压力测试
- 负载测试
- 响应时间测试
- 并发测试

#### 安全测试
- 输入验证测试
- 权限测试
- 注入攻击测试
- 加密测试
```

##### 优势#

- 快速：快速生成大量测试
- 全面：覆盖多种测试场景
- 可维护：生成可读性强的测试代码
- 可定制：根据需求调整测试策略
- 高质量：基于代码结构生成有意义的测试

#### 5. 代码重构#

##### 场景描述#

代码重构是保持代码健康的重要工作，但手动重构容易出错。Skills 可以安全地进行代码重构，确保代码质量和可维护性。

##### 应用示例#

###### Skill: 代码重构

```
markdown复制## Skill: 代码重构

### 功能
识别重构机会并安全地执行重构

### 输入
- 代码文件或目录
- 重构类型
- 安全级别

### 执行步骤
1. 分析代码结构
2. 识别重构机会
3. 执行重构操作
4. 验证重构结果
5. 生成重构报告
```

```
## Skill: 代码重构

### 功能
识别重构机会并安全地执行重构

### 输入
- 代码文件或目录
- 重构类型
- 安全级别

### 执行步骤
1. 分析代码结构
2. 识别重构机会
3. 执行重构操作
4. 验证重构结果
5. 生成重构报告
```

##### 使用示例#

```
bash复制# 提取函数
claude --skill refactor --file src/main.py --type extract-function --name validate_input

# 重命名变量
claude --skill refactor --file src/utils.py --type rename --old count --new totalCount

# 应用设计模式
claude --skill refactor --file src/service.py --type apply-pattern --pattern singleton

# 简化复杂函数
claude --skill refactor --file src/processor.py --type simplify --max-complexity 10
```

```
# 提取函数
claude --skill refactor --file src/main.py --type extract-function --name validate_input

# 重命名变量
claude --skill refactor --file src/utils.py --type rename --old count --new totalCount

# 应用设计模式
claude --skill refactor --file src/service.py --type apply-pattern --pattern singleton

# 简化复杂函数
claude --skill refactor --file src/processor.py --type simplify --max-complexity 10
```

##### 重构类型#

```
markdown复制### 支持的重构类型

#### 基础重构
- 提取函数
- 提取变量
- 内联函数
- 重命名
- 移动函数

#### 结构重构
- 提取类
- 提取接口
- 移动类
- 合并类
- 分割类

#### 模式应用
- 单例模式
- 工厂模式
- 观察者模式
- 策略模式
- 装饰器模式

#### 代码简化
- 减少复杂度
- 消除重复
- 简化条件
- 优化循环
```

```
### 支持的重构类型

#### 基础重构
- 提取函数
- 提取变量
- 内联函数
- 重命名
- 移动函数

#### 结构重构
- 提取类
- 提取接口
- 移动类
- 合并类
- 分割类

#### 模式应用
- 单例模式
- 工厂模式
- 观察者模式
- 策略模式
- 装饰器模式

#### 代码简化
- 减少复杂度
- 消除重复
- 简化条件
- 优化循环
```

##### 优势#

- 安全：自动验证重构结果
- 全面：考虑所有影响范围
- 可追溯：记录重构历史
- 可回滚：支持回滚操作
- 高效：快速完成复杂重构任务

#### 6. 错误诊断与修复#

##### 场景描述#

调试和修复错误是开发中的常见任务。Skills 可以快速诊断问题并提供修复建议，减少调试时间，提高开发效率。

##### 应用示例#

###### Skill: 错误诊断

```
markdown复制## Skill: 错误诊断
### 功能
分析错误信息，诊断问题并提供修复方案
### 输入
- 错误消息
- 堆栈跟踪
- 相关代码

### 执行步骤
1. 分析错误信息
2. 定位问题代码
3. 识别根本原因
4. 生成修复方案
5. 验证修复效果
```

```
## Skill: 错误诊断
### 功能
分析错误信息，诊断问题并提供修复方案
### 输入
- 错误消息
- 堆栈跟踪
- 相关代码

### 执行步骤
1. 分析错误信息
2. 定位问题代码
3. 识别根本原因
4. 生成修复方案
5. 验证修复效果
```

##### 使用示例#

```
bash复制# 诊断运行时错误
claude --skill diagnose --error "TypeError: Cannot read property 'x' of undefined" --stacktrace <stacktrace.txt>

# 诊断编译错误
claude --skill diagnose --error "Module not found: Error: Can't resolve './utils'" --file src/index.js

# 诊断测试失败
claude --skill diagnose --test-failure --test-file tests/api.test.js
```

```
# 诊断运行时错误
claude --skill diagnose --error "TypeError: Cannot read property 'x' of undefined" --stacktrace <stacktrace.txt>

# 诊断编译错误
claude --skill diagnose --error "Module not found: Error: Can't resolve './utils'" --file src/index.js

# 诊断测试失败
claude --skill diagnose --test-failure --test-file tests/api.test.js
```

##### 错误类型#

```
markdown复制### 可诊断的错误类型
#### 运行时错误
- 类型错误
- 引用错误
- 空指针异常
- 超时错误

#### 编译错误
- 语法错误
- 类型错误
- 模块未找到
- 依赖冲突

#### 逻辑错误
- 业务逻辑错误
- 算法错误
- 边界条件错误
- 状态管理错误

#### 性能问题
- 内存泄漏
- 性能瓶颈
- 资源竞争
- 死锁
```

```
### 可诊断的错误类型
#### 运行时错误
- 类型错误
- 引用错误
- 空指针异常
- 超时错误

#### 编译错误
- 语法错误
- 类型错误
- 模块未找到
- 依赖冲突

#### 逻辑错误
- 业务逻辑错误
- 算法错误
- 边界条件错误
- 状态管理错误

#### 性能问题
- 内存泄漏
- 性能瓶颈
- 资源竞争
- 死锁
```

##### 优势#

- 快速：快速定位问题
- 准确：提供准确的诊断
- 可操作：提供可执行的修复方案
- 教育性：帮助理解问题原因
- 全面：覆盖多种错误类型

#### 7. 代码迁移#

##### 场景描述#

将代码从一个平台或框架迁移到另一个平台是复杂且耗时的任务。Skills 可以自动化大部分迁移工作，减少手动工作量，提高迁移准确性。

##### 应用示例#

###### Skill: 框架迁移

```
markdown复制## Skill: 框架迁移

### 功能
将代码从一个框架迁移到另一个框架

### 输入
- 源框架
- 目标框架
- 代码目录

### 执行步骤
1. 分析源代码结构
2. 识别迁移模式
3. 执行代码转换
4. 验证迁移结果
5. 生成迁移报告
```

```
## Skill: 框架迁移

### 功能
将代码从一个框架迁移到另一个框架

### 输入
- 源框架
- 目标框架
- 代码目录

### 执行步骤
1. 分析源代码结构
2. 识别迁移模式
3. 执行代码转换
4. 验证迁移结果
5. 生成迁移报告
```

##### 使用示例#

```
bash复制# 从 Express 迁移到 Fastify
claude --skill migrate --from express --to fastify --dir src/

# 从 jQuery 迁移到 React
claude --skill migrate --from jquery --to react --dir src/

# 从 Python 2 迁移到 Python 3
claude --skill migrate --from python2 --to python3 --dir src/
```

```
# 从 Express 迁移到 Fastify
claude --skill migrate --from express --to fastify --dir src/

# 从 jQuery 迁移到 React
claude --skill migrate --from jquery --to react --dir src/

# 从 Python 2 迁移到 Python 3
claude --skill migrate --from python2 --to python3 --dir src/
```

##### 迁移类型#

```
markdown复制### 支持的迁移类型

#### 框架迁移
- Web 框架
- UI 框架
- 测试框架
- 构建工具

#### 语言迁移
- Python 2 → Python 3
- JavaScript → TypeScript
- Java → Kotlin

#### 平台迁移
- 本地 → 云平台
- 单体 → 微服务
- 传统 → 容器化

#### 数据库迁移
- SQL → NoSQL
- 一个数据库 → 另一个数据库
```

```
### 支持的迁移类型

#### 框架迁移
- Web 框架
- UI 框架
- 测试框架
- 构建工具

#### 语言迁移
- Python 2 → Python 3
- JavaScript → TypeScript
- Java → Kotlin

#### 平台迁移
- 本地 → 云平台
- 单体 → 微服务
- 传统 → 容器化

#### 数据库迁移
- SQL → NoSQL
- 一个数据库 → 另一个数据库
```

##### 优势#

- 自动化：自动化大部分迁移工作
- 准确：减少人为错误
- 可验证：自动测试迁移结果
- 可回滚：支持回滚到原始状态
- 高效：快速完成复杂迁移任务

#### 8. 性能优化#

##### 场景描述#

性能优化需要深入理解代码和系统。Skills 可以分析性能瓶颈并提供优化建议。

##### 应用示例#

###### Skill: 性能分析

#### Skill: 性能分析#

##### 功能#

分析代码性能，识别瓶颈并提供优化建议

##### 输入#

- 代码文件
- 性能数据（可选）
- 优化目标

##### 执行步骤#

```
bash复制### 使用示例
```

```
### 使用示例
```

### 分析函数性能

claude --skill analyze-performance --file src/processor.py --function process_data

### 分析数据库查询

claude --skill analyze-performance --type database --query "SELECT * FROM users WHERE active = true"

### 分析 API 响应时间

claude --skill analyze-performance --type api --endpoint /api/users --target-time 100ms

##### 优化类型#

##### 可优化的性能类型#

###### 算法优化

- 时间复杂度优化
- 空间复杂度优化
- 算法选择
- 数据结构优化

###### 数据库优化

- 查询优化
- 索引优化
- 连接优化
- 缓存策略

###### 网络优化

- 请求合并
- 数据压缩
- 并发控制
- 连接池

###### 前端优化

- 资源加载
- 渲染优化
- 代码分割
- 缓存策略

```
bash复制### 优势
- **全面**：覆盖多个性能维度
- **精准**：准确定位瓶颈
- **可操作**：提供具体的优化方案
- **可验证**：验证优化效果
## 9. 安全审计
### 场景描述
安全是软件系统的重要考虑因素。Skills 可以自动进行安全审计，识别潜在的安全问题。
### 应用示例
#### Skill: 安全审计
```

```
### 优势
- **全面**：覆盖多个性能维度
- **精准**：准确定位瓶颈
- **可操作**：提供具体的优化方案
- **可验证**：验证优化效果
## 9. 安全审计
### 场景描述
安全是软件系统的重要考虑因素。Skills 可以自动进行安全审计，识别潜在的安全问题。
### 应用示例
#### Skill: 安全审计
```

markdown

#### Skill: 安全审计#

##### 功能#

审计代码安全性，识别潜在的安全漏洞

##### 输入#

- 代码目录
- 审计标准（OWASP, CWE 等）

##### 执行步骤#

True. 分析代码结构
True. 识别潜在的安全漏洞
True. 生成审计报告
True. 提供修复建议

##### 使用示例#

```
bash复制# 执行安全审计
claude --skill security-audit --dir src/ --standard owasp

# 审计特定漏洞类型
claude --skill security-audit --dir src/ --vulnerabilities sql-injection,xss,csrf

# 生成安全报告
claude --skill security-audit --dir src/ --output security-report.md
```

```
# 执行安全审计
claude --skill security-audit --dir src/ --standard owasp

# 审计特定漏洞类型
claude --skill security-audit --dir src/ --vulnerabilities sql-injection,xss,csrf

# 生成安全报告
claude --skill security-audit --dir src/ --output security-report.md
```

##### 审计内容#

##### 审计的安全问题#

###### 注入攻击

- SQL 注入
- NoSQL 注入
- 命令注入
- LDAP 注入

###### 跨站脚本（XSS）

- 反射型 XSS
- 存储型 XSS
- DOM 型 XSS

###### 认证与授权

- 弱密码
- 会话管理
- 权限提升
- 认证绕过

###### 数据保护

- 敏感数据泄露
- 加密不足
- 数据完整性
- 隐私保护

##### 优势#

- 全面：覆盖多种安全问题
- 标准化：遵循安全标准
- 可追溯：记录审计历史
- 可修复：提供修复建议

#### 10. 持续集成/部署#

##### 场景描述#

CI/CD 流程自动化可以显著提高开发效率。Skills 可以集成到 CI/CD 流程中，自动化各种任务。

##### 应用示例#

###### Skill: CI/CD 自动化

```
markdown复制## Skill: CI/CD 自动化

### 功能
自动化 CI/CD 流程中的各种任务

### 输入
- CI/CD 配置
- 任务类型

### 执行步骤
1. 分析 CI/CD 配置
2. 执行自动化任务
3. 生成执行报告
4. 通知结果
```

```
## Skill: CI/CD 自动化

### 功能
自动化 CI/CD 流程中的各种任务

### 输入
- CI/CD 配置
- 任务类型

### 执行步骤
1. 分析 CI/CD 配置
2. 执行自动化任务
3. 生成执行报告
4. 通知结果
```

##### 使用示例#

```
bash复制# 在 CI 流程中运行
claude --skill ci-pipeline --stage test --pr $PR_NUMBER

# 在 CD 流程中运行
claude --skill cd-pipeline --stage deploy --environment production

# 生成部署报告
claude --skill generate-deployment-report --commit $COMMIT_SHA
```

```
# 在 CI 流程中运行
claude --skill ci-pipeline --stage test --pr $PR_NUMBER

# 在 CD 流程中运行
claude --skill cd-pipeline --stage deploy --environment production

# 生成部署报告
claude --skill generate-deployment-report --commit $COMMIT_SHA
```

##### 集成方式#

```
yaml复制# .github/workflows/ci.yml
name: CI Pipeline
on: [pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Claude Code Skills
        run: |
          claude --skill code-review --pr ${{ github.event.number }}
          claude --skill run-tests --coverage 80
          claude --skill generate-docs
```

```
# .github/workflows/ci.yml
name: CI Pipeline
on: [pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Claude Code Skills
        run: |
          claude --skill code-review --pr ${{ github.event.number }}
          claude --skill run-tests --coverage 80
          claude --skill generate-docs
```

##### 优势#

- 自动化：减少手动操作
- 一致性：确保流程一致性
- 可扩展性：轻松添加新任务
- 可监控：实时监控流程状态
- 可回滚：支持失败回滚

---

# 第 15 章

## 1 Skills 执行机制

**URL**: https://claudecode.tangshuang.net/course/15.1%20Skills%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6

#### Skills 执行机制概述#

Skills 的执行机制是理解其工作原理的核心。本节将深入探讨 Skills 如何被调用、解析和执行，以及整个执行流程中的关键环节。

#### 执行流程概览#

Skills 的执行流程可以分为以下几个主要阶段：

```
graph复制A[用户请求] --> B[主代理接收]
B --> C{选择 Skill}
C --> D[加载 Skill 定义]
D --> E[解析参数和上下文]
E --> F[执行 Skill 逻辑]
F --> G[调用工具]
G --> H[处理结果]
H --> I[返回输出]
I --> J[主代理整合]
J --> K[呈现给用户]
```

```
A[用户请求] --> B[主代理接收]
B --> C{选择 Skill}
C --> D[加载 Skill 定义]
D --> E[解析参数和上下文]
E --> F[执行 Skill 逻辑]
F --> G[调用工具]
G --> H[处理结果]
H --> I[返回输出]
I --> J[主代理整合]
J --> K[呈现给用户]
```

#### 1. Skill 调用#

##### 调用方式#

###### 1.1 直接调用

用户直接指定要使用的 Skill：

```
bash复制# 命令行调用
claude --skill code-review --file src/main.py

# 交互式调用
/skill code-review
```

```
# 命令行调用
claude --skill code-review --file src/main.py

# 交互式调用
/skill code-review
```

###### 1.2 自动选择

主代理根据任务自动选择合适的 Skill：

```
markdown复制## 自动选择流程
### 用户请求
"帮我审查这段代码的质量"

### 主代理分析
1. 理解用户意图
2. 搜索相关 Skills
3. 匹配最合适的 Skill
4. 执行并返回结果
```

```
## 自动选择流程
### 用户请求
"帮我审查这段代码的质量"

### 主代理分析
1. 理解用户意图
2. 搜索相关 Skills
3. 匹配最合适的 Skill
4. 执行并返回结果
```

###### 1.3 嵌套调用

一个 Skill 调用另一个 Skill：

```
markdown复制## 嵌套调用示例

### Skill: 部署应用

#### 执行步骤
1. 调用代码审查 Skill
2. 调用测试运行 Skill
3. 调用部署 Skill
4. 生成部署报告
```

```
## 嵌套调用示例

### Skill: 部署应用

#### 执行步骤
1. 调用代码审查 Skill
2. 调用测试运行 Skill
3. 调用部署 Skill
4. 生成部署报告
```

##### 参数传递#

```
markdown复制## 参数传递方式

### 命令行参数
```bash
claude --skill code-gen --language python --framework flask
```

```
## 参数传递方式

### 命令行参数
```bash
claude --skill code-gen --language python --framework flask
```

##### 交互式输入#

```
markdown复制> 请提供以下信息：
> - 编程语言：Python
> - 框架：Flask
> - 功能描述：用户认证系统
```

```
> 请提供以下信息：
> - 编程语言：Python
> - 框架：Flask
> - 功能描述：用户认证系统
```

##### 配置文件#

```
yaml复制skills:
  code-gen:
    language: python
    framework: flask
```

```
skills:
  code-gen:
    language: python
    framework: flask
```

##### 上下文推断#

```
markdown复制## 从上下文推断
- 从文件扩展名推断语言
- 从项目配置推断框架
- 从代码风格推断风格偏好
- 从历史记录推断用户偏好
```

```
## 从上下文推断
- 从文件扩展名推断语言
- 从项目配置推断框架
- 从代码风格推断风格偏好
- 从历史记录推断用户偏好
```

#### 2. Skill 加载#

##### 加载过程#

###### 2.1 定位 Skill

```
markdown复制## Skill 定位流程

### 搜索顺序
1. 项目本地 Skills
2. 用户自定义 Skills
3. 系统内置 Skills
4. 插件提供的 Skills
```

```
## Skill 定位流程

### 搜索顺序
1. 项目本地 Skills
2. 用户自定义 Skills
3. 系统内置 Skills
4. 插件提供的 Skills
```

###### 2.2 读取定义

```
markdown复制## Skill 定义结构

### 元数据
```yaml
name: code-review
version: 1.2.0
description: 自动审查代码质量
author: Claude Code Team
```

```
## Skill 定义结构

### 元数据
```yaml
name: code-review
version: 1.2.0
description: 自动审查代码质量
author: Claude Code Team
```

##### 输入规范#

```
yaml复制inputs:
  file:
    type: string
    required: true
    description: 要审查的文件路径
  strict:
    type: boolean
    required: false
    default: false
    description: 是否严格模式
```

```
inputs:
  file:
    type: string
    required: true
    description: 要审查的文件路径
  strict:
    type: boolean
    required: false
    default: false
    description: 是否严格模式
```

##### 执行逻辑#

```
markdown复制## 执行步骤
1. 读取代码文件
2. 分析代码结构
3. 检查代码质量
4. 生成审查报告
```

```
## 执行步骤
1. 读取代码文件
2. 分析代码结构
3. 检查代码质量
4. 生成审查报告
```

###### 2.3 验证定义

```
markdown复制## 定义验证

### 验证项
- 必需字段是否存在
- 参数类型是否正确
- 默认值是否有效
- 引用是否存在
- 语法是否正确

### 验证失败处理
- 返回错误信息
- 提供修复建议
- 阻止 Skill 执行
```

```
## 定义验证

### 验证项
- 必需字段是否存在
- 参数类型是否正确
- 默认值是否有效
- 引用是否存在
- 语法是否正确

### 验证失败处理
- 返回错误信息
- 提供修复建议
- 阻止 Skill 执行
```

##### 缓存机制#

```
markdown复制## Skill 缓存

### 缓存内容
- Skill 定义
- 解析结果
- 依赖关系

### 缓存策略
- 内存缓存（会话级别）
- 磁盘缓存（持久化）
- 版本控制（基于 Skill 版本）

### 缓存失效
- Skill 定义更新
- 依赖变更
- 手动清除

## 3. 上下文解析

### 上下文类型

#### 3.1 项目上下文

## 3. 上下文管理

### 3.1 项目上下文

```markdown
## 项目上下文

### 包含信息
- 项目结构
- 文件列表
- 依赖关系
- 配置文件
- 技术栈

### 获取方式
- 读取项目配置
- 扫描文件系统
- 分析依赖文件
- 检测技术栈
```

```
## Skill 缓存

### 缓存内容
- Skill 定义
- 解析结果
- 依赖关系

### 缓存策略
- 内存缓存（会话级别）
- 磁盘缓存（持久化）
- 版本控制（基于 Skill 版本）

### 缓存失效
- Skill 定义更新
- 依赖变更
- 手动清除

## 3. 上下文解析

### 上下文类型

#### 3.1 项目上下文

## 3. 上下文管理

### 3.1 项目上下文

```markdown
## 项目上下文

### 包含信息
- 项目结构
- 文件列表
- 依赖关系
- 配置文件
- 技术栈

### 获取方式
- 读取项目配置
- 扫描文件系统
- 分析依赖文件
- 检测技术栈
```

###### 3.2 代码上下文

```
markdown复制## 代码上下文

### 包含信息
- 代码结构
- 函数定义
- 类定义
- 导入关系
- 调用关系

### 获取方式
- 解析源代码
- 构建抽象语法树
- 分析符号表
- 追踪依赖关系
```

```
## 代码上下文

### 包含信息
- 代码结构
- 函数定义
- 类定义
- 导入关系
- 调用关系

### 获取方式
- 解析源代码
- 构建抽象语法树
- 分析符号表
- 追踪依赖关系
```

###### 3.3 用户上下文

```
markdown复制## 用户上下文

### 包含信息
- 用户偏好
- 历史操作
- 常用命令
- 学习进度

### 获取方式
- 读取用户配置
- 查看历史记录
- 分析使用模式
- 记录用户反馈
```

```
## 用户上下文

### 包含信息
- 用户偏好
- 历史操作
- 常用命令
- 学习进度

### 获取方式
- 读取用户配置
- 查看历史记录
- 分析使用模式
- 记录用户反馈
```

##### 上下文收集#

```
markdown复制## 上下文收集策略

### 按需收集
- 只收集需要的上下文
- 避免不必要的开销
- 动态调整收集范围

### 增量收集
- 基于已有上下文
- 只收集变更部分
- 减少重复工作

### 并行收集
- 同时收集多个上下文
- 提高收集效率
- 合理分配资源
```

```
## 上下文收集策略

### 按需收集
- 只收集需要的上下文
- 避免不必要的开销
- 动态调整收集范围

### 增量收集
- 基于已有上下文
- 只收集变更部分
- 减少重复工作

### 并行收集
- 同时收集多个上下文
- 提高收集效率
- 合理分配资源
```

##### 上下文限制#

```
markdown复制## 上下文限制

### 大小限制
- 上下文窗口大小
- Token 限制
- 内存限制

### 处理策略
- 优先级排序
- 摘要压缩
- 分批处理
- 流式处理
```

```
## 上下文限制

### 大小限制
- 上下文窗口大小
- Token 限制
- 内存限制

### 处理策略
- 优先级排序
- 摘要压缩
- 分批处理
- 流式处理
```

#### 4. Skill 执行#

##### 执行模式#

###### 4.1 同步执行

```
markdown复制## 同步执行

### 特点
- 阻塞等待结果
- 适用于快速任务
- 简单的错误处理

### 示例
```python
result = execute_skill("code-review", file="src/main.py")
print(result)
```

```
## 同步执行

### 特点
- 阻塞等待结果
- 适用于快速任务
- 简单的错误处理

### 示例
```python
result = execute_skill("code-review", file="src/main.py")
print(result)
```

```
bash复制
#### 4.2 异步执行

```markdown
## 异步执行

### 特点
- 非阻塞执行
- 适用于耗时任务
- 复杂的错误处理

### 示例
```python
task = execute_skill_async("code-review", file="src/main.py")
# 继续其他工作
result = await task.get_result()
```

```
#### 4.2 异步执行

```markdown
## 异步执行

### 特点
- 非阻塞执行
- 适用于耗时任务
- 复杂的错误处理

### 示例
```python
task = execute_skill_async("code-review", file="src/main.py")
# 继续其他工作
result = await task.get_result()
```

```
bash复制
#### 4.3 流式执行

```markdown
## 流式执行

### 特点
- 实时返回结果
- 适用于大输出任务
- 更好的用户体验

### 示例
```python
for chunk in execute_skill_stream("code-review", file="src/main.py"):
    print(chunk, end='')
```

```
#### 4.3 流式执行

```markdown
## 流式执行

### 特点
- 实时返回结果
- 适用于大输出任务
- 更好的用户体验

### 示例
```python
for chunk in execute_skill_stream("code-review", file="src/main.py"):
    print(chunk, end='')
```

```
bash复制
### 执行步骤

#### 4.4 步骤分解

```markdown
## Skill: 代码审查

### 执行步骤
1. **准备阶段**
   - 验证输入参数
   - 加载代码文件
   - 初始化审查规则

2. **分析阶段**
   - 解析代码结构
   - 分析代码质量
   - 检查安全问题

3. **评估阶段**
   - 评估代码复杂度
   - 验证最佳实践
   - 计算质量分数

4. **生成阶段**
   - 生成问题列表
   - 提供改进建议
   - 创建审查报告

5. **验证阶段**
   - 验证报告完整性
   - 检查建议可行性
   - 确保输出格式正确
```

```
### 执行步骤

#### 4.4 步骤分解

```markdown
## Skill: 代码审查

### 执行步骤
1. **准备阶段**
   - 验证输入参数
   - 加载代码文件
   - 初始化审查规则

2. **分析阶段**
   - 解析代码结构
   - 分析代码质量
   - 检查安全问题

3. **评估阶段**
   - 评估代码复杂度
   - 验证最佳实践
   - 计算质量分数

4. **生成阶段**
   - 生成问题列表
   - 提供改进建议
   - 创建审查报告

5. **验证阶段**
   - 验证报告完整性
   - 检查建议可行性
   - 确保输出格式正确
```

##### 错误处理#

###### 4.5 错误类型

```
markdown复制## 错误类型

### 输入错误
- 参数缺失
> - 参数类型错误
> - 参数值无效

### 执行错误
> - 文件不存在
> - 权限不足
> - 资源不足

### 逻辑错误
> - 无法解析代码
> - 分析失败
> - 生成失败

#### 4.6 错误处理策略

~~~markdown
markdown

## 错误处理策略

### 立即失败
- 遇到错误立即停止
- 返回错误信息
- 不继续执行

### 跳过继续
- 记录错误
- 跳过当前步骤
- 继续执行

### 重试机制
- 自动重试
- 指数退避
- 最大重试次数

### 降级处理
- 使用备用方案
- 简化执行逻辑
- 返回部分结果

## 5. 工具调用

### 工具调用机制

#### 5.1 工具选择

```markdown

## 工具选择

### 选择依据
> - 任务需求
> - 可用工具
> - 工具能力
> - 性能考虑

### 选择策略
> - 最佳匹配
> - 优先级排序
> - 负载均衡
> - 缓存利用

#### 5.2 工具调用

~~~markdown
markdown

## 工具调用流程

### 调用准备
1. 准备工具参数
2. 验证参数有效性
3. 设置调用选项

### 执行调用
1. 发送调用请求
2. 等待工具响应
3. 处理响应数据

### 结果处理
1. 解析响应数据
2. 验证结果有效性
3. 传递给下一步

### 工具调用模式

#### 5.3 顺序调用

```markdown

## 顺序调用

### 示例
~~~python
```python

# 读取文件
content = read_file("src/main.py")

# 分析代码
analysis = analyze_code(content)

# 生成报告
report = generate_report(analysis)

### 特点
> - 简单直观
> - 易于理解
> - 适合线性流程
#### 5.4 条件调用
~~~
``markdown
`````markdown

## 条件调用

### 示例
~~~python
```python

# 检查文件是否存在
if file_exists("src/main.py"):
    # 如果存在，读取并分析
    content = read_file("src/main.py")
    analysis = analyze_code(content)
else:
    # 如果不存在，创建新文件
    create_file("src/main.py", template)

### 特点
> - 灵活性高
> - 适应性强
> - 处理分支逻辑
#### 5.5 循环调用

~~~
``markdown
`````markdown

## 循环调用

### 示例
~~~python
```python

# 获取所有 Python 文件
files = glob("**/*.py")

# 对每个文件执行分析
for file in files:
    content = read_file(file)
    analysis = analyze_code(content)
    save_analysis(file, analysis)

### 特点
> - 批量处理
> - 高效执行
> - 适合重复任务
#### 5.6 并行调用
~~~
``markdown
`````markdown

## 并行调用

### 示例
~~~python
```python

# 并行读取多个文件
tasks = [
    read_file_async("src/main.py"),
    read_file_async("src/utils.py"),
    read_file_async("src/api.py")
]

# 等待所有任务完成
results = await asyncio.gather(*tasks)

### 特点
> - 高性能
> - 节省时间
> - 适合独立任务
## 6. 结果处理
### 结果类型
#### 6.1 结构化结果

~~~
``markdown
`````markdown

## 结构化结果

### 示例
~~~json
```json

{
  "issues": [
    {
      "type": "security",
      "severity": "high",
      "message": "SQL injection vulnerability",
      "location": "src/main.py:42",
      "suggestion": "Use parameterized queries"
    }
  ],
  "summary": {
    "total_issues": 5,
    "critical": 1,
    "high": 2,
    "medium": 2
  }
}

### 特点
> - 易于解析
> - 结构清晰
> - 适合程序处理
#### 6.2 文本结果
~~~
``markdown
`````markdown

## 文本结果

### 示例

代码审查报告

发现的问题：

 - 使用参数化查询

 - 删除未使用的导入

总结：
> - 总问题数：5
> - 严重：1
> - 高：2
> - 中：2

~~~
### 特点
> - 易于阅读
> - 人类友好
> - 适合展示
#### 6.3 混合结果
~~~`markdown
`markdown

## 混合结果

### 示例
~~~markdown
```markdown

## 代码审查报告

### 结构化数据
~~~json
```json

{
  "total_issues": 5,
  "critical": 1
}

### 详细说明
发现 1 个严重问题和 4 个其他问题...

### 建议
建议优先修复严重问题...

### 特点
- 兼顾机器和人类
- 灵活性高
- 适合复杂场景
~~~
### 结果验证

#### 6.4 验证检查

~~~
markdown

## 结果验证

### 验证项
- 结果完整性
- 数据有效性
- 格式正确性
- 逻辑一致性

### 验证方法
- 模式匹配
- 类型检查
- 逻辑验证
- 交叉验证

#### 6.5 结果修正

~~~`markdown
````markdown

## 结果修正

### 修正策略
> - 自动修正
> - 提示用户
> - 记录问题
> - 重试执行

### 修正示例
~~~python
```python

# 自动修正格式问题
result = format_result(raw_result)

# 提示用户确认
if not confirm_result(result):
    result = retry_execution()

```## 7. 输出返回

### 输出格式

#### 7.1 控制台输出

## 控制台输出
### 特点
- 实时显示
- 交互友好
- 适合开发调试
### 示例
```

```
## 错误类型

### 输入错误
- 参数缺失
> - 参数类型错误
> - 参数值无效

### 执行错误
> - 文件不存在
> - 权限不足
> - 资源不足

### 逻辑错误
> - 无法解析代码
> - 分析失败
> - 生成失败

#### 4.6 错误处理策略

~~~markdown
markdown

## 错误处理策略

### 立即失败
- 遇到错误立即停止
- 返回错误信息
- 不继续执行

### 跳过继续
- 记录错误
- 跳过当前步骤
- 继续执行

### 重试机制
- 自动重试
- 指数退避
- 最大重试次数

### 降级处理
- 使用备用方案
- 简化执行逻辑
- 返回部分结果

## 5. 工具调用

### 工具调用机制

#### 5.1 工具选择

```markdown

## 工具选择

### 选择依据
> - 任务需求
> - 可用工具
> - 工具能力
> - 性能考虑

### 选择策略
> - 最佳匹配
> - 优先级排序
> - 负载均衡
> - 缓存利用

#### 5.2 工具调用

~~~markdown
markdown

## 工具调用流程

### 调用准备
1. 准备工具参数
2. 验证参数有效性
3. 设置调用选项

### 执行调用
1. 发送调用请求
2. 等待工具响应
3. 处理响应数据

### 结果处理
1. 解析响应数据
2. 验证结果有效性
3. 传递给下一步

### 工具调用模式

#### 5.3 顺序调用

```markdown

## 顺序调用

### 示例
~~~python
```python

# 读取文件
content = read_file("src/main.py")

# 分析代码
analysis = analyze_code(content)

# 生成报告
report = generate_report(analysis)

### 特点
> - 简单直观
> - 易于理解
> - 适合线性流程
#### 5.4 条件调用
~~~
``markdown
`````markdown

## 条件调用

### 示例
~~~python
```python

# 检查文件是否存在
if file_exists("src/main.py"):
    # 如果存在，读取并分析
    content = read_file("src/main.py")
    analysis = analyze_code(content)
else:
    # 如果不存在，创建新文件
    create_file("src/main.py", template)

### 特点
> - 灵活性高
> - 适应性强
> - 处理分支逻辑
#### 5.5 循环调用

~~~
``markdown
`````markdown

## 循环调用

### 示例
~~~python
```python

# 获取所有 Python 文件
files = glob("**/*.py")

# 对每个文件执行分析
for file in files:
    content = read_file(file)
    analysis = analyze_code(content)
    save_analysis(file, analysis)

### 特点
> - 批量处理
> - 高效执行
> - 适合重复任务
#### 5.6 并行调用
~~~
``markdown
`````markdown

## 并行调用

### 示例
~~~python
```python

# 并行读取多个文件
tasks = [
    read_file_async("src/main.py"),
    read_file_async("src/utils.py"),
    read_file_async("src/api.py")
]

# 等待所有任务完成
results = await asyncio.gather(*tasks)

### 特点
> - 高性能
> - 节省时间
> - 适合独立任务
## 6. 结果处理
### 结果类型
#### 6.1 结构化结果

~~~
``markdown
`````markdown

## 结构化结果

### 示例
~~~json
```json

{
  "issues": [
    {
      "type": "security",
      "severity": "high",
      "message": "SQL injection vulnerability",
      "location": "src/main.py:42",
      "suggestion": "Use parameterized queries"
    }
  ],
  "summary": {
    "total_issues": 5,
    "critical": 1,
    "high": 2,
    "medium": 2
  }
}

### 特点
> - 易于解析
> - 结构清晰
> - 适合程序处理
#### 6.2 文本结果
~~~
``markdown
`````markdown

## 文本结果

### 示例

代码审查报告

发现的问题：

 - 使用参数化查询

 - 删除未使用的导入

总结：
> - 总问题数：5
> - 严重：1
> - 高：2
> - 中：2

~~~
### 特点
> - 易于阅读
> - 人类友好
> - 适合展示
#### 6.3 混合结果
~~~`markdown
`markdown

## 混合结果

### 示例
~~~markdown
```markdown

## 代码审查报告

### 结构化数据
~~~json
```json

{
  "total_issues": 5,
  "critical": 1
}

### 详细说明
发现 1 个严重问题和 4 个其他问题...

### 建议
建议优先修复严重问题...

### 特点
- 兼顾机器和人类
- 灵活性高
- 适合复杂场景
~~~
### 结果验证

#### 6.4 验证检查

~~~
markdown

## 结果验证

### 验证项
- 结果完整性
- 数据有效性
- 格式正确性
- 逻辑一致性

### 验证方法
- 模式匹配
- 类型检查
- 逻辑验证
- 交叉验证

#### 6.5 结果修正

~~~`markdown
````markdown

## 结果修正

### 修正策略
> - 自动修正
> - 提示用户
> - 记录问题
> - 重试执行

### 修正示例
~~~python
```python

# 自动修正格式问题
result = format_result(raw_result)

# 提示用户确认
if not confirm_result(result):
    result = retry_execution()

```## 7. 输出返回

### 输出格式

#### 7.1 控制台输出

## 控制台输出
### 特点
- 实时显示
- 交互友好
- 适合开发调试
### 示例
```

正在执行代码审查...
✓ 分析代码结构
✓ 检查安全问题
✓ 评估代码质量

审查完成！发现 5 个问题。

```
bash复制
#### 7.2 文件输出

## 文件输出
### 特点
- 持久化存储
- 可追溯
- 适合报告归档
### 示例
~~~`bash
`bash

claude --skill code-review --file src/main.py --output report.md

```> >

~~~
#### 7.3 API 输出

## API 输出
### 特点
- 结构化数据
- 易于集成
- 适合自动化
### 示例
~~~`json
`json

{
"skill": "code-review",
"status": "success",
"result": {...}
}

```> > ~~~

### 输出优化

#### 7.4 性能优化

## 输出性能优化
### 优化策略
- 流式输出
- 增量更新
- 压缩输出
- 缓存结果
### 示例
~~~`python
`python

# 流式输出大结果
for chunk in stream_result(result):
yield chunk

```> >

~~~
#### 7.5 用户体验优化

## 用户体验优化
### 优化策略
- 进度显示
- 实时反馈
- 高亮显示
- 交互式输出
### 示例
~~~
``> > 正在执行代码审查... [████████░░] 80%
✓ 分析代码结构
✓ 检查安全问题
→ 评估代码质量...

~~~## 8. 执行监控

### 监控指标

#### 8.1 性能指标

## 性能指标
### 指标类型
- 执行时间
- 内存使用
- CPU 使用
- I/O 操作
### 监控方式
- 实时监控
- 定期采样
- 事件触发
- 阈值告警
```

```
#### 7.2 文件输出

## 文件输出
### 特点
- 持久化存储
- 可追溯
- 适合报告归档
### 示例
~~~`bash
`bash

claude --skill code-review --file src/main.py --output report.md

```> >

~~~
#### 7.3 API 输出

## API 输出
### 特点
- 结构化数据
- 易于集成
- 适合自动化
### 示例
~~~`json
`json

{
"skill": "code-review",
"status": "success",
"result": {...}
}

```> > ~~~

### 输出优化

#### 7.4 性能优化

## 输出性能优化
### 优化策略
- 流式输出
- 增量更新
- 压缩输出
- 缓存结果
### 示例
~~~`python
`python

# 流式输出大结果
for chunk in stream_result(result):
yield chunk

```> >

~~~
#### 7.5 用户体验优化

## 用户体验优化
### 优化策略
- 进度显示
- 实时反馈
- 高亮显示
- 交互式输出
### 示例
~~~
``> > 正在执行代码审查... [████████░░] 80%
✓ 分析代码结构
✓ 检查安全问题
→ 评估代码质量...

~~~## 8. 执行监控

### 监控指标

#### 8.1 性能指标

## 性能指标
### 指标类型
- 执行时间
- 内存使用
- CPU 使用
- I/O 操作
### 监控方式
- 实时监控
- 定期采样
- 事件触发
- 阈值告警
```

###### 8.2 质量指标

```
markdown复制```markdown

## 质量指标

### 指标类型
- 成功率
- 错误率
- 重试次数
- 用户满意度

### 监控方式
- 统计分析
- 趋势跟踪
- 异常检测
- 反馈收集

```### 日志记录

#### 8.3 日志级别

## 日志级别
### DEBUG
详细的调试信息
- 每个步骤的详细信息
- 中间结果
- 变量值
### INFO
一般信息
- 执行开始/结束
- 主要步骤
- 关键决策
### WARNING
警告信息
- 潜在问题
- 非最佳实践
- 性能警告
### ERROR
错误信息
- 错误详情
- 堆栈跟踪
- 恢复建议

```
#### 8.4 日志格式

~~~markdown
```markdown

## 日志格式

### 标准格式

```> [2024-01-15 10:30:45] [INFO] [skill:code-review] 开始执行代码审查
[2024-01-15 10:30:46] [DEBUG] [skill:code-review] 读取文件: src/main.py
[2024-01-15 10:30:47] [INFO] [skill:code-review] 分析完成，发现 5 个问题
### 结构化格式
~~~`json
`json

{
"timestamp": "2024-01-15T10:30:45Z",
"level": "INFO",
"skill": "code-review",
"message": "开始执行代码审查"
}

```> >
```

```
```markdown

## 质量指标

### 指标类型
- 成功率
- 错误率
- 重试次数
- 用户满意度

### 监控方式
- 统计分析
- 趋势跟踪
- 异常检测
- 反馈收集

```### 日志记录

#### 8.3 日志级别

## 日志级别
### DEBUG
详细的调试信息
- 每个步骤的详细信息
- 中间结果
- 变量值
### INFO
一般信息
- 执行开始/结束
- 主要步骤
- 关键决策
### WARNING
警告信息
- 潜在问题
- 非最佳实践
- 性能警告
### ERROR
错误信息
- 错误详情
- 堆栈跟踪
- 恢复建议

```
#### 8.4 日志格式

~~~markdown
```markdown

## 日志格式

### 标准格式

```> [2024-01-15 10:30:45] [INFO] [skill:code-review] 开始执行代码审查
[2024-01-15 10:30:46] [DEBUG] [skill:code-review] 读取文件: src/main.py
[2024-01-15 10:30:47] [INFO] [skill:code-review] 分析完成，发现 5 个问题
### 结构化格式
~~~`json
`json

{
"timestamp": "2024-01-15T10:30:45Z",
"level": "INFO",
"skill": "code-review",
"message": "开始执行代码审查"
}

```> >
```

#### 总结#

Skills 的执行机制是一个复杂而精密的系统，涉及多个环节和组件。理解这些机制有助于：

True. 优化性能：识别和优化性能瓶颈
True. 提高可靠性：增强错误处理和恢复能力
True. 改善体验：提供更好的用户交互体验
True. 扩展功能：基于执行机制开发新功能

在下一节中，我们将探讨 Skills 的上下文管理机制，了解如何高效地管理和利用上下文信息。

---

## 2 Skills 上下文管理

**URL**: https://claudecode.tangshuang.net/course/15.2%20Skills%20%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86

#### 上下文管理概述#

上下文管理是 Skills 能够理解项目、代码和用户需求的关键机制。本节将深入探讨 Skills 如何收集、存储、检索和利用上下文信息。

#### 上下文类型#

##### 1. 项目上下文#

###### 1.1 项目结构

#### 项目结构上下文#

##### 包含信息#

- 目录层次结构
- 文件组织方式
- 模块划分
- 资源位置

##### 收集方式#

- 扫描文件系统
- 解析目录结构
- 识别关键目录
- 构建结构树

##### 示例#

```
bash复制├── src/
│   ├── main.py
│   ├── utils/
│   │   ├── helpers.py
│   │   └── validators.py
│   └── api/
│       ├── routes.py
│       └── models.py
├── tests/
│   ├── test_main.py
│   └── test_utils.py
├── docs/
│   └── api.md
├── config/
│   ├── settings.py
│   └── logging.yaml
├── requirements.txt
├── setup.py
└── README.md
~~~#### 1.2 技术栈

## 技术栈上下文
### 包含信息
- 编程语言
- 框架和库
- 构建工具
- 测试框架
- 部署平台
### 收集方式
- 解析依赖文件
- 检测配置文件
- 分析导入语句
- 识别工具链
### 示例
~~~`yaml
`yaml

technology_stack:
language: Python
version: "3.9"
frameworks:
 - Flask 2.3.0
 - SQLAlchemy 2.0.0
libraries:
 - requests 2.28.0
 - numpy 1.24.0
build_tools:
 - setuptools
 - wheel
test_frameworks:
 - pytest 7.3.0
 - pytest-cov
deployment:
 - Docker
 - Kubernetes

#### 1.3 配置信息

## 配置上下文
### 包含信息
- 应用配置
- 环境变量
- 构建配置
- 部署配置
### 收集方式
- 读取配置文件
- 解析环境变量
- 分析设置文件
- 检测 CI/CD 配置
### 示例
~~~`python
`python

# config/settings.py
class Config:
DEBUG = False
TESTING = False
DATABASE_URI = os.getenv('DATABASE_URI')
SECRET_KEY = os.getenv('SECRET_KEY')
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')

class DevelopmentConfig(Config):
DEBUG = True

class ProductionConfig(Config):
DEBUG = False

### 2. 代码上下文
```

```
├── src/
│   ├── main.py
│   ├── utils/
│   │   ├── helpers.py
│   │   └── validators.py
│   └── api/
│       ├── routes.py
│       └── models.py
├── tests/
│   ├── test_main.py
│   └── test_utils.py
├── docs/
│   └── api.md
├── config/
│   ├── settings.py
│   └── logging.yaml
├── requirements.txt
├── setup.py
└── README.md
~~~#### 1.2 技术栈

## 技术栈上下文
### 包含信息
- 编程语言
- 框架和库
- 构建工具
- 测试框架
- 部署平台
### 收集方式
- 解析依赖文件
- 检测配置文件
- 分析导入语句
- 识别工具链
### 示例
~~~`yaml
`yaml

technology_stack:
language: Python
version: "3.9"
frameworks:
 - Flask 2.3.0
 - SQLAlchemy 2.0.0
libraries:
 - requests 2.28.0
 - numpy 1.24.0
build_tools:
 - setuptools
 - wheel
test_frameworks:
 - pytest 7.3.0
 - pytest-cov
deployment:
 - Docker
 - Kubernetes

#### 1.3 配置信息

## 配置上下文
### 包含信息
- 应用配置
- 环境变量
- 构建配置
- 部署配置
### 收集方式
- 读取配置文件
- 解析环境变量
- 分析设置文件
- 检测 CI/CD 配置
### 示例
~~~`python
`python

# config/settings.py
class Config:
DEBUG = False
TESTING = False
DATABASE_URI = os.getenv('DATABASE_URI')
SECRET_KEY = os.getenv('SECRET_KEY')
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')

class DevelopmentConfig(Config):
DEBUG = True

class ProductionConfig(Config):
DEBUG = False

### 2. 代码上下文
```

###### 2.1 代码结构

#### 代码结构上下文#

##### 包含信息#

- 模块组织
- 类层次结构
- 函数定义
- 变量作用域

##### 收集方式#

- 解析源代码
- 构建抽象语法树（AST）
- 分析符号表
- 追踪依赖关系

##### 示例#

```
bash复制src/
├── main.py
│   ├── class Application
│   │   ├── method __init__
│   │   ├── method run
│   │   └── method shutdown
│   └── function main
├── utils/
│   ├── helpers.py
│   │   ├── function format_date
│   │   └── function validate_email
│   └── validators.py
│       └── class Validator
│           ├── method validate
│           └── method sanitize

```> > ~~~

#### 2.2 代码依赖

## 代码依赖上下文
### 包含信息
- 导入关系
- 函数调用
- 类继承
- 模块引用
### 收集方式
- 分析 import 语句
- 追踪函数调用
- 解析类定义
- 构建依赖图
### 示例
~~~`python
`python

# 依赖图
main.py
├─> utils/helpers.py
│   ├─> datetime (标准库)
│   └─> utils/validators.py
│       └─> re (标准库)
├─> api/routes.py
│   ├─> flask (外部库)
│   └─> api/models.py
└─> config/settings.py
└─> os (标准库)

```> >

~~~
#### 2.3 代码模式

## 代码模式上下文
### 包含信息
- 设计模式
- 编码风格
- 命名约定
- 代码规范
### 收集方式
- 模式识别算法
- 风格分析
- 命名分析
- 规则检查
### 示例
~~~`yaml
`yaml

code_patterns:
design_patterns:
 - singleton: Application
 - factory: create_validator
 - strategy: validate_input

coding_style:
naming_convention: snake_case
max_line_length: 88
docstring_style: Google

conventions:
 - use_type_hints: true
 - include_docstrings: true
 - follow_pep8: true

```> > ~~~

### 3. 用户上下文

#### 3.1 用户偏好

## 用户偏好上下文
### 包含信息
- 编码风格偏好
- 工具使用偏好
- 输出格式偏好
- 交互方式偏好
### 收集方式
- 读取用户配置
- 分析历史操作
- 收集用户反馈
- 学习使用模式
### 示例
~~~`yaml
`yaml

user_preferences:
coding_style:
language: Python
style_guide: PEP8
formatter: black
linter: pylint

output_preferences:
format: markdown
verbosity: normal
include_code_blocks: true

interaction_preferences:
auto_confirm: false
show_progress: true
color_output: true

```> >

~~~
#### 3.2 历史记录

## 历史记录上下文
### 包含信息
- 执行过的命令
- 使用过的 Skills
- 修改过的文件
- 生成的内容
### 收集方式
- 记录操作日志
- 追踪文件变更
- 统计使用频率
- 分析操作模式
### 示例
~~~`json
`json

{
"history": [
{
"timestamp": "2024-01-15T10:30:00Z",
"command": "claude --skill code-review --file src/main.py",
"skill": "code-review",
"files": ["src/main.py"],
"result": "success"
},
{
"timestamp": "2024-01-15T10:35:00Z",
"command": "claude --skill generate-tests --file src/utils.py",
"skill": "generate-tests",
"files": ["src/utils.py", "tests/test_utils.py"],
"result": "success"
}
]
}

```#### 3.3 学习进度

~~~
markdown

## 学习进度上下文

### 包含信息
- 掌握的 Skills
- 常用的功能
- 遇到的问题
- 改进建议

### 收集方式
- 跟踪使用情况
- 分析错误模式
- 收集反馈
- 评估熟练度

### 示例
learning_progress:
mastered_skills:
 - code-review: 85%
 - generate-tests: 70%
 - refactor: 60%

frequently_used:
 - code-review: 45
 - generate-tests: 30
 - format-code: 25

common_issues:
 - type: parameter_validation
frequency: 10
suggestion: "使用 --help 查看参数说明"

improvement_suggestions:
 - "尝试使用更多高级功能"
 - "学习自定义 Skill 开发"

`> >

~~~
### 4. 会话上下文

#### 4.1 对话历史

~~~
markdown

## 对话历史上下文

### 包含信息
- 用户请求
- 系统响应
- 执行的操作
- 中间结果

### 收集方式
- 记录对话
- 追踪操作
- 保存结果
- 维护状态

### 示例
{
"conversation": [
{
"role": "user",
"message": "帮我审查 src/main.py 的代码质量",
"timestamp": "2024-01-15T10:30:00Z"
},
{
"role": "assistant",
"message": "正在执行代码审查...",
"action": "execute_skill",
"skill": "code-review",
"timestamp": "2024-01-15T10:30:01Z"
},
{
"role": "assistant",
"message": "审查完成！发现 5 个问题。",
"result": {...},
"timestamp": "2024-01-15T10:30:15Z"
}
]
}

`> >
#### 4.2 执行状态
~~~markdown
markdown

## 执行状态上下文

### 包含信息
- 当前任务
- 执行进度
- 中间结果
- 错误信息

### 收集方式
- 跟踪执行
- 记录进度
- 保存状态
- 捕获错误

### 示例
~~~yaml
```yaml

execution_state:
  current_task:
    skill: code-review
    step: 3/5
    status: in_progress

  progress:
    completed_steps:
      - analyze_structure
      - check_security
    current_step: evaluate_quality
    remaining_steps:
      - generate_report
      - save_results

  intermediate_results:
    issues_found: 3
    security_issues: 1
    quality_score: 75

  errors: []

#### 4.3 资源状态

```markdown

## 资源状态上下文

### 包含信息
> - 打开的文件
> - 使用的工具
> - 占用的资源
> - 网络连接

### 收集方式
> - 监控资源
> - 追踪连接
> - 统计使用
> - 检测泄漏

### 示例
~~~yaml
```yaml

resource_state:
  open_files:
    - src/main.py
    - src/utils.py
    - tests/test_main.py

  active_tools:
    - read_file
    - search_codebase
    - run_command

  resource_usage:
    memory: "256MB"
    cpu: "15%"
    disk_io: "10MB/s"

  network_connections:
    - type: mcp
      server: github
      status: connected

## 上下文收集

### 收集策略

#### 1. 按需收集

## 按需收集策略
### 原则
- 只收集需要的上下文
- 避免不必要的开销
- 动态调整收集范围
### 实现方式
- 分析 Skill 需求
- 识别必需的上下文
- 延迟加载非关键上下文
- 按需扩展收集范围
### 示例
~~~`python
`python

def collect_context(skill_name, parameters):
 # 分析 Skill 需求
requirements = analyze_skill_requirements(skill_name)

 # 收集必需的上下文
context = {}
for req in requirements.required:
context[req] = collect_required_context(req)

 # 延迟加载可选上下文
for req in requirements.optional:
if should_collect(req, parameters):
context[req] = collect_optional_context(req)

return context

```> >

~~~
#### 2. 增量收集

## 增量收集策略
### 原则
- 基于已有上下文
- 只收集变更部分
- 减少重复工作
### 实现方式
- 维护上下文快照
- 检测变更
- 只更新变更部分
- 复用未变更部分
### 示例
~~~`python
`python

def incremental_collect(previous_context, changes):
new_context = previous_context.copy()

for change in changes:
if change.type == "file_modified":
 # 只更新变更的文件
new_context["code"][change.file] = analyze_file(change.file)
elif change.type == "file_added":
 # 添加新文件
new_context["code"][change.file] = analyze_file(change.file)
elif change.type == "file_deleted":
 # 删除文件
del new_context["code"][change.file]

return new_context

```> > ~~~

#### 3. 并行收集

## 并行收集策略
### 原则
- 同时收集多个上下文
- 提高收集效率
- 合理分配资源
### 实现方式
- 识别独立任务
- 并行执行
- 合并结果
- 处理依赖关系
### 示例
~~~`python
`python

async def parallel_collect(context_types):
tasks = []

 # 创建并行任务
for ctx_type in context_types:
if is_independent(ctx_type):
task = asyncio.create_task(collect_context(ctx_type))
tasks.append(task)

 # 等待所有任务完成
results = await asyncio.gather(*tasks)

 # 合并结果
context = merge_results(results)
return context

```> >

~~~
### 收集优化

#### 1. 缓存机制

## 缓存机制
### 缓存策略
- 内存缓存（快速访问）
- 磁盘缓存（持久化）
- 分布式缓存（多节点）
### 缓存键
- 上下文类型
- 文件路径
- 时间戳
- 版本号
### 缓存失效
- 文件变更
- 配置更新
- 时间过期
- 手动清除
### 示例
~~~`python
`python

class ContextCache:
def __init__(self):
self.memory_cache = {}
self.disk_cache = DiskCache()

def get(self, key):
 # 先查内存缓存
if key in self.memory_cache:
return self.memory_cache[key]

 # 再查磁盘缓存
value = self.disk_cache.get(key)
if value:
self.memory_cache[key] = value
return value

return None

def set(self, key, value, ttl=3600):
 # 设置内存缓存
self.memory_cache[key] = value

 # 设置磁盘缓存
self.disk_cache.set(key, value, ttl)

```> > ~~~

#### 2. 智能过滤

## 智能过滤
### 过滤策略
- 相关性分析
- 重要性评分
- 优先级排序
- 数量限制
### 过滤维度
- 文件类型
- 代码复杂度
- 修改频率
- 使用频率
### 示例
~~~`python
`python

def filter_context(context, requirements):
filtered = {}

 # 按相关性过滤
for item in context.items():
relevance = calculate_relevance(item, requirements)
if relevance > threshold:
filtered[item.key] = item.value

 # 按重要性排序
sorted_items = sort_by_importance(filtered)

 # 限制数量
limited = limit_items(sorted_items, max_items)

return limited

```> >

~~~
#### 3. 压缩技术

## 压缩技术
### 压缩策略
- 摘要压缩
- 去重压缩
- 结构压缩
- 算法压缩
### 压缩方法
- 提取关键信息
- 移除冗余数据
- 简化结构
- 使用压缩算法
### 示例
~~~`python
`python

def compress_context(context):
compressed = {}

for key, value in context.items():
 # 摘要压缩
if is_large(value):
compressed[key] = summarize(value)
 # 去重压缩
elif has_duplicates(value):
compressed[key] = deduplicate(value)
 # 结构压缩
else:
compressed[key] = simplify_structure(value)

return compressed

```## 上下文存储

### 存储结构

#### 1. 层次结构

~~~
markdown

## 层次存储结构

### 存储层次

### 存储策略
- 热数据存内存
- 温数据存磁盘
- 冷数据存远程

### 示例
Context Storage
├── Memory Layer
│   ├── Current Session
│   ├── Active Skills
│   └── Frequently Used
├── Disk Layer
│   ├── Project Context
│   ├── User Preferences
│   └── Historical Data
└── Remote Layer
│   ├── Backup Data
│   ├── Shared Context
│   └── Archive Data

`````> >

~~~
#### 2. 索引结构

~~~markdown
markdown

## 索引结构

### 索引类型
- 文件索引
- 符号索引
- 依赖索引
- 时间索引

### 索引优化
- B+ 树索引
- 哈希索引
- 全文索引
- 倒排索引

### 示例
class ContextIndex:
def __init__(self):
self.file_index = BPlusTree()
self.symbol_index = HashIndex()
self.dependency_index = GraphIndex()
self.time_index = TimeSeriesIndex()

def add(self, context_item):
 # 添加到多个索引
self.file_index.add(context_item.path, context_item)
self.symbol_index.add(context_item.symbols, context_item)
self.dependency_index.add(context_item.dependencies, context_item)
self.time_index.add(context_item.timestamp, context_item)

def query(self, query):
 # 组合查询
results = []
if query.path:
results.extend(self.file_index.query(query.path))
if query.symbols:
results.extend(self.symbol_index.query(query.symbols))
return deduplicate(results)

`````> > ~~~

### 存储优化

#### 1. 增量更新

~~~markdown
markdown

## 增量更新

### 更新策略
- 检测变更
- 只更新变更部分
- 维护版本历史
- 支持回滚

### 实现方式
- 文件监控
- 变更检测
- 差异计算
- 增量应用

### 示例
def incremental_update(context, changes):
for change in changes:
if change.type == "modified":
 # 计算差异
diff = calculate_diff(context[change.file], change.new_content)
 # 应用差异
context[change.file] = apply_diff(context[change.file], diff)
elif change.type == "added":
 # 添加新文件
context[change.file] = change.new_content
elif change.type == "deleted":
 # 删除文件
del context[change.file]

return context

`````> >

~~~
#### 2. 版本控制

~~~markdown
markdown

## 版本控制

### 版本策略
- 时间戳版本
- 增量版本
- 标签版本
- 分支版本

### 版本操作
- 创建版本
- 切换版本
- 比较版本
- 合并版本

### 示例
class ContextVersionManager:
def __init__(self):
self.versions = {}
self.current_version = None

def create_version(self, label=None):
version = {
"id": generate_id(),
"timestamp": datetime.now(),
"label": label,
"context": copy.deepcopy(self.current_context)
}
self.versions[version["id"]] = version
self.current_version = version["id"]
return version["id"]

def switch_version(self, version_id):
if version_id in self.versions:
self.current_version = version_id
self.current_context = copy.deepcopy(self.versions[version_id]["context"])
return True
return False

`````> > ~~~

## 上下文检索

### 检索策略

#### 1. 精确检索

~~~markdown
markdown

## 精确检索

### 检索方式
- 按键检索
- 按路径检索
- 按符号检索
- 按时间检索

### 示例
def exact_retrieve(context, query):
if query.type == "key":
return context.get(query.key)
elif query.type == "path":
return context.get_file(query.path)
elif query.type == "symbol":
return context.get_symbol(query.symbol)
elif query.type == "time":
return context.get_by_time(query.time_range)

`````> >

~~~
#### 2. 模糊检索

~~~markdown
markdown

## 模糊检索

### 检索方式
- 模糊匹配
- 相似度检索
- 语义检索
- 关联检索

### 示例
def fuzzy_retrieve(context, query):
results = []

for item in context.items():
 # 计算相似度
similarity = calculate_similarity(item, query)
if similarity > threshold:
results.append((item, similarity))

 # 按相似度排序
results.sort(key=lambda x: x[1], reverse=True)

return [item for item, _ in results]

#### 3. 组合检索
~~~
markdown

## 组合检索

### 检索方式
- 多条件组合
- 逻辑运算
- 权重组合
- 分级检索

### 示例
~~~python
```python

def combined_retrieve(context, query):
    results = []

    # 执行多个检索
    for condition in query.conditions:
        partial_results = retrieve(context, condition)
        results.extend(partial_results)

    # 应用逻辑运算
    if query.operator == "AND":
        results = intersect(results)
    elif query.operator == "OR":
        results = union(results)

    # 应用权重
    weighted_results = apply_weights(results, query.weights)

    return weighted_results

### 检索优化

#### 1. 预计算

~~~`markdown
````markdown

## 预计算

### 预计算内容
> - 统计信息
> - 关联关系
> - 索引数据
> - 聚合结果

### 预计算时机
> - 上下文更新时
> - 定期批处理
> - 按需触发

### 示例
~~~python
```python

def precompute_context(context):
    # 计算统计信息
    stats = calculate_statistics(context)
    context.statistics = stats

    # 计算关联关系
    relations = calculate_relations(context)
    context.relations = relations

    # 构建索引
    index = build_index(context)
    context.index = index

```> >
#### 2. 查询优化
~~~`markdown
`markdown

## 查询优化

### 优化策略
> - 查询重写
> - 执行计划优化
> - 索引选择
> - 结果缓存

### 示例
~~~python
```python

def optimize_query(query, context):
    # 查询重写
    optimized = rewrite_query(query)

    # 选择最佳索引
    best_index = select_best_index(optimized, context.indexes)

    # 生成执行计划
    plan = generate_execution_plan(optimized, best_index)

    return plan
```

```
src/
├── main.py
│   ├── class Application
│   │   ├── method __init__
│   │   ├── method run
│   │   └── method shutdown
│   └── function main
├── utils/
│   ├── helpers.py
│   │   ├── function format_date
│   │   └── function validate_email
│   └── validators.py
│       └── class Validator
│           ├── method validate
│           └── method sanitize

```> > ~~~

#### 2.2 代码依赖

## 代码依赖上下文
### 包含信息
- 导入关系
- 函数调用
- 类继承
- 模块引用
### 收集方式
- 分析 import 语句
- 追踪函数调用
- 解析类定义
- 构建依赖图
### 示例
~~~`python
`python

# 依赖图
main.py
├─> utils/helpers.py
│   ├─> datetime (标准库)
│   └─> utils/validators.py
│       └─> re (标准库)
├─> api/routes.py
│   ├─> flask (外部库)
│   └─> api/models.py
└─> config/settings.py
└─> os (标准库)

```> >

~~~
#### 2.3 代码模式

## 代码模式上下文
### 包含信息
- 设计模式
- 编码风格
- 命名约定
- 代码规范
### 收集方式
- 模式识别算法
- 风格分析
- 命名分析
- 规则检查
### 示例
~~~`yaml
`yaml

code_patterns:
design_patterns:
 - singleton: Application
 - factory: create_validator
 - strategy: validate_input

coding_style:
naming_convention: snake_case
max_line_length: 88
docstring_style: Google

conventions:
 - use_type_hints: true
 - include_docstrings: true
 - follow_pep8: true

```> > ~~~

### 3. 用户上下文

#### 3.1 用户偏好

## 用户偏好上下文
### 包含信息
- 编码风格偏好
- 工具使用偏好
- 输出格式偏好
- 交互方式偏好
### 收集方式
- 读取用户配置
- 分析历史操作
- 收集用户反馈
- 学习使用模式
### 示例
~~~`yaml
`yaml

user_preferences:
coding_style:
language: Python
style_guide: PEP8
formatter: black
linter: pylint

output_preferences:
format: markdown
verbosity: normal
include_code_blocks: true

interaction_preferences:
auto_confirm: false
show_progress: true
color_output: true

```> >

~~~
#### 3.2 历史记录

## 历史记录上下文
### 包含信息
- 执行过的命令
- 使用过的 Skills
- 修改过的文件
- 生成的内容
### 收集方式
- 记录操作日志
- 追踪文件变更
- 统计使用频率
- 分析操作模式
### 示例
~~~`json
`json

{
"history": [
{
"timestamp": "2024-01-15T10:30:00Z",
"command": "claude --skill code-review --file src/main.py",
"skill": "code-review",
"files": ["src/main.py"],
"result": "success"
},
{
"timestamp": "2024-01-15T10:35:00Z",
"command": "claude --skill generate-tests --file src/utils.py",
"skill": "generate-tests",
"files": ["src/utils.py", "tests/test_utils.py"],
"result": "success"
}
]
}

```#### 3.3 学习进度

~~~
markdown

## 学习进度上下文

### 包含信息
- 掌握的 Skills
- 常用的功能
- 遇到的问题
- 改进建议

### 收集方式
- 跟踪使用情况
- 分析错误模式
- 收集反馈
- 评估熟练度

### 示例
learning_progress:
mastered_skills:
 - code-review: 85%
 - generate-tests: 70%
 - refactor: 60%

frequently_used:
 - code-review: 45
 - generate-tests: 30
 - format-code: 25

common_issues:
 - type: parameter_validation
frequency: 10
suggestion: "使用 --help 查看参数说明"

improvement_suggestions:
 - "尝试使用更多高级功能"
 - "学习自定义 Skill 开发"

`> >

~~~
### 4. 会话上下文

#### 4.1 对话历史

~~~
markdown

## 对话历史上下文

### 包含信息
- 用户请求
- 系统响应
- 执行的操作
- 中间结果

### 收集方式
- 记录对话
- 追踪操作
- 保存结果
- 维护状态

### 示例
{
"conversation": [
{
"role": "user",
"message": "帮我审查 src/main.py 的代码质量",
"timestamp": "2024-01-15T10:30:00Z"
},
{
"role": "assistant",
"message": "正在执行代码审查...",
"action": "execute_skill",
"skill": "code-review",
"timestamp": "2024-01-15T10:30:01Z"
},
{
"role": "assistant",
"message": "审查完成！发现 5 个问题。",
"result": {...},
"timestamp": "2024-01-15T10:30:15Z"
}
]
}

`> >
#### 4.2 执行状态
~~~markdown
markdown

## 执行状态上下文

### 包含信息
- 当前任务
- 执行进度
- 中间结果
- 错误信息

### 收集方式
- 跟踪执行
- 记录进度
- 保存状态
- 捕获错误

### 示例
~~~yaml
```yaml

execution_state:
  current_task:
    skill: code-review
    step: 3/5
    status: in_progress

  progress:
    completed_steps:
      - analyze_structure
      - check_security
    current_step: evaluate_quality
    remaining_steps:
      - generate_report
      - save_results

  intermediate_results:
    issues_found: 3
    security_issues: 1
    quality_score: 75

  errors: []

#### 4.3 资源状态

```markdown

## 资源状态上下文

### 包含信息
> - 打开的文件
> - 使用的工具
> - 占用的资源
> - 网络连接

### 收集方式
> - 监控资源
> - 追踪连接
> - 统计使用
> - 检测泄漏

### 示例
~~~yaml
```yaml

resource_state:
  open_files:
    - src/main.py
    - src/utils.py
    - tests/test_main.py

  active_tools:
    - read_file
    - search_codebase
    - run_command

  resource_usage:
    memory: "256MB"
    cpu: "15%"
    disk_io: "10MB/s"

  network_connections:
    - type: mcp
      server: github
      status: connected

## 上下文收集

### 收集策略

#### 1. 按需收集

## 按需收集策略
### 原则
- 只收集需要的上下文
- 避免不必要的开销
- 动态调整收集范围
### 实现方式
- 分析 Skill 需求
- 识别必需的上下文
- 延迟加载非关键上下文
- 按需扩展收集范围
### 示例
~~~`python
`python

def collect_context(skill_name, parameters):
 # 分析 Skill 需求
requirements = analyze_skill_requirements(skill_name)

 # 收集必需的上下文
context = {}
for req in requirements.required:
context[req] = collect_required_context(req)

 # 延迟加载可选上下文
for req in requirements.optional:
if should_collect(req, parameters):
context[req] = collect_optional_context(req)

return context

```> >

~~~
#### 2. 增量收集

## 增量收集策略
### 原则
- 基于已有上下文
- 只收集变更部分
- 减少重复工作
### 实现方式
- 维护上下文快照
- 检测变更
- 只更新变更部分
- 复用未变更部分
### 示例
~~~`python
`python

def incremental_collect(previous_context, changes):
new_context = previous_context.copy()

for change in changes:
if change.type == "file_modified":
 # 只更新变更的文件
new_context["code"][change.file] = analyze_file(change.file)
elif change.type == "file_added":
 # 添加新文件
new_context["code"][change.file] = analyze_file(change.file)
elif change.type == "file_deleted":
 # 删除文件
del new_context["code"][change.file]

return new_context

```> > ~~~

#### 3. 并行收集

## 并行收集策略
### 原则
- 同时收集多个上下文
- 提高收集效率
- 合理分配资源
### 实现方式
- 识别独立任务
- 并行执行
- 合并结果
- 处理依赖关系
### 示例
~~~`python
`python

async def parallel_collect(context_types):
tasks = []

 # 创建并行任务
for ctx_type in context_types:
if is_independent(ctx_type):
task = asyncio.create_task(collect_context(ctx_type))
tasks.append(task)

 # 等待所有任务完成
results = await asyncio.gather(*tasks)

 # 合并结果
context = merge_results(results)
return context

```> >

~~~
### 收集优化

#### 1. 缓存机制

## 缓存机制
### 缓存策略
- 内存缓存（快速访问）
- 磁盘缓存（持久化）
- 分布式缓存（多节点）
### 缓存键
- 上下文类型
- 文件路径
- 时间戳
- 版本号
### 缓存失效
- 文件变更
- 配置更新
- 时间过期
- 手动清除
### 示例
~~~`python
`python

class ContextCache:
def __init__(self):
self.memory_cache = {}
self.disk_cache = DiskCache()

def get(self, key):
 # 先查内存缓存
if key in self.memory_cache:
return self.memory_cache[key]

 # 再查磁盘缓存
value = self.disk_cache.get(key)
if value:
self.memory_cache[key] = value
return value

return None

def set(self, key, value, ttl=3600):
 # 设置内存缓存
self.memory_cache[key] = value

 # 设置磁盘缓存
self.disk_cache.set(key, value, ttl)

```> > ~~~

#### 2. 智能过滤

## 智能过滤
### 过滤策略
- 相关性分析
- 重要性评分
- 优先级排序
- 数量限制
### 过滤维度
- 文件类型
- 代码复杂度
- 修改频率
- 使用频率
### 示例
~~~`python
`python

def filter_context(context, requirements):
filtered = {}

 # 按相关性过滤
for item in context.items():
relevance = calculate_relevance(item, requirements)
if relevance > threshold:
filtered[item.key] = item.value

 # 按重要性排序
sorted_items = sort_by_importance(filtered)

 # 限制数量
limited = limit_items(sorted_items, max_items)

return limited

```> >

~~~
#### 3. 压缩技术

## 压缩技术
### 压缩策略
- 摘要压缩
- 去重压缩
- 结构压缩
- 算法压缩
### 压缩方法
- 提取关键信息
- 移除冗余数据
- 简化结构
- 使用压缩算法
### 示例
~~~`python
`python

def compress_context(context):
compressed = {}

for key, value in context.items():
 # 摘要压缩
if is_large(value):
compressed[key] = summarize(value)
 # 去重压缩
elif has_duplicates(value):
compressed[key] = deduplicate(value)
 # 结构压缩
else:
compressed[key] = simplify_structure(value)

return compressed

```## 上下文存储

### 存储结构

#### 1. 层次结构

~~~
markdown

## 层次存储结构

### 存储层次

### 存储策略
- 热数据存内存
- 温数据存磁盘
- 冷数据存远程

### 示例
Context Storage
├── Memory Layer
│   ├── Current Session
│   ├── Active Skills
│   └── Frequently Used
├── Disk Layer
│   ├── Project Context
│   ├── User Preferences
│   └── Historical Data
└── Remote Layer
│   ├── Backup Data
│   ├── Shared Context
│   └── Archive Data

`````> >

~~~
#### 2. 索引结构

~~~markdown
markdown

## 索引结构

### 索引类型
- 文件索引
- 符号索引
- 依赖索引
- 时间索引

### 索引优化
- B+ 树索引
- 哈希索引
- 全文索引
- 倒排索引

### 示例
class ContextIndex:
def __init__(self):
self.file_index = BPlusTree()
self.symbol_index = HashIndex()
self.dependency_index = GraphIndex()
self.time_index = TimeSeriesIndex()

def add(self, context_item):
 # 添加到多个索引
self.file_index.add(context_item.path, context_item)
self.symbol_index.add(context_item.symbols, context_item)
self.dependency_index.add(context_item.dependencies, context_item)
self.time_index.add(context_item.timestamp, context_item)

def query(self, query):
 # 组合查询
results = []
if query.path:
results.extend(self.file_index.query(query.path))
if query.symbols:
results.extend(self.symbol_index.query(query.symbols))
return deduplicate(results)

`````> > ~~~

### 存储优化

#### 1. 增量更新

~~~markdown
markdown

## 增量更新

### 更新策略
- 检测变更
- 只更新变更部分
- 维护版本历史
- 支持回滚

### 实现方式
- 文件监控
- 变更检测
- 差异计算
- 增量应用

### 示例
def incremental_update(context, changes):
for change in changes:
if change.type == "modified":
 # 计算差异
diff = calculate_diff(context[change.file], change.new_content)
 # 应用差异
context[change.file] = apply_diff(context[change.file], diff)
elif change.type == "added":
 # 添加新文件
context[change.file] = change.new_content
elif change.type == "deleted":
 # 删除文件
del context[change.file]

return context

`````> >

~~~
#### 2. 版本控制

~~~markdown
markdown

## 版本控制

### 版本策略
- 时间戳版本
- 增量版本
- 标签版本
- 分支版本

### 版本操作
- 创建版本
- 切换版本
- 比较版本
- 合并版本

### 示例
class ContextVersionManager:
def __init__(self):
self.versions = {}
self.current_version = None

def create_version(self, label=None):
version = {
"id": generate_id(),
"timestamp": datetime.now(),
"label": label,
"context": copy.deepcopy(self.current_context)
}
self.versions[version["id"]] = version
self.current_version = version["id"]
return version["id"]

def switch_version(self, version_id):
if version_id in self.versions:
self.current_version = version_id
self.current_context = copy.deepcopy(self.versions[version_id]["context"])
return True
return False

`````> > ~~~

## 上下文检索

### 检索策略

#### 1. 精确检索

~~~markdown
markdown

## 精确检索

### 检索方式
- 按键检索
- 按路径检索
- 按符号检索
- 按时间检索

### 示例
def exact_retrieve(context, query):
if query.type == "key":
return context.get(query.key)
elif query.type == "path":
return context.get_file(query.path)
elif query.type == "symbol":
return context.get_symbol(query.symbol)
elif query.type == "time":
return context.get_by_time(query.time_range)

`````> >

~~~
#### 2. 模糊检索

~~~markdown
markdown

## 模糊检索

### 检索方式
- 模糊匹配
- 相似度检索
- 语义检索
- 关联检索

### 示例
def fuzzy_retrieve(context, query):
results = []

for item in context.items():
 # 计算相似度
similarity = calculate_similarity(item, query)
if similarity > threshold:
results.append((item, similarity))

 # 按相似度排序
results.sort(key=lambda x: x[1], reverse=True)

return [item for item, _ in results]

#### 3. 组合检索
~~~
markdown

## 组合检索

### 检索方式
- 多条件组合
- 逻辑运算
- 权重组合
- 分级检索

### 示例
~~~python
```python

def combined_retrieve(context, query):
    results = []

    # 执行多个检索
    for condition in query.conditions:
        partial_results = retrieve(context, condition)
        results.extend(partial_results)

    # 应用逻辑运算
    if query.operator == "AND":
        results = intersect(results)
    elif query.operator == "OR":
        results = union(results)

    # 应用权重
    weighted_results = apply_weights(results, query.weights)

    return weighted_results

### 检索优化

#### 1. 预计算

~~~`markdown
````markdown

## 预计算

### 预计算内容
> - 统计信息
> - 关联关系
> - 索引数据
> - 聚合结果

### 预计算时机
> - 上下文更新时
> - 定期批处理
> - 按需触发

### 示例
~~~python
```python

def precompute_context(context):
    # 计算统计信息
    stats = calculate_statistics(context)
    context.statistics = stats

    # 计算关联关系
    relations = calculate_relations(context)
    context.relations = relations

    # 构建索引
    index = build_index(context)
    context.index = index

```> >
#### 2. 查询优化
~~~`markdown
`markdown

## 查询优化

### 优化策略
> - 查询重写
> - 执行计划优化
> - 索引选择
> - 结果缓存

### 示例
~~~python
```python

def optimize_query(query, context):
    # 查询重写
    optimized = rewrite_query(query)

    # 选择最佳索引
    best_index = select_best_index(optimized, context.indexes)

    # 生成执行计划
    plan = generate_execution_plan(optimized, best_index)

    return plan
```

#### 总结#

Skills 的上下文管理是一个复杂而精密的系统，涉及多种上下文类型、收集策略、存储机制和检索方法。有效的上下文管理能够：

True. 提高准确性：提供更准确的上下文信息
True. 提升性能：优化上下文收集和检索效率
True. 增强体验：提供更流畅的用户体验
True. 支持扩展：为功能扩展提供基础

在下一节中，我们将探讨 Skills 与主代理的交互机制，了解 Skills 如何与主代理协同工作。

```
bash复制~~~
```

```
~~~
```

---

## 3 Skills 与主代理的交互

**URL**: https://claudecode.tangshuang.net/course/15.3%20Skills%20%E4%B8%8E%E4%B8%BB%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92

#### 交互机制概述#

Skills 与主代理的交互是 Claude Code 系统的核心。主代理负责协调和管理 Skills，而 Skills 则提供具体的功能实现。本节将深入探讨两者之间的交互机制。

#### 交互模式#

##### 1. 主动调用模式#

###### 1.1 调用流程

#### 主动调用流程#

##### 步骤 1：任务识别#

主代理接收用户请求，分析任务类型和需求

##### 步骤 2：Skill 选择#

根据任务需求，从可用 Skills 中选择最合适的 Skill

##### 步骤 3：参数准备#

准备 Skill 需要的参数和上下文信息

##### 步骤 4：Skill 调用#

调用选定的 Skill，传递参数和上下文

##### 步骤 5：结果处理#

接收 Skill 的执行结果，进行必要的处理和整合

##### 步骤 6：响应生成#

基于 Skill 的结果，生成最终的响应返回给用户

###### 1.2 代码示例

```
bash复制python

class MainAgent:
    def __init__(self):
        self.skills = load_skills()
        self.context_manager = ContextManager()

    def process_request(self, user_request):
        # 1. 任务识别
        task = self.analyze_task(user_request)

        # 2. Skill 选择
        skill = self.select_skill(task)

        # 3. 参数准备
        context = self.context_manager.collect_context(skill, task)
        parameters = self.prepare_parameters(task, context)

        # 4. Skill 调用
        result = skill.execute(parameters, context)

        # 5. 结果处理
        processed_result = self.process_result(result, context)

        # 6. 响应生成
        response = self.generate_response(processed_result)

        return response

### 2. 被动调用模式

#### 2.1 调用流程

## 被动调用流程
### 步骤 1：用户指定
用户明确指定要使用的 Skill
### 步骤 2：参数验证
验证用户提供的参数是否有效
### 步骤 3：上下文收集
收集 Skill 需要的上下文信息
### 步骤 4：Skill 执行
执行指定的 Skill
### 步骤 5：结果返回
直接返回 Skill 的执行结果
```

```
python

class MainAgent:
    def __init__(self):
        self.skills = load_skills()
        self.context_manager = ContextManager()

    def process_request(self, user_request):
        # 1. 任务识别
        task = self.analyze_task(user_request)

        # 2. Skill 选择
        skill = self.select_skill(task)

        # 3. 参数准备
        context = self.context_manager.collect_context(skill, task)
        parameters = self.prepare_parameters(task, context)

        # 4. Skill 调用
        result = skill.execute(parameters, context)

        # 5. 结果处理
        processed_result = self.process_result(result, context)

        # 6. 响应生成
        response = self.generate_response(processed_result)

        return response

### 2. 被动调用模式

#### 2.1 调用流程

## 被动调用流程
### 步骤 1：用户指定
用户明确指定要使用的 Skill
### 步骤 2：参数验证
验证用户提供的参数是否有效
### 步骤 3：上下文收集
收集 Skill 需要的上下文信息
### 步骤 4：Skill 执行
执行指定的 Skill
### 步骤 5：结果返回
直接返回 Skill 的执行结果
```

###### 2.2 代码示例

```
bash复制python

class MainAgent:
    def execute_skill(self, skill_name, user_parameters):
        # 1. 验证 Skill 存在
        if skill_name not in self.skills:
            raise SkillNotFoundError(skill_name)

        skill = self.skills[skill_name]

        # 2. 参数验证
        validated_params = skill.validate_parameters(user_parameters)

        # 3. 上下文收集
        context = self.context_manager.collect_context(skill, validated_params)

        # 4. Skill 执行
        result = skill.execute(validated_params, context)

        # 5. 结果返回
        return result

### 3. 嵌套调用模式

#### 3.1 调用流程

## 嵌套调用流程
### 示例场景：部署应用
### 调用层次
主代理
└─> 部署 Skill
├─> 测试 Skill
│   └─> 代码分析 Skill
│       └─> 文档检查 Skill
├─> 构建 Skill
│   └─> 依赖检查 Skill
└─> 验证 Skill
└─> 健康检查 Skill
### 执行流程
```

```
python

class MainAgent:
    def execute_skill(self, skill_name, user_parameters):
        # 1. 验证 Skill 存在
        if skill_name not in self.skills:
            raise SkillNotFoundError(skill_name)

        skill = self.skills[skill_name]

        # 2. 参数验证
        validated_params = skill.validate_parameters(user_parameters)

        # 3. 上下文收集
        context = self.context_manager.collect_context(skill, validated_params)

        # 4. Skill 执行
        result = skill.execute(validated_params, context)

        # 5. 结果返回
        return result

### 3. 嵌套调用模式

#### 3.1 调用流程

## 嵌套调用流程
### 示例场景：部署应用
### 调用层次
主代理
└─> 部署 Skill
├─> 测试 Skill
│   └─> 代码分析 Skill
│       └─> 文档检查 Skill
├─> 构建 Skill
│   └─> 依赖检查 Skill
└─> 验证 Skill
└─> 健康检查 Skill
### 执行流程
```

###### 3.2 代码示例

```
bash复制python

class DeploymentSkill(Skill):
    def execute(self, parameters, context):
        # 调用测试 Skill
        test_result = self.call_skill("test", context)

        if not test_result.success:
            return DeploymentResult(success=False, error="Tests failed")

        # 调用构建 Skill
        build_result = self.call_skill("build", context)

        if not build_result.success:
            return DeploymentResult(success=False, error="Build failed")

        # 执行部署
        deploy_result = self.deploy(build_result.artifact)

        # 调用验证 Skill
        verify_result = self.call_skill("verify", context)

        return DeploymentResult(
            success=verify_result.success,
            deploy_result=deploy_result,
            verify_result=verify_result
        )

## 通信机制

### 1. 消息传递

#### 1.1 消息格式

## 消息格式
### 请求消息
~~~`json
`json

{
"message_id": "msg_123456",
"timestamp": "2024-01-15T10:30:00Z",
"type": "skill_request",
"skill_name": "code-review",
"parameters": {
"file": "src/main.py",
"strict": true
},
"context": {
"project": {...},
"code": {...},
```

```
python

class DeploymentSkill(Skill):
    def execute(self, parameters, context):
        # 调用测试 Skill
        test_result = self.call_skill("test", context)

        if not test_result.success:
            return DeploymentResult(success=False, error="Tests failed")

        # 调用构建 Skill
        build_result = self.call_skill("build", context)

        if not build_result.success:
            return DeploymentResult(success=False, error="Build failed")

        # 执行部署
        deploy_result = self.deploy(build_result.artifact)

        # 调用验证 Skill
        verify_result = self.call_skill("verify", context)

        return DeploymentResult(
            success=verify_result.success,
            deploy_result=deploy_result,
            verify_result=verify_result
        )

## 通信机制

### 1. 消息传递

#### 1.1 消息格式

## 消息格式
### 请求消息
~~~`json
`json

{
"message_id": "msg_123456",
"timestamp": "2024-01-15T10:30:00Z",
"type": "skill_request",
"skill_name": "code-review",
"parameters": {
"file": "src/main.py",
"strict": true
},
"context": {
"project": {...},
"code": {...},
```

"user": {...}
}
}

```
bash复制
~~~
json

{
  "message_id": "msg_123456",
  "timestamp": "2024-01-15T10:30:15Z",
  "type": "skill_response",
  "status": "success",
  "result": {
    "issues": [...],
    "summary": {...}
  },
  "metadata": {
    "execution_time": 15.2,
    "memory_used": "256MB"
  }
}

### 错误消息
~~~`json
````json

{
"message_id": "msg_123456",
"timestamp": "2024-01-15T10:30:10Z",
"type": "skill_error",
"error": {
"code": "FILE_NOT_FOUND",
"message": "File src/main.py not found",
"details": {...}
}
}

```> >
~~~
#### 1.2 消息队列

class MessageQueue:
def __init__(self):
self.queue = asyncio.Queue()
self.handlers = {}
async def send(self, message):
await self.queue.put(message)
async def receive(self):
return await self.queue.get()
def register_handler(self, message_type, handler):
self.handlers[message_type] = handler
async def process_messages(self):
while True:
message = await self.receive()
handler = self.handlers.get(message.type)
if handler:
await handler(message)

~~~
### 2. 事件驱动
#### 2.1 事件类型
~~~
markdown

## 事件类型

### Skill 事件
- skill_started: Skill 开始执行
- skill_progress: Skill 执行进度更新
- skill_completed: Skill 执行完成
- skill_failed: Skill 执行失败

### 上下文事件
- context_updated: 上下文更新
- context_invalidated: 上下文失效

### 工具事件
- tool_called: 工具被调用
- tool_completed: 工具执行完成
- tool_failed: 工具执行失败

#### 2.2 事件处理

class EventHandler:
def __init__(self):
self.listeners = defaultdict(list)
def on(self, event_type, callback):
self.listeners[event_type].append(callback)
async def emit(self, event_type, data):
for callback in self.listeners.get(event_type, []):
await callback(data)
async def handle_skill_started(self, event):
print(f"Skill {event.skill_name} started")
async def handle_skill_progress(self, event):
print(f"Progress: {event.progress}%")
async def handle_skill_completed(self, event):
print(f"Skill {event.skill_name} completed")

~~~
### 3. 流式通信
#### 3.1 流式输出
~~~
python

class StreamingSkill(Skill):
    async def execute_stream(self, parameters, context):
        # 步骤 1
        yield {"step": 1, "message": "Analyzing code..."}
        result1 = await self.analyze_code(parameters, context)

        # 步骤 2
        yield {"step": 2, "message": "Checking security..."}
        result2 = await self.check_security(result1, context)

        # 步骤 3
        yield {"step": 3, "message": "Generating report..."}
        result3 = await self.generate_report(result2, context)

        # 最终结果
        yield {"step": 4, "message": "Completed", "result": result3}

#### 3.2 流式消费

async def consume_stream(skill, parameters, context):
async for chunk in skill.execute_stream(parameters, context):
if "message" in chunk:
print(chunk["message"])
if "result" in chunk:
return chunk["result"]

~~~
## 状态管理
### 1. 执行状态
#### 1.1 状态类型
~~~
markdown

## 执行状态

### 状态定义
- PENDING: 等待执行
- RUNNING: 正在执行
- PAUSED: 已暂停
- COMPLETED: 已完成
- FAILED: 执行失败
- CANCELLED: 已取消

### 状态转换
PENDING → RUNNING → COMPLETED
PENDING → RUNNING → FAILED
RUNNING → PAUSED → RUNNING
RUNNING → CANCELLED

#### 1.2 状态管理

class ExecutionState:
def __init__(self):
self.state = "PENDING"
self.start_time = None
self.end_time = None
self.progress = 0
self.error = None
def start(self):
self.state = "RUNNING"
self.start_time = datetime.now()
def complete(self):
self.state = "COMPLETED"
self.end_time = datetime.now()
def fail(self, error):
self.state = "FAILED"
self.error = error
self.end_time = datetime.now()
def update_progress(self, progress):
self.progress = progress
def get_duration(self):
if self.start_time and self.end_time:
return (self.end_time - self.start_time).total_seconds()
return None

~~~
### 2. 上下文状态
#### 2.1 上下文快照
~~~
python

class ContextSnapshot:
    def __init__(self, context):
        self.timestamp = datetime.now()
        self.context = copy.deepcopy(context)
        self.version = self.generate_version()

    def generate_version(self):
        return hashlib.md5(
            json.dumps(self.context, sort_keys=True).encode()
        ).hexdigest()

    def compare(self, other_snapshot):
        return self.version == other_snapshot.version

#### 2.2 上下文恢复

class ContextManager:
def __init__(self):
self.snapshots = []
self.current_context = {}
def create_snapshot(self):
snapshot = ContextSnapshot(self.current_context)
self.snapshots.append(snapshot)
return snapshot
def restore_snapshot(self, snapshot):
self.current_context = copy.deepcopy(snapshot.context)
def rollback_to(self, version):
for snapshot in reversed(self.snapshots):
if snapshot.version == version:
self.restore_snapshot(snapshot)
return True
return False

~~~
### 3. 会话状态
#### 3.1 会话管理
~~~
python

class SessionManager:
    def __init__(self):
        self.sessions = {}
        self.current_session_id = None

    def create_session(self):
        session_id = generate_id()
        self.sessions[session_id] = {
            "id": session_id,
            "created_at": datetime.now(),
            "context": {},
            "history": [],
            "state": "ACTIVE"
        }
        self.current_session_id = session_id
        return session_id

    def get_session(self, session_id):
        return self.sessions.get(session_id)

    def update_session(self, session_id, updates):
        if session_id in self.sessions:
            self.sessions[session_id].update(updates)

    def close_session(self, session_id):
        if session_id in self.sessions:
            self.sessions[session_id]["state"] = "CLOSED"
            self.sessions[session_id]["closed_at"] = datetime.now()

## 错误处理

### 1. 错误传播

#### 1.1 错误类型

## 错误类型
### Skill 错误
- SkillNotFoundError: Skill 不存在
- SkillExecutionError: Skill 执行失败
- SkillTimeoutError: Skill 执行超时
### 参数错误
- ParameterValidationError: 参数验证失败
- MissingParameterError: 缺少必需参数
- InvalidParameterError: 参数值无效
### 上下文错误
- ContextNotFoundError: 上下文不存在
- ContextInvalidError: 上下文无效
- ContextTimeoutError: 上下文获取超时

~~~
#### 1.2 错误处理策略
~~~
python

class ErrorHandler:
    def __init__(self):
        self.retries = {}
        self.fallbacks = {}

    def handle_error(self, error, context):
        error_type = type(error).__name__

        # 检查是否应该重试
        if self.should_retry(error_type):
            return self.retry(error, context)

        # 检查是否有回退方案
        if self.has_fallback(error_type):
            return self.fallback(error, context)

        # 否则抛出错误
        raise error

    def should_retry(self, error_type):
        return error_type in self.retries

    def retry(self, error, context):
        retry_config = self.retries[type(error).__name__]
        max_attempts = retry_config.get("max_attempts", 3)
        delay = retry_config.get("delay", 1)

        attempt = context.get("attempt", 0) + 1
        if attempt < max_attempts:
            context["attempt"] = attempt
            time.sleep(delay * attempt)
            return "RETRY"

        return error

    def has_fallback(self, error_type):
        return error_type in self.fallbacks

    def fallback(self, error, context):
        fallback_func = self.fallbacks[type(error).__name__]
        return fallback_func(error, context)

### 2. 错误恢复

#### 2.1 恢复策略

## 恢复策略
### 自动恢复
- 重试机制
- 回退方案
- 降级处理
### 手动恢复
- 用户确认
- 参数修正
- 上下文调整
### 状态恢复
- 快照恢复
- 断点续传
- 事务回滚

~~~
#### 2.2 恢复实现
~~~
python

class RecoveryManager:
    def __init__(self):
        self.checkpoints = {}

    def create_checkpoint(self, execution_id, state):
        self.checkpoints[execution_id] = {
            "timestamp": datetime.now(),
            "state": copy.deepcopy(state)
        }

    def restore_checkpoint(self, execution_id):
        if execution_id in self.checkpoints:
            return copy.deepcopy(self.checkpoints[execution_id]["state"])
        return None

    def recover_from_error(self, error, execution_id):
        # 恢复到检查点
        state = self.restore_checkpoint(execution_id)
        if state:
            # 尝试恢复执行
            return self.resume_execution(state)

        # 如果没有检查点，尝试其他恢复策略
        return self.alternative_recovery(error)

## 性能优化

### 1. 并行执行

#### 1.1 并行策略

class ParallelExecutor:
def __init__(self, max_workers=4):
self.max_workers = max_workers
self.executor = ThreadPoolExecutor(max_workers=max_workers)
async def execute_parallel(self, tasks):
futures = []
for task in tasks:
future = self.executor.submit(task.execute)
futures.append(future)
results = []
for future in futures:
result = await asyncio.wrap_future(future)
results.append(result)
return results

~~~
#### 1.2 依赖管理
~~~
python

class DependencyManager:
    def __init__(self):
        self.dependencies = {}

    def add_dependency(self, task, depends_on):
        if task not in self.dependencies:
            self.dependencies[task] = []
        self.dependencies[task].extend(depends_on)

    def get_execution_order(self, tasks):
        order = []
        visited = set()

        def visit(task):
            if task in visited:
                return
            visited.add(task)

            for dep in self.dependencies.get(task, []):
                visit(dep)

            order.append(task)

        for task in tasks:
            visit(task)

        return order

### 2. 资源管理

#### 2.1 资源池

class ResourcePool:
def __init__(self, max_resources):
self.max_resources = max_resources
self.available = max_resources
self.lock = asyncio.Lock()
async def acquire(self):
async with self.lock:
while self.available <= 0:
await asyncio.sleep(0.1)
self.available -= 1
return True
async def release(self):
async with self.lock:
self.available += 1
async def __aenter__(self):
await self.acquire()
return self
async def __aexit__(self, exc_type, exc_val, exc_tb):
await self.release()

~~~
#### 2.2 资源监控
~~~
python

class ResourceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)

    def record_metric(self, name, value):
        self.metrics[name].append({
            "value": value,
            "timestamp": datetime.now()
        })

    def get_average(self, name):
        values = [m["value"] for m in self.metrics[name]]
        return sum(values) / len(values) if values else 0

    def get_peak(self, name):
        values = [m["value"] for m in self.metrics[name]]
        return max(values) if values else 0
```

```
~~~
json

{
  "message_id": "msg_123456",
  "timestamp": "2024-01-15T10:30:15Z",
  "type": "skill_response",
  "status": "success",
  "result": {
    "issues": [...],
    "summary": {...}
  },
  "metadata": {
    "execution_time": 15.2,
    "memory_used": "256MB"
  }
}

### 错误消息
~~~`json
````json

{
"message_id": "msg_123456",
"timestamp": "2024-01-15T10:30:10Z",
"type": "skill_error",
"error": {
"code": "FILE_NOT_FOUND",
"message": "File src/main.py not found",
"details": {...}
}
}

```> >
~~~
#### 1.2 消息队列

class MessageQueue:
def __init__(self):
self.queue = asyncio.Queue()
self.handlers = {}
async def send(self, message):
await self.queue.put(message)
async def receive(self):
return await self.queue.get()
def register_handler(self, message_type, handler):
self.handlers[message_type] = handler
async def process_messages(self):
while True:
message = await self.receive()
handler = self.handlers.get(message.type)
if handler:
await handler(message)

~~~
### 2. 事件驱动
#### 2.1 事件类型
~~~
markdown

## 事件类型

### Skill 事件
- skill_started: Skill 开始执行
- skill_progress: Skill 执行进度更新
- skill_completed: Skill 执行完成
- skill_failed: Skill 执行失败

### 上下文事件
- context_updated: 上下文更新
- context_invalidated: 上下文失效

### 工具事件
- tool_called: 工具被调用
- tool_completed: 工具执行完成
- tool_failed: 工具执行失败

#### 2.2 事件处理

class EventHandler:
def __init__(self):
self.listeners = defaultdict(list)
def on(self, event_type, callback):
self.listeners[event_type].append(callback)
async def emit(self, event_type, data):
for callback in self.listeners.get(event_type, []):
await callback(data)
async def handle_skill_started(self, event):
print(f"Skill {event.skill_name} started")
async def handle_skill_progress(self, event):
print(f"Progress: {event.progress}%")
async def handle_skill_completed(self, event):
print(f"Skill {event.skill_name} completed")

~~~
### 3. 流式通信
#### 3.1 流式输出
~~~
python

class StreamingSkill(Skill):
    async def execute_stream(self, parameters, context):
        # 步骤 1
        yield {"step": 1, "message": "Analyzing code..."}
        result1 = await self.analyze_code(parameters, context)

        # 步骤 2
        yield {"step": 2, "message": "Checking security..."}
        result2 = await self.check_security(result1, context)

        # 步骤 3
        yield {"step": 3, "message": "Generating report..."}
        result3 = await self.generate_report(result2, context)

        # 最终结果
        yield {"step": 4, "message": "Completed", "result": result3}

#### 3.2 流式消费

async def consume_stream(skill, parameters, context):
async for chunk in skill.execute_stream(parameters, context):
if "message" in chunk:
print(chunk["message"])
if "result" in chunk:
return chunk["result"]

~~~
## 状态管理
### 1. 执行状态
#### 1.1 状态类型
~~~
markdown

## 执行状态

### 状态定义
- PENDING: 等待执行
- RUNNING: 正在执行
- PAUSED: 已暂停
- COMPLETED: 已完成
- FAILED: 执行失败
- CANCELLED: 已取消

### 状态转换
PENDING → RUNNING → COMPLETED
PENDING → RUNNING → FAILED
RUNNING → PAUSED → RUNNING
RUNNING → CANCELLED

#### 1.2 状态管理

class ExecutionState:
def __init__(self):
self.state = "PENDING"
self.start_time = None
self.end_time = None
self.progress = 0
self.error = None
def start(self):
self.state = "RUNNING"
self.start_time = datetime.now()
def complete(self):
self.state = "COMPLETED"
self.end_time = datetime.now()
def fail(self, error):
self.state = "FAILED"
self.error = error
self.end_time = datetime.now()
def update_progress(self, progress):
self.progress = progress
def get_duration(self):
if self.start_time and self.end_time:
return (self.end_time - self.start_time).total_seconds()
return None

~~~
### 2. 上下文状态
#### 2.1 上下文快照
~~~
python

class ContextSnapshot:
    def __init__(self, context):
        self.timestamp = datetime.now()
        self.context = copy.deepcopy(context)
        self.version = self.generate_version()

    def generate_version(self):
        return hashlib.md5(
            json.dumps(self.context, sort_keys=True).encode()
        ).hexdigest()

    def compare(self, other_snapshot):
        return self.version == other_snapshot.version

#### 2.2 上下文恢复

class ContextManager:
def __init__(self):
self.snapshots = []
self.current_context = {}
def create_snapshot(self):
snapshot = ContextSnapshot(self.current_context)
self.snapshots.append(snapshot)
return snapshot
def restore_snapshot(self, snapshot):
self.current_context = copy.deepcopy(snapshot.context)
def rollback_to(self, version):
for snapshot in reversed(self.snapshots):
if snapshot.version == version:
self.restore_snapshot(snapshot)
return True
return False

~~~
### 3. 会话状态
#### 3.1 会话管理
~~~
python

class SessionManager:
    def __init__(self):
        self.sessions = {}
        self.current_session_id = None

    def create_session(self):
        session_id = generate_id()
        self.sessions[session_id] = {
            "id": session_id,
            "created_at": datetime.now(),
            "context": {},
            "history": [],
            "state": "ACTIVE"
        }
        self.current_session_id = session_id
        return session_id

    def get_session(self, session_id):
        return self.sessions.get(session_id)

    def update_session(self, session_id, updates):
        if session_id in self.sessions:
            self.sessions[session_id].update(updates)

    def close_session(self, session_id):
        if session_id in self.sessions:
            self.sessions[session_id]["state"] = "CLOSED"
            self.sessions[session_id]["closed_at"] = datetime.now()

## 错误处理

### 1. 错误传播

#### 1.1 错误类型

## 错误类型
### Skill 错误
- SkillNotFoundError: Skill 不存在
- SkillExecutionError: Skill 执行失败
- SkillTimeoutError: Skill 执行超时
### 参数错误
- ParameterValidationError: 参数验证失败
- MissingParameterError: 缺少必需参数
- InvalidParameterError: 参数值无效
### 上下文错误
- ContextNotFoundError: 上下文不存在
- ContextInvalidError: 上下文无效
- ContextTimeoutError: 上下文获取超时

~~~
#### 1.2 错误处理策略
~~~
python

class ErrorHandler:
    def __init__(self):
        self.retries = {}
        self.fallbacks = {}

    def handle_error(self, error, context):
        error_type = type(error).__name__

        # 检查是否应该重试
        if self.should_retry(error_type):
            return self.retry(error, context)

        # 检查是否有回退方案
        if self.has_fallback(error_type):
            return self.fallback(error, context)

        # 否则抛出错误
        raise error

    def should_retry(self, error_type):
        return error_type in self.retries

    def retry(self, error, context):
        retry_config = self.retries[type(error).__name__]
        max_attempts = retry_config.get("max_attempts", 3)
        delay = retry_config.get("delay", 1)

        attempt = context.get("attempt", 0) + 1
        if attempt < max_attempts:
            context["attempt"] = attempt
            time.sleep(delay * attempt)
            return "RETRY"

        return error

    def has_fallback(self, error_type):
        return error_type in self.fallbacks

    def fallback(self, error, context):
        fallback_func = self.fallbacks[type(error).__name__]
        return fallback_func(error, context)

### 2. 错误恢复

#### 2.1 恢复策略

## 恢复策略
### 自动恢复
- 重试机制
- 回退方案
- 降级处理
### 手动恢复
- 用户确认
- 参数修正
- 上下文调整
### 状态恢复
- 快照恢复
- 断点续传
- 事务回滚

~~~
#### 2.2 恢复实现
~~~
python

class RecoveryManager:
    def __init__(self):
        self.checkpoints = {}

    def create_checkpoint(self, execution_id, state):
        self.checkpoints[execution_id] = {
            "timestamp": datetime.now(),
            "state": copy.deepcopy(state)
        }

    def restore_checkpoint(self, execution_id):
        if execution_id in self.checkpoints:
            return copy.deepcopy(self.checkpoints[execution_id]["state"])
        return None

    def recover_from_error(self, error, execution_id):
        # 恢复到检查点
        state = self.restore_checkpoint(execution_id)
        if state:
            # 尝试恢复执行
            return self.resume_execution(state)

        # 如果没有检查点，尝试其他恢复策略
        return self.alternative_recovery(error)

## 性能优化

### 1. 并行执行

#### 1.1 并行策略

class ParallelExecutor:
def __init__(self, max_workers=4):
self.max_workers = max_workers
self.executor = ThreadPoolExecutor(max_workers=max_workers)
async def execute_parallel(self, tasks):
futures = []
for task in tasks:
future = self.executor.submit(task.execute)
futures.append(future)
results = []
for future in futures:
result = await asyncio.wrap_future(future)
results.append(result)
return results

~~~
#### 1.2 依赖管理
~~~
python

class DependencyManager:
    def __init__(self):
        self.dependencies = {}

    def add_dependency(self, task, depends_on):
        if task not in self.dependencies:
            self.dependencies[task] = []
        self.dependencies[task].extend(depends_on)

    def get_execution_order(self, tasks):
        order = []
        visited = set()

        def visit(task):
            if task in visited:
                return
            visited.add(task)

            for dep in self.dependencies.get(task, []):
                visit(dep)

            order.append(task)

        for task in tasks:
            visit(task)

        return order

### 2. 资源管理

#### 2.1 资源池

class ResourcePool:
def __init__(self, max_resources):
self.max_resources = max_resources
self.available = max_resources
self.lock = asyncio.Lock()
async def acquire(self):
async with self.lock:
while self.available <= 0:
await asyncio.sleep(0.1)
self.available -= 1
return True
async def release(self):
async with self.lock:
self.available += 1
async def __aenter__(self):
await self.acquire()
return self
async def __aexit__(self, exc_type, exc_val, exc_tb):
await self.release()

~~~
#### 2.2 资源监控
~~~
python

class ResourceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)

    def record_metric(self, name, value):
        self.metrics[name].append({
            "value": value,
            "timestamp": datetime.now()
        })

    def get_average(self, name):
        values = [m["value"] for m in self.metrics[name]]
        return sum(values) / len(values) if values else 0

    def get_peak(self, name):
        values = [m["value"] for m in self.metrics[name]]
        return max(values) if values else 0
```

#### 总结#

Skills 与主代理的交互机制是一个复杂而精密的系统，涉及多种交互模式、通信机制、状态管理、错误处理和性能优化。理解这些机制有助于：

True. 优化性能：通过并行执行和资源管理提高性能
True. 增强可靠性：通过完善的错误处理和恢复机制提高可靠性
True. 改善体验：通过流式通信和事件驱动改善用户体验
True. 支持扩展：通过灵活的交互机制支持功能扩展

在下一节中，我们将探讨 Skills 的性能优化策略，了解如何进一步提高 Skills 的执行效率。

```
bash复制~~~
```

```
~~~
```

---

## 4 Skills 性能优化

**URL**: https://claudecode.tangshuang.net/course/15.4%20Skills%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96

#### 性能优化概述#

Skills 的性能优化是提高 Claude Code 整体效率的关键。本节将深入探讨 Skills 的各种性能优化策略和技巧。

#### 优化策略#

##### 1. 缓存优化#

###### 1.1 多级缓存

#### 多级缓存架构#

##### 缓存层次#

True. L1 缓存（内存）

- 最快访问速度
- 最小容量
- 存储热点数据

True. L2 缓存（本地磁盘）

- 中等访问速度
- 中等容量
- 存储温数据

True. L3 缓存（远程存储）

- 较慢访问速度
- 最大容量
- 存储冷数据

##### 缓存策略#

- LRU（最近最少使用）
- LFU（最不经常使用）
- TTL（生存时间）
- 手动失效

###### 1.2 缓存实现

```
bash复制python

class MultiLevelCache:
    def __init__(self):
        self.l1_cache = LRUCache(maxsize=100)
        self.l2_cache = DiskCache(cache_dir="/tmp/skills_cache")
        self.l3_cache = RedisCache(host="localhost", port=6379)

    async def get(self, key):
        # L1 缓存
        value = self.l1_cache.get(key)
        if value is not None:
            return value

        # L2 缓存
        value = await self.l2_cache.get(key)
        if value is not None:
            self.l1_cache[key] = value
            return value

        # L3 缓存
        value = await self.l3_cache.get(key)
        if value is not None:
            self.l1_cache[key] = value
            await self.l2_cache.set(key, value)
            return value

        return None

    async def set(self, key, value, ttl=3600):
        # 设置所有级别的缓存
        self.l1_cache[key] = value
        await self.l2_cache.set(key, value, ttl)
        await self.l3_cache.set(key, value, ttl)

    async def invalidate(self, key):
        # 使所有级别的缓存失效
        if key in self.l1_cache:
            del self.l1_cache[key]
        await self.l2_cache.delete(key)
        await self.l3_cache.delete(key)

#### 1.3 缓存键设计

class CacheKeyGenerator:
@staticmethod
def generate(skill_name, parameters, context_version):
key_parts = [
skill_name,
hashlib.md5(json.dumps(parameters, sort_keys=True).encode()).hexdigest(),
context_version
]
return ":".join(key_parts)
@staticmethod
def generate_context_key(context):
key_parts = [
"context",
hashlib.md5(json.dumps(context, sort_keys=True).encode()).hexdigest()
]
return ":".join(key_parts)
```

```
python

class MultiLevelCache:
    def __init__(self):
        self.l1_cache = LRUCache(maxsize=100)
        self.l2_cache = DiskCache(cache_dir="/tmp/skills_cache")
        self.l3_cache = RedisCache(host="localhost", port=6379)

    async def get(self, key):
        # L1 缓存
        value = self.l1_cache.get(key)
        if value is not None:
            return value

        # L2 缓存
        value = await self.l2_cache.get(key)
        if value is not None:
            self.l1_cache[key] = value
            return value

        # L3 缓存
        value = await self.l3_cache.get(key)
        if value is not None:
            self.l1_cache[key] = value
            await self.l2_cache.set(key, value)
            return value

        return None

    async def set(self, key, value, ttl=3600):
        # 设置所有级别的缓存
        self.l1_cache[key] = value
        await self.l2_cache.set(key, value, ttl)
        await self.l3_cache.set(key, value, ttl)

    async def invalidate(self, key):
        # 使所有级别的缓存失效
        if key in self.l1_cache:
            del self.l1_cache[key]
        await self.l2_cache.delete(key)
        await self.l3_cache.delete(key)

#### 1.3 缓存键设计

class CacheKeyGenerator:
@staticmethod
def generate(skill_name, parameters, context_version):
key_parts = [
skill_name,
hashlib.md5(json.dumps(parameters, sort_keys=True).encode()).hexdigest(),
context_version
]
return ":".join(key_parts)
@staticmethod
def generate_context_key(context):
key_parts = [
"context",
hashlib.md5(json.dumps(context, sort_keys=True).encode()).hexdigest()
]
return ":".join(key_parts)
```

##### 2. 并行执行#

###### 2.1 任务并行

```
bash复制python

class ParallelSkillExecutor:
    def __init__(self, max_workers=4):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    async def execute_parallel(self, tasks):
        futures = []
        for task in tasks:
            future = self.executor.submit(task.execute)
            futures.append(future)

        results = []
        for future in as_completed(futures):
            result = await asyncio.wrap_future(future)
            results.append(result)

        return results

    async def execute_parallel_with_order(self, tasks):
        loop = asyncio.get_event_loop()
        futures = [loop.run_in_executor(self.executor, task.execute) for task in tasks]
        results = await asyncio.gather(*futures)
        return results

#### 2.2 流水线执行

class PipelineExecutor:
def __init__(self, stages):
self.stages = stages
self.queues = [asyncio.Queue() for _ in range(len(stages) + 1)]
async def add_task(self, task):
await self.queues[0].put(task)
async def worker(self, stage_index):
while True:
task = await self.queues[stage_index].get()
result = await self.stages[stage_index].process(task)
await self.queues[stage_index + 1].put(result)
async def run(self):
workers = []
for i in range(len(self.stages)):
worker = asyncio.create_task(self.worker(i))
workers.append(worker)
await asyncio.gather(*workers)
```

```
python

class ParallelSkillExecutor:
    def __init__(self, max_workers=4):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    async def execute_parallel(self, tasks):
        futures = []
        for task in tasks:
            future = self.executor.submit(task.execute)
            futures.append(future)

        results = []
        for future in as_completed(futures):
            result = await asyncio.wrap_future(future)
            results.append(result)

        return results

    async def execute_parallel_with_order(self, tasks):
        loop = asyncio.get_event_loop()
        futures = [loop.run_in_executor(self.executor, task.execute) for task in tasks]
        results = await asyncio.gather(*futures)
        return results

#### 2.2 流水线执行

class PipelineExecutor:
def __init__(self, stages):
self.stages = stages
self.queues = [asyncio.Queue() for _ in range(len(stages) + 1)]
async def add_task(self, task):
await self.queues[0].put(task)
async def worker(self, stage_index):
while True:
task = await self.queues[stage_index].get()
result = await self.stages[stage_index].process(task)
await self.queues[stage_index + 1].put(result)
async def run(self):
workers = []
for i in range(len(self.stages)):
worker = asyncio.create_task(self.worker(i))
workers.append(worker)
await asyncio.gather(*workers)
```

##### 3. 增量处理#

###### 3.1 变更检测

```
bash复制python

class ChangeDetector:
    def __init__(self):
        self.file_hashes = {}
        self.context_hashes = {}

    def detect_file_changes(self, files):
        changes = []
        for file in files:
            current_hash = self.calculate_file_hash(file)
            previous_hash = self.file_hashes.get(file)

            if previous_hash is None:
                changes.append({"type": "added", "file": file})
            elif current_hash != previous_hash:
                changes.append({"type": "modified", "file": file})

            self.file_hashes[file] = current_hash

        return changes

    def calculate_file_hash(self, file_path):
        with open(file_path, 'rb') as f:
            return hashlib.md5(f.read()).hexdigest()

#### 3.2 增量更新

class IncrementalUpdater:
def __init__(self):
self.previous_context = None
self.previous_results = None
async def update(self, new_context, changes):
if self.previous_context is None:
return await self.full_process(new_context)
# 只处理变更的部分
updated_results = copy.deepcopy(self.previous_results)
for change in changes:
if change["type"] == "modified":
result = await self.process_change(change)
updated_results[change["file"]] = result
elif change["type"] == "added":
result = await self.process_change(change)
updated_results[change["file"]] = result
elif change["type"] == "deleted":
del updated_results[change["file"]]
self.previous_context = new_context
self.previous_results = updated_results
return updated_results
```

```
python

class ChangeDetector:
    def __init__(self):
        self.file_hashes = {}
        self.context_hashes = {}

    def detect_file_changes(self, files):
        changes = []
        for file in files:
            current_hash = self.calculate_file_hash(file)
            previous_hash = self.file_hashes.get(file)

            if previous_hash is None:
                changes.append({"type": "added", "file": file})
            elif current_hash != previous_hash:
                changes.append({"type": "modified", "file": file})

            self.file_hashes[file] = current_hash

        return changes

    def calculate_file_hash(self, file_path):
        with open(file_path, 'rb') as f:
            return hashlib.md5(f.read()).hexdigest()

#### 3.2 增量更新

class IncrementalUpdater:
def __init__(self):
self.previous_context = None
self.previous_results = None
async def update(self, new_context, changes):
if self.previous_context is None:
return await self.full_process(new_context)
# 只处理变更的部分
updated_results = copy.deepcopy(self.previous_results)
for change in changes:
if change["type"] == "modified":
result = await self.process_change(change)
updated_results[change["file"]] = result
elif change["type"] == "added":
result = await self.process_change(change)
updated_results[change["file"]] = result
elif change["type"] == "deleted":
del updated_results[change["file"]]
self.previous_context = new_context
self.previous_results = updated_results
return updated_results
```

##### 4. 资源优化#

###### 4.1 内存管理

```
bash复制python

class MemoryManager:
    def __init__(self, max_memory_mb=1024):
        self.max_memory = max_memory_mb * 1024 * 1024
        self.current_memory = 0
        self.allocations = {}

    def allocate(self, key, size):
        if self.current_memory + size > self.max_memory:
            self.free_memory(size)

        self.allocations[key] = size
        self.current_memory += size

    def free_memory(self, required_size):
        freed = 0
        for key in list(self.allocations.keys()):
            if freed >= required_size:
                break
            freed += self.allocations[key]
            del self.allocations[key]

        self.current_memory -= freed

    def get_memory_usage(self):
        return self.current_memory / (1024 * 1024)

#### 4.2 连接池

class ConnectionPool:
def __init__(self, max_connections=10):
self.max_connections = max_connections
self.connections = []
self.available = asyncio.Queue()
self.lock = asyncio.Lock()
async def acquire(self):
if not self.available.empty():
return await self.available.get()
async with self.lock:
if len(self.connections) < self.max_connections:
conn = await self.create_connection()
self.connections.append(conn)
return conn
return await self.available.get()
async def release(self, connection):
await self.available.put(connection)
async def create_connection(self):
return await self.connect_to_service()
```

```
python

class MemoryManager:
    def __init__(self, max_memory_mb=1024):
        self.max_memory = max_memory_mb * 1024 * 1024
        self.current_memory = 0
        self.allocations = {}

    def allocate(self, key, size):
        if self.current_memory + size > self.max_memory:
            self.free_memory(size)

        self.allocations[key] = size
        self.current_memory += size

    def free_memory(self, required_size):
        freed = 0
        for key in list(self.allocations.keys()):
            if freed >= required_size:
                break
            freed += self.allocations[key]
            del self.allocations[key]

        self.current_memory -= freed

    def get_memory_usage(self):
        return self.current_memory / (1024 * 1024)

#### 4.2 连接池

class ConnectionPool:
def __init__(self, max_connections=10):
self.max_connections = max_connections
self.connections = []
self.available = asyncio.Queue()
self.lock = asyncio.Lock()
async def acquire(self):
if not self.available.empty():
return await self.available.get()
async with self.lock:
if len(self.connections) < self.max_connections:
conn = await self.create_connection()
self.connections.append(conn)
return conn
return await self.available.get()
async def release(self, connection):
await self.available.put(connection)
async def create_connection(self):
return await self.connect_to_service()
```

##### 5. 算法优化#

###### 5.1 复杂度分析

```
bash复制markdown

## 常见算法复杂度

### O(1) - 常数时间
- 数组索引访问
- 哈希表查找
- 栈操作

### O(log n) - 对数时间
- 二分查找
- 平衡树操作
- 堆操作

### O(n) - 线性时间
- 数组遍历
- 链表遍历
- 简单排序

### O(n log n) - 线性对数时间
- 快速排序
- 归并排序
- 堆排序

### O(n²) - 平方时间
- 冒泡排序
- 嵌套循环
- 矩阵乘法

#### 5.2 优化示例

class OptimizedCodeAnalyzer:
def __init__(self):
self.symbol_index = {}
self.dependency_graph = {}
def analyze(self, code):
# 使用索引加速查找
symbols = self.extract_symbols(code)
for symbol in symbols:
if symbol not in self.symbol_index:
self.symbol_index[symbol] = []
self.symbol_index[symbol].append(code)
# 使用图表示依赖关系
dependencies = self.extract_dependencies(code)
for dep in dependencies:
if dep not in self.dependency_graph:
self.dependency_graph[dep] = []
self.dependency_graph[dep].append(code)
def find_usages(self, symbol):
# O(1) 查找
return self.symbol_index.get(symbol, [])
def find_dependents(self, code):
# O(1) 查找
return self.dependency_graph.get(code, [])
```

```
markdown

## 常见算法复杂度

### O(1) - 常数时间
- 数组索引访问
- 哈希表查找
- 栈操作

### O(log n) - 对数时间
- 二分查找
- 平衡树操作
- 堆操作

### O(n) - 线性时间
- 数组遍历
- 链表遍历
- 简单排序

### O(n log n) - 线性对数时间
- 快速排序
- 归并排序
- 堆排序

### O(n²) - 平方时间
- 冒泡排序
- 嵌套循环
- 矩阵乘法

#### 5.2 优化示例

class OptimizedCodeAnalyzer:
def __init__(self):
self.symbol_index = {}
self.dependency_graph = {}
def analyze(self, code):
# 使用索引加速查找
symbols = self.extract_symbols(code)
for symbol in symbols:
if symbol not in self.symbol_index:
self.symbol_index[symbol] = []
self.symbol_index[symbol].append(code)
# 使用图表示依赖关系
dependencies = self.extract_dependencies(code)
for dep in dependencies:
if dep not in self.dependency_graph:
self.dependency_graph[dep] = []
self.dependency_graph[dep].append(code)
def find_usages(self, symbol):
# O(1) 查找
return self.symbol_index.get(symbol, [])
def find_dependents(self, code):
# O(1) 查找
return self.dependency_graph.get(code, [])
```

##### 6. 数据结构优化#

###### 6.1 数据结构选择

```
bash复制markdown

## 数据结构选择指南

### 数组
- 适合：随机访问、固定大小
- 不适合：频繁插入/删除

### 链表
- 适合：频繁插入/删除
- 不适合：随机访问

### 哈希表
- 适合：快速查找、键值对
- 不适合：有序遍历

### 树
- 适合：有序数据、层次结构
- 不适合：简单数据

### 图
- 适合：关系数据、网络结构
- 不适合：简单线性数据

#### 6.2 优化实现

class OptimizedContextStore:
def __init__(self):
self.file_index = {}  # 文件 -> 内容
self.symbol_index = defaultdict(list)  # 符号 -> 文件列表
self.dependency_graph = defaultdict(set)  # 文件 -> 依赖文件
self.reverse_dependency_graph = defaultdict(set)  # 文件 -> 被依赖文件
def add_file(self, file_path, content):
self.file_index[file_path] = content
symbols = self.extract_symbols(content)
for symbol in symbols:
self.symbol_index[symbol].append(file_path)
dependencies = self.extract_dependencies(content)
for dep in dependencies:
self.dependency_graph[file_path].add(dep)
self.reverse_dependency_graph[dep].add(file_path)
def get_files_by_symbol(self, symbol):
return self.symbol_index.get(symbol, [])
def get_dependents(self, file_path):
return self.reverse_dependency_graph.get(file_path, set())
def get_dependencies(self, file_path):
return self.dependency_graph.get(file_path, set())
```

```
markdown

## 数据结构选择指南

### 数组
- 适合：随机访问、固定大小
- 不适合：频繁插入/删除

### 链表
- 适合：频繁插入/删除
- 不适合：随机访问

### 哈希表
- 适合：快速查找、键值对
- 不适合：有序遍历

### 树
- 适合：有序数据、层次结构
- 不适合：简单数据

### 图
- 适合：关系数据、网络结构
- 不适合：简单线性数据

#### 6.2 优化实现

class OptimizedContextStore:
def __init__(self):
self.file_index = {}  # 文件 -> 内容
self.symbol_index = defaultdict(list)  # 符号 -> 文件列表
self.dependency_graph = defaultdict(set)  # 文件 -> 依赖文件
self.reverse_dependency_graph = defaultdict(set)  # 文件 -> 被依赖文件
def add_file(self, file_path, content):
self.file_index[file_path] = content
symbols = self.extract_symbols(content)
for symbol in symbols:
self.symbol_index[symbol].append(file_path)
dependencies = self.extract_dependencies(content)
for dep in dependencies:
self.dependency_graph[file_path].add(dep)
self.reverse_dependency_graph[dep].add(file_path)
def get_files_by_symbol(self, symbol):
return self.symbol_index.get(symbol, [])
def get_dependents(self, file_path):
return self.reverse_dependency_graph.get(file_path, set())
def get_dependencies(self, file_path):
return self.dependency_graph.get(file_path, set())
```

#### 性能监控#

##### 1. 指标收集#

###### 1.1 性能指标

```
bash复制python

class PerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)

    def record_execution_time(self, skill_name, duration):
        self.metrics[f"{skill_name}_execution_time"].append({
            "value": duration,
            "timestamp": datetime.now()
        })

    def record_memory_usage(self, skill_name, memory_mb):
        self.metrics[f"{skill_name}_memory_usage"].append({
            "value": memory_mb,
            "timestamp": datetime.now()
        })

    def record_cache_hit_rate(self, cache_name, hit_rate):
        self.metrics[f"{cache_name}_hit_rate"].append({
            "value": hit_rate,
            "timestamp": datetime.now()
        })

    def get_average(self, metric_name):
        values = [m["value"] for m in self.metrics[metric_name]]
        return sum(values) / len(values) if values else 0

    def get_percentile(self, metric_name, percentile):
        values = sorted([m["value"] for m in self.metrics[metric_name]])
        if not values:
            return 0
        index = int(len(values) * percentile / 100)
        return values[index]

#### 1.2 实时监控

class RealTimeMonitor:
def __init__(self, interval=1):
self.interval = interval
self.running = False
self.callbacks = []
def add_callback(self, callback):
self.callbacks.append(callback)
async def start(self):
self.running = True
while self.running:
metrics = self.collect_metrics()
for callback in self.callbacks:
await callback(metrics)
await asyncio.sleep(self.interval)
def stop(self):
self.running = False
def collect_metrics(self):
return {
"cpu_usage": psutil.cpu_percent(),
"memory_usage": psutil.virtual_memory().percent,
"disk_io": psutil.disk_io_counters(),
"network_io": psutil.net_io_counters()
}
```

```
python

class PerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)

    def record_execution_time(self, skill_name, duration):
        self.metrics[f"{skill_name}_execution_time"].append({
            "value": duration,
            "timestamp": datetime.now()
        })

    def record_memory_usage(self, skill_name, memory_mb):
        self.metrics[f"{skill_name}_memory_usage"].append({
            "value": memory_mb,
            "timestamp": datetime.now()
        })

    def record_cache_hit_rate(self, cache_name, hit_rate):
        self.metrics[f"{cache_name}_hit_rate"].append({
            "value": hit_rate,
            "timestamp": datetime.now()
        })

    def get_average(self, metric_name):
        values = [m["value"] for m in self.metrics[metric_name]]
        return sum(values) / len(values) if values else 0

    def get_percentile(self, metric_name, percentile):
        values = sorted([m["value"] for m in self.metrics[metric_name]])
        if not values:
            return 0
        index = int(len(values) * percentile / 100)
        return values[index]

#### 1.2 实时监控

class RealTimeMonitor:
def __init__(self, interval=1):
self.interval = interval
self.running = False
self.callbacks = []
def add_callback(self, callback):
self.callbacks.append(callback)
async def start(self):
self.running = True
while self.running:
metrics = self.collect_metrics()
for callback in self.callbacks:
await callback(metrics)
await asyncio.sleep(self.interval)
def stop(self):
self.running = False
def collect_metrics(self):
return {
"cpu_usage": psutil.cpu_percent(),
"memory_usage": psutil.virtual_memory().percent,
"disk_io": psutil.disk_io_counters(),
"network_io": psutil.net_io_counters()
}
```

##### 2. 性能分析#

###### 2.1 瓶颈识别

```
bash复制python

class BottleneckAnalyzer:
    def __init__(self):
        self.execution_times = defaultdict(list)
        self.call_counts = defaultdict(int)

    def record_call(self, skill_name, duration):
        self.execution_times[skill_name].append(duration)
        self.call_counts[skill_name] += 1

    def analyze(self):
        report = {}

        for skill_name in self.execution_times:
            times = self.execution_times[skill_name]
            call_count = self.call_counts[skill_name]

            report[skill_name] = {
                "total_time": sum(times),
                "average_time": sum(times) / len(times),
                "max_time": max(times),
                "min_time": min(times),
                "call_count": call_count,
                "time_percentage": self.calculate_percentage(skill_name)
            }

        return report

    def calculate_percentage(self, skill_name):
        total_time = sum(sum(times) for times in self.execution_times.values())
        skill_time = sum(self.execution_times[skill_name])
        return (skill_time / total_time * 100) if total_time > 0 else 0

#### 2.2 性能报告

class PerformanceReporter:
def __init__(self):
self.analyzer = BottleneckAnalyzer()
def generate_report(self):
analysis = self.analyzer.analyze()
report = []
report.append("# Performance Report")
report.append(f"Generated: {datetime.now()}")
report.append("")
report.append("## Execution Summary")
for skill_name, metrics in sorted(
analysis.items(),
key=lambda x: x[1]["total_time"],
reverse=True
):
report.append(f"\n### {skill_name}")
report.append(f"- Total Time: {metrics['total_time']:.2f}s")
report.append(f"- Average Time: {metrics['average_time']:.2f}s")
report.append(f"- Max Time: {metrics['max_time']:.2f}s")
report.append(f"- Call Count: {metrics['call_count']}")
report.append(f"- Time Percentage: {metrics['time_percentage']:.2f}%")
return "\n".join(report)
```

```
python

class BottleneckAnalyzer:
    def __init__(self):
        self.execution_times = defaultdict(list)
        self.call_counts = defaultdict(int)

    def record_call(self, skill_name, duration):
        self.execution_times[skill_name].append(duration)
        self.call_counts[skill_name] += 1

    def analyze(self):
        report = {}

        for skill_name in self.execution_times:
            times = self.execution_times[skill_name]
            call_count = self.call_counts[skill_name]

            report[skill_name] = {
                "total_time": sum(times),
                "average_time": sum(times) / len(times),
                "max_time": max(times),
                "min_time": min(times),
                "call_count": call_count,
                "time_percentage": self.calculate_percentage(skill_name)
            }

        return report

    def calculate_percentage(self, skill_name):
        total_time = sum(sum(times) for times in self.execution_times.values())
        skill_time = sum(self.execution_times[skill_name])
        return (skill_time / total_time * 100) if total_time > 0 else 0

#### 2.2 性能报告

class PerformanceReporter:
def __init__(self):
self.analyzer = BottleneckAnalyzer()
def generate_report(self):
analysis = self.analyzer.analyze()
report = []
report.append("# Performance Report")
report.append(f"Generated: {datetime.now()}")
report.append("")
report.append("## Execution Summary")
for skill_name, metrics in sorted(
analysis.items(),
key=lambda x: x[1]["total_time"],
reverse=True
):
report.append(f"\n### {skill_name}")
report.append(f"- Total Time: {metrics['total_time']:.2f}s")
report.append(f"- Average Time: {metrics['average_time']:.2f}s")
report.append(f"- Max Time: {metrics['max_time']:.2f}s")
report.append(f"- Call Count: {metrics['call_count']}")
report.append(f"- Time Percentage: {metrics['time_percentage']:.2f}%")
return "\n".join(report)
```

#### 优化实践#

##### 1. 代码审查优化#

###### 1.1 优化策略

```
bash复制markdown

## 代码审查优化

### 增量审查
- 只审查变更的文件
- 复用之前的审查结果
- 使用文件哈希检测变更

### 并行审查
- 并行审查多个文件
- 使用线程池加速
- 合理分配资源

### 缓存结果
- 缓存审查结果
- 使用多级缓存
- 设置合理的 TTL

### 智能过滤
- 过滤无关文件
- 优先审查重要文件
- 使用规则引擎

#### 1.2 实现示例

class OptimizedCodeReview:
def __init__(self):
self.cache = MultiLevelCache()
self.change_detector = ChangeDetector()
self.executor = ParallelSkillExecutor()
async def review(self, files):
# 检测变更
changes = self.change_detector.detect_file_changes(files)
# 只审查变更的文件
changed_files = [c["file"] for c in changes if c["type"] in ["added", "modified"]]
# 并行审查
tasks = [self.review_file(file) for file in changed_files]
results = await self.executor.execute_parallel(tasks)
return results
async def review_file(self, file_path):
# 检查缓存
cache_key = self.generate_cache_key(file_path)
cached_result = await self.cache.get(cache_key)
if cached_result:
return cached_result
# 执行审查
result = await self.execute_review(file_path)
# 缓存结果
await self.cache.set(cache_key, result)
return result
```

```
markdown

## 代码审查优化

### 增量审查
- 只审查变更的文件
- 复用之前的审查结果
- 使用文件哈希检测变更

### 并行审查
- 并行审查多个文件
- 使用线程池加速
- 合理分配资源

### 缓存结果
- 缓存审查结果
- 使用多级缓存
- 设置合理的 TTL

### 智能过滤
- 过滤无关文件
- 优先审查重要文件
- 使用规则引擎

#### 1.2 实现示例

class OptimizedCodeReview:
def __init__(self):
self.cache = MultiLevelCache()
self.change_detector = ChangeDetector()
self.executor = ParallelSkillExecutor()
async def review(self, files):
# 检测变更
changes = self.change_detector.detect_file_changes(files)
# 只审查变更的文件
changed_files = [c["file"] for c in changes if c["type"] in ["added", "modified"]]
# 并行审查
tasks = [self.review_file(file) for file in changed_files]
results = await self.executor.execute_parallel(tasks)
return results
async def review_file(self, file_path):
# 检查缓存
cache_key = self.generate_cache_key(file_path)
cached_result = await self.cache.get(cache_key)
if cached_result:
return cached_result
# 执行审查
result = await self.execute_review(file_path)
# 缓存结果
await self.cache.set(cache_key, result)
return result
```

##### 2. 文档生成优化#

###### 2.1 优化策略

```
bash复制markdown

## 文档生成优化

### 增量生成
- 只生成变更的文档
- 复用未变更的部分
- 使用差异算法

### 模板缓存
- 缓存文档模板
- 预编译模板
- 使用高效的模板引擎

### 批量处理
- 批量生成文档
- 减少文件 I/O
- 使用流式写入

### 压缩输出
- 压缩生成的文档
- 使用高效的压缩算法
- 支持流式压缩

#### 2.2 实现示例

class OptimizedDocGenerator:
def __init__(self):
self.template_cache = LRUCache(maxsize=50)
self.diff_calculator = DiffCalculator()
async def generate_docs(self, files, previous_docs=None):
if previous_docs is None:
return await self.full_generate(files)
# 计算差异
diffs = self.diff_calculator.calculate_diffs(files, previous_docs)
# 只生成变更的部分
results = {}
for file_path, diff in diffs.items():
if diff["changed"]:
results[file_path] = await self.generate_doc(file_path)
else:
results[file_path] = previous_docs[file_path]
return results
async def generate_doc(self, file_path):
# 获取模板
template = await self.get_template(file_path)
# 生成文档
content = await self.render_template(template, file_path)
return content
async def get_template(self, file_path):
template_name = self.get_template_name(file_path)
if template_name in self.template_cache:
return self.template_cache[template_name]
template = await self.load_template(template_name)
self.template_cache[template_name] = template
return template
```

```
markdown

## 文档生成优化

### 增量生成
- 只生成变更的文档
- 复用未变更的部分
- 使用差异算法

### 模板缓存
- 缓存文档模板
- 预编译模板
- 使用高效的模板引擎

### 批量处理
- 批量生成文档
- 减少文件 I/O
- 使用流式写入

### 压缩输出
- 压缩生成的文档
- 使用高效的压缩算法
- 支持流式压缩

#### 2.2 实现示例

class OptimizedDocGenerator:
def __init__(self):
self.template_cache = LRUCache(maxsize=50)
self.diff_calculator = DiffCalculator()
async def generate_docs(self, files, previous_docs=None):
if previous_docs is None:
return await self.full_generate(files)
# 计算差异
diffs = self.diff_calculator.calculate_diffs(files, previous_docs)
# 只生成变更的部分
results = {}
for file_path, diff in diffs.items():
if diff["changed"]:
results[file_path] = await self.generate_doc(file_path)
else:
results[file_path] = previous_docs[file_path]
return results
async def generate_doc(self, file_path):
# 获取模板
template = await self.get_template(file_path)
# 生成文档
content = await self.render_template(template, file_path)
return content
async def get_template(self, file_path):
template_name = self.get_template_name(file_path)
if template_name in self.template_cache:
return self.template_cache[template_name]
template = await self.load_template(template_name)
self.template_cache[template_name] = template
return template
```

##### 3. 测试生成优化#

###### 3.1 优化策略

```
bash复制markdown

## 测试生成优化

### 智能分析
- 分析代码覆盖率
- 识别未测试的路径
- 优先生成关键测试

### 测试去重
- 检测重复测试
- 合并相似测试
- 优化测试套件

### 并行执行
- 并行运行测试
- 使用测试分片
- 优化测试顺序

### 缓存测试结果
- 缓存测试结果
- 使用快照
- 支持增量测试

#### 3.2 实现示例

class OptimizedTestGenerator:
def __init__(self):
self.coverage_analyzer = CoverageAnalyzer()
self.test_deduplicator = TestDeduplicator()
self.result_cache = ResultCache()
async def generate_tests(self, files):
# 分析覆盖率
coverage = await self.coverage_analyzer.analyze(files)
# 识别需要测试的代码
untested_code = coverage.get_untested_code()
# 生成测试
tests = []
for code in untested_code:
test = await self.generate_test(code)
tests.append(test)
# 去重
unique_tests = self.test_deduplicator.deduplicate(tests)
return unique_tests
async def generate_test(self, code):
# 检查缓存
cache_key = self.generate_cache_key(code)
cached_test = await self.result_cache.get(cache_key)
if cached_test:
return cached_test
# 生成测试
test = await self.create_test(code)
# 缓存结果
await self.result_cache.set(cache_key, test)
return test

```
```

```
markdown

## 测试生成优化

### 智能分析
- 分析代码覆盖率
- 识别未测试的路径
- 优先生成关键测试

### 测试去重
- 检测重复测试
- 合并相似测试
- 优化测试套件

### 并行执行
- 并行运行测试
- 使用测试分片
- 优化测试顺序

### 缓存测试结果
- 缓存测试结果
- 使用快照
- 支持增量测试

#### 3.2 实现示例

class OptimizedTestGenerator:
def __init__(self):
self.coverage_analyzer = CoverageAnalyzer()
self.test_deduplicator = TestDeduplicator()
self.result_cache = ResultCache()
async def generate_tests(self, files):
# 分析覆盖率
coverage = await self.coverage_analyzer.analyze(files)
# 识别需要测试的代码
untested_code = coverage.get_untested_code()
# 生成测试
tests = []
for code in untested_code:
test = await self.generate_test(code)
tests.append(test)
# 去重
unique_tests = self.test_deduplicator.deduplicate(tests)
return unique_tests
async def generate_test(self, code):
# 检查缓存
cache_key = self.generate_cache_key(code)
cached_test = await self.result_cache.get(cache_key)
if cached_test:
return cached_test
# 生成测试
test = await self.create_test(code)
# 缓存结果
await self.result_cache.set(cache_key, test)
return test

```
```

---

# 第 16 章

## 1 Skills 创建方式

**URL**: https://claudecode.tangshuang.net/course/16.1%20Skills%20%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F

#### Skills 创建方式概述#

Claude Code 提供了多种创建 Skills 的方式，从简单的自然语言描述到复杂的编程实现，满足不同场景和技能水平的需求。本节将详细介绍各种创建方式及其适用场景。

#### 创建方式分类#

##### 1. 自然语言描述#

###### 1.1 基本描述

```
markdown复制## Skill: 代码审查

### 功能
自动审查代码质量，检查安全性、性能和最佳实践。

### 输入
- 代码文件路径
- 审查标准（可选）
- 严格程度（可选）

### 执行步骤
1. 读取代码文件
2. 分析代码结构
3. 检查安全问题
4. 评估代码质量
5. 生成审查报告

### 输出
- 审查报告
- 问题列表
- 改进建议
```

```
## Skill: 代码审查

### 功能
自动审查代码质量，检查安全性、性能和最佳实践。

### 输入
- 代码文件路径
- 审查标准（可选）
- 严格程度（可选）

### 执行步骤
1. 读取代码文件
2. 分析代码结构
3. 检查安全问题
4. 评估代码质量
5. 生成审查报告

### 输出
- 审查报告
- 问题列表
- 改进建议
```

###### 1.2 详细描述

```
markdown复制## Skill: API 端点生成

### 目标
根据数据模型自动生成 REST API 端点

### 功能描述
本 Skill 能够分析数据模型定义，自动生成符合 RESTful 规范的 API 端点，包括路由定义、控制器逻辑、输入验证和响应格式。

### 输入参数
- `model_file`: 数据模型文件路径（必需）
- `framework`: 使用的框架（可选，默认：Flask）
- `output_dir`: 输出目录（可选，默认：./api）
- `include_tests`: 是否生成测试（可选，默认：true）

### 执行流程
1. **模型分析阶段**
   - 读取数据模型文件
   - 解析模型定义
   - 识别字段和关系

2. **端点生成阶段**
   - 为每个模型生成 CRUD 端点
   - 创建路由定义
   - 实现控制器逻辑

3. **验证实现阶段**
   - 添加输入验证
   - 实现数据验证规则
   - 生成验证错误处理

4. **文档生成阶段**
   - 生成 API 文档
   - 添加端点说明
   - 提供示例代码

5. **测试生成阶段**
   - 生成单元测试
   - 创建集成测试
   - 添加测试数据

### 输出内容
- 路由文件（routes.py）
- 控制器文件（controllers.py）
- 验证文件（validators.py）
- API 文档（api.md）
- 测试文件（test_api.py）

### 示例

输入：
```python
class User:
    id: int
    name: str
    email: str
    created_at: datetime
```

```
## Skill: API 端点生成

### 目标
根据数据模型自动生成 REST API 端点

### 功能描述
本 Skill 能够分析数据模型定义，自动生成符合 RESTful 规范的 API 端点，包括路由定义、控制器逻辑、输入验证和响应格式。

### 输入参数
- `model_file`: 数据模型文件路径（必需）
- `framework`: 使用的框架（可选，默认：Flask）
- `output_dir`: 输出目录（可选，默认：./api）
- `include_tests`: 是否生成测试（可选，默认：true）

### 执行流程
1. **模型分析阶段**
   - 读取数据模型文件
   - 解析模型定义
   - 识别字段和关系

2. **端点生成阶段**
   - 为每个模型生成 CRUD 端点
   - 创建路由定义
   - 实现控制器逻辑

3. **验证实现阶段**
   - 添加输入验证
   - 实现数据验证规则
   - 生成验证错误处理

4. **文档生成阶段**
   - 生成 API 文档
   - 添加端点说明
   - 提供示例代码

5. **测试生成阶段**
   - 生成单元测试
   - 创建集成测试
   - 添加测试数据

### 输出内容
- 路由文件（routes.py）
- 控制器文件（controllers.py）
- 验证文件（validators.py）
- API 文档（api.md）
- 测试文件（test_api.py）

### 示例

输入：
```python
class User:
    id: int
    name: str
    email: str
    created_at: datetime
```

```
python复制# routes.py
from flask import Blueprint, request, jsonify
from datetime import datetime

users_bp = Blueprint('users', __name__)

@users_bp.route('/users', methods=['GET'])
def get_users():
    """获取用户列表"""
    users = User.query.all()
    return jsonify([{
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    } for user in users])

@users_bp.route('/users/<int:id>', methods=['GET'])
def get_user(id):
```

```
# routes.py
from flask import Blueprint, request, jsonify
from datetime import datetime

users_bp = Blueprint('users', __name__)

@users_bp.route('/users', methods=['GET'])
def get_users():
    """获取用户列表"""
    users = User.query.all()
    return jsonify([{
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    } for user in users])

@users_bp.route('/users/<int:id>', methods=['GET'])
def get_user(id):
```

```
bash复制"""获取单个用户"""
user = User.query.get_or_404(id)
return jsonify({
    'id': user.id,
    'name': user.name,
    'email': user.email,
    'created_at': user.created_at.isoformat()
})
```

```
"""获取单个用户"""
user = User.query.get_or_404(id)
return jsonify({
    'id': user.id,
    'name': user.name,
    'email': user.email,
    'created_at': user.created_at.isoformat()
})
```

@users_bp.route('/users', methods=['POST'])
def create_user():
"""创建新用户"""
data = request.get_json()
user = User(
name=data['name'],
email=data['email']
)
from flask_sqlalchemy import SQLAlchemy
db.session.add(user)
db.session.commit()
return jsonify({
'id': user.id,
'name': user.name,
'email': user.email,
'created_at': user.created_at.isoformat()
}), 201

@users_bp.route('/users/int:id', methods=['PUT'])
def update_user(id):
"""更新用户信息"""
user = User.query.get_or_404(id)
data = request.get_json()
user.name = data.get('name', user.name)
user.email = data.get('email', user.email)
db.session.commit()
return jsonify({
'id': user.id,
'name': user.name,
'email': user.email,
'created_at': user.created_at.isoformat()
})

@users_bp.route('/users/int:id', methods=['DELETE'])
def delete_user(id):
"""删除用户"""
user = User.query.get_or_404(id)
db.session.delete(user)
db.session.commit()
return '', 204

##### 2. 示例驱动#

###### 2.1 输入输出示例

```
markdown复制## Skill: 代码格式化

### 功能
根据项目规范自动格式化代码

### 输入示例
```

```
## Skill: 代码格式化

### 功能
根据项目规范自动格式化代码

### 输入示例
```

def calculate_sum(numbers):
total=0
for n in numbers:
total+=n
return total

```
bash复制
### 输出示例
```

```
### 输出示例
```

def calculate_sum(numbers):
total = 0
for n in numbers:
total += n
return total

```
bash复制
### 变换规则
- 运算符周围添加空格
- 逗号后添加空格
- 缩进使用 4 个空格
- 函数定义后添加空行

### 2.2 多示例学习

```markdown
## Skill: 函数重构

### 功能
将复杂函数重构为更小的、可维护的函数

### 示例 1
```python
# 输入
def process_user_data(data):
    if not data:
        return None
    user = User()
    user.name = data.get('name')
    user.email = data.get('email')
    if not user.email:
        raise ValueError('Email is required')
    user.age = data.get('age', 0)
    if user.age < 0:
        raise ValueError('Age must be positive')
    return user
```

```
### 变换规则
- 运算符周围添加空格
- 逗号后添加空格
- 缩进使用 4 个空格
- 函数定义后添加空行

### 2.2 多示例学习

```markdown
## Skill: 函数重构

### 功能
将复杂函数重构为更小的、可维护的函数

### 示例 1
```python
# 输入
def process_user_data(data):
    if not data:
        return None
    user = User()
    user.name = data.get('name')
    user.email = data.get('email')
    if not user.email:
        raise ValueError('Email is required')
    user.age = data.get('age', 0)
    if user.age < 0:
        raise ValueError('Age must be positive')
    return user
```

```
python复制# 输出
def validate_email(email):
    if not email:
        raise ValueError('Email is required')
    return email

def validate_age(age):
    if age < 0:
        raise ValueError('Age must be positive')
    return age

def create_user_from_data(data):
    if not data:
        return None

    user = User()
    user.name = data.get('name')
    user.email = validate_email(data.get('email'))
    user.age = validate_age(data.get('age', 0))

    return user
```

```
# 输出
def validate_email(email):
    if not email:
        raise ValueError('Email is required')
    return email

def validate_age(age):
    if age < 0:
        raise ValueError('Age must be positive')
    return age

def create_user_from_data(data):
    if not data:
        return None

    user = User()
    user.name = data.get('name')
    user.email = validate_email(data.get('email'))
    user.age = validate_age(data.get('age', 0))

    return user
```

##### 示例 2#

```
python复制# 输入
def calculate_price(items):
    total = 0
    for item in items:
        if item['type'] == 'book':
            total += item['price'] * 0.9
        elif item['type'] == 'food':
            total += item['price'] * 0.95
        else:
            total += item['price']
    return total
```

```
# 输入
def calculate_price(items):
    total = 0
    for item in items:
        if item['type'] == 'book':
            total += item['price'] * 0.9
        elif item['type'] == 'food':
            total += item['price'] * 0.95
        else:
            total += item['price']
    return total
```

```
python复制# 输出
def apply_discount(item):
    if item['type'] == 'book':
        return item['price'] * 0.9
    elif item['type'] == 'food':
        return item['price'] * 0.95
    else:
        return item['price']

def calculate_price(items):
    total = 0
    for item in items:
        total += apply_discount(item)
    return total
```

```
# 输出
def apply_discount(item):
    if item['type'] == 'book':
        return item['price'] * 0.9
    elif item['type'] == 'food':
        return item['price'] * 0.95
    else:
        return item['price']

def calculate_price(items):
    total = 0
    for item in items:
        total += apply_discount(item)
    return total
```

```
bash复制
#### 3.1 模板定义

```markdown
## Skill: 文件生成模板

### 模板内容
```

```
#### 3.1 模板定义

```markdown
## Skill: 文件生成模板

### 模板内容
```

### {{file_name}}

### Generated by Claude Code Skill

### Date: {{date}}

import {{imports}}

class {{class_name}}:
"""{{class_description}}"""

```
bash复制def __init__(self{{init_params}}):
    """Initialize {{class_name}}"""
    {{init_body}}

def {{method_name}}(self{{method_params}}):
    """{{method_description}}"""
    {{method_body}}
```

```
def __init__(self{{init_params}}):
    """Initialize {{class_name}}"""
    {{init_body}}

def {{method_name}}(self{{method_params}}):
    """{{method_description}}"""
    {{method_body}}
```

```
bash复制
### 变量说明
- `file_name`: 文件名
- `date`: 生成日期
- `imports`: 导入语句
- `class_name`: 类名
- `class_description`: 类描述
- `init_params`: 初始化参数
- `init_body`: 初始化方法体
- `method_name`: 方法名
- `method_params`: 方法参数
- `method_description`: 方法描述
- `method_body`: 方法体
```

```
### 变量说明
- `file_name`: 文件名
- `date`: 生成日期
- `imports`: 导入语句
- `class_name`: 类名
- `class_description`: 类描述
- `init_params`: 初始化参数
- `init_body`: 初始化方法体
- `method_name`: 方法名
- `method_params`: 方法参数
- `method_description`: 方法描述
- `method_body`: 方法体
```

###### 3.2 模板使用

```
markdown复制## Skill: 模型生成

### 使用模板
```

```
## Skill: 模型生成

### 使用模板
```

### user.py

### Generated by Claude Code Skill

### Date: 2024-01-15

from datetime import datetime
from typing import Optional

class User:
"""User model representing a user in the system"""

```
bash复制def __init__(self, id: int, name: str, email: str, created_at: Optional[datetime] = None):
    """Initialize User"""
    self.id = id
    self.name = name
    self.email = email
    self.created_at = created_at or datetime.now()

def validate(self):
    """Validate user data"""
    if not self.email:
        raise ValueError("Email is required")
    if not self.name:
        raise ValueError("Name is required")
```

```
def __init__(self, id: int, name: str, email: str, created_at: Optional[datetime] = None):
    """Initialize User"""
    self.id = id
    self.name = name
    self.email = email
    self.created_at = created_at or datetime.now()

def validate(self):
    """Validate user data"""
    if not self.email:
        raise ValueError("Email is required")
    if not self.name:
        raise ValueError("Name is required")
```

```
bash复制
### 参数映射
```json
{
  "file_name": "user.py",
  "date": "2024-01-15",
  "imports": "from datetime import datetime\nfrom typing import Optional",
  "class_name": "User",
  "class_description": "User model representing a user in the system",
  "init_params": ", id: int, name: str, email: str, created_at: Optional[datetime] = None",
  "init_body": "self.id = id\n        self.name = name\n        self.email = email\n        self.created_at = created_at or datetime.now()",
  "method_name": "validate",
  "method_params": "",
  "method_description": "Validate user data",
  "method_body": "if not self.email:\n            raise ValueError(\"Email is required\")\n        if not self.name:\n            raise ValueError(\"Name is required\")"
}
```

```
### 参数映射
```json
{
  "file_name": "user.py",
  "date": "2024-01-15",
  "imports": "from datetime import datetime\nfrom typing import Optional",
  "class_name": "User",
  "class_description": "User model representing a user in the system",
  "init_params": ", id: int, name: str, email: str, created_at: Optional[datetime] = None",
  "init_body": "self.id = id\n        self.name = name\n        self.email = email\n        self.created_at = created_at or datetime.now()",
  "method_name": "validate",
  "method_params": "",
  "method_description": "Validate user data",
  "method_body": "if not self.email:\n            raise ValueError(\"Email is required\")\n        if not self.name:\n            raise ValueError(\"Name is required\")"
}
```

##### 4. 编程实现#

###### 4.1 基础实现

```
python复制class CodeReviewSkill:
    def __init__(self):
        self.name = "code-review"
        self.version = "1.0.0"
        self.description = "自动审查代码质量"

    def validate_parameters(self, parameters):
        required = ["file"]
        for param in required:
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")
        return True

    def execute(self, parameters, context):
        # 验证参数
        self.validate_parameters(parameters)

        # 读取文件
        file_path = parameters["file"]
        with open(file_path, 'r') as f:
            code = f.read()

        # 分析代码
        issues = self.analyze_code(code)

        # 生成报告
        report = self.generate_report(issues)

        return report

    def analyze_code(self, code):
        issues = []

        # 检查代码长度
        if len(code) > 1000:
            issues.append({
                "type": "complexity",
                "severity": "medium",
                "message": "代码过长，建议拆分"
            })

        # 检查注释
        if '"""' not in code and "'''" not in code:
            issues.append({
                "type": "documentation",
                "severity": "low",
                "message": "缺少文档字符串"
            })

        return issues

    def generate_report(self, issues):
        report = {
            "total_issues": len(issues),
            "issues": issues,
            "summary": self.generate_summary(issues)
        }
        return report

    def generate_summary(self, issues):
        severity_count = {}
        for issue in issues:
            severity = issue["severity"]
            severity_count[severity] = severity_count.get(severity, 0) + 1
        return severity_count
```

```
class CodeReviewSkill:
    def __init__(self):
        self.name = "code-review"
        self.version = "1.0.0"
        self.description = "自动审查代码质量"

    def validate_parameters(self, parameters):
        required = ["file"]
        for param in required:
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")
        return True

    def execute(self, parameters, context):
        # 验证参数
        self.validate_parameters(parameters)

        # 读取文件
        file_path = parameters["file"]
        with open(file_path, 'r') as f:
            code = f.read()

        # 分析代码
        issues = self.analyze_code(code)

        # 生成报告
        report = self.generate_report(issues)

        return report

    def analyze_code(self, code):
        issues = []

        # 检查代码长度
        if len(code) > 1000:
            issues.append({
                "type": "complexity",
                "severity": "medium",
                "message": "代码过长，建议拆分"
            })

        # 检查注释
        if '"""' not in code and "'''" not in code:
            issues.append({
                "type": "documentation",
                "severity": "low",
                "message": "缺少文档字符串"
            })

        return issues

    def generate_report(self, issues):
        report = {
            "total_issues": len(issues),
            "issues": issues,
            "summary": self.generate_summary(issues)
        }
        return report

    def generate_summary(self, issues):
        severity_count = {}
        for issue in issues:
            severity = issue["severity"]
            severity_count[severity] = severity_count.get(severity, 0) + 1
        return severity_count
```

###### 4.2 高级实现

```
python复制import ast
import re
from typing import List, Dict, Any

class AdvancedCodeReviewSkill:
    def __init__(self):
        self.name = "advanced-code-review"
        self.version = "2.0.0"
        self.description = "高级代码审查"
        self.checkers = [
            SecurityChecker(),
            PerformanceChecker(),
            StyleChecker(),
            ComplexityChecker()
        ]

    def execute(self, parameters, context):
        # 验证参数
        self.validate_parameters(parameters)

        # 读取文件
        file_path = parameters["file"]
        code = self.read_file(file_path)

        # 解析 AST
        tree = ast.parse(code)

        # 运行检查器
        all_issues = []
        for checker in self.checkers:
            issues = checker.check(tree, code, context)
            all_issues.extend(issues)

        # 生成报告
        report = self.generate_report(all_issues, file_path)
        return report

    def read_file(self, file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()

    def generate_report(self, issues, file_path):
        return {
            "file": file_path,
            "total_issues": len(issues),
            "issues_by_severity": self.group_by_severity(issues),
            "issues_by_type": self.group_by_type(issues),
            "issues": issues,
            "recommendations": self.generate_recommendations(issues)
        }

    def group_by_severity(self, issues):
        grouped = {}
        for issue in issues:
            severity = issue["severity"]
            if severity not in grouped:
                grouped[severity] = []
            grouped[severity].append(issue)
        return grouped

    def group_by_type(self, issues):
        grouped = {}
        for issue in issues:
            issue_type = issue["type"]
            if issue_type not in grouped:
                grouped[issue_type] = []
            grouped[issue_type].append(issue)
        return grouped

    def generate_recommendations(self, issues):
        recommendations = []
        for issue in issues:
            if issue["severity"] in ["high", "critical"]:
                recommendations.append({
                    "issue": issue,
                    "priority": "high",
                    "action": self.get_fix_action(issue)
                })
        return recommendations

    def get_fix_action(self, issue):
        actions = {
            "security": "立即修复安全问题",
            "performance": "优化性能瓶颈",
            "style": "调整代码风格",
            "complexity": "简化复杂逻辑"
        }
        return actions.get(issue["type"], "审查并修复")


class SecurityChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查 SQL 注入
        sql_pattern = re.compile(r'execute\(["\'].*\+.*["\']\)')
        if sql_pattern.search(code):
            issues.append({
                "type": "security",
                "severity": "critical",
                "message": "潜在的 SQL 注入漏洞",
                "line": self.find_line(code, sql_pattern)
            })

        # 检查硬编码密码
        password_pattern = re.compile(r'password\s*=\s*["\'][^"\']+["\']')
        if password_pattern.search(code):
            issues.append({
                "type": "security",
                "severity": "high",
                "message": "硬编码密码",
                "line": self.find_line(code, password_pattern)
            })

        return issues

    def find_line(self, code, pattern):
        match = pattern.search(code)
        if match:
            return code[:match.start()].count('\n') + 1
        return 0


class PerformanceChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查循环中的数据库查询
        for node in ast.walk(tree):
            if isinstance(node, ast.For):
                for child in ast.walk(node):
                    if isinstance(child, ast.Call):
                        if self.is_database_call(child):
                            issues.append({
                                "type": "performance",
                                "severity": "high",
                                "message": "循环中的数据库查询",
                                "line": node.lineno
                            })

        return issues

    def is_database_call(self, node):
        # 简化的数据库调用检测
        if isinstance(node.func, ast.Attribute):
            return node.func.attr in ['query', 'execute', 'find']
        return False


class StyleChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查行长度
        for i, line in enumerate(code.split('\n'), 1):
            if len(line) > 100:
                issues.append({
                    "type": "style",
                    "severity": "low",
                    "message": "行过长",
                    "line": i
                })

        return issues

    def calculate_complexity(self, node):
        complexity = 1
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.For, ast.While, ast.Try)):
                complexity += 1
        return complexity

### 5. 组合创建
#### 5.1 混合方式

```markdown
## Skill: 智能代码生成

### 创建方式
- 自然语言描述：定义目标和约束
- 示例驱动：提供输入输出示例
- 模板化：使用代码模板
- 编程实现：实现核心逻辑

### 自然语言描述
根据用户需求生成符合项目规范的代码，包括函数定义、类实现、错误处理和文档。

### 示例驱动
提供多个代码示例，展示不同场景下的生成结果。

### 模板化
使用预定义的代码模板，确保生成的代码符合项目规范。

### 编程实现
实现代码生成逻辑，包括 AST 解析、代码分析和模板渲染。
```

```
import ast
import re
from typing import List, Dict, Any

class AdvancedCodeReviewSkill:
    def __init__(self):
        self.name = "advanced-code-review"
        self.version = "2.0.0"
        self.description = "高级代码审查"
        self.checkers = [
            SecurityChecker(),
            PerformanceChecker(),
            StyleChecker(),
            ComplexityChecker()
        ]

    def execute(self, parameters, context):
        # 验证参数
        self.validate_parameters(parameters)

        # 读取文件
        file_path = parameters["file"]
        code = self.read_file(file_path)

        # 解析 AST
        tree = ast.parse(code)

        # 运行检查器
        all_issues = []
        for checker in self.checkers:
            issues = checker.check(tree, code, context)
            all_issues.extend(issues)

        # 生成报告
        report = self.generate_report(all_issues, file_path)
        return report

    def read_file(self, file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()

    def generate_report(self, issues, file_path):
        return {
            "file": file_path,
            "total_issues": len(issues),
            "issues_by_severity": self.group_by_severity(issues),
            "issues_by_type": self.group_by_type(issues),
            "issues": issues,
            "recommendations": self.generate_recommendations(issues)
        }

    def group_by_severity(self, issues):
        grouped = {}
        for issue in issues:
            severity = issue["severity"]
            if severity not in grouped:
                grouped[severity] = []
            grouped[severity].append(issue)
        return grouped

    def group_by_type(self, issues):
        grouped = {}
        for issue in issues:
            issue_type = issue["type"]
            if issue_type not in grouped:
                grouped[issue_type] = []
            grouped[issue_type].append(issue)
        return grouped

    def generate_recommendations(self, issues):
        recommendations = []
        for issue in issues:
            if issue["severity"] in ["high", "critical"]:
                recommendations.append({
                    "issue": issue,
                    "priority": "high",
                    "action": self.get_fix_action(issue)
                })
        return recommendations

    def get_fix_action(self, issue):
        actions = {
            "security": "立即修复安全问题",
            "performance": "优化性能瓶颈",
            "style": "调整代码风格",
            "complexity": "简化复杂逻辑"
        }
        return actions.get(issue["type"], "审查并修复")


class SecurityChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查 SQL 注入
        sql_pattern = re.compile(r'execute\(["\'].*\+.*["\']\)')
        if sql_pattern.search(code):
            issues.append({
                "type": "security",
                "severity": "critical",
                "message": "潜在的 SQL 注入漏洞",
                "line": self.find_line(code, sql_pattern)
            })

        # 检查硬编码密码
        password_pattern = re.compile(r'password\s*=\s*["\'][^"\']+["\']')
        if password_pattern.search(code):
            issues.append({
                "type": "security",
                "severity": "high",
                "message": "硬编码密码",
                "line": self.find_line(code, password_pattern)
            })

        return issues

    def find_line(self, code, pattern):
        match = pattern.search(code)
        if match:
            return code[:match.start()].count('\n') + 1
        return 0


class PerformanceChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查循环中的数据库查询
        for node in ast.walk(tree):
            if isinstance(node, ast.For):
                for child in ast.walk(node):
                    if isinstance(child, ast.Call):
                        if self.is_database_call(child):
                            issues.append({
                                "type": "performance",
                                "severity": "high",
                                "message": "循环中的数据库查询",
                                "line": node.lineno
                            })

        return issues

    def is_database_call(self, node):
        # 简化的数据库调用检测
        if isinstance(node.func, ast.Attribute):
            return node.func.attr in ['query', 'execute', 'find']
        return False


class StyleChecker:
    def check(self, tree, code, context):
        issues = []

        # 检查行长度
        for i, line in enumerate(code.split('\n'), 1):
            if len(line) > 100:
                issues.append({
                    "type": "style",
                    "severity": "low",
                    "message": "行过长",
                    "line": i
                })

        return issues

    def calculate_complexity(self, node):
        complexity = 1
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.For, ast.While, ast.Try)):
                complexity += 1
        return complexity

### 5. 组合创建
#### 5.1 混合方式

```markdown
## Skill: 智能代码生成

### 创建方式
- 自然语言描述：定义目标和约束
- 示例驱动：提供输入输出示例
- 模板化：使用代码模板
- 编程实现：实现核心逻辑

### 自然语言描述
根据用户需求生成符合项目规范的代码，包括函数定义、类实现、错误处理和文档。

### 示例驱动
提供多个代码示例，展示不同场景下的生成结果。

### 模板化
使用预定义的代码模板，确保生成的代码符合项目规范。

### 编程实现
实现代码生成逻辑，包括 AST 解析、代码分析和模板渲染。
```

###### 5.2 分层实现

```
python复制class HybridCodeGenerator:
    def __init__(self):
        self.description = self.load_description()
        self.examples = self.load_examples()
        self.templates = self.load_templates()
        self.generator = CodeGenerator()

    def execute(self, parameters, context):
        # 1. 理解需求（自然语言）
        requirements = self.understand_requirements(parameters)
        # 2. 查找示例（示例驱动）
        similar_examples = self.find_similar_examples(requirements)
        # 3. 选择模板（模板化）
        template = self.select_template(requirements, similar_examples)
        # 4. 生成代码（编程实现）
        code = self.generator.generate(requirements, template, context)
        # 5. 验证结果
        validated = self.validate_code(code, requirements)
        return validated

    def understand_requirements(self, parameters):
        # 使用自然语言理解解析需求
        pass

    def find_similar_examples(self, requirements):
        # 查找相似的示例
        pass

    def select_template(self, requirements, examples):
        # 选择合适的模板
        pass

    def validate_code(self, code, requirements):
        # 验证生成的代码
        pass
```

```
class HybridCodeGenerator:
    def __init__(self):
        self.description = self.load_description()
        self.examples = self.load_examples()
        self.templates = self.load_templates()
        self.generator = CodeGenerator()

    def execute(self, parameters, context):
        # 1. 理解需求（自然语言）
        requirements = self.understand_requirements(parameters)
        # 2. 查找示例（示例驱动）
        similar_examples = self.find_similar_examples(requirements)
        # 3. 选择模板（模板化）
        template = self.select_template(requirements, similar_examples)
        # 4. 生成代码（编程实现）
        code = self.generator.generate(requirements, template, context)
        # 5. 验证结果
        validated = self.validate_code(code, requirements)
        return validated

    def understand_requirements(self, parameters):
        # 使用自然语言理解解析需求
        pass

    def find_similar_examples(self, requirements):
        # 查找相似的示例
        pass

    def select_template(self, requirements, examples):
        # 选择合适的模板
        pass

    def validate_code(self, code, requirements):
        # 验证生成的代码
        pass
```

#### 创建流程#

##### 1. 需求分析#

```
markdown复制## 需求分析步骤

### 1.1 明确目标
- Skill 要解决什么问题？
- 预期的输入和输出是什么？
- 有什么特殊要求？

### 1.2 确定范围
- Skill 的功能边界在哪里？
- 需要支持哪些场景？
- 有什么限制条件？

### 1.3 评估可行性
- 技术上是否可行？
- 需要什么资源？
- 有什么风险？
```

```
## 需求分析步骤

### 1.1 明确目标
- Skill 要解决什么问题？
- 预期的输入和输出是什么？
- 有什么特殊要求？

### 1.2 确定范围
- Skill 的功能边界在哪里？
- 需要支持哪些场景？
- 有什么限制条件？

### 1.3 评估可行性
- 技术上是否可行？
- 需要什么资源？
- 有什么风险？
```

##### 2. 设计 Skill#

```
markdown复制## Skill 设计步骤

### 2.1 定义接口
- 输入参数
- 输出格式
- 错误处理

### 2.2 设计流程
- 执行步骤
- 决策点
- 异常处理

### 2.3 选择实现方式
- 自然语言描述
- 示例驱动
- 模板化
- 编程实现
- 组合方式
```

```
## Skill 设计步骤

### 2.1 定义接口
- 输入参数
- 输出格式
- 错误处理

### 2.2 设计流程
- 执行步骤
- 决策点
- 异常处理

### 2.3 选择实现方式
- 自然语言描述
- 示例驱动
- 模板化
- 编程实现
- 组合方式
```

##### 3. 实现 Skill#

```
markdown复制## Skill 实现步骤

### 3.1 基础实现
- 实现 Skill 框架
- 实现基本功能
- 添加错误处理

### 3.2 功能完善
- 添加高级功能
- 优化性能
- 改进用户体验

### 3.3 测试验证
- 单元测试
- 集成测试
- 性能测试
```

```
## Skill 实现步骤

### 3.1 基础实现
- 实现 Skill 框架
- 实现基本功能
- 添加错误处理

### 3.2 功能完善
- 添加高级功能
- 优化性能
- 改进用户体验

### 3.3 测试验证
- 单元测试
- 集成测试
- 性能测试
```

##### 4. 部署使用#

```
markdown复制## Skill 部署步骤

### 4.1 注册 Skill
- 添加到 Skill 库
- 配置元数据
- 设置权限

### 4.2 测试运行
- 功能测试
- 性能测试
- 用户测试

### 4.3 文档编写
- 使用说明
- API 文档
- 示例代码
```

```
## Skill 部署步骤

### 4.1 注册 Skill
- 添加到 Skill 库
- 配置元数据
- 设置权限

### 4.2 测试运行
- 功能测试
- 性能测试
- 用户测试

### 4.3 文档编写
- 使用说明
- API 文档
- 示例代码
```

#### 最佳实践#

##### 1. 简单场景#

```
markdown复制## 简单场景建议

### 使用自然语言描述
- 任务简单明确
- 逻辑不复杂
- 不需要精确控制

### 示例
代码格式化、简单文本处理、基础代码生成
```

```
## 简单场景建议

### 使用自然语言描述
- 任务简单明确
- 逻辑不复杂
- 不需要精确控制

### 示例
代码格式化、简单文本处理、基础代码生成
```

##### 2. 中等复杂度#

```
markdown复制## 中等复杂度建议

### 使用示例驱动
- 需要展示模式
- 有多个变体
- 需要学习示例

### 示例
代码重构、模式应用、风格转换
```

```
## 中等复杂度建议

### 使用示例驱动
- 需要展示模式
- 有多个变体
- 需要学习示例

### 示例
代码重构、模式应用、风格转换
```

##### 3. 高复杂度#

```
markdown复制## 高复杂度建议

### 使用编程实现
- 需要精确控制
- 逻辑复杂
- 性能要求高

### 示例
复杂代码分析、性能优化、安全审计
```

```
## 高复杂度建议

### 使用编程实现
- 需要精确控制
- 逻辑复杂
- 性能要求高

### 示例
复杂代码分析、性能优化、安全审计
```

##### 4. 需要灵活性#

```
markdown复制## 需要灵活性建议

### 使用组合方式
- 需要多种能力
- 场景多变
- 需要适应性强

### 示例
智能代码生成、自动化工作流、复杂任务编排
```

```
## 需要灵活性建议

### 使用组合方式
- 需要多种能力
- 场景多变
- 需要适应性强

### 示例
智能代码生成、自动化工作流、复杂任务编排
```

---

## 2 Skills 配置选项

**URL**: https://claudecode.tangshuang.net/course/16.2%20Skills%20%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9

#### 配置选项概述#

Skills 提供了丰富的配置选项，允许用户根据具体需求定制 Skills 的行为。本节将详细介绍各种配置选项及其使用方法。

#### 配置层级#

##### 1. 全局配置#

###### 1.1 配置文件位置

#### 全局配置文件#

##### 文件位置#

- Linux/macOS: ~/.claude/config.yaml
- Windows: %USERPROFILE%.claude\config.yaml

##### 配置示例#

```
yaml复制# Claude Code 全局配置
version: "1.0"

skills:
  # 全局 Skill 设置
  default_timeout: 300
  max_retries: 3
  log_level: INFO

  # 默认参数
  defaults:
    code-review:
      strict: false
      include_security: true

    generate-tests:
      framework: pytest
      coverage_target: 80
```

```
# Claude Code 全局配置
version: "1.0"

skills:
  # 全局 Skill 设置
  default_timeout: 300
  max_retries: 3
  log_level: INFO

  # 默认参数
  defaults:
    code-review:
      strict: false
      include_security: true

    generate-tests:
      framework: pytest
      coverage_target: 80
```

###### 1.2 全局配置项

```
yaml复制# 全局配置项详解
skills:
  # 执行配置
  execution:
    timeout: 300              # 默认超时时间（秒）
    max_concurrent: 4         # 最大并发数
    retry_policy:
      max_attempts: 3         # 最大重试次数
      backoff: exponential    # 退避策略：linear, exponential
      initial_delay: 1        # 初始延迟（秒）

  # 缓存配置
  cache:
    enabled: true             # 是否启用缓存
    ttl: 3600                 # 缓存生存时间（秒）
    max_size: 1000            # 最大缓存条目数
    storage: memory           # 存储类型：memory, disk, redis

  # 日志配置
  logging:
    level: INFO               # 日志级别：DEBUG, INFO, WARNING, ERROR
    format: text              # 日志格式：text, json
    output: console           # 输出位置：console, file, both
    file_path: /tmp/claude-skills.log

  # 性能配置
  performance:
    enable_profiling: false   # 是否启用性能分析
    profile_interval: 60      # 性能分析间隔（秒）
    memory_limit: 1024        # 内存限制（MB）

  # 安全配置
  security:
    validate_inputs: true     # 是否验证输入
    sanitize_outputs: true    # 是否清理输出
    allow_network: false      # 是否允许网络访问
```

```
# 全局配置项详解
skills:
  # 执行配置
  execution:
    timeout: 300              # 默认超时时间（秒）
    max_concurrent: 4         # 最大并发数
    retry_policy:
      max_attempts: 3         # 最大重试次数
      backoff: exponential    # 退避策略：linear, exponential
      initial_delay: 1        # 初始延迟（秒）

  # 缓存配置
  cache:
    enabled: true             # 是否启用缓存
    ttl: 3600                 # 缓存生存时间（秒）
    max_size: 1000            # 最大缓存条目数
    storage: memory           # 存储类型：memory, disk, redis

  # 日志配置
  logging:
    level: INFO               # 日志级别：DEBUG, INFO, WARNING, ERROR
    format: text              # 日志格式：text, json
    output: console           # 输出位置：console, file, both
    file_path: /tmp/claude-skills.log

  # 性能配置
  performance:
    enable_profiling: false   # 是否启用性能分析
    profile_interval: 60      # 性能分析间隔（秒）
    memory_limit: 1024        # 内存限制（MB）

  # 安全配置
  security:
    validate_inputs: true     # 是否验证输入
    sanitize_outputs: true    # 是否清理输出
    allow_network: false      # 是否允许网络访问
```

##### 2. 项目配置#

###### 2.1 配置文件位置

```
bash复制markdown

## 项目配置文件

### 文件位置
- 项目根目录: .claude/project.yaml

### 配置示例
~~~yaml
```yaml

# 项目特定配置
version: "1.0"

project:
  name: "my-project"
  type: "web-application"
  language: "python"
  framework: "flask"
```

```
markdown

## 项目配置文件

### 文件位置
- 项目根目录: .claude/project.yaml

### 配置示例
~~~yaml
```yaml

# 项目特定配置
version: "1.0"

project:
  name: "my-project"
  type: "web-application"
  language: "python"
  framework: "flask"
```

skills:

### 项目特定的 Skill 设置

code-review:
strict: true
custom_rules:
- no_print_statements
- type_hints_required
ignore_patterns:
- "/tests/"
- "/migrations/"
- "/vendor/"

generate-tests:
framework: "pytest"
coverage_target: 90
test_dir: "tests"
mock_external_calls: true

format-code:
style: "black"
line_length: 88
target_version: "py38"

###### 2.2 项目配置项

```
bash复制yaml

# 项目配置项详解

project:
  # 项目元数据
  metadata:
    name: "my-project"
    description: "A web application"
    version: "1.0.0"
    author: "Team"

  # 技术栈
  tech_stack:
    language: "python"
    version: "3.9"
    frameworks:
      - name: "flask"
        version: "2.3.0"
      - name: "sqlalchemy"
        version: "2.0.0"
    libraries:
      - name: "requests"
        version: "2.28.0"
      - name: "numpy"
        version: "1.24.0"

  # 代码规范
  code_standards:
    style_guide: "PEP8"
    formatter: "black"
    linter: "pylint"
    max_line_length: 88
    docstring_style: "google"

  # 测试配置
  testing:
    framework: "pytest"
    coverage_target: 80
    test_dir: "tests"
    mock_external: true

  # 文档配置
  documentation:
    format: "markdown"
    include_api_docs: true
    include_examples: true
    output_dir: "docs"

skills:
  # Skill 覆盖配置
  overrides:
    code-review:
      enabled: true
      priority: high
      parameters:
        strict: true
        include_security: true
        include_performance: true

    generate-tests:
      enabled: true
      priority: medium
      parameters:
        framework: pytest
        coverage_target: 90
        generate_mocks: true

### 3. 用户配置

#### 3.1 配置文件位置

## 用户配置文件
### 文件位置
- Linux/macOS: ~/.claude/user.yaml
- Windows: %USERPROFILE%\.claude\user.yaml
### 配置示例
~~~`yaml
`yaml

# 用户特定配置
version: "1.0"

user:
name: "John Doe"
email: "john@example.com"

preferences:
 # 编码偏好
coding:
language: "python"
style: "PEP8"
formatter: "black"
indent_size: 4

 # 输出偏好
output:
format: "markdown"
verbosity: "normal"
include_code_blocks: true
color_output: true

 # 交互偏好
interaction:
auto_confirm: false
show_progress: true
show_timing: true

 # 编辑器偏好
editor:
default: "vscode"
line_numbers: true
word_wrap: false

skills:
 # 用户自定义的 Skill 设置
aliases:
cr: code-review
gt: generate-tests
fc: format-code

favorites:
 - code-review
 - generate-tests
 - refactor-code

```> >
```

```
yaml

# 项目配置项详解

project:
  # 项目元数据
  metadata:
    name: "my-project"
    description: "A web application"
    version: "1.0.0"
    author: "Team"

  # 技术栈
  tech_stack:
    language: "python"
    version: "3.9"
    frameworks:
      - name: "flask"
        version: "2.3.0"
      - name: "sqlalchemy"
        version: "2.0.0"
    libraries:
      - name: "requests"
        version: "2.28.0"
      - name: "numpy"
        version: "1.24.0"

  # 代码规范
  code_standards:
    style_guide: "PEP8"
    formatter: "black"
    linter: "pylint"
    max_line_length: 88
    docstring_style: "google"

  # 测试配置
  testing:
    framework: "pytest"
    coverage_target: 80
    test_dir: "tests"
    mock_external: true

  # 文档配置
  documentation:
    format: "markdown"
    include_api_docs: true
    include_examples: true
    output_dir: "docs"

skills:
  # Skill 覆盖配置
  overrides:
    code-review:
      enabled: true
      priority: high
      parameters:
        strict: true
        include_security: true
        include_performance: true

    generate-tests:
      enabled: true
      priority: medium
      parameters:
        framework: pytest
        coverage_target: 90
        generate_mocks: true

### 3. 用户配置

#### 3.1 配置文件位置

## 用户配置文件
### 文件位置
- Linux/macOS: ~/.claude/user.yaml
- Windows: %USERPROFILE%\.claude\user.yaml
### 配置示例
~~~`yaml
`yaml

# 用户特定配置
version: "1.0"

user:
name: "John Doe"
email: "john@example.com"

preferences:
 # 编码偏好
coding:
language: "python"
style: "PEP8"
formatter: "black"
indent_size: 4

 # 输出偏好
output:
format: "markdown"
verbosity: "normal"
include_code_blocks: true
color_output: true

 # 交互偏好
interaction:
auto_confirm: false
show_progress: true
show_timing: true

 # 编辑器偏好
editor:
default: "vscode"
line_numbers: true
word_wrap: false

skills:
 # 用户自定义的 Skill 设置
aliases:
cr: code-review
gt: generate-tests
fc: format-code

favorites:
 - code-review
 - generate-tests
 - refactor-code

```> >
```

###### 3.2 用户配置项

### 用户配置项详解

### 用户信息

profile:
name: "John Doe"
email: "john@example.com"
timezone: "UTC+8"
language: "zh-CN"
preferences:

### 交互偏好

interaction:
auto_confirm: false          # 自动确认
show_progress: true          # 显示进度
show_timing: true            # 显示耗时
show_details: false          # 显示详细信息
prompt_style: "compact"      # 提示样式：compact, verbose

### 输出偏好

output:
format: "markdown"           # 输出格式：markdown, json, html
verbosity: "normal"          # 详细程度：quiet, normal, verbose
include_code_blocks: true    # 包含代码块
include_line_numbers: false  # 包含行号
color_output: true           # 彩色输出
max_lines: 1000              # 最大输出行数

### 编辑器偏好

editor:
default: "vscode"            # 默认编辑器
open_in_new_tab: true        # 在新标签页打开
focus_after_open: true       # 打开后聚焦
line_numbers: true          # 显示行号
word_wrap: false            # 自动换行

### 通知偏好

notifications:
enabled: true                # 启用通知
on_completion: true          # 完成时通知
on_error: true               # 错误时通知
sound: false                 # 播放声音
skills:

### Skill 别名

aliases:
cr: code-review
gt: generate-tests
fc: format-code
ref: refactor-code
doc: generate-docs

### 常用 Skills

favorites:

- code-review
- generate-tests
- format-code
- refactor-code

### Skill 默认参数

defaults:
code-review:
strict: false
include_security: true
generate-tests:
framework: pytest
coverage_target: 80
format-code:
style: black
line_length: 88

```
bash复制### 4. Skill 特定配置
#### 4.1 代码审查配置
```

```
### 4. Skill 特定配置
#### 4.1 代码审查配置
```

### code-review Skill 配置

skills:
code-review:
# 基本设置
enabled: true
priority: high

```
bash复制# 审查标准
standards:
  # 代码质量
  quality:
    check_complexity: true
    max_complexity: 10
    check_duplication: true
    max_duplication: 5

  # 安全性
  security:
    enabled: true
    check_sql_injection: true
    check_xss: true
    check_hardcoded_secrets: true
    check_insecure_deserialization: true

  # 性能
  performance:
    enabled: true
    check_n_plus_one: true
    check_memory_leaks: true
    check_inefficient_loops: true

  # 最佳实践
  best_practices:
    enabled: true
    check_error_handling: true
    check_logging: true
    check_documentation: true
    check_type_hints: true

# 严格程度
strictness: "medium"  # low, medium, high, strict

# 忽略规则
ignore_rules:
  - "line-too-long"
  - "too-many-arguments"

# 忽略模式
ignore_patterns:
  - "*/tests/*"
  - "*/migrations/*"
  - "*/vendor/*"
  - "*/node_modules/*"

# 输出格式
output:
  format: "markdown"
  include_code_snippets: true
  include_fix_suggestions: true
  group_by_severity: true

# 自定义规则
custom_rules:
  - name: "no_print_statements"
    severity: "warning"
    message: "Avoid using print statements"
    pattern: "print\\("

  - name: "type_hints_required"
    severity: "error"
    message: "Function must have type hints"
    check_function: has_type_hints
```

```
# 审查标准
standards:
  # 代码质量
  quality:
    check_complexity: true
    max_complexity: 10
    check_duplication: true
    max_duplication: 5

  # 安全性
  security:
    enabled: true
    check_sql_injection: true
    check_xss: true
    check_hardcoded_secrets: true
    check_insecure_deserialization: true

  # 性能
  performance:
    enabled: true
    check_n_plus_one: true
    check_memory_leaks: true
    check_inefficient_loops: true

  # 最佳实践
  best_practices:
    enabled: true
    check_error_handling: true
    check_logging: true
    check_documentation: true
    check_type_hints: true

# 严格程度
strictness: "medium"  # low, medium, high, strict

# 忽略规则
ignore_rules:
  - "line-too-long"
  - "too-many-arguments"

# 忽略模式
ignore_patterns:
  - "*/tests/*"
  - "*/migrations/*"
  - "*/vendor/*"
  - "*/node_modules/*"

# 输出格式
output:
  format: "markdown"
  include_code_snippets: true
  include_fix_suggestions: true
  group_by_severity: true

# 自定义规则
custom_rules:
  - name: "no_print_statements"
    severity: "warning"
    message: "Avoid using print statements"
    pattern: "print\\("

  - name: "type_hints_required"
    severity: "error"
    message: "Function must have type hints"
    check_function: has_type_hints
```

###### 4.2 测试生成配置

### generate-tests Skill 配置

skills:
generate-tests:

### 基本设置

enabled: true
priority: medium

### 测试框架

framework: "pytest"  # pytest, unittest, jest, mocha

### 测试类型

test_types:

- unit_tests
- integration_tests
- edge_cases

### 覆盖率目标

coverage:
enabled: true
target: 80
minimum: 60

### 测试生成策略

generation:
strategy: "comprehensive"  # basic, comprehensive, exhaustive
include_positive_tests: true
include_negative_tests: true
include_edge_cases: true
include_boundary_tests: true

### Mock 配置

mocking:
enabled: true
mock_external_calls: true
mock_database: true
mock_network: true
use_realistic_mocks: true

### 测试数据

test_data:
generate_fixtures: true
use_realistic_data: true
include_edge_cases: true

### 输出配置

output:
test_dir: "tests"
file_naming: "test_{module}.py"
include_docstrings: true
include_comments: true

### 断言配置

assertions:
use_strict_assertions: true
include_error_messages: true
check_return_values: true
check_exceptions: true

```
bash复制#### 4.3 代码格式化配置
```

```
#### 4.3 代码格式化配置
```

### format-code Skill 配置

skills:
format-code:
# 基本设置
enabled: true
priority: low

```
bash复制# 格式化工具
formatter: "black"  # black, autopep8, yapf, prettier

# 格式化规则
rules:
  line_length: 88
  indent_size: 4
  indent_style: "space"
  quote_style: "double"
  trailing_comma: true
  spaces_around_operators: true

# 目标版本
target_version: "py38"

# 排除文件
exclude:
  - "*/tests/*"
  - "*/migrations/*"
  - "*/vendor/*"

# 自动修复
auto_fix: true
fix_imports: true
sort_imports: true

# 输出配置
output:
  in_place: true
  create_backup: true
  show_diff: true
```

```
# 格式化工具
formatter: "black"  # black, autopep8, yapf, prettier

# 格式化规则
rules:
  line_length: 88
  indent_size: 4
  indent_style: "space"
  quote_style: "double"
  trailing_comma: true
  spaces_around_operators: true

# 目标版本
target_version: "py38"

# 排除文件
exclude:
  - "*/tests/*"
  - "*/migrations/*"
  - "*/vendor/*"

# 自动修复
auto_fix: true
fix_imports: true
sort_imports: true

# 输出配置
output:
  in_place: true
  create_backup: true
  show_diff: true
```

#### 配置优先级#

##### 优先级规则#

#### 配置优先级（从高到低）#

##### 1. 命令行参数#

```
bash复制`bash

claude --skill code-review --strict --file src/main.py

```### 2. 环境变量
```

```
`bash

claude --skill code-review --strict --file src/main.py

```### 2. 环境变量
```

export CLAUDE_SKILL_CODE_REVIEW_STRICT=true

##### 3. 项目配置#

```
bash复制````yaml

# .claude/project.yaml
skills:
code-review:
strict: true

```### 4. 用户配置
```

```
````yaml

# .claude/project.yaml
skills:
code-review:
strict: true

```### 4. 用户配置
```

### ~/.claude/user.yaml

skills:
code-review:
strict: false

##### 5. 全局配置#

```
bash复制````yaml

# ~/.claude/config.yaml
skills:
code-review:
strict: false

```### 6. 默认配置
```

```
````yaml

# ~/.claude/config.yaml
skills:
code-review:
strict: false

```### 6. 默认配置
```

### 内置默认值

strict: false

##### 配置合并#

```
bash复制python

class ConfigManager:
    def __init__(self):
        self.configs = {
            "default": self.load_default_config(),
            "global": self.load_global_config(),
            "user": self.load_user_config(),
            "project": self.load_project_config()
        }

    def get_config(self, skill_name, key):
        # 按优先级查找配置
        for config_type in ["project", "user", "global", "default"]:
            config = self.configs[config_type]
            if skill_name in config.get("skills", {}):
                skill_config = config["skills"][skill_name]
                if key in skill_config:
                    return skill_config[key]
        return None

    def merge_configs(self, skill_name):
        # 合并所有配置
        merged = {}
        for config_type in ["default", "global", "user", "project"]:
            config = self.configs[config_type]
            if skill_name in config.get("skills", {}):
                merged = self.deep_merge(merged, config["skills"][skill_name])
        return merged

    def deep_merge(self, dict1, dict2):
        result = dict1.copy()
        for key, value in dict2.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self.deep_merge(result[key], value)
            else:
                result[key] = value
        return result

## 动态配置

### 1. 环境变量

## 环境变量配置
### 命名规则
- 前缀: CLAUDE_SKILL_
- 格式: CLAUDE_SKILL_{SKILL_NAME}_{KEY}
- 示例: CLAUDE_SKILL_CODE_REVIEW_STRICT
### 使用示例
~~~`bash
`bash

# 设置代码审查严格模式
export CLAUDE_SKILL_CODE_REVIEW_STRICT=true

# 设置测试生成覆盖率目标
export CLAUDE_SKILL_GENERATE_TESTS_COVERAGE_TARGET=90

# 设置格式化工具
export CLAUDE_SKILL_FORMAT_CODE_FORMATTER=black

```> >
```

```
python

class ConfigManager:
    def __init__(self):
        self.configs = {
            "default": self.load_default_config(),
            "global": self.load_global_config(),
            "user": self.load_user_config(),
            "project": self.load_project_config()
        }

    def get_config(self, skill_name, key):
        # 按优先级查找配置
        for config_type in ["project", "user", "global", "default"]:
            config = self.configs[config_type]
            if skill_name in config.get("skills", {}):
                skill_config = config["skills"][skill_name]
                if key in skill_config:
                    return skill_config[key]
        return None

    def merge_configs(self, skill_name):
        # 合并所有配置
        merged = {}
        for config_type in ["default", "global", "user", "project"]:
            config = self.configs[config_type]
            if skill_name in config.get("skills", {}):
                merged = self.deep_merge(merged, config["skills"][skill_name])
        return merged

    def deep_merge(self, dict1, dict2):
        result = dict1.copy()
        for key, value in dict2.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self.deep_merge(result[key], value)
            else:
                result[key] = value
        return result

## 动态配置

### 1. 环境变量

## 环境变量配置
### 命名规则
- 前缀: CLAUDE_SKILL_
- 格式: CLAUDE_SKILL_{SKILL_NAME}_{KEY}
- 示例: CLAUDE_SKILL_CODE_REVIEW_STRICT
### 使用示例
~~~`bash
`bash

# 设置代码审查严格模式
export CLAUDE_SKILL_CODE_REVIEW_STRICT=true

# 设置测试生成覆盖率目标
export CLAUDE_SKILL_GENERATE_TESTS_COVERAGE_TARGET=90

# 设置格式化工具
export CLAUDE_SKILL_FORMAT_CODE_FORMATTER=black

```> >
```

##### 2. 运行时配置#

class RuntimeConfig:
def init(self):
self.config = {}
def set(self, key, value):
self.config[key] = value
def get(self, key, default=None):
return self.config.get(key, default)
def update(self, updates):
self.config.update(updates)
def clear(self):
self.config.clear()

### 使用示例

runtime_config = RuntimeConfig()
runtime_config.set("code_review.strict", True)
runtime_config.set("generate_tests.coverage_target", 90)

```
bash复制### 3. 条件配置
```

```
### 3. 条件配置
```

### 条件配置示例

skills:
code-review:
# 根据环境配置
environments:
development:
strict: false
include_performance: false
testing:
strict: true
include_performance: true
production:
strict: true
include_performance: true
include_security: true

```
bash复制# 根据文件类型配置
file_types:
  python:
    check_type_hints: true
    check_docstrings: true
  javascript:
    check_eslint: true
    check_typescript: true
  html:
    check_accessibility: true
    check_seo: true
```

```
# 根据文件类型配置
file_types:
  python:
    check_type_hints: true
    check_docstrings: true
  javascript:
    check_eslint: true
    check_typescript: true
  html:
    check_accessibility: true
    check_seo: true
```

#### 配置验证#

##### 1. 配置验证#

class ConfigValidator:
def init(self):
self.schemas = self.load_schemas()
def validate(self, skill_name, config):
schema = self.schemas.get(skill_name)
if not schema:
return True
errors = []
for key, value in config.items():
if key not in schema:
errors.append(f"Unknown configuration key: {key}")
continue
key_schema = schema[key]
if not self.validate_value(value, key_schema):
errors.append(f"Invalid value for {key}: {value}")
return len(errors) == 0, errors
def validate_value(self, value, schema):
value_type = schema.get("type")
if value_type == "boolean":
return isinstance(value, bool)
elif value_type == "integer":
return isinstance(value, int)
elif value_type == "string":
return isinstance(value, str)
elif value_type == "enum":
return value in schema.get("values", [])
return True
def load_schemas(self):
return {
"code-review": {
"strict": {"type": "boolean"},
"include_security": {"type": "boolean"},
"include_performance": {"type": "boolean"},
"strictness": {"type": "enum", "values": ["low", "medium", "high", "strict"]}
},
"generate-tests": {
"framework": {"type": "enum", "values": ["pytest", "unittest", "jest", "mocha"]},
"coverage_target": {"type": "integer"},
"mock_external_calls": {"type": "boolean"}
}
}

```
bash复制### 2. 配置迁移
```

```
### 2. 配置迁移
```

python

class ConfigMigrator:
def init(self):
self.migrations = {
"1.0": self.migrate_1_0_to_1_1,
"1.1": self.migrate_1_1_to_1_2
}

```
bash复制def migrate(self, config, from_version, to_version):
    current_version = from_version
    while current_version != to_version:
        if current_version in self.migrations:
            config = self.migrations[current_version](config)
            current_version = self.increment_version(current_version)
        else:
            break
    return config

def migrate_1_0_to_1_1(self, config):
    # 迁移逻辑
    if "skills" in config:
        for skill_name, skill_config in config["skills"].items():
            if "strict" in skill_config:
                skill_config["strictness"] = "high" if skill_config["strict"] else "low"
    return config

def increment_version(self, version):
    major, minor = version.split(".")
    return f"{major}.{int(minor) + 1}"
```

```
def migrate(self, config, from_version, to_version):
    current_version = from_version
    while current_version != to_version:
        if current_version in self.migrations:
            config = self.migrations[current_version](config)
            current_version = self.increment_version(current_version)
        else:
            break
    return config

def migrate_1_0_to_1_1(self, config):
    # 迁移逻辑
    if "skills" in config:
        for skill_name, skill_config in config["skills"].items():
            if "strict" in skill_config:
                skill_config["strictness"] = "high" if skill_config["strict"] else "low"
    return config

def increment_version(self, version):
    major, minor = version.split(".")
    return f"{major}.{int(minor) + 1}"
```

```
bash复制
## 总结

Skills 的配置选项提供了灵活的定制能力，通过合理的配置可以显著提高 Skills 的适用性和效率。理解配置层级、优先级和验证机制有助于更好地管理和使用 Skills。

在下一节中，我们将探讨 Skills 的生命周期管理，了解 Skills 的创建、更新、删除等操作。
```

```
## 总结

Skills 的配置选项提供了灵活的定制能力，通过合理的配置可以显著提高 Skills 的适用性和效率。理解配置层级、优先级和验证机制有助于更好地管理和使用 Skills。

在下一节中，我们将探讨 Skills 的生命周期管理，了解 Skills 的创建、更新、删除等操作。
```

---

## 3 Skills 生命周期管理

**URL**: https://claudecode.tangshuang.net/course/16.3%20Skills%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86

#### 生命周期概述#

Skills 的生命周期管理涵盖了从创建到删除的整个过程。本节将详细介绍 Skills 的各个生命周期阶段及其管理方法。

#### 生命周期阶段#

##### 1. 创建阶段#

###### 1.1 Skill 创建流程

#### Skill 创建流程#

##### 步骤 1：需求分析#

- 明确 Skill 的目标
- 确定输入输出
- 识别关键功能

##### 步骤 2：设计 Skill#

- 设计接口
- 规划流程
- 选择实现方式

##### 步骤 3：实现 Skill#

- 编写代码
- 添加测试
- 编写文档

##### 步骤 4：注册 Skill#

- 添加到 Skill 库
- 配置元数据
- 设置权限

##### 步骤 5：测试验证#

- 功能测试
- 性能测试
- 用户测试

###### 1.2 创建 API

```
python复制class SkillManager:
    def __init__(self):
        self.skills = {}
        self.skill_registry = SkillRegistry()

    def create_skill(self, skill_definition):
        self.validate_definition(skill_definition)
        skill = self.instantiate_skill(skill_definition)
        skill_id = self.skill_registry.register(skill)
        self.save_skill(skill_id, skill)
        return skill_id

    def validate_definition(self, definition):
        required_fields = ["name", "version", "description"]
        for field in required_fields:
            if field not in definition:
                raise ValueError(f"Missing required field: {field}")

    def instantiate_skill(self, definition):
        skill_type = definition.get("type", "natural_language")
        if skill_type == "natural_language":
            return NaturalLanguageSkill(definition)
        elif skill_type == "example_driven":
            return ExampleDrivenSkill(definition)
        elif skill_type == "programmatic":
            return ProgrammaticSkill(definition)
        else:
            raise ValueError(f"Unknown skill type: {skill_type}")

    def save_skill(self, skill_id, skill):
        skill_path = self.get_skill_path(skill_id)
        with open(skill_path, 'w') as f:
            json.dump(skill.to_dict(), f, indent=2)
```

```
class SkillManager:
    def __init__(self):
        self.skills = {}
        self.skill_registry = SkillRegistry()

    def create_skill(self, skill_definition):
        self.validate_definition(skill_definition)
        skill = self.instantiate_skill(skill_definition)
        skill_id = self.skill_registry.register(skill)
        self.save_skill(skill_id, skill)
        return skill_id

    def validate_definition(self, definition):
        required_fields = ["name", "version", "description"]
        for field in required_fields:
            if field not in definition:
                raise ValueError(f"Missing required field: {field}")

    def instantiate_skill(self, definition):
        skill_type = definition.get("type", "natural_language")
        if skill_type == "natural_language":
            return NaturalLanguageSkill(definition)
        elif skill_type == "example_driven":
            return ExampleDrivenSkill(definition)
        elif skill_type == "programmatic":
            return ProgrammaticSkill(definition)
        else:
            raise ValueError(f"Unknown skill type: {skill_type}")

    def save_skill(self, skill_id, skill):
        skill_path = self.get_skill_path(skill_id)
        with open(skill_path, 'w') as f:
            json.dump(skill.to_dict(), f, indent=2)
```

##### 2. 激活阶段#

###### 2.1 Skill 激活流程

#### Skill 激活流程#

##### 步骤 1：加载 Skill#

- 读取 Skill 定义
- 解析配置
- 初始化 Skill

##### 步骤 2：验证依赖#

- 检查依赖项
- 验证版本兼容性
- 加载依赖

##### 步骤 3：初始化 Skill#

- 执行初始化逻辑
- 设置上下文
- 注册事件监听器

##### 步骤 4：激活 Skill#

- 标记为活跃状态
- 启用功能
- 开始监听事件

###### 2.2 激活 API

```
python复制class SkillManager:
    def activate_skill(self, skill_id):
        skill = self.load_skill(skill_id)
        self.verify_dependencies(skill)
        skill.initialize()
        skill.activate()
        self.update_skill_status(skill_id, "active")
        return skill

    def load_skill(self, skill_id):
        skill_path = self.get_skill_path(skill_id)
        with open(skill_path, 'r') as f:
```

```
class SkillManager:
    def activate_skill(self, skill_id):
        skill = self.load_skill(skill_id)
        self.verify_dependencies(skill)
        skill.initialize()
        skill.activate()
        self.update_skill_status(skill_id, "active")
        return skill

    def load_skill(self, skill_id):
        skill_path = self.get_skill_path(skill_id)
        with open(skill_path, 'r') as f:
```

```
bash复制        skill_data = json.load(f)
    skill_type = skill_data["type"]
    if skill_type == "natural_language":
        skill = NaturalLanguageSkill(skill_data)
    elif skill_type == "example_driven":
        skill = ExampleDrivenSkill(skill_data)
    elif skill_type == "programmatic":
        skill = ProgrammaticSkill(skill_data)
    else:
        raise ValueError(f"Unknown skill type: {skill_type}")
    return skill

def verify_dependencies(self, skill):
    dependencies = skill.get_dependencies()
    for dep in dependencies:
        if not self.is_dependency_available(dep):
            raise DependencyError(f"Dependency not available: {dep}")

def is_dependency_available(self, dependency):
    pass

def update_skill_status(self, skill_id, status):
    pass
```

```
skill_data = json.load(f)
    skill_type = skill_data["type"]
    if skill_type == "natural_language":
        skill = NaturalLanguageSkill(skill_data)
    elif skill_type == "example_driven":
        skill = ExampleDrivenSkill(skill_data)
    elif skill_type == "programmatic":
        skill = ProgrammaticSkill(skill_data)
    else:
        raise ValueError(f"Unknown skill type: {skill_type}")
    return skill

def verify_dependencies(self, skill):
    dependencies = skill.get_dependencies()
    for dep in dependencies:
        if not self.is_dependency_available(dep):
            raise DependencyError(f"Dependency not available: {dep}")

def is_dependency_available(self, dependency):
    pass

def update_skill_status(self, skill_id, status):
    pass
```

##### 3. 运行阶段#

###### 3.1 Skill 执行流程

#### Skill 执行流程#

##### 步骤 1：接收请求#

- 接收用户请求
- 解析参数
- 验证输入

##### 步骤 2：准备执行#

- 收集上下文
- 准备资源
- 初始化状态

##### 步骤 3：执行逻辑#

- 执行 Skill 逻辑
- 调用工具
- 处理结果

##### 步骤 4：返回结果#

- 格式化输出
- 返回结果
- 清理资源

###### 3.2 执行 API

```
python复制class SkillExecutor:
    def __init__(self):
        self.context_manager = ContextManager()
        self.resource_manager = ResourceManager()

    def execute(self, skill, parameters):
        self.validate_parameters(skill, parameters)
        context = self.prepare_context(skill, parameters)
        resources = self.acquire_resources(skill, parameters)

        try:
            result = skill.execute(parameters, context)
            formatted_result = self.format_result(result, skill)
            return formatted_result
        finally:
            self.release_resources(resources)

    def validate_parameters(self, skill, parameters):
        schema = skill.get_parameter_schema()
        for param in schema.get("required", []):
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")

    def prepare_context(self, skill, parameters):
        return self.context_manager.collect_context(skill, parameters)

    def acquire_resources(self, skill, parameters):
        return self.resource_manager.acquire(skill.get_resource_requirements())

    def format_result(self, result, skill):
        output_format = skill.get_output_format()
        if output_format == "json":
            return json.dumps(result)
        elif output_format == "markdown":
            return self.to_markdown(result)
        else:
            return result

    def release_resources(self, resources):
        self.resource_manager.release(resources)

### 4. 更新阶段

#### 4.1 Skill 更新流程

## Skill 更新流程
### 步骤 1：检查更新
- 检查新版本
- 验证兼容性
- 备份当前版本
### 步骤 2：下载更新
- 下载新版本
- 验证完整性
- 解压更新
### 步骤 3：应用更新
- 停用 Skill
- 替换文件
- 迁移配置
### 步骤 4：重新激活
- 验证更新
- 重新激活
- 测试功能

#### 4.2 更新 API
```python
class SkillUpdater:
    def __init__(self):
        self.backup_manager = BackupManager()
        self.config_migrator = ConfigMigrator()

    def update_skill(self, skill_id, new_version):
        current_version = self.get_current_version(skill_id)
        if not self.should_update(current_version, new_version):
            return False

        backup = self.backup_manager.create_backup(skill_id)

        try:
            update_data = self.download_update(skill_id, new_version)
            self.validate_update(update_data)
            self.deactivate_skill(skill_id)
            self.apply_update(skill_id, update_data)
            self.migrate_config(skill_id, current_version, new_version)
            self.activate_skill(skill_id)
            self.verify_update(skill_id)
            return True
        except Exception as e:
            self.rollback_update(skill_id, backup)
            raise e

    def should_update(self, current_version, new_version):
        return self.compare_versions(current_version, new_version) < 0

    def compare_versions(self, v1, v2):
        v1_parts = [int(x) for x in v1.split(".")]
        v2_parts = [int(x) for x in v2.split(".")]

        for a, b in zip(v1_parts, v2_parts):
            if a < b:
                return -1
            elif a > b:
                return 1

        return 0

    def download_update(self, skill_id, version):
        # 下载更新
        pass

    def validate_update(self, update_data):
        # 验证更新
        pass

    def apply_update(self, skill_id, update_data):
        # 应用更新
        pass

    def migrate_config(self, skill_id, from_version, to_version):
        # 迁移配置
        self.config_migrator.migrate(skill_id, from_version, to_version)

    def verify_update(self, skill_id):
        # 验证更新
        pass

    def rollback_update(self, skill_id, backup):
        # 回滚更新
        self.backup_manager.restore_backup(skill_id, backup)

### 5. 停用阶段

#### 5.1 Skill 停用流程

## Skill 停用流程
### 步骤 1：停止执行
- 停止新的请求
- 完成正在执行的请求
- 等待所有操作完成
### 步骤 2：清理资源
- 释放资源
- 关闭连接
- 清理缓存
### 步骤 3：保存状态
- 保存当前状态
- 保存执行历史
- 保存配置
### 步骤 4：标记为停用
- 更新状态
- 禁用功能
- 停止监听事件

#### 5.2 停用 API
```python

class SkillManager:
    def deactivate_skill(self, skill_id):
        self.stop_execution(skill_id)

        self.wait_for_completion(skill_id)

        self.cleanup_resources(skill_id)

        self.save_state(skill_id)

        self.update_skill_status(skill_id, "inactive")

    def stop_execution(self, skill_id):
        skill = self.get_skill(skill_id)
        skill.stop()

    def wait_for_completion(self, skill_id):
        skill = self.get_skill(skill_id)
        skill.wait_for_completion()

    def cleanup_resources(self, skill_id):
        skill = self.get_skill(skill_id)
        resources = skill.get_resources()
        for resource in resources:
            resource.release()

    def save_state(self, skill_id):
        skill = self.get_skill(skill_id)
        state = skill.get_state()
        state_path = self.get_state_path(skill_id)
        with open(state_path, 'w') as f:
            json.dump(state, f)

    def update_skill_status(self, skill_id, status):
        # 更新状态
        pass

### 6. 删除阶段

#### 6.1 Skill 删除流程

## Skill 删除流程
### 步骤 1：确认删除
- 显示删除警告
- 确认删除操作
- 检查依赖关系
### 步骤 2：停用 Skill
- 停止执行
- 清理资源
- 保存状态
### 步骤 3：删除文件
- 删除 Skill 文件
- 删除配置文件
- 删除状态文件
### 步骤 4：清理注册
- 从注册表移除
- 清理引用
- 更新索引

#### 6.2 删除 API
```python

class SkillManager:
    def delete_skill(self, skill_id, force=False):
        # 确认删除
        if not force and not self.confirm_deletion(skill_id):
            return False

        # 检查依赖
        dependents = self.get_dependents(skill_id)
        if dependents and not force:
            raise DependencyError(f"Skill has dependents: {dependents}")

        # 停用 Skill
        self.deactivate_skill(skill_id)

        # 删除文件
        self.delete_skill_files(skill_id)

        # 清理注册
        self.unregister_skill(skill_id)

        return True

    def confirm_deletion(self, skill_id):
        skill = self.get_skill(skill_id)
        print(f"Are you sure you want to delete skill '{skill.name}'?")
        response = input("Type 'yes' to confirm: ")
        return response.lower() == "yes"

    def get_dependents(self, skill_id):
        # 获取依赖此 Skill 的其他 Skills
        pass

    def delete_skill_files(self, skill_id):
        skill_path = self.get_skill_path(skill_id)
        config_path = self.get_config_path(skill_id)
        state_path = self.get_state_path(skill_id)

        for path in [skill_path, config_path, state_path]:
            if os.path.exists(path):
                os.remove(path)

    def unregister_skill(self, skill_id):
        self.skill_registry.unregister(skill_id)

## 状态管理

### 1. 状态定义

## Skill 状态

### 状态类型
- CREATED: 已创建
- ACTIVATING: 激活中
- ACTIVE: 活跃
- DEACTIVATING: 停用中
- INACTIVE: 停用
- UPDATING: 更新中
- ERROR: 错误
- DELETED: 已删除
### 状态转换
CREATED → ACTIVATING → ACTIVE
ACTIVE → DEACTIVATING → INACTIVE
ACTIVE → UPDATING → ACTIVE
ACTIVE → ERROR → INACTIVE
INACTIVE → DELETED
```

```
class SkillExecutor:
    def __init__(self):
        self.context_manager = ContextManager()
        self.resource_manager = ResourceManager()

    def execute(self, skill, parameters):
        self.validate_parameters(skill, parameters)
        context = self.prepare_context(skill, parameters)
        resources = self.acquire_resources(skill, parameters)

        try:
            result = skill.execute(parameters, context)
            formatted_result = self.format_result(result, skill)
            return formatted_result
        finally:
            self.release_resources(resources)

    def validate_parameters(self, skill, parameters):
        schema = skill.get_parameter_schema()
        for param in schema.get("required", []):
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")

    def prepare_context(self, skill, parameters):
        return self.context_manager.collect_context(skill, parameters)

    def acquire_resources(self, skill, parameters):
        return self.resource_manager.acquire(skill.get_resource_requirements())

    def format_result(self, result, skill):
        output_format = skill.get_output_format()
        if output_format == "json":
            return json.dumps(result)
        elif output_format == "markdown":
            return self.to_markdown(result)
        else:
            return result

    def release_resources(self, resources):
        self.resource_manager.release(resources)

### 4. 更新阶段

#### 4.1 Skill 更新流程

## Skill 更新流程
### 步骤 1：检查更新
- 检查新版本
- 验证兼容性
- 备份当前版本
### 步骤 2：下载更新
- 下载新版本
- 验证完整性
- 解压更新
### 步骤 3：应用更新
- 停用 Skill
- 替换文件
- 迁移配置
### 步骤 4：重新激活
- 验证更新
- 重新激活
- 测试功能

#### 4.2 更新 API
```python
class SkillUpdater:
    def __init__(self):
        self.backup_manager = BackupManager()
        self.config_migrator = ConfigMigrator()

    def update_skill(self, skill_id, new_version):
        current_version = self.get_current_version(skill_id)
        if not self.should_update(current_version, new_version):
            return False

        backup = self.backup_manager.create_backup(skill_id)

        try:
            update_data = self.download_update(skill_id, new_version)
            self.validate_update(update_data)
            self.deactivate_skill(skill_id)
            self.apply_update(skill_id, update_data)
            self.migrate_config(skill_id, current_version, new_version)
            self.activate_skill(skill_id)
            self.verify_update(skill_id)
            return True
        except Exception as e:
            self.rollback_update(skill_id, backup)
            raise e

    def should_update(self, current_version, new_version):
        return self.compare_versions(current_version, new_version) < 0

    def compare_versions(self, v1, v2):
        v1_parts = [int(x) for x in v1.split(".")]
        v2_parts = [int(x) for x in v2.split(".")]

        for a, b in zip(v1_parts, v2_parts):
            if a < b:
                return -1
            elif a > b:
                return 1

        return 0

    def download_update(self, skill_id, version):
        # 下载更新
        pass

    def validate_update(self, update_data):
        # 验证更新
        pass

    def apply_update(self, skill_id, update_data):
        # 应用更新
        pass

    def migrate_config(self, skill_id, from_version, to_version):
        # 迁移配置
        self.config_migrator.migrate(skill_id, from_version, to_version)

    def verify_update(self, skill_id):
        # 验证更新
        pass

    def rollback_update(self, skill_id, backup):
        # 回滚更新
        self.backup_manager.restore_backup(skill_id, backup)

### 5. 停用阶段

#### 5.1 Skill 停用流程

## Skill 停用流程
### 步骤 1：停止执行
- 停止新的请求
- 完成正在执行的请求
- 等待所有操作完成
### 步骤 2：清理资源
- 释放资源
- 关闭连接
- 清理缓存
### 步骤 3：保存状态
- 保存当前状态
- 保存执行历史
- 保存配置
### 步骤 4：标记为停用
- 更新状态
- 禁用功能
- 停止监听事件

#### 5.2 停用 API
```python

class SkillManager:
    def deactivate_skill(self, skill_id):
        self.stop_execution(skill_id)

        self.wait_for_completion(skill_id)

        self.cleanup_resources(skill_id)

        self.save_state(skill_id)

        self.update_skill_status(skill_id, "inactive")

    def stop_execution(self, skill_id):
        skill = self.get_skill(skill_id)
        skill.stop()

    def wait_for_completion(self, skill_id):
        skill = self.get_skill(skill_id)
        skill.wait_for_completion()

    def cleanup_resources(self, skill_id):
        skill = self.get_skill(skill_id)
        resources = skill.get_resources()
        for resource in resources:
            resource.release()

    def save_state(self, skill_id):
        skill = self.get_skill(skill_id)
        state = skill.get_state()
        state_path = self.get_state_path(skill_id)
        with open(state_path, 'w') as f:
            json.dump(state, f)

    def update_skill_status(self, skill_id, status):
        # 更新状态
        pass

### 6. 删除阶段

#### 6.1 Skill 删除流程

## Skill 删除流程
### 步骤 1：确认删除
- 显示删除警告
- 确认删除操作
- 检查依赖关系
### 步骤 2：停用 Skill
- 停止执行
- 清理资源
- 保存状态
### 步骤 3：删除文件
- 删除 Skill 文件
- 删除配置文件
- 删除状态文件
### 步骤 4：清理注册
- 从注册表移除
- 清理引用
- 更新索引

#### 6.2 删除 API
```python

class SkillManager:
    def delete_skill(self, skill_id, force=False):
        # 确认删除
        if not force and not self.confirm_deletion(skill_id):
            return False

        # 检查依赖
        dependents = self.get_dependents(skill_id)
        if dependents and not force:
            raise DependencyError(f"Skill has dependents: {dependents}")

        # 停用 Skill
        self.deactivate_skill(skill_id)

        # 删除文件
        self.delete_skill_files(skill_id)

        # 清理注册
        self.unregister_skill(skill_id)

        return True

    def confirm_deletion(self, skill_id):
        skill = self.get_skill(skill_id)
        print(f"Are you sure you want to delete skill '{skill.name}'?")
        response = input("Type 'yes' to confirm: ")
        return response.lower() == "yes"

    def get_dependents(self, skill_id):
        # 获取依赖此 Skill 的其他 Skills
        pass

    def delete_skill_files(self, skill_id):
        skill_path = self.get_skill_path(skill_id)
        config_path = self.get_config_path(skill_id)
        state_path = self.get_state_path(skill_id)

        for path in [skill_path, config_path, state_path]:
            if os.path.exists(path):
                os.remove(path)

    def unregister_skill(self, skill_id):
        self.skill_registry.unregister(skill_id)

## 状态管理

### 1. 状态定义

## Skill 状态

### 状态类型
- CREATED: 已创建
- ACTIVATING: 激活中
- ACTIVE: 活跃
- DEACTIVATING: 停用中
- INACTIVE: 停用
- UPDATING: 更新中
- ERROR: 错误
- DELETED: 已删除
### 状态转换
CREATED → ACTIVATING → ACTIVE
ACTIVE → DEACTIVATING → INACTIVE
ACTIVE → UPDATING → ACTIVE
ACTIVE → ERROR → INACTIVE
INACTIVE → DELETED
```

##### 2. 状态转换#

```
python复制
class SkillStateMachine:
    def __init__(self):
        self.transitions = {
            "CREATED": ["ACTIVATING", "DELETED"],
            "ACTIVATING": ["ACTIVE", "ERROR"],
            "ACTIVE": ["DEACTIVATING", "UPDATING", "ERROR"],
            "DEACTIVATING": ["INACTIVE", "ERROR"],
            "INACTIVE": ["ACTIVATING", "DELETED"],
            "UPDATING": ["ACTIVE", "ERROR"],
            "ERROR": ["INACTIVE", "DELETED"],
            "DELETED": []
        }

    def can_transition(self, from_state, to_state):
        return to_state in self.transitions.get(from_state, [])

    def transition(self, skill_id, new_state):
        current_state = self.get_current_state(skill_id)

        if not self.can_transition(current_state, new_state):
            raise InvalidStateTransitionError(
                f"Cannot transition from {current_state} to {new_state}"
            )

        self.set_state(skill_id, new_state)

    def get_current_state(self, skill_id):
        # 获取当前状态
        pass

    def set_state(self, skill_id, state):
        # 设置状态
        pass

## 版本管理

### 1. 版本控制
```python
class SkillVersionManager:
    def __init__(self):
        self.versions = {}

    def create_version(self, skill_id, version_number, changes):
        version = {
            "id": self.generate_version_id(),
            "skill_id": skill_id,
            "version": version_number,
            "created_at": datetime.now(),
            "changes": changes,
            "checksum": self.calculate_checksum(skill_id)
        }
        if skill_id not in self.versions:
            self.versions[skill_id] = []
        self.versions[skill_id].append(version)
        return version["id"]

    def get_version(self, skill_id, version_number):
        versions = self.versions.get(skill_id, [])
        for version in versions:
            if version["version"] == version_number:
                return version
        return None

    def get_latest_version(self, skill_id):
        versions = self.versions.get(skill_id, [])
        if not versions:
            return None
        return versions[-1]

    def list_versions(self, skill_id):
        return self.versions.get(skill_id, [])

    def rollback_to_version(self, skill_id, version_number):
        version = self.get_version(skill_id, version_number)
        if not version:
            raise VersionNotFoundError(version_number)
        self.restore_version(skill_id, version)

    def generate_version_id(self):
        return str(uuid.uuid4())

    def calculate_checksum(self, skill_id):
        pass

    def restore_version(self, skill_id, version):
        pass
```

```
class SkillStateMachine:
    def __init__(self):
        self.transitions = {
            "CREATED": ["ACTIVATING", "DELETED"],
            "ACTIVATING": ["ACTIVE", "ERROR"],
            "ACTIVE": ["DEACTIVATING", "UPDATING", "ERROR"],
            "DEACTIVATING": ["INACTIVE", "ERROR"],
            "INACTIVE": ["ACTIVATING", "DELETED"],
            "UPDATING": ["ACTIVE", "ERROR"],
            "ERROR": ["INACTIVE", "DELETED"],
            "DELETED": []
        }

    def can_transition(self, from_state, to_state):
        return to_state in self.transitions.get(from_state, [])

    def transition(self, skill_id, new_state):
        current_state = self.get_current_state(skill_id)

        if not self.can_transition(current_state, new_state):
            raise InvalidStateTransitionError(
                f"Cannot transition from {current_state} to {new_state}"
            )

        self.set_state(skill_id, new_state)

    def get_current_state(self, skill_id):
        # 获取当前状态
        pass

    def set_state(self, skill_id, state):
        # 设置状态
        pass

## 版本管理

### 1. 版本控制
```python
class SkillVersionManager:
    def __init__(self):
        self.versions = {}

    def create_version(self, skill_id, version_number, changes):
        version = {
            "id": self.generate_version_id(),
            "skill_id": skill_id,
            "version": version_number,
            "created_at": datetime.now(),
            "changes": changes,
            "checksum": self.calculate_checksum(skill_id)
        }
        if skill_id not in self.versions:
            self.versions[skill_id] = []
        self.versions[skill_id].append(version)
        return version["id"]

    def get_version(self, skill_id, version_number):
        versions = self.versions.get(skill_id, [])
        for version in versions:
            if version["version"] == version_number:
                return version
        return None

    def get_latest_version(self, skill_id):
        versions = self.versions.get(skill_id, [])
        if not versions:
            return None
        return versions[-1]

    def list_versions(self, skill_id):
        return self.versions.get(skill_id, [])

    def rollback_to_version(self, skill_id, version_number):
        version = self.get_version(skill_id, version_number)
        if not version:
            raise VersionNotFoundError(version_number)
        self.restore_version(skill_id, version)

    def generate_version_id(self):
        return str(uuid.uuid4())

    def calculate_checksum(self, skill_id):
        pass

    def restore_version(self, skill_id, version):
        pass
```

##### 2. 变更日志#

```
python复制
class ChangeLog:
    def __init__(self):
        self.entries = []

    def add_entry(self, skill_id, version, changes):
        entry = {
            "id": self.generate_entry_id(),
            "skill_id": skill_id,
            "version": version,
            "timestamp": datetime.now(),
            "changes": changes
        }
        self.entries.append(entry)
        return entry["id"]

    def get_entries(self, skill_id):
        return [e for e in self.entries if e["skill_id"] == skill_id]

    def get_entry(self, entry_id):
        for entry in self.entries:
            if entry["id"] == entry_id:
                return entry
        return None

    def generate_changelog(self, skill_id, from_version, to_version):
        entries = self.get_entries(skill_id)
        changelog = []

        for entry in entries:
            version = entry["version"]
            if self.compare_versions(from_version, version) <= 0 and \
               self.compare_versions(version, to_version) <= 0:
                changelog.append(entry)

        return changelog

    def generate_entry_id(self):
        return str(uuid.uuid4())

    def compare_versions(self, v1, v2):
        v1_parts = [int(x) for x in v1.split(".")]
        v2_parts = [int(x) for x in v2.split(".")]

        for a, b in zip(v1_parts, v2_parts):
            if a < b:
                return -1
            elif a > b:
                return 1

        return 0

## 依赖管理

### 1. 依赖解析
```python
class DependencyResolver:
    def __init__(self):
        self.dependency_graph = {}

    def add_dependency(self, skill_id, depends_on):
        if skill_id not in self.dependency_graph:
            self.dependency_graph[skill_id] = []
        if depends_on not in self.dependency_graph[skill_id]:
            self.dependency_graph[skill_id].append(depends_on)

    def resolve_dependencies(self, skill_id):
        visited = set()
        result = []

        def visit(node):
            if node in visited:
                return
            visited.add(node)
            for dep in self.dependency_graph.get(node, []):
                visit(dep)
            result.append(node)

        visit(skill_id)
        return result

    def check_circular_dependencies(self):
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)
            for dep in self.dependency_graph.get(node, []):
                if dep not in visited:
                    if dfs(dep):
                        return True
                elif dep in rec_stack:
                    return True
            rec_stack.remove(node)
            return False

        for node in self.dependency_graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

```
class ChangeLog:
    def __init__(self):
        self.entries = []

    def add_entry(self, skill_id, version, changes):
        entry = {
            "id": self.generate_entry_id(),
            "skill_id": skill_id,
            "version": version,
            "timestamp": datetime.now(),
            "changes": changes
        }
        self.entries.append(entry)
        return entry["id"]

    def get_entries(self, skill_id):
        return [e for e in self.entries if e["skill_id"] == skill_id]

    def get_entry(self, entry_id):
        for entry in self.entries:
            if entry["id"] == entry_id:
                return entry
        return None

    def generate_changelog(self, skill_id, from_version, to_version):
        entries = self.get_entries(skill_id)
        changelog = []

        for entry in entries:
            version = entry["version"]
            if self.compare_versions(from_version, version) <= 0 and \
               self.compare_versions(version, to_version) <= 0:
                changelog.append(entry)

        return changelog

    def generate_entry_id(self):
        return str(uuid.uuid4())

    def compare_versions(self, v1, v2):
        v1_parts = [int(x) for x in v1.split(".")]
        v2_parts = [int(x) for x in v2.split(".")]

        for a, b in zip(v1_parts, v2_parts):
            if a < b:
                return -1
            elif a > b:
                return 1

        return 0

## 依赖管理

### 1. 依赖解析
```python
class DependencyResolver:
    def __init__(self):
        self.dependency_graph = {}

    def add_dependency(self, skill_id, depends_on):
        if skill_id not in self.dependency_graph:
            self.dependency_graph[skill_id] = []
        if depends_on not in self.dependency_graph[skill_id]:
            self.dependency_graph[skill_id].append(depends_on)

    def resolve_dependencies(self, skill_id):
        visited = set()
        result = []

        def visit(node):
            if node in visited:
                return
            visited.add(node)
            for dep in self.dependency_graph.get(node, []):
                visit(dep)
            result.append(node)

        visit(skill_id)
        return result

    def check_circular_dependencies(self):
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)
            for dep in self.dependency_graph.get(node, []):
                if dep not in visited:
                    if dfs(dep):
                        return True
                elif dep in rec_stack:
                    return True
            rec_stack.remove(node)
            return False

        for node in self.dependency_graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

##### 2. 依赖安装#

```
python复制
class DependencyInstaller:
    def __init__(self):
        self.resolver = DependencyResolver()

    def install_dependencies(self, skill_id):
        # 解析依赖
        dependencies = self.resolver.resolve_dependencies(skill_id)

        # 安装依赖
        for dep_id in dependencies:
            if dep_id != skill_id:
                self.install_skill(dep_id)

    def install_skill(self, skill_id):
        # 安装 Skill
        pass

    def uninstall_dependencies(self, skill_id):
        # 查找依赖此 Skill 的其他 Skills
        dependents = self.get_dependents(skill_id)

        # 如果没有其他依赖，可以卸载
        if not dependents:
            self.uninstall_skill(skill_id)

    def get_dependents(self, skill_id):
        # 获取依赖此 Skill 的其他 Skills
        pass
```

```
class DependencyInstaller:
    def __init__(self):
        self.resolver = DependencyResolver()

    def install_dependencies(self, skill_id):
        # 解析依赖
        dependencies = self.resolver.resolve_dependencies(skill_id)

        # 安装依赖
        for dep_id in dependencies:
            if dep_id != skill_id:
                self.install_skill(dep_id)

    def install_skill(self, skill_id):
        # 安装 Skill
        pass

    def uninstall_dependencies(self, skill_id):
        # 查找依赖此 Skill 的其他 Skills
        dependents = self.get_dependents(skill_id)

        # 如果没有其他依赖，可以卸载
        if not dependents:
            self.uninstall_skill(skill_id)

    def get_dependents(self, skill_id):
        # 获取依赖此 Skill 的其他 Skills
        pass
```

#### 总结#

Skills 的生命周期管理是一个复杂而重要的过程，涉及创建、激活、运行、更新、停用和删除等多个阶段。通过有效的生命周期管理，可以确保 Skills 的稳定运行和持续改进。

在下一节中，我们将探讨 Skills 的权限控制，了解如何管理和限制 Skills 的访问权限。

---

## 4 Skills 权限控制

**URL**: https://claudecode.tangshuang.net/course/16.4%20Skills%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6

#### 权限控制概述#

Skills 的权限控制是确保系统安全和数据保护的重要机制。本节将详细介绍 Skills 的权限模型、权限类型和权限管理方法。

#### 权限模型#

##### 1. 基于角色的访问控制（RBAC）#

###### 1.1 角色定义

#### 角色类型#

##### 管理员角色#

- 完全访问权限
- 可以创建、修改、删除 Skills
- 可以管理用户和角色

##### 开发者角色#

- 可以创建和修改 Skills
- 可以执行 Skills
- 不能删除其他用户的 Skills

##### 用户角色#

- 只能执行 Skills
- 不能创建或修改 Skills
- 访问受限的资源和功能

##### 访客角色#

- 只读权限
- 只能查看 Skill 文档
- 不能执行任何操作

###### 1.2 权限定义

```
python复制class Permission:
    def __init__(self, name, description):
        self.name = name
        self.description = description

# Skill 权限
SKILL_CREATE = Permission("skill:create", "创建 Skill")
SKILL_READ = Permission("skill:read", "读取 Skill")
SKILL_UPDATE = Permission("skill:update", "更新 Skill")
SKILL_DELETE = Permission("skill:delete", "删除 Skill")
```

```
class Permission:
    def __init__(self, name, description):
        self.name = name
        self.description = description

# Skill 权限
SKILL_CREATE = Permission("skill:create", "创建 Skill")
SKILL_READ = Permission("skill:read", "读取 Skill")
SKILL_UPDATE = Permission("skill:update", "更新 Skill")
SKILL_DELETE = Permission("skill:delete", "删除 Skill")
```

SKILL_EXECUTE = Permission("skill:execute", "执行 Skill")

### 资源权限

RESOURCE_READ = Permission("resource:read", "读取资源")
RESOURCE_WRITE = Permission("resource:write", "写入资源")
RESOURCE_DELETE = Permission("resource:delete", "删除资源")

### 系统权限

SYSTEM_CONFIG = Permission("system:config", "配置系统")
SYSTEM_MONITOR = Permission("system:monitor", "监控系统")

###### 1.3 角色权限映射

```
python复制class Role:
    def __init__(self, name, permissions):
        self.name = name
        self.permissions = permissions
# 定义角色
    ADMIN = Role("admin", [
        SKILL_CREATE, SKILL_READ, SKILL_UPDATE, SKILL_DELETE, SKILL_EXECUTE,
        RESOURCE_READ, RESOURCE_WRITE, RESOURCE_DELETE,
        SYSTEM_CONFIG, SYSTEM_MONITOR
    ])
    DEVELOPER = Role("developer", [
        SKILL_CREATE, SKILL_READ, SKILL_UPDATE, SKILL_EXECUTE,
        RESOURCE_READ, RESOURCE_WRITE
    ])
    USER = Role("user", [
        SKILL_READ, SKILL_EXECUTE,
        RESOURCE_READ
    ])
    GUEST = Role("guest", [
        SKILL_READ
    ])

~~~
### 2. 基于属性的访问控制（ABAC）
#### 2.1 属性定义
```python
class Attribute:
    def __init__(self, name, value):
        self.name = name
        self.value = value

# 用户属性
class UserAttributes:
    def __init__(self, user_id, role, department, level):
        self.user_id = Attribute("user_id", user_id)
        self.role = Attribute("role", role)
        self.department = Attribute("department", department)
        self.level = Attribute("level", level)

# 资源属性
class ResourceAttributes:
    def __init__(self, resource_id, owner, sensitivity, classification):
        self.resource_id = Attribute("resource_id", resource_id)
        self.owner = Attribute("owner", owner)
        self.sensitivity = Attribute("sensitivity", sensitivity)
        self.classification = Attribute("classification", classification)

# 环境属性
class EnvironmentAttributes:
    def __init__(self, time, location, device):
        self.time = Attribute("time", time)
        self.location = Attribute("location", location)
        self.device = Attribute("device", device)

#### 2.2 策略定义
```python
class AccessPolicy:
    def __init__(self, name, condition, effect):
        self.name = name
        self.condition = condition
        self.effect = effect
# 示例策略
    POLICIES = [
        AccessPolicy(
            name="admin_full_access",
            condition=lambda user, resource, env: user.role.value == "admin",
            effect="allow"
        ),
        AccessPolicy(
            name="owner_access",
            condition=lambda user, resource, env: user.user_id.value == resource.owner.value,
            effect="allow"
        ),
        AccessPolicy(
            name="sensitivity_restriction",
            condition=lambda user, resource, env: resource.sensitivity.value == "high" and user.level.value < 3,
            effect="deny"
        ),
        AccessPolicy(
            name="business_hours_only",
            condition=lambda user, resource, env: not (9 <= env.time.value.hour < 17),
            effect="deny"
        )
    ]

~~~
### 3. 权限检查
#### 3.1 RBAC 检查
```python
class RBACChecker:
    def __init__(self):
        self.user_roles = {}
        self.role_permissions = {}

    def assign_role(self, user_id, role):
        if user_id not in self.user_roles:
            self.user_roles[user_id] = []
        self.user_roles[user_id].append(role)

    def check_permission(self, user_id, permission):
        # 获取用户角色
        roles = self.user_roles.get(user_id, [])

        # 检查每个角色是否有该权限
        for role in roles:
            if permission in role.permissions:
                return True

        return False

    def check_skill_permission(self, user_id, skill_id, action):
        permission = Permission(f"skill:{action}", "")
        return self.check_permission(user_id, permission)

#### 3.2 ABAC 检查

class ABACChecker:
    def __init__(self):
        self.policies = []

    def add_policy(self, policy):
        self.policies.append(policy)

    def check_access(self, user, resource, environment):
        for policy in self.policies:
            if policy.condition(user, resource, environment):
                return policy.effect == "allow"
        return False

    def check_skill_access(self, user, skill, environment):
        return self.check_access(user, skill, environment)

~~~
## 资源访问控制
### 1. 文件系统访问
#### 1.1 文件权限
```python
class FilePermission:
    def __init__(self, path, read, write, execute):
        self.path = path
        self.read = read
        self.write = write
        self.execute = execute

class FileAccessController:
    def __init__(self):
        self.permissions = {}

    def set_permission(self, path, read=False, write=False, execute=False):
        self.permissions[path] = FilePermission(path, read, write, execute)

    def check_read(self, user_id, path):
        permission = self.permissions.get(path)
        if not permission:
            return False

        # 检查用户是否有读权限
        if permission.read:
            return True

        # 检查用户是否是文件所有者
        if self.is_owner(user_id, path):
            return True

        return False

    def check_write(self, user_id, path):
        permission = self.permissions.get(path)
        if not permission:
            return False

        if permission.write:
            return True

        if self.is_owner(user_id, path):
            return True

        return False

    def is_owner(self, user_id, path):
        # 检查用户是否是文件所有者
        pass
```

```
class Role:
    def __init__(self, name, permissions):
        self.name = name
        self.permissions = permissions
# 定义角色
    ADMIN = Role("admin", [
        SKILL_CREATE, SKILL_READ, SKILL_UPDATE, SKILL_DELETE, SKILL_EXECUTE,
        RESOURCE_READ, RESOURCE_WRITE, RESOURCE_DELETE,
        SYSTEM_CONFIG, SYSTEM_MONITOR
    ])
    DEVELOPER = Role("developer", [
        SKILL_CREATE, SKILL_READ, SKILL_UPDATE, SKILL_EXECUTE,
        RESOURCE_READ, RESOURCE_WRITE
    ])
    USER = Role("user", [
        SKILL_READ, SKILL_EXECUTE,
        RESOURCE_READ
    ])
    GUEST = Role("guest", [
        SKILL_READ
    ])

~~~
### 2. 基于属性的访问控制（ABAC）
#### 2.1 属性定义
```python
class Attribute:
    def __init__(self, name, value):
        self.name = name
        self.value = value

# 用户属性
class UserAttributes:
    def __init__(self, user_id, role, department, level):
        self.user_id = Attribute("user_id", user_id)
        self.role = Attribute("role", role)
        self.department = Attribute("department", department)
        self.level = Attribute("level", level)

# 资源属性
class ResourceAttributes:
    def __init__(self, resource_id, owner, sensitivity, classification):
        self.resource_id = Attribute("resource_id", resource_id)
        self.owner = Attribute("owner", owner)
        self.sensitivity = Attribute("sensitivity", sensitivity)
        self.classification = Attribute("classification", classification)

# 环境属性
class EnvironmentAttributes:
    def __init__(self, time, location, device):
        self.time = Attribute("time", time)
        self.location = Attribute("location", location)
        self.device = Attribute("device", device)

#### 2.2 策略定义
```python
class AccessPolicy:
    def __init__(self, name, condition, effect):
        self.name = name
        self.condition = condition
        self.effect = effect
# 示例策略
    POLICIES = [
        AccessPolicy(
            name="admin_full_access",
            condition=lambda user, resource, env: user.role.value == "admin",
            effect="allow"
        ),
        AccessPolicy(
            name="owner_access",
            condition=lambda user, resource, env: user.user_id.value == resource.owner.value,
            effect="allow"
        ),
        AccessPolicy(
            name="sensitivity_restriction",
            condition=lambda user, resource, env: resource.sensitivity.value == "high" and user.level.value < 3,
            effect="deny"
        ),
        AccessPolicy(
            name="business_hours_only",
            condition=lambda user, resource, env: not (9 <= env.time.value.hour < 17),
            effect="deny"
        )
    ]

~~~
### 3. 权限检查
#### 3.1 RBAC 检查
```python
class RBACChecker:
    def __init__(self):
        self.user_roles = {}
        self.role_permissions = {}

    def assign_role(self, user_id, role):
        if user_id not in self.user_roles:
            self.user_roles[user_id] = []
        self.user_roles[user_id].append(role)

    def check_permission(self, user_id, permission):
        # 获取用户角色
        roles = self.user_roles.get(user_id, [])

        # 检查每个角色是否有该权限
        for role in roles:
            if permission in role.permissions:
                return True

        return False

    def check_skill_permission(self, user_id, skill_id, action):
        permission = Permission(f"skill:{action}", "")
        return self.check_permission(user_id, permission)

#### 3.2 ABAC 检查

class ABACChecker:
    def __init__(self):
        self.policies = []

    def add_policy(self, policy):
        self.policies.append(policy)

    def check_access(self, user, resource, environment):
        for policy in self.policies:
            if policy.condition(user, resource, environment):
                return policy.effect == "allow"
        return False

    def check_skill_access(self, user, skill, environment):
        return self.check_access(user, skill, environment)

~~~
## 资源访问控制
### 1. 文件系统访问
#### 1.1 文件权限
```python
class FilePermission:
    def __init__(self, path, read, write, execute):
        self.path = path
        self.read = read
        self.write = write
        self.execute = execute

class FileAccessController:
    def __init__(self):
        self.permissions = {}

    def set_permission(self, path, read=False, write=False, execute=False):
        self.permissions[path] = FilePermission(path, read, write, execute)

    def check_read(self, user_id, path):
        permission = self.permissions.get(path)
        if not permission:
            return False

        # 检查用户是否有读权限
        if permission.read:
            return True

        # 检查用户是否是文件所有者
        if self.is_owner(user_id, path):
            return True

        return False

    def check_write(self, user_id, path):
        permission = self.permissions.get(path)
        if not permission:
            return False

        if permission.write:
            return True

        if self.is_owner(user_id, path):
            return True

        return False

    def is_owner(self, user_id, path):
        # 检查用户是否是文件所有者
        pass
```

###### 1.2 目录访问

```
python复制class DirectoryAccessController:
    def __init__(self):
        self.access_rules = {}

    def set_access_rule(self, directory, allowed_users, allowed_roles):
        self.access_rules[directory] = {
            "users": allowed_users,
            "roles": allowed_roles
        }

    def check_access(self, user_id, user_roles, directory):
        rule = self.access_rules.get(directory)
        if not rule:
            return False
        if user_id in rule["users"]:
            return True
        for role in user_roles:
            if role in rule["roles"]:
                return True
        return False
```

```
class DirectoryAccessController:
    def __init__(self):
        self.access_rules = {}

    def set_access_rule(self, directory, allowed_users, allowed_roles):
        self.access_rules[directory] = {
            "users": allowed_users,
            "roles": allowed_roles
        }

    def check_access(self, user_id, user_roles, directory):
        rule = self.access_rules.get(directory)
        if not rule:
            return False
        if user_id in rule["users"]:
            return True
        for role in user_roles:
            if role in rule["roles"]:
                return True
        return False
```

##### 2. API 访问控制#

###### 2.1 API 权限

```
python复制class APIPermission:
    def __init__(self, endpoint, method, required_permissions):
        self.endpoint = endpoint
        self.method = method
        self.required_permissions = required_permissions

class APIAccessController:
    def __init__(self):
        self.api_permissions = {}

    def register_endpoint(self, endpoint, method, required_permissions):
        key = f"{method}:{endpoint}"
        self.api_permissions[key] = APIPermission(
            endpoint, method, required_permissions
        )

    def check_access(self, user_id, endpoint, method):
        key = f"{method}:{endpoint}"
        permission = self.api_permissions.get(key)

        if not permission:
            return False

        # 检查用户是否有所有必需的权限
        for required_perm in permission.required_permissions:
            if not self.has_permission(user_id, required_perm):
                return False

        return True

    def has_permission(self, user_id, permission):
        # 检查用户是否有特定权限
        pass
```

```
class APIPermission:
    def __init__(self, endpoint, method, required_permissions):
        self.endpoint = endpoint
        self.method = method
        self.required_permissions = required_permissions

class APIAccessController:
    def __init__(self):
        self.api_permissions = {}

    def register_endpoint(self, endpoint, method, required_permissions):
        key = f"{method}:{endpoint}"
        self.api_permissions[key] = APIPermission(
            endpoint, method, required_permissions
        )

    def check_access(self, user_id, endpoint, method):
        key = f"{method}:{endpoint}"
        permission = self.api_permissions.get(key)

        if not permission:
            return False

        # 检查用户是否有所有必需的权限
        for required_perm in permission.required_permissions:
            if not self.has_permission(user_id, required_perm):
                return False

        return True

    def has_permission(self, user_id, permission):
        # 检查用户是否有特定权限
        pass
```

###### 2.2 速率限制

```
python复制class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)

    def check_rate_limit(self, user_id, endpoint, limit, window):
        now = datetime.now()
        window_start = now - timedelta(seconds=window)
        user_requests = self.requests[user_id]
        recent_requests = [
            req for req in user_requests
            if req["timestamp"] >= window_start and req["endpoint"] == endpoint
        ]
        if len(recent_requests) >= limit:
            return False
        user_requests.append({
            "endpoint": endpoint,
            "timestamp": now
        })
        return True
```

```
class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)

    def check_rate_limit(self, user_id, endpoint, limit, window):
        now = datetime.now()
        window_start = now - timedelta(seconds=window)
        user_requests = self.requests[user_id]
        recent_requests = [
            req for req in user_requests
            if req["timestamp"] >= window_start and req["endpoint"] == endpoint
        ]
        if len(recent_requests) >= limit:
            return False
        user_requests.append({
            "endpoint": endpoint,
            "timestamp": now
        })
        return True
```

##### 3. 数据访问控制#

###### 3.1 数据库访问

```
python复制class DatabaseAccessController:
    def __init__(self):
        self.table_permissions = {}

    def set_table_permission(self, table, permissions):
        self.table_permissions[table] = permissions

    def check_select(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("select", False)

    def check_insert(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("insert", False)

    def check_update(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("update", False)

    def check_delete(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("delete", False)

#### 3.2 字段级访问

class FieldAccessController:
    def __init__(self):
        self.field_permissions = {}

    def set_field_permission(self, table, field, allowed_roles):
        key = f"{table}.{field}"
        self.field_permissions[key] = allowed_roles

    def check_field_access(self, user_roles, table, field):
        key = f"{table}.{field}"
        allowed_roles = self.field_permissions.get(key, [])
        for role in user_roles:
            if role in allowed_roles:
                return True
        return False

    def filter_fields(self, user_roles, table, fields):
        accessible_fields = []
        for field in fields:
            if self.check_field_access(user_roles, table, field):
                accessible_fields.append(field)
        return accessible_fields
```

```
class DatabaseAccessController:
    def __init__(self):
        self.table_permissions = {}

    def set_table_permission(self, table, permissions):
        self.table_permissions[table] = permissions

    def check_select(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("select", False)

    def check_insert(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("insert", False)

    def check_update(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("update", False)

    def check_delete(self, user_id, table):
        permission = self.table_permissions.get(table)
        if not permission:
            return False

        return permission.get("delete", False)

#### 3.2 字段级访问

class FieldAccessController:
    def __init__(self):
        self.field_permissions = {}

    def set_field_permission(self, table, field, allowed_roles):
        key = f"{table}.{field}"
        self.field_permissions[key] = allowed_roles

    def check_field_access(self, user_roles, table, field):
        key = f"{table}.{field}"
        allowed_roles = self.field_permissions.get(key, [])
        for role in user_roles:
            if role in allowed_roles:
                return True
        return False

    def filter_fields(self, user_roles, table, fields):
        accessible_fields = []
        for field in fields:
            if self.check_field_access(user_roles, table, field):
                accessible_fields.append(field)
        return accessible_fields
```

#### Skill 权限管理#

##### 1. Skill 创建权限#

```
bash复制python

class SkillCreationManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_create_skill(self, user_id, skill_definition):
        # 检查用户是否有创建 Skill 的权限
        if not self.permission_checker.check_permission(user_id, SKILL_CREATE):
            return False

        # 检查 Skill 定义是否符合规范
        if not self.validate_skill_definition(skill_definition):
            return False

        # 检查资源访问权限
        if not self.check_resource_access(user_id, skill_definition):
            return False

        return True

    def validate_skill_definition(self, definition):
        # 验证 Skill 定义
        required_fields = ["name", "version", "description"]
        for field in required_fields:
            if field not in definition:
                return False
        return True

    def check_resource_access(self, user_id, definition):
        # 检查 Skill 需要访问的资源
        resources = definition.get("resources", [])
        for resource in resources:
            if not self.permission_checker.check_resource_access(user_id, resource):
                return False
        return True
```

### 2. Skill 执行权限
```python
class SkillExecutionManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_execute_skill(self, user_id, skill_id, parameters):
        if not self.permission_checker.check_permission(user_id, SKILL_EXECUTE):
            return False
        skill = self.get_skill(skill_id)
        if not skill:
            return False
        if not self.check_skill_specific_permission(user_id, skill):
            return False
        if not self.check_parameter_permissions(user_id, skill, parameters):
            return False
        return True

    def check_skill_specific_permission(self, user_id, skill):
        required_permissions = skill.get_required_permissions()
        for permission in required_permissions:
            if not self.permission_checker.check_permission(user_id, permission):
                return False
        return True

    def check_parameter_permissions(self, user_id, skill, parameters):
        for key, value in parameters.items():
            if self.is_resource_reference(value):
                if not self.permission_checker.check_resource_access(user_id, value):
                    return False
        return True

    def is_resource_reference(self, value):
        return isinstance(value, str) and value.startswith("resource://")
```

```
python

class SkillCreationManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_create_skill(self, user_id, skill_definition):
        # 检查用户是否有创建 Skill 的权限
        if not self.permission_checker.check_permission(user_id, SKILL_CREATE):
            return False

        # 检查 Skill 定义是否符合规范
        if not self.validate_skill_definition(skill_definition):
            return False

        # 检查资源访问权限
        if not self.check_resource_access(user_id, skill_definition):
            return False

        return True

    def validate_skill_definition(self, definition):
        # 验证 Skill 定义
        required_fields = ["name", "version", "description"]
        for field in required_fields:
            if field not in definition:
                return False
        return True

    def check_resource_access(self, user_id, definition):
        # 检查 Skill 需要访问的资源
        resources = definition.get("resources", [])
        for resource in resources:
            if not self.permission_checker.check_resource_access(user_id, resource):
                return False
        return True
```

### 2. Skill 执行权限
```python
class SkillExecutionManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_execute_skill(self, user_id, skill_id, parameters):
        if not self.permission_checker.check_permission(user_id, SKILL_EXECUTE):
            return False
        skill = self.get_skill(skill_id)
        if not skill:
            return False
        if not self.check_skill_specific_permission(user_id, skill):
            return False
        if not self.check_parameter_permissions(user_id, skill, parameters):
            return False
        return True

    def check_skill_specific_permission(self, user_id, skill):
        required_permissions = skill.get_required_permissions()
        for permission in required_permissions:
            if not self.permission_checker.check_permission(user_id, permission):
                return False
        return True

    def check_parameter_permissions(self, user_id, skill, parameters):
        for key, value in parameters.items():
            if self.is_resource_reference(value):
                if not self.permission_checker.check_resource_access(user_id, value):
                    return False
        return True

    def is_resource_reference(self, value):
        return isinstance(value, str) and value.startswith("resource://")
```

##### 3. Skill 修改权限#

```
bash复制python

class SkillModificationManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_modify_skill(self, user_id, skill_id):
        # 检查用户是否有修改 Skill 的权限
        if not self.permission_checker.check_permission(user_id, SKILL_UPDATE):
            return False

        # 检查 Skill 是否存在
        skill = self.get_skill(skill_id)
        if not skill:
            return False

        # 检查用户是否是 Skill 所有者
        if not self.is_skill_owner(user_id, skill):
            return False

        return True

    def is_skill_owner(self, user_id, skill):
        return skill.owner_id == user_id
```

### 4. Skill 删除权限
```python
class SkillDeletionManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_delete_skill(self, user_id, skill_id):
        if not self.permission_checker.check_permission(user_id, SKILL_DELETE):
            return False
        skill = self.get_skill(skill_id)
        if not skill:
            return False
        if not (self.is_skill_owner(user_id, skill) or
                self.permission_checker.is_admin(user_id)):
            return False
        if self.has_dependents(skill_id):
            return False
        return True

    def is_skill_owner(self, user_id, skill):
        return skill.owner_id == user_id

    def has_dependents(self, skill_id):
        pass
```

## 审计日志
### 1. 访问日志
```python
class AccessLogger:
    def __init__(self):
        self.logs = []

    def log_access(self, user_id, resource, action, result):
        log_entry = {
            "timestamp": datetime.now(),
            "user_id": user_id,
            "resource": resource,
            "action": action,
            "result": result
        }
        self.logs.append(log_entry)

    def get_access_logs(self, user_id=None, resource=None, action=None):
        filtered_logs = self.logs

        if user_id:
            filtered_logs = [log for log in filtered_logs if log["user_id"] == user_id]

        if resource:
            filtered_logs = [log for log in filtered_logs if log["resource"] == resource]

        if action:
            filtered_logs = [log for log in filtered_logs if log["action"] == action]

        return filtered_logs
```

### 2. 权限变更日志
```python
class PermissionChangeLogger:
    def __init__(self):
        self.changes = []

    def log_permission_change(self, user_id, target, old_permissions, new_permissions, changed_by):
        change_entry = {
            "timestamp": datetime.now(),
            "user_id": user_id,
            "target": target,
            "old_permissions": old_permissions,
            "new_permissions": new_permissions,
            "changed_by": changed_by
        }
        self.changes.append(change_entry)

    def get_permission_changes(self, user_id=None, target=None):
        filtered_changes = self.changes
        if user_id:
            filtered_changes = [change for change in filtered_changes if change["user_id"] == user_id]
        if target:
            filtered_changes = [change for change in filtered_changes if change["target"] == target]
        return filtered_changes
```
```

```
python

class SkillModificationManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_modify_skill(self, user_id, skill_id):
        # 检查用户是否有修改 Skill 的权限
        if not self.permission_checker.check_permission(user_id, SKILL_UPDATE):
            return False

        # 检查 Skill 是否存在
        skill = self.get_skill(skill_id)
        if not skill:
            return False

        # 检查用户是否是 Skill 所有者
        if not self.is_skill_owner(user_id, skill):
            return False

        return True

    def is_skill_owner(self, user_id, skill):
        return skill.owner_id == user_id
```

### 4. Skill 删除权限
```python
class SkillDeletionManager:
    def __init__(self, permission_checker):
        self.permission_checker = permission_checker

    def can_delete_skill(self, user_id, skill_id):
        if not self.permission_checker.check_permission(user_id, SKILL_DELETE):
            return False
        skill = self.get_skill(skill_id)
        if not skill:
            return False
        if not (self.is_skill_owner(user_id, skill) or
                self.permission_checker.is_admin(user_id)):
            return False
        if self.has_dependents(skill_id):
            return False
        return True

    def is_skill_owner(self, user_id, skill):
        return skill.owner_id == user_id

    def has_dependents(self, skill_id):
        pass
```

## 审计日志
### 1. 访问日志
```python
class AccessLogger:
    def __init__(self):
        self.logs = []

    def log_access(self, user_id, resource, action, result):
        log_entry = {
            "timestamp": datetime.now(),
            "user_id": user_id,
            "resource": resource,
            "action": action,
            "result": result
        }
        self.logs.append(log_entry)

    def get_access_logs(self, user_id=None, resource=None, action=None):
        filtered_logs = self.logs

        if user_id:
            filtered_logs = [log for log in filtered_logs if log["user_id"] == user_id]

        if resource:
            filtered_logs = [log for log in filtered_logs if log["resource"] == resource]

        if action:
            filtered_logs = [log for log in filtered_logs if log["action"] == action]

        return filtered_logs
```

### 2. 权限变更日志
```python
class PermissionChangeLogger:
    def __init__(self):
        self.changes = []

    def log_permission_change(self, user_id, target, old_permissions, new_permissions, changed_by):
        change_entry = {
            "timestamp": datetime.now(),
            "user_id": user_id,
            "target": target,
            "old_permissions": old_permissions,
            "new_permissions": new_permissions,
            "changed_by": changed_by
        }
        self.changes.append(change_entry)

    def get_permission_changes(self, user_id=None, target=None):
        filtered_changes = self.changes
        if user_id:
            filtered_changes = [change for change in filtered_changes if change["user_id"] == user_id]
        if target:
            filtered_changes = [change for change in filtered_changes if change["target"] == target]
        return filtered_changes
```
```

---

## 5 Skills 版本管理

**URL**: https://claudecode.tangshuang.net/course/16.5%20Skills%20%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86

#### 版本管理概述#

Skills 的版本管理是维护和演进 Skills 的重要机制。本节将详细介绍 Skills 的版本控制、版本发布和版本迁移等内容。

#### 版本控制#

##### 1. 版本号规范#

###### 1.1 语义化版本

#### 语义化版本（SemVer）#

##### 版本格式#

主版本号.次版本号.修订号（MAJOR.MINOR.PATCH）

##### 版本规则#

- 主版本号（MAJOR）：不兼容的 API 修改
- 次版本号（MINOR）：向下兼容的功能性新增
- 修订号（PATCH）：向下兼容的问题修正

##### 示例#

- 1.0.0 → 1.1.0：新增功能（向下兼容）
- 1.1.0 → 1.1.1：修复 bug（向下兼容）
- 1.1.1 → 2.0.0：不兼容的 API 变更

###### 1.2 预发布版本

##### 格式#

主版本号.次版本号.修订号-预发布标识.预发布版本号

##### 预发布标识#

- alpha：内部测试版
- beta：公开测试版
- rc：候选发布版

##### 示例#

- 1.0.0-alpha.1：第一个 alpha 版本
- 1.0.0-beta.1：第一个 beta 版本
- 1.0.0-rc.1：第一个候选版本

###### 1.3 构建元数据

##### 格式#

主版本号.次版本号.修订号+构建元数据

##### 构建元数据#

- 构建日期
- 构建号
- Git 提交哈希

##### 示例#

- 1.0.0+20240115
- 1.0.0+build.123
- 1.0.0+abc123def456

##### 2. 版本比较#

###### 2.1 版本比较算法

```
python复制class VersionComparator:
    def compare(self, v1, v2):
```

```
class VersionComparator:
    def compare(self, v1, v2):
```

```
bash复制    v1_parts = self.parse_version(v1)
    v2_parts = self.parse_version(v2)

    # 比较主版本号
    if v1_parts["major"] != v2_parts["major"]:
        return -1 if v1_parts["major"] < v2_parts["major"] else 1

    # 比较次版本号
    if v1_parts["minor"] != v2_parts["minor"]:
        return -1 if v1_parts["minor"] < v2_parts["minor"] else 1

    # 比较修订号
    if v1_parts["patch"] != v2_parts["patch"]:
        return -1 if v1_parts["patch"] < v2_parts["patch"] else 1

    # 比较预发布版本
    if v1_parts["prerelease"] and v2_parts["prerelease"]:
        return self.compare_prerelease(v1_parts["prerelease"], v2_parts["prerelease"])
    elif v1_parts["prerelease"]:
        return -1
    elif v2_parts["prerelease"]:
        return 1

    return 0

def parse_version(self, version):
    # 解析版本号
    parts = version.split("-", 1)
    version_part = parts[0]
    prerelease_part = parts[1] if len(parts) > 1 else None

    version_numbers = version_part.split(".")
    major = int(version_numbers[0]) if len(version_numbers) > 0 else 0
    minor = int(version_numbers[1]) if len(version_numbers) > 1 else 0
    patch = int(version_numbers[2]) if len(version_numbers) > 2 else 0

    # 解析构建元数据
    build_metadata = None
    if "+" in version_part:
        version_part, build_metadata = version_part.split("+", 1)

    return {
        "major": major,
        "minor": minor,
        "patch": patch,
        "prerelease": prerelease_part,
        "build": build_metadata
    }

def compare_prerelease(self, p1, p2):
    # 比较预发布版本
    p1_parts = p1.split(".")
    p2_parts = p2.split(".")

    for i in range(max(len(p1_parts), len(p2_parts))):
        if i >= len(p1_parts):
            return -1
        if i >= len(p2_parts):
            return 1

        part1 = p1_parts[i]
        part2 = p2_parts[i]

        # 数字比较
        if part1.isdigit() and part2.isdigit():
            num1 = int(part1)
            num2 = int(part2)
            if num1 != num2:
                return -1 if num1 < num2 else 1
        else:
            # 字符串比较
            if part1 != part2:
                return -1 if part1 < part2 else 1

    return 0
```

```
v1_parts = self.parse_version(v1)
    v2_parts = self.parse_version(v2)

    # 比较主版本号
    if v1_parts["major"] != v2_parts["major"]:
        return -1 if v1_parts["major"] < v2_parts["major"] else 1

    # 比较次版本号
    if v1_parts["minor"] != v2_parts["minor"]:
        return -1 if v1_parts["minor"] < v2_parts["minor"] else 1

    # 比较修订号
    if v1_parts["patch"] != v2_parts["patch"]:
        return -1 if v1_parts["patch"] < v2_parts["patch"] else 1

    # 比较预发布版本
    if v1_parts["prerelease"] and v2_parts["prerelease"]:
        return self.compare_prerelease(v1_parts["prerelease"], v2_parts["prerelease"])
    elif v1_parts["prerelease"]:
        return -1
    elif v2_parts["prerelease"]:
        return 1

    return 0

def parse_version(self, version):
    # 解析版本号
    parts = version.split("-", 1)
    version_part = parts[0]
    prerelease_part = parts[1] if len(parts) > 1 else None

    version_numbers = version_part.split(".")
    major = int(version_numbers[0]) if len(version_numbers) > 0 else 0
    minor = int(version_numbers[1]) if len(version_numbers) > 1 else 0
    patch = int(version_numbers[2]) if len(version_numbers) > 2 else 0

    # 解析构建元数据
    build_metadata = None
    if "+" in version_part:
        version_part, build_metadata = version_part.split("+", 1)

    return {
        "major": major,
        "minor": minor,
        "patch": patch,
        "prerelease": prerelease_part,
        "build": build_metadata
    }

def compare_prerelease(self, p1, p2):
    # 比较预发布版本
    p1_parts = p1.split(".")
    p2_parts = p2.split(".")

    for i in range(max(len(p1_parts), len(p2_parts))):
        if i >= len(p1_parts):
            return -1
        if i >= len(p2_parts):
            return 1

        part1 = p1_parts[i]
        part2 = p2_parts[i]

        # 数字比较
        if part1.isdigit() and part2.isdigit():
            num1 = int(part1)
            num2 = int(part2)
            if num1 != num2:
                return -1 if num1 < num2 else 1
        else:
            # 字符串比较
            if part1 != part2:
                return -1 if part1 < part2 else 1

    return 0
```

```
bash复制
#### 2.2 版本范围

```python
class VersionRange:
    def __init__(self, range_spec):
        self.range_spec = range_spec
        self.comparator = VersionComparator()

    def satisfies(self, version):
        constraints = self.parse_range(self.range_spec)
        for constraint in constraints:
            if not self.check_constraint(version, constraint):
                return False
        return True

    def parse_range(self, range_spec):
        constraints = []
        if not any(c in range_spec for c in ['^', '~', '>=', '<=', '>', '<', '||']):
            constraints.append({
                "operator": "==",
                "version": range_spec
            })
            return constraints
        parts = range_spec.split("||")
        for part in parts:
            part = part.strip()
            if part.startswith("^"):
                version = part[1:]
                constraints.append({
                    "operator": "^",
                    "version": version
                })
            elif part.startswith("~"):
                version = part[1:]
                constraints.append({
                    "operator": "~",
                    "version": version
                })
            elif part.startswith(">="):
                version = part[2:]
                constraints.append({
                    "operator": ">=",
                    "version": version
                })
            elif part.startswith("<="):
                version = part[2:]
                constraints.append({
                    "operator": "<=",
                    "version": version
                })
            elif part.startswith(">"):
                version = part[1:]
                constraints.append({
                    "operator": ">",
                    "version": version
                })
            elif part.startswith("<"):
                version = part[1:]
                constraints.append({
                    "operator": "<",
                    "version": version
                })
        return constraints

    def check_constraint(self, version, constraint):
        operator = constraint["operator"]
        constraint_version = constraint["version"]
        if operator == "==":
            return self.comparator.compare(version, constraint_version) == 0
        elif operator == ">=":
            return self.comparator.compare(version, constraint_version) >= 0
        elif operator == "<=":
            return self.comparator.compare(version, constraint_version) <= 0
        elif operator == ">":
            return self.comparator.compare(version, constraint_version) > 0
        elif operator == "<":
            return self.comparator.compare(version, constraint_version) < 0
        elif operator == "^":
            return self.check_caret(version, constraint_version)
        elif operator == "~":
            return self.check_tilde(version, constraint_version)
        return False

    def check_caret(self, version, constraint):
        constraint_parts = self.comparator.parse_version(constraint)
        min_version = constraint
        max_version = f"{constraint_parts['major'] + 1}.0.0"
        return (self.comparator.compare(version, min_version) >= 0 and
                self.comparator.compare(version, max_version) < 0)

    def check_tilde(self, version, constraint):
        constraint_parts = self.comparator.parse_version(constraint)
        min_version = constraint
        max_version = f"{constraint_parts['major']}.{constraint_parts['minor'] + 1}.0"
        return (self.comparator.compare(version, min_version) >= 0 and
                self.comparator.compare(version, max_version) < 0)
```

```
#### 2.2 版本范围

```python
class VersionRange:
    def __init__(self, range_spec):
        self.range_spec = range_spec
        self.comparator = VersionComparator()

    def satisfies(self, version):
        constraints = self.parse_range(self.range_spec)
        for constraint in constraints:
            if not self.check_constraint(version, constraint):
                return False
        return True

    def parse_range(self, range_spec):
        constraints = []
        if not any(c in range_spec for c in ['^', '~', '>=', '<=', '>', '<', '||']):
            constraints.append({
                "operator": "==",
                "version": range_spec
            })
            return constraints
        parts = range_spec.split("||")
        for part in parts:
            part = part.strip()
            if part.startswith("^"):
                version = part[1:]
                constraints.append({
                    "operator": "^",
                    "version": version
                })
            elif part.startswith("~"):
                version = part[1:]
                constraints.append({
                    "operator": "~",
                    "version": version
                })
            elif part.startswith(">="):
                version = part[2:]
                constraints.append({
                    "operator": ">=",
                    "version": version
                })
            elif part.startswith("<="):
                version = part[2:]
                constraints.append({
                    "operator": "<=",
                    "version": version
                })
            elif part.startswith(">"):
                version = part[1:]
                constraints.append({
                    "operator": ">",
                    "version": version
                })
            elif part.startswith("<"):
                version = part[1:]
                constraints.append({
                    "operator": "<",
                    "version": version
                })
        return constraints

    def check_constraint(self, version, constraint):
        operator = constraint["operator"]
        constraint_version = constraint["version"]
        if operator == "==":
            return self.comparator.compare(version, constraint_version) == 0
        elif operator == ">=":
            return self.comparator.compare(version, constraint_version) >= 0
        elif operator == "<=":
            return self.comparator.compare(version, constraint_version) <= 0
        elif operator == ">":
            return self.comparator.compare(version, constraint_version) > 0
        elif operator == "<":
            return self.comparator.compare(version, constraint_version) < 0
        elif operator == "^":
            return self.check_caret(version, constraint_version)
        elif operator == "~":
            return self.check_tilde(version, constraint_version)
        return False

    def check_caret(self, version, constraint):
        constraint_parts = self.comparator.parse_version(constraint)
        min_version = constraint
        max_version = f"{constraint_parts['major'] + 1}.0.0"
        return (self.comparator.compare(version, min_version) >= 0 and
                self.comparator.compare(version, max_version) < 0)

    def check_tilde(self, version, constraint):
        constraint_parts = self.comparator.parse_version(constraint)
        min_version = constraint
        max_version = f"{constraint_parts['major']}.{constraint_parts['minor'] + 1}.0"
        return (self.comparator.compare(version, min_version) >= 0 and
                self.comparator.compare(version, max_version) < 0)
```

##### 3. 版本存储#

###### 3.1 版本仓库

```
python复制class VersionRepository:
    def __init__(self, storage_path):
        self.storage_path = storage_path
        self.comparator = VersionComparator()

    def save_version(self, skill_id, version, skill_data):
        version_path = self.get_version_path(skill_id, version)
        os.makedirs(os.path.dirname(version_path), exist_ok=True)

        with open(version_path, 'w') as f:
            json.dump(skill_data, f, indent=2)

    def load_version(self, skill_id, version):
        version_path = self.get_version_path(skill_id, version)

        if not os.path.exists(version_path):
            raise VersionNotFoundError(version)

        with open(version_path, 'r') as f:
            return json.load(f)

    def list_versions(self, skill_id):
        skill_path = self.get_skill_path(skill_id)

        if not os.path.exists(skill_path):
            return []

        versions = []
        for item in os.listdir(skill_path):
            if os.path.isdir(os.path.join(skill_path, item)):
                versions.append(item)

        versions.sort(key=lambda v: self.comparator.parse_version(v))

        return versions

    def get_latest_version(self, skill_id):
        versions = self.list_versions(skill_id)

        if not versions:
            return None

        return versions[-1]

    def get_version_path(self, skill_id, version):
        return os.path.join(self.storage_path, skill_id, version, "skill.json")

    def get_skill_path(self, skill_id):
        return os.path.join(self.storage_path, skill_id)
```

```
class VersionRepository:
    def __init__(self, storage_path):
        self.storage_path = storage_path
        self.comparator = VersionComparator()

    def save_version(self, skill_id, version, skill_data):
        version_path = self.get_version_path(skill_id, version)
        os.makedirs(os.path.dirname(version_path), exist_ok=True)

        with open(version_path, 'w') as f:
            json.dump(skill_data, f, indent=2)

    def load_version(self, skill_id, version):
        version_path = self.get_version_path(skill_id, version)

        if not os.path.exists(version_path):
            raise VersionNotFoundError(version)

        with open(version_path, 'r') as f:
            return json.load(f)

    def list_versions(self, skill_id):
        skill_path = self.get_skill_path(skill_id)

        if not os.path.exists(skill_path):
            return []

        versions = []
        for item in os.listdir(skill_path):
            if os.path.isdir(os.path.join(skill_path, item)):
                versions.append(item)

        versions.sort(key=lambda v: self.comparator.parse_version(v))

        return versions

    def get_latest_version(self, skill_id):
        versions = self.list_versions(skill_id)

        if not versions:
            return None

        return versions[-1]

    def get_version_path(self, skill_id, version):
        return os.path.join(self.storage_path, skill_id, version, "skill.json")

    def get_skill_path(self, skill_id):
        return os.path.join(self.storage_path, skill_id)
```

###### 3.2 版本索引

```
python复制class VersionIndex:
    def __init__(self, index_path):
        self.index_path = index_path
        self.index = self.load_index()

    def load_index(self):
        if os.path.exists(self.index_path):
            with open(self.index_path, 'r') as f:
                return json.load(f)
        return {}

    def save_index(self):
        with open(self.index_path, 'w') as f:
            json.dump(self.index, f, indent=2)

    def add_version(self, skill_id, version, metadata):
        if skill_id not in self.index:
            self.index[skill_id] = {}
        self.index[skill_id][version] = metadata
        self.save_index()

    def get_version_metadata(self, skill_id, version):
        return self.index.get(skill_id, {}).get(version)

    def list_versions(self, skill_id):
        versions = self.index.get(skill_id, {})
        return list(versions.keys())

    def get_latest_version(self, skill_id):
        versions = self.list_versions(skill_id)
        if not versions:
            return None
        comparator = VersionComparator()
        return max(versions, key=lambda v: comparator.parse_version(v))

    def search_versions(self, skill_id, version_range):
        range_checker = VersionRange(version_range)
        versions = self.list_versions(skill_id)
        return [v for v in versions if range_checker.satisfies(v)]
```

```
class VersionIndex:
    def __init__(self, index_path):
        self.index_path = index_path
        self.index = self.load_index()

    def load_index(self):
        if os.path.exists(self.index_path):
            with open(self.index_path, 'r') as f:
                return json.load(f)
        return {}

    def save_index(self):
        with open(self.index_path, 'w') as f:
            json.dump(self.index, f, indent=2)

    def add_version(self, skill_id, version, metadata):
        if skill_id not in self.index:
            self.index[skill_id] = {}
        self.index[skill_id][version] = metadata
        self.save_index()

    def get_version_metadata(self, skill_id, version):
        return self.index.get(skill_id, {}).get(version)

    def list_versions(self, skill_id):
        versions = self.index.get(skill_id, {})
        return list(versions.keys())

    def get_latest_version(self, skill_id):
        versions = self.list_versions(skill_id)
        if not versions:
            return None
        comparator = VersionComparator()
        return max(versions, key=lambda v: comparator.parse_version(v))

    def search_versions(self, skill_id, version_range):
        range_checker = VersionRange(version_range)
        versions = self.list_versions(skill_id)
        return [v for v in versions if range_checker.satisfies(v)]
```

#### 版本发布#

##### 1. 发布流程#

###### 1.1 发布准备

```
python复制class ReleasePreparer:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.version_index = VersionIndex("./index.json")

    def prepare_release(self, skill_id, version, release_notes):
        if not self.validate_version(version):
            raise InvalidVersionError(version)

        if self.version_exists(skill_id, version):
            raise VersionAlreadyExistsError(version)

        skill_data = self.load_skill_data(skill_id)

        metadata = {
            "version": version,
            "release_date": datetime.now().isoformat(),
            "release_notes": release_notes,
            "checksum": self.calculate_checksum(skill_data)
        }

        return metadata

    def validate_version(self, version):
        pattern = r'^\d+\.\d+\.\d+(-[a-zA-Z0-9]+(\.\d+)?)?(\+[a-zA-Z0-9]+)?$'
        return re.match(pattern, version) is not None

    def version_exists(self, skill_id, version):
        versions = self.version_repository.list_versions(skill_id)
        return version in versions

    def load_skill_data(self, skill_id):
        pass

    def calculate_checksum(self, skill_data):
        data_str = json.dumps(skill_data, sort_keys=True)
        return hashlib.sha256(data_str.encode()).hexdigest()
```

```
class ReleasePreparer:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.version_index = VersionIndex("./index.json")

    def prepare_release(self, skill_id, version, release_notes):
        if not self.validate_version(version):
            raise InvalidVersionError(version)

        if self.version_exists(skill_id, version):
            raise VersionAlreadyExistsError(version)

        skill_data = self.load_skill_data(skill_id)

        metadata = {
            "version": version,
            "release_date": datetime.now().isoformat(),
            "release_notes": release_notes,
            "checksum": self.calculate_checksum(skill_data)
        }

        return metadata

    def validate_version(self, version):
        pattern = r'^\d+\.\d+\.\d+(-[a-zA-Z0-9]+(\.\d+)?)?(\+[a-zA-Z0-9]+)?$'
        return re.match(pattern, version) is not None

    def version_exists(self, skill_id, version):
        versions = self.version_repository.list_versions(skill_id)
        return version in versions

    def load_skill_data(self, skill_id):
        pass

    def calculate_checksum(self, skill_data):
        data_str = json.dumps(skill_data, sort_keys=True)
        return hashlib.sha256(data_str.encode()).hexdigest()
```

###### 1.2 发布执行

```
python复制class ReleasePublisher:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.version_index = VersionIndex("./index.json")

    def publish_release(self, skill_id, version, skill_data, metadata):
        self.version_repository.save_version(skill_id, version, skill_data)
        self.version_index.add_version(skill_id, version, metadata)
        self.create_tag(skill_id, version)
        self.notify_subscribers(skill_id, version, metadata)

    def create_tag(self, skill_id, version):
        tag_name = f"{skill_id}/v{version}"
        tag_message = f"Release {skill_id} version {version}"
        subprocess.run([
            "git", "tag", "-a", tag_name, "-m", tag_message
        ], check=True)

    def notify_subscribers(self, skill_id, version, metadata):
        subscribers = self.get_subscribers(skill_id)
        for subscriber in subscribers:
            self.send_notification(subscriber, skill_id, version, metadata)

    def get_subscribers(self, skill_id):
        pass

    def send_notification(self, subscriber, skill_id, version, metadata):
        pass
```

```
class ReleasePublisher:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.version_index = VersionIndex("./index.json")

    def publish_release(self, skill_id, version, skill_data, metadata):
        self.version_repository.save_version(skill_id, version, skill_data)
        self.version_index.add_version(skill_id, version, metadata)
        self.create_tag(skill_id, version)
        self.notify_subscribers(skill_id, version, metadata)

    def create_tag(self, skill_id, version):
        tag_name = f"{skill_id}/v{version}"
        tag_message = f"Release {skill_id} version {version}"
        subprocess.run([
            "git", "tag", "-a", tag_name, "-m", tag_message
        ], check=True)

    def notify_subscribers(self, skill_id, version, metadata):
        subscribers = self.get_subscribers(skill_id)
        for subscriber in subscribers:
            self.send_notification(subscriber, skill_id, version, metadata)

    def get_subscribers(self, skill_id):
        pass

    def send_notification(self, subscriber, skill_id, version, metadata):
        pass
```

##### 2. 变更日志#

###### 2.1 变更记录

```
python复制class ChangeLogManager:
    def __init__(self):
        self.change_logs = {}

    def add_change(self, skill_id, version, change_type, description):
        if skill_id not in self.change_logs:
            self.change_logs[skill_id] = {}

        if version not in self.change_logs[skill_id]:
            self.change_logs[skill_id][version] = {
                "version": version,
                "date": datetime.now().isoformat(),
                "changes": {
                    "added": [],
                    "changed": [],
                    "deprecated": [],
                    "removed": [],
                    "fixed": [],
                    "security": []
                }
            }

        self.change_logs[skill_id][version]["changes"][change_type].append(description)

    def get_change_log(self, skill_id, version):
        return self.change_logs.get(skill_id, {}).get(version)

    def get_all_change_logs(self, skill_id):
        return self.change_logs.get(skill_id, {})

    def generate_release_notes(self, skill_id, version):
        change_log = self.get_change_log(skill_id, version)

        if not change_log:
            return "No changes recorded."

        notes = [f"# Release {version}"]
        notes.append(f"Date: {change_log['date']}")
        notes.append("")

        changes = change_log["changes"]

        if changes["added"]:
            notes.append("## Added")
            for change in changes["added"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["changed"]:
            notes.append("## Changed")
            for change in changes["changed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["deprecated"]:
            notes.append("## Deprecated")
            for change in changes["deprecated"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["removed"]:
            notes.append("## Removed")
            for change in changes["removed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["fixed"]:
            notes.append("## Fixed")
            for change in changes["fixed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["security"]:
            notes.append("## Security")
            for change in changes["security"]:
                notes.append(f"- {change}")
            notes.append("")

        return "\n".join(notes)
```

```
class ChangeLogManager:
    def __init__(self):
        self.change_logs = {}

    def add_change(self, skill_id, version, change_type, description):
        if skill_id not in self.change_logs:
            self.change_logs[skill_id] = {}

        if version not in self.change_logs[skill_id]:
            self.change_logs[skill_id][version] = {
                "version": version,
                "date": datetime.now().isoformat(),
                "changes": {
                    "added": [],
                    "changed": [],
                    "deprecated": [],
                    "removed": [],
                    "fixed": [],
                    "security": []
                }
            }

        self.change_logs[skill_id][version]["changes"][change_type].append(description)

    def get_change_log(self, skill_id, version):
        return self.change_logs.get(skill_id, {}).get(version)

    def get_all_change_logs(self, skill_id):
        return self.change_logs.get(skill_id, {})

    def generate_release_notes(self, skill_id, version):
        change_log = self.get_change_log(skill_id, version)

        if not change_log:
            return "No changes recorded."

        notes = [f"# Release {version}"]
        notes.append(f"Date: {change_log['date']}")
        notes.append("")

        changes = change_log["changes"]

        if changes["added"]:
            notes.append("## Added")
            for change in changes["added"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["changed"]:
            notes.append("## Changed")
            for change in changes["changed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["deprecated"]:
            notes.append("## Deprecated")
            for change in changes["deprecated"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["removed"]:
            notes.append("## Removed")
            for change in changes["removed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["fixed"]:
            notes.append("## Fixed")
            for change in changes["fixed"]:
                notes.append(f"- {change}")
            notes.append("")

        if changes["security"]:
            notes.append("## Security")
            for change in changes["security"]:
                notes.append(f"- {change}")
            notes.append("")

        return "\n".join(notes)
```

###### 2.2 变更对比

```
python复制class ChangeComparator:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")

    def compare_versions(self, skill_id, from_version, to_version):
        from_data = self.version_repository.load_version(skill_id, from_version)
        to_data = self.version_repository.load_version(skill_id, to_version)
        changes = {
            "added": [],
            "removed": [],
            "modified": []
        }
        changes["added"].extend(self.find_added_parameters(from_data, to_data))
        changes["removed"].extend(self.find_removed_parameters(from_data, to_data))
        changes["modified"].extend(self.find_modified_parameters(from_data, to_data))
        changes["added"].extend(self.find_added_features(from_data, to_data))
        changes["removed"].extend(self.find_removed_features(from_data, to_data))
        changes["modified"].extend(self.find_modified_features(from_data, to_data))
        return changes

    def find_added_parameters(self, from_data, to_data):
        from_params = set(from_data.get("parameters", {}).keys())
        to_params = set(to_data.get("parameters", {}).keys())
        return list(to_params - from_params)

    def find_removed_parameters(self, from_data, to_data):
        from_params = set(from_data.get("parameters", {}).keys())
        to_params = set(to_data.get("parameters", {}).keys())
        return list(from_params - to_params)

    def find_modified_parameters(self, from_data, to_data):
        from_params = from_data.get("parameters", {})
        to_params = to_data.get("parameters", {})
        modified = []
        for param in from_params:
            if param in to_params and from_params[param] != to_params[param]:
                modified.append(param)
        return modified

    def find_added_features(self, from_data, to_data):
        from_features = set(from_data.get("features", []))
        to_features = set(to_data.get("features", []))
        return list(to_features - from_features)

    def find_removed_features(self, from_data, to_data):
        from_features = set(from_data.get("features", []))
        to_features = set(to_data.get("features", []))
        return list(from_features - to_features)

    def find_modified_features(self, from_data, to_data):
        pass
```

```
class ChangeComparator:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")

    def compare_versions(self, skill_id, from_version, to_version):
        from_data = self.version_repository.load_version(skill_id, from_version)
        to_data = self.version_repository.load_version(skill_id, to_version)
        changes = {
            "added": [],
            "removed": [],
            "modified": []
        }
        changes["added"].extend(self.find_added_parameters(from_data, to_data))
        changes["removed"].extend(self.find_removed_parameters(from_data, to_data))
        changes["modified"].extend(self.find_modified_parameters(from_data, to_data))
        changes["added"].extend(self.find_added_features(from_data, to_data))
        changes["removed"].extend(self.find_removed_features(from_data, to_data))
        changes["modified"].extend(self.find_modified_features(from_data, to_data))
        return changes

    def find_added_parameters(self, from_data, to_data):
        from_params = set(from_data.get("parameters", {}).keys())
        to_params = set(to_data.get("parameters", {}).keys())
        return list(to_params - from_params)

    def find_removed_parameters(self, from_data, to_data):
        from_params = set(from_data.get("parameters", {}).keys())
        to_params = set(to_data.get("parameters", {}).keys())
        return list(from_params - to_params)

    def find_modified_parameters(self, from_data, to_data):
        from_params = from_data.get("parameters", {})
        to_params = to_data.get("parameters", {})
        modified = []
        for param in from_params:
            if param in to_params and from_params[param] != to_params[param]:
                modified.append(param)
        return modified

    def find_added_features(self, from_data, to_data):
        from_features = set(from_data.get("features", []))
        to_features = set(to_data.get("features", []))
        return list(to_features - from_features)

    def find_removed_features(self, from_data, to_data):
        from_features = set(from_data.get("features", []))
        to_features = set(to_data.get("features", []))
        return list(from_features - to_features)

    def find_modified_features(self, from_data, to_data):
        pass
```

#### 版本迁移#

#### 版本迁移#

##### 1. 迁移脚本#

###### 1.1 迁移定义

```
python复制class Migration:
    def __init__(self, from_version, to_version, migrate_func):
        self.from_version = from_version
        self.to_version = to_version
        self.migrate_func = migrate_func

    def can_migrate(self, from_version, to_version):
        comparator = VersionComparator()
        return (comparator.compare(from_version, self.from_version) >= 0 and
                comparator.compare(to_version, self.to_version) <= 0)

    def migrate(self, data):
        return self.migrate_func(data)
```

```
class Migration:
    def __init__(self, from_version, to_version, migrate_func):
        self.from_version = from_version
        self.to_version = to_version
        self.migrate_func = migrate_func

    def can_migrate(self, from_version, to_version):
        comparator = VersionComparator()
        return (comparator.compare(from_version, self.from_version) >= 0 and
                comparator.compare(to_version, self.to_version) <= 0)

    def migrate(self, data):
        return self.migrate_func(data)
```

###### 1.2 迁移注册

```
python复制class MigrationRegistry:
    def __init__(self):
        self.migrations = []

    def register_migration(self, migration):
        self.migrations.append(migration)

    def get_migrations(self, from_version, to_version):
        applicable_migrations = []
        for migration in self.migrations:
            if migration.can_migrate(from_version, to_version):
                applicable_migrations.append(migration)
        comparator = VersionComparator()
        applicable_migrations.sort(key=lambda m: comparator.parse_version(m.from_version))
        return applicable_migrations
```

```
class MigrationRegistry:
    def __init__(self):
        self.migrations = []

    def register_migration(self, migration):
        self.migrations.append(migration)

    def get_migrations(self, from_version, to_version):
        applicable_migrations = []
        for migration in self.migrations:
            if migration.can_migrate(from_version, to_version):
                applicable_migrations.append(migration)
        comparator = VersionComparator()
        applicable_migrations.sort(key=lambda m: comparator.parse_version(m.from_version))
        return applicable_migrations
```

##### 2. 迁移执行#

###### 2.1 数据迁移

```
python复制class DataMigrator:
    def __init__(self, migration_registry):
        self.migration_registry = migration_registry

    def migrate_data(self, data, from_version, to_version):
        migrations = self.migration_registry.get_migrations(from_version, to_version)
        current_data = data
        current_version = from_version

        for migration in migrations:
            current_data = migration.migrate(current_data)
            current_version = migration.to_version

        return current_data

    def migrate_skill(self, skill_id, from_version, to_version):
        version_repository = VersionRepository("./skills")
        data = version_repository.load_version(skill_id, from_version)
        migrated_data = self.migrate_data(data, from_version, to_version)
        version_repository.save_version(skill_id, to_version, migrated_data)
        return migrated_data
```

```
class DataMigrator:
    def __init__(self, migration_registry):
        self.migration_registry = migration_registry

    def migrate_data(self, data, from_version, to_version):
        migrations = self.migration_registry.get_migrations(from_version, to_version)
        current_data = data
        current_version = from_version

        for migration in migrations:
            current_data = migration.migrate(current_data)
            current_version = migration.to_version

        return current_data

    def migrate_skill(self, skill_id, from_version, to_version):
        version_repository = VersionRepository("./skills")
        data = version_repository.load_version(skill_id, from_version)
        migrated_data = self.migrate_data(data, from_version, to_version)
        version_repository.save_version(skill_id, to_version, migrated_data)
        return migrated_data
```

###### 2.2 配置迁移

```
python复制class ConfigMigrator:
    def __init__(self, migration_registry):
        self.migration_registry = migration_registry

    def migrate_config(self, config, from_version, to_version):
        migrations = self.migration_registry.get_migrations(from_version, to_version)
        current_config = config
        current_version = from_version
        for migration in migrations:
            current_config = migration.migrate(current_config)
            current_version = migration.to_version
        return current_config

    def migrate_user_config(self, user_id, from_version, to_version):
        config = self.load_user_config(user_id)
        migrated_config = self.migrate_config(config, from_version, to_version)
        self.save_user_config(user_id, migrated_config)
        return migrated_config

    def load_user_config(self, user_id):
        pass

    def save_user_config(self, user_id, config):
        pass
```

```
class ConfigMigrator:
    def __init__(self, migration_registry):
        self.migration_registry = migration_registry

    def migrate_config(self, config, from_version, to_version):
        migrations = self.migration_registry.get_migrations(from_version, to_version)
        current_config = config
        current_version = from_version
        for migration in migrations:
            current_config = migration.migrate(current_config)
            current_version = migration.to_version
        return current_config

    def migrate_user_config(self, user_id, from_version, to_version):
        config = self.load_user_config(user_id)
        migrated_config = self.migrate_config(config, from_version, to_version)
        self.save_user_config(user_id, migrated_config)
        return migrated_config

    def load_user_config(self, user_id):
        pass

    def save_user_config(self, user_id, config):
        pass
```

#### 版本回滚#

##### 1. 回滚准备#

```
bash复制python

class RollbackPreparer:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.backup_repository = BackupRepository("./backups")

    def prepare_rollback(self, skill_id, from_version, to_version):
        # 验证版本
        if not self.version_exists(skill_id, to_version):
            raise VersionNotFoundError(to_version)

        # 创建备份
        backup_id = self.create_backup(skill_id, from_version)

        # 准备回滚
        rollback_plan = {
            "skill_id": skill_id,
            "from_version": from_version,
            "to_version": to_version,
            "backup_id": backup_id,
            "steps": self.generate_rollback_steps(skill_id, from_version, to_version)
        }

        return rollback_plan

    def version_exists(self, skill_id, version):
        versions = self.version_repository.list_versions(skill_id)
        return version in versions

    def create_backup(self, skill_id, version):
        # 创建备份
        backup_id = self.backup_repository.create_backup(skill_id, version)
        return backup_id

    def generate_rollback_steps(self, skill_id, from_version, to_version):
        # 生成回滚步骤
        steps = [
            {
                "step": 1,
                "action": "stop_skill",
                "description": "停止 Skill"
            },
            {
                "step": 2,
                "action": "restore_version",
                "description": f"恢复到版本 {to_version}"
            },
            {
                "step": 3,
                "action": "migrate_config",
                "description": "迁移配置"
            },
            {
                "step": 4,
                "action": "start_skill",
                "description": "启动 Skill"
            },
            {
                "step": 5,
                "action": "verify",
                "description": "验证回滚"
            }
        ]

        return steps

### 2. 回滚执行

```python
class RollbackExecutor:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.backup_repository = BackupRepository("./backups")
        self.config_migrator = ConfigMigrator(MigrationRegistry())

    def execute_rollback(self, rollback_plan):
        try:
            for step in rollback_plan["steps"]:
                self.execute_step(rollback_plan, step)
            return True
        except Exception as e:
            self.restore_backup(rollback_plan["backup_id"])
            raise e

    def execute_step(self, rollback_plan, step):
        action = step["action"]
        if action == "stop_skill":
            self.stop_skill(rollback_plan["skill_id"])
        elif action == "restore_version":
            self.restore_version(
                rollback_plan["skill_id"],
                rollback_plan["to_version"]
            )
        elif action == "migrate_config":
            self.migrate_config(
                rollback_plan["from_version"],
                rollback_plan["to_version"]
            )
        elif action == "start_skill":
            self.start_skill(rollback_plan["skill_id"])
        elif action == "verify":
            self.verify_rollback(rollback_plan)

    def stop_skill(self, skill_id):
        pass

    def restore_version(self, skill_id, version):
        pass

    def migrate_config(self, from_version, to_version):
        pass

    def start_skill(self, skill_id):
        pass

    def verify_rollback(self, rollback_plan):
        pass

    def restore_backup(self, backup_id):
        self.backup_repository.restore_backup(backup_id)
```

```
python

class RollbackPreparer:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.backup_repository = BackupRepository("./backups")

    def prepare_rollback(self, skill_id, from_version, to_version):
        # 验证版本
        if not self.version_exists(skill_id, to_version):
            raise VersionNotFoundError(to_version)

        # 创建备份
        backup_id = self.create_backup(skill_id, from_version)

        # 准备回滚
        rollback_plan = {
            "skill_id": skill_id,
            "from_version": from_version,
            "to_version": to_version,
            "backup_id": backup_id,
            "steps": self.generate_rollback_steps(skill_id, from_version, to_version)
        }

        return rollback_plan

    def version_exists(self, skill_id, version):
        versions = self.version_repository.list_versions(skill_id)
        return version in versions

    def create_backup(self, skill_id, version):
        # 创建备份
        backup_id = self.backup_repository.create_backup(skill_id, version)
        return backup_id

    def generate_rollback_steps(self, skill_id, from_version, to_version):
        # 生成回滚步骤
        steps = [
            {
                "step": 1,
                "action": "stop_skill",
                "description": "停止 Skill"
            },
            {
                "step": 2,
                "action": "restore_version",
                "description": f"恢复到版本 {to_version}"
            },
            {
                "step": 3,
                "action": "migrate_config",
                "description": "迁移配置"
            },
            {
                "step": 4,
                "action": "start_skill",
                "description": "启动 Skill"
            },
            {
                "step": 5,
                "action": "verify",
                "description": "验证回滚"
            }
        ]

        return steps

### 2. 回滚执行

```python
class RollbackExecutor:
    def __init__(self):
        self.version_repository = VersionRepository("./skills")
        self.backup_repository = BackupRepository("./backups")
        self.config_migrator = ConfigMigrator(MigrationRegistry())

    def execute_rollback(self, rollback_plan):
        try:
            for step in rollback_plan["steps"]:
                self.execute_step(rollback_plan, step)
            return True
        except Exception as e:
            self.restore_backup(rollback_plan["backup_id"])
            raise e

    def execute_step(self, rollback_plan, step):
        action = step["action"]
        if action == "stop_skill":
            self.stop_skill(rollback_plan["skill_id"])
        elif action == "restore_version":
            self.restore_version(
                rollback_plan["skill_id"],
                rollback_plan["to_version"]
            )
        elif action == "migrate_config":
            self.migrate_config(
                rollback_plan["from_version"],
                rollback_plan["to_version"]
            )
        elif action == "start_skill":
            self.start_skill(rollback_plan["skill_id"])
        elif action == "verify":
            self.verify_rollback(rollback_plan)

    def stop_skill(self, skill_id):
        pass

    def restore_version(self, skill_id, version):
        pass

    def migrate_config(self, from_version, to_version):
        pass

    def start_skill(self, skill_id):
        pass

    def verify_rollback(self, rollback_plan):
        pass

    def restore_backup(self, backup_id):
        self.backup_repository.restore_backup(backup_id)
```

---

# 第 17 章

## 1 Skills 开发环境搭建

**URL**: https://claudecode.tangshuang.net/course/17.1%20Skills%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA

#### 开发环境概述#

开发 Skills 需要搭建合适的开发环境，包括必要的工具、依赖和配置。本节将详细介绍如何搭建 Skills 开发环境。

#### 环境要求#

##### 1. 系统要求#

#### 系统要求#

##### 操作系统#

- Linux（推荐 Ubuntu 20.04+）
- macOS 10.15+
- Windows 10+（需要 WSL2）

##### 硬件要求#

- CPU: 4 核心及以上
- 内存: 8GB 及以上（推荐 16GB）
- 磁盘: 20GB 可用空间

##### 软件要求#

- Python 3.8+
- Node.js 16+（可选，用于前端开发）
- Git 2.20+
- Docker 20+（可选，用于容器化）

##### 2. 开发工具#

#### 推荐开发工具#

##### 代码编辑器#

- VS Code（推荐）
- PyCharm
- Sublime Text

##### 版本控制#

- Git
- GitHub Desktop（可选）

##### 调试工具#

- Python Debugger (pdb)
- VS Code Debugger

##### 测试工具#

- pytest
- unittest
- coverage.py

#### 环境安装#

##### 1. Python 环境安装#

###### 1.1 安装 Python

```
bash复制# macOS
brew install python@3.9

# Ubuntu/Debian
sudo apt update
sudo apt install python3.9 python3.9-venv python3-pip

# Windows
# 从 https://www.python.org/downloads/ 下载安装程序
```

```
# macOS
brew install python@3.9

# Ubuntu/Debian
sudo apt update
sudo apt install python3.9 python3.9-venv python3-pip

# Windows
# 从 https://www.python.org/downloads/ 下载安装程序
```

###### 1.2 创建虚拟环境

```
bash复制# 创建虚拟环境
python3 -m venv venv

# 激活虚拟环境
# macOS/Linux
source venv/bin/activate

# Windows
venv\Scripts\activate
```

```
# 创建虚拟环境
python3 -m venv venv

# 激活虚拟环境
# macOS/Linux
source venv/bin/activate

# Windows
venv\Scripts\activate
```

###### 1.3 安装依赖

```
bash复制# 创建 requirements.txt
cat > requirements.txt << EOF
claude-code>=1.0.0
pytest>=7.0.0
pytest-cov>=4.0.0
black>=23.0.0
pylint>=2.17.0
mypy>=1.0.0
EOF

# 安装依赖
pip install -r requirements.txt
```

```
# 创建 requirements.txt
cat > requirements.txt << EOF
claude-code>=1.0.0
pytest>=7.0.0
pytest-cov>=4.0.0
black>=23.0.0
pylint>=2.17.0
mypy>=1.0.0
EOF

# 安装依赖
pip install -r requirements.txt
```

##### 2. Claude Code SDK 安装#

###### 2.1 安装 SDK

```
bash复制# 安装 Claude Code SDK
pip install claude-code-sdk

# 验证安装
claude --version
```

```
# 安装 Claude Code SDK
pip install claude-code-sdk

# 验证安装
claude --version
```

###### 2.2 配置 SDK

```
bash复制# 创建配置目录
mkdir -p ~/.claude

# 创建配置文件
cat > ~/.claude/config.yaml << EOF
version: "1.0"
skills:
  development:
    enabled: true
```

```
# 创建配置目录
mkdir -p ~/.claude

# 创建配置文件
cat > ~/.claude/config.yaml << EOF
version: "1.0"
skills:
  development:
    enabled: true
```

```
bash复制auto_reload: true
log_level: DEBUG
```

```
auto_reload: true
log_level: DEBUG
```

sdk:
api_key: your_api_key_here
endpoint: https://api.claudecode.com
EOF

```
bash复制### 3. 开发工具安装

#### 3.1 VS Code 扩展

> ## 推荐安装的 VS Code 扩展
> - Python
> - Pylance
> - Black Formatter
> - Pylint
> - pytest
> - GitLens
> - Docker

#### 3.2 配置 VS Code

```json
{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/bin/python",
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.formatting.provider": "black",
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": [
        "tests"
    ],
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    }
}
```

```
### 3. 开发工具安装

#### 3.1 VS Code 扩展

> ## 推荐安装的 VS Code 扩展
> - Python
> - Pylance
> - Black Formatter
> - Pylint
> - pytest
> - GitLens
> - Docker

#### 3.2 配置 VS Code

```json
{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/bin/python",
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.formatting.provider": "black",
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": [
        "tests"
    ],
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    }
}
```

#### 项目初始化#

##### 1. 创建项目结构#

```
bash复制# 创建项目目录
mkdir my-skill
cd my-skill

# 创建项目结构
mkdir -p src/skills
mkdir -p tests
mkdir -p docs
mkdir -p examples
mkdir -p scripts
```

```
# 创建项目目录
mkdir my-skill
cd my-skill

# 创建项目结构
mkdir -p src/skills
mkdir -p tests
mkdir -p docs
mkdir -p examples
mkdir -p scripts
```

##### 2. 初始化项目#

###### 2.1 创建 setup.py

```
python复制# setup.py
from setuptools import setup, find_packages
setup(
name="my-skill",
version="0.1.0",
description="A custom Claude Code skill",
author="Your Name",
author_email="your.email@example.com",
packages=find_packages(where="src"),
package_dir={"": "src"},
python_requires=">=3.8",
install_requires=[
"claude-code-sdk>=1.0.0",
],
extras_require={
"dev": [
"pytest>=7.0.0",
"pytest-cov>=4.0.0",
"black>=23.0.0",
"pylint>=2.17.0",
"mypy>=1.0.0",
]
},
entry_points={
"claude.skills": [
"my_skill = skills.my_skill:MySkill",
]
}
)

~~~
#### 2.2 创建 pyproject.toml
```toml
# pyproject.toml
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm>=6.2"]

[project]
name = "my-skill"
version = "0.1.0"
description = "A custom Claude Code skill"
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
requires-python = ">=3.8"
dependencies = [
    "claude-code-sdk>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "black>=23.0.0",
    "pylint>=2.17.0",
    "mypy>=1.0.0",
]

[project.entry-points."claude.skills"]
my_skill = "skills.my_skill:MySkill"

[tool.black]
line-length = 88
target-version = ['py38']

[tool.pylint.messages_control]
disable = [
    "C0111",  # missing-docstring
]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

```
# setup.py
from setuptools import setup, find_packages
setup(
name="my-skill",
version="0.1.0",
description="A custom Claude Code skill",
author="Your Name",
author_email="your.email@example.com",
packages=find_packages(where="src"),
package_dir={"": "src"},
python_requires=">=3.8",
install_requires=[
"claude-code-sdk>=1.0.0",
],
extras_require={
"dev": [
"pytest>=7.0.0",
"pytest-cov>=4.0.0",
"black>=23.0.0",
"pylint>=2.17.0",
"mypy>=1.0.0",
]
},
entry_points={
"claude.skills": [
"my_skill = skills.my_skill:MySkill",
]
}
)

~~~
#### 2.2 创建 pyproject.toml
```toml
# pyproject.toml
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm>=6.2"]

[project]
name = "my-skill"
version = "0.1.0"
description = "A custom Claude Code skill"
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
requires-python = ">=3.8"
dependencies = [
    "claude-code-sdk>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "black>=23.0.0",
    "pylint>=2.17.0",
    "mypy>=1.0.0",
]

[project.entry-points."claude.skills"]
my_skill = "skills.my_skill:MySkill"

[tool.black]
line-length = 88
target-version = ['py38']

[tool.pylint.messages_control]
disable = [
    "C0111",  # missing-docstring
]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

###### 2.3 创建 README.md

```
markdown复制# My Skill
A custom Claude Code skill for demonstrating skill development.

## Installation

```bash
pip install my-skill
```

```
# My Skill
A custom Claude Code skill for demonstrating skill development.

## Installation

```bash
pip install my-skill
```

#### Usage#

```
bash复制claude --skill my-skill --param value
```

```
claude --skill my-skill --param value
```

#### Development#

```
bash复制# Install development dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Run linting
pylint src/skills

# Format code
black src/skills
```

```
# Install development dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Run linting
pylint src/skills

# Format code
black src/skills
```

#### License#

```
bash复制
~~~
### 3. 创建基础 Skill

#### 3.1 创建 Skill 文件

```python
# src/skills/my_skill.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        input_text = parameters["input"]
        # 处理输入
        output = self.process_input(input_text)
        return SkillResult(
            success=True,
            data={
                "input": input_text,
                "output": output
            }
        )

    def process_input(self, input_text: str) -> str:
        # 实现具体的处理逻辑
        return input_text.upper()
```

```
~~~
### 3. 创建基础 Skill

#### 3.1 创建 Skill 文件

```python
# src/skills/my_skill.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        input_text = parameters["input"]
        # 处理输入
        output = self.process_input(input_text)
        return SkillResult(
            success=True,
            data={
                "input": input_text,
                "output": output
            }
        )

    def process_input(self, input_text: str) -> str:
        # 实现具体的处理逻辑
        return input_text.upper()
```

```
bash复制#### 3.2 创建测试文件

```python
# tests/test_my_skill.py
import pytest
from skills.my_skill import MySkill

class TestMySkill:
    def setup_method(self):
        self.skill = MySkill()

    def test_skill_initialization(self):
        assert self.skill.name == "my-skill"
        assert self.skill.version == "0.1.0"

    def test_get_parameters_schema(self):
        schema = self.skill.get_parameters_schema()
        assert "properties" in schema
        assert "input" in schema["properties"]

    def test_execute(self):
        from claude_code_sdk import SkillContext

        parameters = {"input": "hello"}
        context = SkillContext()
        result = self.skill.execute(parameters, context)

        assert result.success
        assert result.data["output"] == "HELLO"

    def test_process_input(self):
        assert self.skill.process_input("hello") == "HELLO"
        assert self.skill.process_input("world") == "WORLD"
```

## 开发配置

### 1. 调试配置

#### 1.1 VS Code 调试配置

```json
// .vscode/launch.json
{
"version": "0.2.0",
"configurations": [
{
"name": "Python: Current File",
"type": "python",
"request": "launch",
"program": "${file}",
"console": "integratedTerminal",
"env": {
"PYTHONPATH": "${workspaceFolder}/src"
}
},
{
"name": "Python: pytest",
"type": "python",
"request": "launch",
"module": "pytest",
"args": [
"tests",
"-v"
],
"console": "integratedTerminal",
"env": {
"PYTHONPATH": "${workspaceFolder}/src"
}
}
]
}
```
```

```
#### 3.2 创建测试文件

```python
# tests/test_my_skill.py
import pytest
from skills.my_skill import MySkill

class TestMySkill:
    def setup_method(self):
        self.skill = MySkill()

    def test_skill_initialization(self):
        assert self.skill.name == "my-skill"
        assert self.skill.version == "0.1.0"

    def test_get_parameters_schema(self):
        schema = self.skill.get_parameters_schema()
        assert "properties" in schema
        assert "input" in schema["properties"]

    def test_execute(self):
        from claude_code_sdk import SkillContext

        parameters = {"input": "hello"}
        context = SkillContext()
        result = self.skill.execute(parameters, context)

        assert result.success
        assert result.data["output"] == "HELLO"

    def test_process_input(self):
        assert self.skill.process_input("hello") == "HELLO"
        assert self.skill.process_input("world") == "WORLD"
```

## 开发配置

### 1. 调试配置

#### 1.1 VS Code 调试配置

```json
// .vscode/launch.json
{
"version": "0.2.0",
"configurations": [
{
"name": "Python: Current File",
"type": "python",
"request": "launch",
"program": "${file}",
"console": "integratedTerminal",
"env": {
"PYTHONPATH": "${workspaceFolder}/src"
}
},
{
"name": "Python: pytest",
"type": "python",
"request": "launch",
"module": "pytest",
"args": [
"tests",
"-v"
],
"console": "integratedTerminal",
"env": {
"PYTHONPATH": "${workspaceFolder}/src"
}
}
]
}
```
```

###### 1.2 日志配置

```
python复制# src/skills/logger.py
import logging
import sys

def setup_logger(name: str, level: int = logging.DEBUG):
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # 创建控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)

    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)

    # 添加处理器
    logger.addHandler(console_handler)

    return logger

# 使用示例
logger = setup_logger(__name__)
logger.debug("Debug message")
logger.info("Info message")
logger.warning("Warning message")
logger.error("Error message")
```

```
# src/skills/logger.py
import logging
import sys

def setup_logger(name: str, level: int = logging.DEBUG):
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # 创建控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)

    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)

    # 添加处理器
    logger.addHandler(console_handler)

    return logger

# 使用示例
logger = setup_logger(__name__)
logger.debug("Debug message")
logger.info("Info message")
logger.warning("Warning message")
logger.error("Error message")
```

##### 2. 测试配置#

###### 2.1 pytest 配置

```
python复制# tests/conftest.py
import pytest
from claude_code_sdk import SkillContext

@pytest.fixture
def skill_context():
    return SkillContext()

@pytest.fixture
def sample_parameters():
    return {
        "input": "test input"
    }
```

```
# tests/conftest.py
import pytest
from claude_code_sdk import SkillContext

@pytest.fixture
def skill_context():
    return SkillContext()

@pytest.fixture
def sample_parameters():
    return {
        "input": "test input"
    }
```

```
bash复制#### 2.2 测试覆盖率配置

```bash
# 运行测试并生成覆盖率报告
pytest --cov=src/skills --cov-report=html --cov-report=term

# 生成覆盖率报告
pytest --cov=src/skills --cov-report=html
open htmlcov/index.html
```

### 3. 代码质量配置

#### 3.1 Black 配置

```ini
# setup.cfg
[tool:pytest]
testpaths = tests

[black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
# directories
\.eggs
| \.git
| \.hg
| \.mypy_cache
| \.tox
| \.venv
| build
| dist
)/
'''
```
```

```
#### 2.2 测试覆盖率配置

```bash
# 运行测试并生成覆盖率报告
pytest --cov=src/skills --cov-report=html --cov-report=term

# 生成覆盖率报告
pytest --cov=src/skills --cov-report=html
open htmlcov/index.html
```

### 3. 代码质量配置

#### 3.1 Black 配置

```ini
# setup.cfg
[tool:pytest]
testpaths = tests

[black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
# directories
\.eggs
| \.git
| \.hg
| \.mypy_cache
| \.tox
| \.venv
| build
| dist
)/
'''
```
```

###### 3.2 Pylint 配置

```
ini复制# .pylintrc
[MASTER]
disable=C0111,C0103

[FORMAT]
max-line-length=88

[DESIGN]
max-args=7
max-locals=15
max-returns=6
max-branches=12
max-statements=50
```

```
# .pylintrc
[MASTER]
disable=C0111,C0103

[FORMAT]
max-line-length=88

[DESIGN]
max-args=7
max-locals=15
max-returns=6
max-branches=12
max-statements=50
```

###### 3.3 MyPy 配置

```
ini复制# mypy.ini
[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True

[mypy-tests.*]
disallow_untyped_defs = False
```

```
# mypy.ini
[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True

[mypy-tests.*]
disallow_untyped_defs = False
```

```
bash复制## 开发工作流
### 1. 开发流程

```markdown
## 开发流程

### 1. 功能开发

### 2. 代码审查

### 3. 发布
```

### 2. Git 工作流

```bash
# 创建功能分支
git checkout -b feature/new-feature

# 提交代码
git add .
git commit -m "Add new feature"

# 推送到远程
git push origin feature/new-feature

# 创建 Pull Request
# 在 GitHub 上创建 PR

# 合并后删除分支
git checkout main
git pull origin main
git branch -d feature/new-feature
git push origin --delete feature/new-feature
```
```

```
## 开发工作流
### 1. 开发流程

```markdown
## 开发流程

### 1. 功能开发

### 2. 代码审查

### 3. 发布
```

### 2. Git 工作流

```bash
# 创建功能分支
git checkout -b feature/new-feature

# 提交代码
git add .
git commit -m "Add new feature"

# 推送到远程
git push origin feature/new-feature

# 创建 Pull Request
# 在 GitHub 上创建 PR

# 合并后删除分支
git checkout main
git pull origin main
git branch -d feature/new-feature
git push origin --delete feature/new-feature
```
```

##### 3. 持续集成#

###### 3.1 GitHub Actions 配置

```
yaml复制# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"
```

```
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"
```

```
yaml复制    - name: Lint with pylint
      run: |
        pylint src/skills

    - name: Format check with black
      run: |
        black --check src/skills

    - name: Type check with mypy
      run: |
        mypy src/skills

    - name: Test with pytest
      run: |
        pytest --cov=src/skills --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
```

```
- name: Lint with pylint
      run: |
        pylint src/skills

    - name: Format check with black
      run: |
        black --check src/skills

    - name: Type check with mypy
      run: |
        mypy src/skills

    - name: Test with pytest
      run: |
        pytest --cov=src/skills --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
```

#### 常见问题#

##### 1. 安装问题#

#### 常见安装问题#

##### 问题：pip 安装失败#

```
bash复制# 升级 pip
pip install --upgrade pip

# 使用国内镜像
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple my-skill
```

```
# 升级 pip
pip install --upgrade pip

# 使用国内镜像
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple my-skill
```

##### 问题：依赖冲突#

```
bash复制# 使用虚拟环境
python -m venv venv
source venv/bin/activate

# 使用 pip-tools
pip install pip-tools
pip-compile requirements.in
pip-sync requirements.txt
```

```
# 使用虚拟环境
python -m venv venv
source venv/bin/activate

# 使用 pip-tools
pip install pip-tools
pip-compile requirements.in
pip-sync requirements.txt
```

##### 2. 运行问题#

#### 常见运行问题#

##### 问题：Skill 找不到#

```
bash复制# 确认 Skill 已注册
claude skill list

# 重新安装 Skill
pip install -e .

# 检查 PYTHONPATH
export PYTHONPATH="${PYTHONPATH}:$(pwd)/src"
```

```
# 确认 Skill 已注册
claude skill list

# 重新安装 Skill
pip install -e .

# 检查 PYTHONPATH
export PYTHONPATH="${PYTHONPATH}:$(pwd)/src"
```

##### 问题：权限错误#

```
bash复制# 检查文件权限
ls -la

# 修改权限
chmod +x scripts/*.sh

# 使用 sudo（不推荐）
sudo pip install my-skill
```

```
# 检查文件权限
ls -la

# 修改权限
chmod +x scripts/*.sh

# 使用 sudo（不推荐）
sudo pip install my-skill
```

##### 3. 调试问题#

#### 常见调试问题#

##### 问题：无法设置断点#

```
python复制# 使用 pdb
import pdb; pdb.set_trace()

# 使用 ipdb
import ipdb; ipdb.set_trace()

# 使用 VS Code 调试器
# 在代码行号左侧点击设置断点
```

```
# 使用 pdb
import pdb; pdb.set_trace()

# 使用 ipdb
import ipdb; ipdb.set_trace()

# 使用 VS Code 调试器
# 在代码行号左侧点击设置断点
```

##### 问题：日志不输出#

```
python复制# 确保日志级别正确
logger.setLevel(logging.DEBUG)

# 添加处理器
handler = logging.StreamHandler()
logger.addHandler(handler)

# 检查日志配置
logging.basicConfig(level=logging.DEBUG)
```

```
# 确保日志级别正确
logger.setLevel(logging.DEBUG)

# 添加处理器
handler = logging.StreamHandler()
logger.addHandler(handler)

# 检查日志配置
logging.basicConfig(level=logging.DEBUG)
```

---

## 2 Skills 项目结构

**URL**: https://claudecode.tangshuang.net/course/17.2%20Skills%20%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84

#### 项目结构概述#

良好的项目结构是开发高质量 Skills 的基础。本节将详细介绍 Skills 项目的标准结构和最佳实践。

##### 1. 基础结构#

```
bash复制my-skill/
├── src/                      # 源代码目录
│   └── skills/               # Skills 模块
│       ├── __init__.py        # 模块初始化
│       ├── my_skill.py        # 主 Skill 实现
│       ├── utils/             # 工具函数
│       │   ├── __init__.py
│       │   ├── helpers.py     # 辅助函数
│       │   └── validators.py  # 验证器
│       └── models/           # 数据模型
│           ├── __init__.py
│           └── schemas.py    # 数据模式
├── tests/                    # 测试目录
│   ├── __init__.py
│   ├── conftest.py           # pytest 配置
│   ├── test_my_skill.py      # Skill 测试
│   ├── test_utils.py         # 工具测试
│   └── fixtures/             # 测试固件
│       ├── __init__.py
│       └── data/             # 测试数据
├── docs/                     # 文档目录
│   ├── api.md                # API 文档
│   ├── usage.md              # 使用文档
│   └── development.md        # 开发文档
├── examples/                 # 示例目录
│   ├── basic_usage.py        # 基本使用示例
│   └── advanced_usage.py    # 高级使用示例
├── scripts/                  # 脚本目录
│   ├── build.py              # 构建脚本
│   ├── deploy.py             # 部署脚本
│   └── test.sh               # 测试脚本
├── configs/                  # 配置目录
│   ├── development.yaml      # 开发配置
│   ├── production.yaml       # 生产配置
│   └── testing.yaml          # 测试配置
├── resources/                # 资源目录
│   ├── templates/            # 模板文件
│   ├── static/              # 静态文件
│   └── data/                # 数据文件
├── .gitignore               # Git 忽略文件
├── .pylintrc               # Pylint 配置
```

```
my-skill/
├── src/                      # 源代码目录
│   └── skills/               # Skills 模块
│       ├── __init__.py        # 模块初始化
│       ├── my_skill.py        # 主 Skill 实现
│       ├── utils/             # 工具函数
│       │   ├── __init__.py
│       │   ├── helpers.py     # 辅助函数
│       │   └── validators.py  # 验证器
│       └── models/           # 数据模型
│           ├── __init__.py
│           └── schemas.py    # 数据模式
├── tests/                    # 测试目录
│   ├── __init__.py
│   ├── conftest.py           # pytest 配置
│   ├── test_my_skill.py      # Skill 测试
│   ├── test_utils.py         # 工具测试
│   └── fixtures/             # 测试固件
│       ├── __init__.py
│       └── data/             # 测试数据
├── docs/                     # 文档目录
│   ├── api.md                # API 文档
│   ├── usage.md              # 使用文档
│   └── development.md        # 开发文档
├── examples/                 # 示例目录
│   ├── basic_usage.py        # 基本使用示例
│   └── advanced_usage.py    # 高级使用示例
├── scripts/                  # 脚本目录
│   ├── build.py              # 构建脚本
│   ├── deploy.py             # 部署脚本
│   └── test.sh               # 测试脚本
├── configs/                  # 配置目录
│   ├── development.yaml      # 开发配置
│   ├── production.yaml       # 生产配置
│   └── testing.yaml          # 测试配置
├── resources/                # 资源目录
│   ├── templates/            # 模板文件
│   ├── static/              # 静态文件
│   └── data/                # 数据文件
├── .gitignore               # Git 忽略文件
├── .pylintrc               # Pylint 配置
```

├── .mypy.ini               # MyPy 配置
├── pyproject.toml           # 项目配置
├── setup.py                # 安装脚本
├── requirements.txt        # 依赖列表
├── requirements-dev.txt    # 开发依赖
├── README.md              # 项目说明
├── LICENSE                # 许可证
└── CHANGELOG.md           # 变更日志

```
bash复制
#### 2.1 源代码目录（src/）

# src/skills/__init__.py
"""
Skills 模块
"""
from skills.my_skill import MySkill
__all__ = ["MySkill"]
__version__ = "0.1.0"

```python
# src/skills/my_skill.py
"""
主 Skill 实现
"""
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    """自定义 Skill 实现"""

    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        """获取参数模式"""
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        """执行 Skill"""
        input_text = parameters["input"]
        output = self.process_input(input_text)

        return SkillResult(
            success=True,
            data={
                "input": input_text,
                "output": output
            }
        )

    def process_input(self, input_text: str) -> str:
        """处理输入文本"""
        return input_text.upper()

```

```python
# src/skills/utils/__init__.py
"""
工具函数模块
"""
from skills.utils.helpers import format_output, validate_input
from skills.utils.validators import validate_parameters
__all__ = ["format_output", "validate_input", "validate_parameters"]

```

```python
# src/skills/utils/helpers.py
"""
辅助函数
"""
from typing import Any

def format_output(data: Any, format_type: str = "json") -> str:
    """格式化输出"""
    if format_type == "json":
        import json
        return json.dumps(data, indent=2)
    elif format_type == "yaml":
        import yaml
        return yaml.dump(data)
    else:
        return str(data)

def validate_input(input_text: str) -> bool:
    """验证输入"""
    return isinstance(input_text, str) and len(input_text) > 0

```

```python
# src/skills/utils/validators.py
"""
验证器
"""
from typing import Dict, Any
def validate_parameters(parameters: Dict[str, Any], schema: Dict[str, Any]) -> bool:
    """验证参数"""
    required = schema.get("required", [])
    properties = schema.get("properties", {})

    for param in required:
        if param not in parameters:
            return False

    param_schema = properties.get(param, {})
    param_type = param_schema.get("type")
    if param_type:
        if param_type == "string" and not isinstance(parameters[param], str):
            return False
elif param_type == "number" and not isinstance(parameters[param], (int, float)):
            return False
        elif param_type == "boolean" and not isinstance(parameters[param], bool):
            return False
    return True
```

```python
# src/skills/models/__init__.py
"""
数据模型模块
"""
from skills.models.schemas import InputSchema, OutputSchema

__all__ = ["InputSchema", "OutputSchema"]
```

```python
# src/skills/models/schemas.py
"""
数据模式
"""
from dataclasses import dataclass
from typing import Optional
@dataclass
class InputSchema:
    """输入模式"""
    input: str
    options: Optional[dict] = None


@dataclass
class OutputSchema:
    """输出模式"""
    success: bool
    data: dict
    message: Optional[str] = None

```
#### 2.2 测试目录（tests/）

```python
# tests/__init__.py
"""
测试模块
"""
```

```python
# tests/conftest.py
"""
pytest 配置
"""
import pytest
from claude_code_sdk import SkillContext
@pytest.fixture
def skill_context():
    """Skill 上下文固件"""
    return SkillContext()


@pytest.fixture
def sample_parameters():
    """示例参数固件"""
    return {
        "input": "test input"
    }


@pytest.fixture
def sample_context():
    """示例上下文固件"""
    return {
        "project": {
            "name": "test-project",
            "path": "/tmp/test-project"
        },
        "user": {
            "id": "user123",
            "name": "Test User"
        }
    }

```python
# tests/test_my_skill.py
"""
Skill 测试
"""
import pytest
from skills.my_skill import MySkill

class TestMySkill:
    """MySkill 测试类"""

    def setup_method(self):
        """设置方法"""
        self.skill = MySkill()

    def test_skill_initialization(self):
        """测试 Skill 初始化"""
        assert self.skill.name == "my-skill"
        assert self.skill.version == "0.1.0"
        assert self.skill.description == "A custom Claude Code skill"

    def test_get_parameters_schema(self):
        """测试获取参数模式"""
        schema = self.skill.get_parameters_schema()

        assert "properties" in schema
        assert "input" in schema["properties"]
        assert "required" in schema
        assert "input" in schema["required"]

    def test_execute_success(self, skill_context):
        """测试成功执行"""
        parameters = {"input": "hello"}
        result = self.skill.execute(parameters, skill_context)

        assert result.success
        assert result.data["output"] == "HELLO"

    def test_execute_missing_parameter(self, skill_context):
        """测试缺少参数"""
        parameters = {}

        with pytest.raises(KeyError):
            self.skill.execute(parameters, skill_context)

    def test_process_input(self):
        """测试处理输入"""
        assert self.skill.process_input("hello") == "HELLO"
        assert self.skill.process_input("world") == "WORLD"
        assert self.skill.process_input("123") == "123"

```python
# tests/test_utils.py
"""
工具函数测试
"""
import pytest
from skills.utils.helpers import format_output, validate_input
from skills.utils.validators import validate_parameters


class TestHelpers:
    """辅助函数测试"""

    def test_format_output_json(self):
        """测试 JSON 格式化"""
        data = {"key": "value"}
        result = format_output(data, "json")
        assert '"key": "value"' in result

    def test_format_output_yaml(self):
        """测试 YAML 格式化"""
        data = {"key": "value"}
        result = format_output(data, "yaml")
        assert "key: value" in result

    def test_validate_input_valid(self):
        """测试有效输入"""
        assert validate_input("hello") == True
        assert validate_input("world") == True

    def test_validate_input_invalid(self):
        """测试无效输入"""
        assert validate_input("") == False
        assert validate_input(123) == False


class TestValidators:
"""验证器测试"""

    def test_validate_parameters_valid(self):
"""测试有效参数"""
        parameters = {"input": "test"}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == True

    def test_validate_parameters_missing_required(self):
"""测试缺少必需参数"""
        parameters = {}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == False

    def test_validate_parameters_wrong_type(self):
"""测试错误类型"""
        parameters = {"input": 123}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == False

```
#### 2.3 配置文件

~~~yaml
```yaml

# configs/development.yaml
# 开发环境配置
version: "1.0"

skills:
  my-skill:
    enabled: true
    debug: true
    log_level: DEBUG

logging:
  level: DEBUG
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  output: console

cache:
  enabled: true
  ttl: 3600
  storage: memory

```> # configs/production.yaml
# 生产环境配置
version: "1.0"
skills:
my-skill:
enabled: true
debug: false
log_level: INFO
logging:
level: INFO
format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
output: file
file_path: /var/log/my-skill.log
cache:
enabled: true
ttl: 7200
storage: redis
redis_host: localhost
redis_port: 6379

```
~~~yaml
```yaml

```
# configs/testing.yaml
# 测试环境配置
version: "1.0"

skills:
  my-skill:
    enabled: true
    debug: true
    log_level: DEBUG

logging:
  level: DEBUG
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  output: console

cache:
  enabled: false

testing:
  mock_external_calls: true
  use_test_data: true

```## 项目组织原则

### 1. 模块化设计

## 模块化原则
### 单一职责
每个模块只负责一个功能
- my_skill.py: 主 Skill 逻辑
- helpers.py: 辅助函数
- validators.py: 验证逻辑
### 高内聚低耦合
模块内部紧密相关，模块之间松散耦合
- 使用接口定义
- 依赖注入
- 事件驱动
### 可复用性
设计可复用的组件
- 工具函数独立
- 数据模型通用
- 配置灵活

```
### 2. 命名规范

~~~markdown
```markdown

## 命名规范

### 文件命名
- 使用小写字母和下划线
- 描述性名称
- 避免缩写

示例：
- my_skill.py ✓
- helpers.py ✓
- validators.py ✓
- MySkill.py ✗
- helper.py ✗

### 类命名
- 使用大驼峰命名法
- 名词或名词短语
- 描述性名称

示例：
- MySkill ✓
- SkillContext ✓
- InputSchema ✓
- mySkill ✗
- skill_context ✗

### 函数命名
- 使用小写字母和下划线
- 动词或动词短语
- 描述性名称

示例：
- execute() ✓
- process_input() ✓
- validate_parameters() ✓
- Execute() ✗
- processInput() ✗

### 变量命名
- 使用小写字母和下划线
- 描述性名称
- 避免单字母变量

示例：
- input_text ✓
- result_data ✓
- skill_context ✓
- txt ✗
- data ✗

```### 3. 目录组织

## 目录组织原则
### 按功能组织
将相关功能放在同一目录
- utils/: 工具函数
- models/: 数据模型
- tests/: 测试代码
### 按层次组织
保持清晰的层次结构
- src/: 源代码
- tests/: 测试代码
- docs/: 文档
### 避免过深嵌套
目录层次不超过 3 层
- src/skills/my_skill.py ✓
- src/skills/utils/helpers.py ✓
- src/skills/utils/data/processors/helpers.py ✗

```
## 文档组织

### 1. API 文档

~~~markdown
```markdown

# docs/api.md

# MySkill API 文档

## 概述

MySkill 是一个自定义的 Claude Code Skill，用于处理文本输入。

## 参数

### input (必需)
- 类型: string
- 描述: 要处理的输入文本
- 示例: "hello world"

### options (可选)
- 类型: object
- 描述: 附加选项
- 属性:
  - format: 输出格式 (json, yaml, text)
  - case: 大小写转换 (upper, lower, title)

## 返回值

### success
- 类型: boolean
- 描述: 操作是否成功

### data
- 类型: object
- 描述: 返回的数据
- 属性:
  - input: 原始输入
  - output: 处理后的输出

### message
- 类型: string (可选)
- 描述: 附加消息

## 示例

### 基本使用
```python
```python

from skills.my_skill import MySkill

skill = MySkill()
result = skill.execute(
    {"input": "hello world"},
    context
)

print(result.data["output"])  # "HELLO WORLD"

### 高级使用

```python

result = skill.execute(
{
"input": "hello world",
"options": {
"format": "json",
"case": "upper"
}
},
context
)

### 2. 使用文档

# docs/usage.md
# MySkill 使用指南
## 安装
~~~`bash
`bash

pip install my-skill

## 基本使用

### 命令行

~~~bash
bash

claude --skill my-skill --input "hello world"

### Python API

```python

from skills.my_skill import MySkill
from claude_code_sdk import SkillContext

skill = MySkill()
context = SkillContext()

result = skill.execute(
{"input": "hello world"},
context
)

print(result.data["output"])

## 高级用法

### 自定义选项

```python
python

result = skill.execute(
    {
        "input": "hello world",
        "options": {
            "format": "yaml",
            "case": "title"
        }
    },
    context
)

### 批量处理

```python

inputs = ["hello", "world", "test"]

results = []
for input_text in inputs:
result = skill.execute(
{"input": input_text},
context
)
results.append(result)

## 错误处理

### 缺少参数

```python
python

try:
    result = skill.execute({}, context)
except KeyError as e:
    print(f"Missing parameter: {e}")

### 无效输入

```python

from skills.utils.validators import validate_parameters

parameters = {"input": 123}
schema = skill.get_parameters_schema()

if not validate_parameters(parameters, schema):
print("Invalid parameters")

### 3. 开发文档

```
# docs/development.md
# MySkill 开发指南
## 开发环境设置
### 安装依赖
~~~`bash
`bash

pip install -e ".[dev]"

### 运行测试

~~~bash
bash

pytest

### 代码格式化

```bash

black src/skills

### 代码检查

~~~bash
bash

pylint src/skills

## 添加新功能

### 1. 创建新方法

```python

def new_feature(self, data: str) -> str:
"""新功能"""
 # 实现逻辑
return data

### 2. 添加测试

```python
python

def test_new_feature(self):
    """测试新功能"""
    result = self.skill.new_feature("test")
    assert result == "expected"

### 3. 更新文档

更新 API 文档和使用文档。

## 发布流程

### 1. 更新版本号

```python

# setup.py
version="0.2.0"

### 2. 更新变更日志

~~~markdown
markdown

# CHANGELOG.md

## [0.2.0] - 2024-01-15

### Added
- 新功能描述

### Changed
- 变更描述

### Fixed
- 修复描述

### 3. 创建发布

```bash

git tag v0.2.0
git push origin v0.2.0

### 4. 发布到 PyPI

~~~bash
bash

python setup.py sdist bdist_wheel
twine upload dist/*

```
```
```

```
#### 2.1 源代码目录（src/）

# src/skills/__init__.py
"""
Skills 模块
"""
from skills.my_skill import MySkill
__all__ = ["MySkill"]
__version__ = "0.1.0"

```python
# src/skills/my_skill.py
"""
主 Skill 实现
"""
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    """自定义 Skill 实现"""

    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        """获取参数模式"""
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        """执行 Skill"""
        input_text = parameters["input"]
        output = self.process_input(input_text)

        return SkillResult(
            success=True,
            data={
                "input": input_text,
                "output": output
            }
        )

    def process_input(self, input_text: str) -> str:
        """处理输入文本"""
        return input_text.upper()

```

```python
# src/skills/utils/__init__.py
"""
工具函数模块
"""
from skills.utils.helpers import format_output, validate_input
from skills.utils.validators import validate_parameters
__all__ = ["format_output", "validate_input", "validate_parameters"]

```

```python
# src/skills/utils/helpers.py
"""
辅助函数
"""
from typing import Any

def format_output(data: Any, format_type: str = "json") -> str:
    """格式化输出"""
    if format_type == "json":
        import json
        return json.dumps(data, indent=2)
    elif format_type == "yaml":
        import yaml
        return yaml.dump(data)
    else:
        return str(data)

def validate_input(input_text: str) -> bool:
    """验证输入"""
    return isinstance(input_text, str) and len(input_text) > 0

```

```python
# src/skills/utils/validators.py
"""
验证器
"""
from typing import Dict, Any
def validate_parameters(parameters: Dict[str, Any], schema: Dict[str, Any]) -> bool:
    """验证参数"""
    required = schema.get("required", [])
    properties = schema.get("properties", {})

    for param in required:
        if param not in parameters:
            return False

    param_schema = properties.get(param, {})
    param_type = param_schema.get("type")
    if param_type:
        if param_type == "string" and not isinstance(parameters[param], str):
            return False
elif param_type == "number" and not isinstance(parameters[param], (int, float)):
            return False
        elif param_type == "boolean" and not isinstance(parameters[param], bool):
            return False
    return True
```

```python
# src/skills/models/__init__.py
"""
数据模型模块
"""
from skills.models.schemas import InputSchema, OutputSchema

__all__ = ["InputSchema", "OutputSchema"]
```

```python
# src/skills/models/schemas.py
"""
数据模式
"""
from dataclasses import dataclass
from typing import Optional
@dataclass
class InputSchema:
    """输入模式"""
    input: str
    options: Optional[dict] = None


@dataclass
class OutputSchema:
    """输出模式"""
    success: bool
    data: dict
    message: Optional[str] = None

```
#### 2.2 测试目录（tests/）

```python
# tests/__init__.py
"""
测试模块
"""
```

```python
# tests/conftest.py
"""
pytest 配置
"""
import pytest
from claude_code_sdk import SkillContext
@pytest.fixture
def skill_context():
    """Skill 上下文固件"""
    return SkillContext()


@pytest.fixture
def sample_parameters():
    """示例参数固件"""
    return {
        "input": "test input"
    }


@pytest.fixture
def sample_context():
    """示例上下文固件"""
    return {
        "project": {
            "name": "test-project",
            "path": "/tmp/test-project"
        },
        "user": {
            "id": "user123",
            "name": "Test User"
        }
    }

```python
# tests/test_my_skill.py
"""
Skill 测试
"""
import pytest
from skills.my_skill import MySkill

class TestMySkill:
    """MySkill 测试类"""

    def setup_method(self):
        """设置方法"""
        self.skill = MySkill()

    def test_skill_initialization(self):
        """测试 Skill 初始化"""
        assert self.skill.name == "my-skill"
        assert self.skill.version == "0.1.0"
        assert self.skill.description == "A custom Claude Code skill"

    def test_get_parameters_schema(self):
        """测试获取参数模式"""
        schema = self.skill.get_parameters_schema()

        assert "properties" in schema
        assert "input" in schema["properties"]
        assert "required" in schema
        assert "input" in schema["required"]

    def test_execute_success(self, skill_context):
        """测试成功执行"""
        parameters = {"input": "hello"}
        result = self.skill.execute(parameters, skill_context)

        assert result.success
        assert result.data["output"] == "HELLO"

    def test_execute_missing_parameter(self, skill_context):
        """测试缺少参数"""
        parameters = {}

        with pytest.raises(KeyError):
            self.skill.execute(parameters, skill_context)

    def test_process_input(self):
        """测试处理输入"""
        assert self.skill.process_input("hello") == "HELLO"
        assert self.skill.process_input("world") == "WORLD"
        assert self.skill.process_input("123") == "123"

```python
# tests/test_utils.py
"""
工具函数测试
"""
import pytest
from skills.utils.helpers import format_output, validate_input
from skills.utils.validators import validate_parameters


class TestHelpers:
    """辅助函数测试"""

    def test_format_output_json(self):
        """测试 JSON 格式化"""
        data = {"key": "value"}
        result = format_output(data, "json")
        assert '"key": "value"' in result

    def test_format_output_yaml(self):
        """测试 YAML 格式化"""
        data = {"key": "value"}
        result = format_output(data, "yaml")
        assert "key: value" in result

    def test_validate_input_valid(self):
        """测试有效输入"""
        assert validate_input("hello") == True
        assert validate_input("world") == True

    def test_validate_input_invalid(self):
        """测试无效输入"""
        assert validate_input("") == False
        assert validate_input(123) == False


class TestValidators:
"""验证器测试"""

    def test_validate_parameters_valid(self):
"""测试有效参数"""
        parameters = {"input": "test"}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == True

    def test_validate_parameters_missing_required(self):
"""测试缺少必需参数"""
        parameters = {}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == False

    def test_validate_parameters_wrong_type(self):
"""测试错误类型"""
        parameters = {"input": 123}
schema = {
"properties": {
"input": {"type": "string"}
},
"required": ["input"]
}
assert validate_parameters(parameters, schema) == False

```
#### 2.3 配置文件

~~~yaml
```yaml

# configs/development.yaml
# 开发环境配置
version: "1.0"

skills:
  my-skill:
    enabled: true
    debug: true
    log_level: DEBUG

logging:
  level: DEBUG
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  output: console

cache:
  enabled: true
  ttl: 3600
  storage: memory

```> # configs/production.yaml
# 生产环境配置
version: "1.0"
skills:
my-skill:
enabled: true
debug: false
log_level: INFO
logging:
level: INFO
format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
output: file
file_path: /var/log/my-skill.log
cache:
enabled: true
ttl: 7200
storage: redis
redis_host: localhost
redis_port: 6379

```
~~~yaml
```yaml

```
# configs/testing.yaml
# 测试环境配置
version: "1.0"

skills:
  my-skill:
    enabled: true
    debug: true
    log_level: DEBUG

logging:
  level: DEBUG
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  output: console

cache:
  enabled: false

testing:
  mock_external_calls: true
  use_test_data: true

```## 项目组织原则

### 1. 模块化设计

## 模块化原则
### 单一职责
每个模块只负责一个功能
- my_skill.py: 主 Skill 逻辑
- helpers.py: 辅助函数
- validators.py: 验证逻辑
### 高内聚低耦合
模块内部紧密相关，模块之间松散耦合
- 使用接口定义
- 依赖注入
- 事件驱动
### 可复用性
设计可复用的组件
- 工具函数独立
- 数据模型通用
- 配置灵活

```
### 2. 命名规范

~~~markdown
```markdown

## 命名规范

### 文件命名
- 使用小写字母和下划线
- 描述性名称
- 避免缩写

示例：
- my_skill.py ✓
- helpers.py ✓
- validators.py ✓
- MySkill.py ✗
- helper.py ✗

### 类命名
- 使用大驼峰命名法
- 名词或名词短语
- 描述性名称

示例：
- MySkill ✓
- SkillContext ✓
- InputSchema ✓
- mySkill ✗
- skill_context ✗

### 函数命名
- 使用小写字母和下划线
- 动词或动词短语
- 描述性名称

示例：
- execute() ✓
- process_input() ✓
- validate_parameters() ✓
- Execute() ✗
- processInput() ✗

### 变量命名
- 使用小写字母和下划线
- 描述性名称
- 避免单字母变量

示例：
- input_text ✓
- result_data ✓
- skill_context ✓
- txt ✗
- data ✗

```### 3. 目录组织

## 目录组织原则
### 按功能组织
将相关功能放在同一目录
- utils/: 工具函数
- models/: 数据模型
- tests/: 测试代码
### 按层次组织
保持清晰的层次结构
- src/: 源代码
- tests/: 测试代码
- docs/: 文档
### 避免过深嵌套
目录层次不超过 3 层
- src/skills/my_skill.py ✓
- src/skills/utils/helpers.py ✓
- src/skills/utils/data/processors/helpers.py ✗

```
## 文档组织

### 1. API 文档

~~~markdown
```markdown

# docs/api.md

# MySkill API 文档

## 概述

MySkill 是一个自定义的 Claude Code Skill，用于处理文本输入。

## 参数

### input (必需)
- 类型: string
- 描述: 要处理的输入文本
- 示例: "hello world"

### options (可选)
- 类型: object
- 描述: 附加选项
- 属性:
  - format: 输出格式 (json, yaml, text)
  - case: 大小写转换 (upper, lower, title)

## 返回值

### success
- 类型: boolean
- 描述: 操作是否成功

### data
- 类型: object
- 描述: 返回的数据
- 属性:
  - input: 原始输入
  - output: 处理后的输出

### message
- 类型: string (可选)
- 描述: 附加消息

## 示例

### 基本使用
```python
```python

from skills.my_skill import MySkill

skill = MySkill()
result = skill.execute(
    {"input": "hello world"},
    context
)

print(result.data["output"])  # "HELLO WORLD"

### 高级使用

```python

result = skill.execute(
{
"input": "hello world",
"options": {
"format": "json",
"case": "upper"
}
},
context
)

### 2. 使用文档

# docs/usage.md
# MySkill 使用指南
## 安装
~~~`bash
`bash

pip install my-skill

## 基本使用

### 命令行

~~~bash
bash

claude --skill my-skill --input "hello world"

### Python API

```python

from skills.my_skill import MySkill
from claude_code_sdk import SkillContext

skill = MySkill()
context = SkillContext()

result = skill.execute(
{"input": "hello world"},
context
)

print(result.data["output"])

## 高级用法

### 自定义选项

```python
python

result = skill.execute(
    {
        "input": "hello world",
        "options": {
            "format": "yaml",
            "case": "title"
        }
    },
    context
)

### 批量处理

```python

inputs = ["hello", "world", "test"]

results = []
for input_text in inputs:
result = skill.execute(
{"input": input_text},
context
)
results.append(result)

## 错误处理

### 缺少参数

```python
python

try:
    result = skill.execute({}, context)
except KeyError as e:
    print(f"Missing parameter: {e}")

### 无效输入

```python

from skills.utils.validators import validate_parameters

parameters = {"input": 123}
schema = skill.get_parameters_schema()

if not validate_parameters(parameters, schema):
print("Invalid parameters")

### 3. 开发文档

```
# docs/development.md
# MySkill 开发指南
## 开发环境设置
### 安装依赖
~~~`bash
`bash

pip install -e ".[dev]"

### 运行测试

~~~bash
bash

pytest

### 代码格式化

```bash

black src/skills

### 代码检查

~~~bash
bash

pylint src/skills

## 添加新功能

### 1. 创建新方法

```python

def new_feature(self, data: str) -> str:
"""新功能"""
 # 实现逻辑
return data

### 2. 添加测试

```python
python

def test_new_feature(self):
    """测试新功能"""
    result = self.skill.new_feature("test")
    assert result == "expected"

### 3. 更新文档

更新 API 文档和使用文档。

## 发布流程

### 1. 更新版本号

```python

# setup.py
version="0.2.0"

### 2. 更新变更日志

~~~markdown
markdown

# CHANGELOG.md

## [0.2.0] - 2024-01-15

### Added
- 新功能描述

### Changed
- 变更描述

### Fixed
- 修复描述

### 3. 创建发布

```bash

git tag v0.2.0
git push origin v0.2.0

### 4. 发布到 PyPI

~~~bash
bash

python setup.py sdist bdist_wheel
twine upload dist/*

```
```
```

---

## 3 Skills 核心 API

**URL**: https://claudecode.tangshuang.net/course/17.3%20Skills%20%E6%A0%B8%E5%BF%83%20API

#### 核心 API 概述#

Claude Code SDK 提供了丰富的 API 用于开发 Skills。本节将详细介绍 Skills 的核心 API，包括 Skill 基类、上下文管理、工具调用等。

#### Skill 基类#

##### 1. Skill 类#

###### 1.1 基本结构

```
python复制from typing import Dict, Any, Optional
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    """自定义 Skill 实现"""

    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        """获取参数模式"""
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                },
                "options": {
                    "type": "object",
                    "description": "Additional options",
                    "properties": {
                        "format": {
                            "type": "string",
                            "enum": ["json", "yaml", "text"],
                            "default": "json"
                        },
                        "case": {
                            "type": "string",
                            "enum": ["upper", "lower", "title"],
                            "default": "upper"
                        }
                    }
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        """执行 Skill"""
        try:
            # 验证参数
            self.validate_parameters(parameters)

            # 处理输入
            input_text = parameters["input"]
            options = parameters.get("options", {})

            # 处理文本
            output = self.process_text(input_text, options)

            # 返回结果
            return SkillResult(
                success=True,
                data={
                    "input": input_text,
                    "output": output,
                    "options": options
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """验证参数"""
        schema = self.get_parameters_schema()
        required = schema.get("required", [])

        for param in required:
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")

        return True
```

```
from typing import Dict, Any, Optional
from claude_code_sdk import Skill, SkillContext, SkillResult

class MySkill(Skill):
    """自定义 Skill 实现"""

    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        """获取参数模式"""
        return {
            "type": "object",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Input text to process"
                },
                "options": {
                    "type": "object",
                    "description": "Additional options",
                    "properties": {
                        "format": {
                            "type": "string",
                            "enum": ["json", "yaml", "text"],
                            "default": "json"
                        },
                        "case": {
                            "type": "string",
                            "enum": ["upper", "lower", "title"],
                            "default": "upper"
                        }
                    }
                }
            },
            "required": ["input"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        """执行 Skill"""
        try:
            # 验证参数
            self.validate_parameters(parameters)

            # 处理输入
            input_text = parameters["input"]
            options = parameters.get("options", {})

            # 处理文本
            output = self.process_text(input_text, options)

            # 返回结果
            return SkillResult(
                success=True,
                data={
                    "input": input_text,
                    "output": output,
                    "options": options
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """验证参数"""
        schema = self.get_parameters_schema()
        required = schema.get("required", [])

        for param in required:
            if param not in parameters:
                raise ValueError(f"Missing required parameter: {param}")

        return True
```

```
bash复制def process_text(self, text: str, options: Dict[str, Any]) -> str:
    """处理文本"""
    case = options.get("case", "upper")

    if case == "upper":
        return text.upper()
    elif case == "lower":
        return text.lower()
    elif case == "title":
        return text.title()
    else:
        return text
```

```
def process_text(self, text: str, options: Dict[str, Any]) -> str:
    """处理文本"""
    case = options.get("case", "upper")

    if case == "upper":
        return text.upper()
    elif case == "lower":
        return text.lower()
    elif case == "title":
        return text.title()
    else:
        return text
```

```
bash复制
#### 1.2 Skill 属性

```python
class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",              # Skill 名称
            version="0.1.0",             # Skill 版本
            description="Description",    # Skill 描述
            author="Author Name",         # 作者
            license="MIT",                # 许可证
            homepage="https://example.com"  # 主页
        )

        # 自定义属性
        self.custom_property = "value"
```

```
#### 1.2 Skill 属性

```python
class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",              # Skill 名称
            version="0.1.0",             # Skill 版本
            description="Description",    # Skill 描述
            author="Author Name",         # 作者
            license="MIT",                # 许可证
            homepage="https://example.com"  # 主页
        )

        # 自定义属性
        self.custom_property = "value"
```

###### 1.3 Skill 方法

```
python复制class MySkill(Skill):
    def initialize(self):
        """初始化 Skill"""
        # 加载配置
        self.config = self.load_config()
        # 初始化资源
        self.resources = self.initialize_resources()

    def load_config(self) -> Dict[str, Any]:
        """加载配置"""
        # 从文件或环境变量加载配置
        pass

    def initialize_resources(self) -> Dict[str, Any]:
        """初始化资源"""
        # 初始化数据库连接、缓存等
        pass

    def cleanup(self):
        """清理资源"""
        # 关闭连接、释放资源
        pass

    def get_metadata(self) -> Dict[str, Any]:
        """获取元数据"""
        return {
            "name": self.name,
            "version": self.version,
            "description": self.description,
            "author": self.author,
            "capabilities": self.get_capabilities()
        }

    def get_capabilities(self) -> list:
        """获取能力列表"""
        return [
            "text_processing",
            "format_conversion",
            "case_conversion"
        ]
```

```
class MySkill(Skill):
    def initialize(self):
        """初始化 Skill"""
        # 加载配置
        self.config = self.load_config()
        # 初始化资源
        self.resources = self.initialize_resources()

    def load_config(self) -> Dict[str, Any]:
        """加载配置"""
        # 从文件或环境变量加载配置
        pass

    def initialize_resources(self) -> Dict[str, Any]:
        """初始化资源"""
        # 初始化数据库连接、缓存等
        pass

    def cleanup(self):
        """清理资源"""
        # 关闭连接、释放资源
        pass

    def get_metadata(self) -> Dict[str, Any]:
        """获取元数据"""
        return {
            "name": self.name,
            "version": self.version,
            "description": self.description,
            "author": self.author,
            "capabilities": self.get_capabilities()
        }

    def get_capabilities(self) -> list:
        """获取能力列表"""
        return [
            "text_processing",
            "format_conversion",
            "case_conversion"
        ]
```

```
bash复制### 2. SkillContext 类
#### 2.1 上下文属性

```python
from claude_code_sdk import SkillContext

# SkillContext 提供以下属性：
# - project: 项目信息
# - user: 用户信息
# - environment: 环境信息
# - session: 会话信息
# - config: 配置信息

def use_context(context: SkillContext):
    # 访问项目信息
    project_name = context.project.name
    project_path = context.project.path

    # 访问用户信息
    user_id = context.user.id
    user_name = context.user.name

    # 访问环境信息
    environment = context.environment.name
    platform = context.environment.platform

    # 访问会话信息
    session_id = context.session.id
    start_time = context.session.start_time

    # 访问配置信息
    config = context.config.settings
```

#### 2.2 上下文方法

```python
def use_context_methods(context: SkillContext):
    # 获取文件内容
    file_content = context.read_file("src/main.py")
    # 写入文件
    context.write_file("output.txt", "Hello, World!")
    # 搜索代码
    results = context.search_codebase("function_name")
    # 执行命令
    output = context.run_command("ls -la")
    # 获取环境变量
    env_var = context.get_env_var("PATH")
    # 记录日志
    context.log("Info message", level="info")
    context.log("Error message", level="error")
```
```

```
### 2. SkillContext 类
#### 2.1 上下文属性

```python
from claude_code_sdk import SkillContext

# SkillContext 提供以下属性：
# - project: 项目信息
# - user: 用户信息
# - environment: 环境信息
# - session: 会话信息
# - config: 配置信息

def use_context(context: SkillContext):
    # 访问项目信息
    project_name = context.project.name
    project_path = context.project.path

    # 访问用户信息
    user_id = context.user.id
    user_name = context.user.name

    # 访问环境信息
    environment = context.environment.name
    platform = context.environment.platform

    # 访问会话信息
    session_id = context.session.id
    start_time = context.session.start_time

    # 访问配置信息
    config = context.config.settings
```

#### 2.2 上下文方法

```python
def use_context_methods(context: SkillContext):
    # 获取文件内容
    file_content = context.read_file("src/main.py")
    # 写入文件
    context.write_file("output.txt", "Hello, World!")
    # 搜索代码
    results = context.search_codebase("function_name")
    # 执行命令
    output = context.run_command("ls -la")
    # 获取环境变量
    env_var = context.get_env_var("PATH")
    # 记录日志
    context.log("Info message", level="info")
    context.log("Error message", level="error")
```
```

##### 3. SkillResult 类#

###### 3.1 结果类型

```
python复制from claude_code_sdk import SkillResult

# 成功结果
success_result = SkillResult(
    success=True,
    data={
        "output": "processed text",
        "metadata": {
            "length": 14,
            "words": 2
        }
    },
    message="Processing completed successfully"
)

# 失败结果
error_result = SkillResult(
    success=False,
    error="Invalid input parameter",
    error_code="INVALID_PARAMETER",
    details={
        "parameter": "input",
        "expected": "string",
        "received": "number"
    }
)

# 部分成功结果
partial_result = SkillResult(
    success=True,
    data={
        "processed": ["item1", "item2"],
        "failed": ["item3"]
    },
    warnings=[
        "item3 could not be processed"
    ]
)
```

```
from claude_code_sdk import SkillResult

# 成功结果
success_result = SkillResult(
    success=True,
    data={
        "output": "processed text",
        "metadata": {
            "length": 14,
            "words": 2
        }
    },
    message="Processing completed successfully"
)

# 失败结果
error_result = SkillResult(
    success=False,
    error="Invalid input parameter",
    error_code="INVALID_PARAMETER",
    details={
        "parameter": "input",
        "expected": "string",
        "received": "number"
    }
)

# 部分成功结果
partial_result = SkillResult(
    success=True,
    data={
        "processed": ["item1", "item2"],
        "failed": ["item3"]
    },
    warnings=[
        "item3 could not be processed"
    ]
)
```

###### 3.2 结果方法

```
python复制def use_result_methods(result: SkillResult):
    # 检查是否成功
    if result.success:
        print("Operation succeeded")
    else:
        print(f"Operation failed: {result.error}")
    # 获取数据
    data = result.data
    # 获取错误信息
    error = result.error
    error_code = result.error_code
    # 获取警告
    warnings = result.warnings
    # 获取消息
    message = result.message
    # 获取详细信息
    details = result.details
    # 转换为字典
    result_dict = result.to_dict()
    # 转换为 JSON
    result_json = result.to_json()
```

```
def use_result_methods(result: SkillResult):
    # 检查是否成功
    if result.success:
        print("Operation succeeded")
    else:
        print(f"Operation failed: {result.error}")
    # 获取数据
    data = result.data
    # 获取错误信息
    error = result.error
    error_code = result.error_code
    # 获取警告
    warnings = result.warnings
    # 获取消息
    message = result.message
    # 获取详细信息
    details = result.details
    # 转换为字典
    result_dict = result.to_dict()
    # 转换为 JSON
    result_json = result.to_json()
```

```
bash复制## 工具调用 API
### 1. 文件系统工具
#### 1.1 读取文件

```python
from claude_code_sdk import SkillContext

def read_file_example(context: SkillContext):
    # 读取文件内容
    content = context.read_file("src/main.py")

    # 读取部分内容
    partial_content = context.read_file(
        "src/main.py",
        start_line=1,
        end_line=10
    )

    # 读取二进制文件
    binary_content = context.read_file_binary("image.png")

    return content
```

#### 1.2 写入文件

```python
def write_file_example(context: SkillContext):
    # 写入文本文件
    context.write_file(
        "output.txt",
        "Hello, World!"
    )
    # 追加内容
    context.write_file(
        "output.txt",
        "\nNew line",
        mode="append"
    )
    # 写入二进制文件
    binary_data = b'\x89PNG\r\n\x1a\n'
    context.write_file_binary("image.png", binary_data)

#### 1.3 编辑文件

```python
def edit_file_example(context: SkillContext):
    # 替换文本
    context.edit_file(
        "src/main.py",
        old_text="old_function",
        new_text="new_function"
    )

    # 使用正则表达式替换
    context.edit_file_regex(
        "src/main.py",
        pattern=r"def (\w+)\(",
        replacement=r"async def \1("
    )

    # 在指定位置插入
    context.insert_file(
        "src/main.py",
        line_number=10,
        text="# New comment"
    )

#### 1.4 删除文件

```python
def delete_file_example(context: SkillContext):
    # 删除文件
    context.delete_file("output.txt")
    # 删除目录
    context.delete_directory("temp")
    # 检查文件是否存在
    exists = context.file_exists("src/main.py")
```
```

```
## 工具调用 API
### 1. 文件系统工具
#### 1.1 读取文件

```python
from claude_code_sdk import SkillContext

def read_file_example(context: SkillContext):
    # 读取文件内容
    content = context.read_file("src/main.py")

    # 读取部分内容
    partial_content = context.read_file(
        "src/main.py",
        start_line=1,
        end_line=10
    )

    # 读取二进制文件
    binary_content = context.read_file_binary("image.png")

    return content
```

#### 1.2 写入文件

```python
def write_file_example(context: SkillContext):
    # 写入文本文件
    context.write_file(
        "output.txt",
        "Hello, World!"
    )
    # 追加内容
    context.write_file(
        "output.txt",
        "\nNew line",
        mode="append"
    )
    # 写入二进制文件
    binary_data = b'\x89PNG\r\n\x1a\n'
    context.write_file_binary("image.png", binary_data)

#### 1.3 编辑文件

```python
def edit_file_example(context: SkillContext):
    # 替换文本
    context.edit_file(
        "src/main.py",
        old_text="old_function",
        new_text="new_function"
    )

    # 使用正则表达式替换
    context.edit_file_regex(
        "src/main.py",
        pattern=r"def (\w+)\(",
        replacement=r"async def \1("
    )

    # 在指定位置插入
    context.insert_file(
        "src/main.py",
        line_number=10,
        text="# New comment"
    )

#### 1.4 删除文件

```python
def delete_file_example(context: SkillContext):
    # 删除文件
    context.delete_file("output.txt")
    # 删除目录
    context.delete_directory("temp")
    # 检查文件是否存在
    exists = context.file_exists("src/main.py")
```
```

##### 2. 搜索工具#

###### 2.1 代码搜索

```
python复制def search_codebase_example(context: SkillContext):
    # 搜索代码
    results = context.search_codebase("function_name")

    # 搜索特定文件类型
    results = context.search_codebase(
        "function_name",
        file_pattern="*.py"
    )

    # 搜索特定目录
    results = context.search_codebase(
        "function_name",
        directory="src"
    )

    # 使用正则表达式搜索
    results = context.search_codebase_regex(
        r"def \w+\(",
        file_pattern="*.py"
    )

    return results
```

```
def search_codebase_example(context: SkillContext):
    # 搜索代码
    results = context.search_codebase("function_name")

    # 搜索特定文件类型
    results = context.search_codebase(
        "function_name",
        file_pattern="*.py"
    )

    # 搜索特定目录
    results = context.search_codebase(
        "function_name",
        directory="src"
    )

    # 使用正则表达式搜索
    results = context.search_codebase_regex(
        r"def \w+\(",
        file_pattern="*.py"
    )

    return results
```

###### 2.2 文件搜索

```
python复制def search_files_example(context: SkillContext):
    # 查找文件
    files = context.find_files("*.py")
    # 查找特定目录
    files = context.find_files(
        "*.py",
        directory="src"
    )
    # 递归查找
    files = context.find_files(
        "*.py",
        recursive=True
    )
    return files
```

```
def search_files_example(context: SkillContext):
    # 查找文件
    files = context.find_files("*.py")
    # 查找特定目录
    files = context.find_files(
        "*.py",
        directory="src"
    )
    # 递归查找
    files = context.find_files(
        "*.py",
        recursive=True
    )
    return files
```

```
bash复制### 3. 命令执行工具
#### 3.1 执行命令

```python
def run_command_example(context: SkillContext):
    # 执行命令
    output = context.run_command("ls -la")

    # 执行命令并捕获输出
    output, error, return_code = context.run_command_with_output(
        "python script.py"
    )

    # 在特定目录执行命令
    output = context.run_command(
        "ls -la",
        working_directory="/tmp"
    )

    # 设置环境变量
    output = context.run_command(
        "echo $MY_VAR",
        env_vars={"MY_VAR": "value"}
    )

    return output
```

#### 3.2 异步执行

```python
async def run_command_async_example(context: SkillContext):
    # 异步执行命令
    task = context.run_command_async("long_running_command")
    # 等待完成
    output = await task.wait()
    # 检查状态
    status = task.get_status()
    # 取消任务
    task.cancel()
```
```

```
### 3. 命令执行工具
#### 3.1 执行命令

```python
def run_command_example(context: SkillContext):
    # 执行命令
    output = context.run_command("ls -la")

    # 执行命令并捕获输出
    output, error, return_code = context.run_command_with_output(
        "python script.py"
    )

    # 在特定目录执行命令
    output = context.run_command(
        "ls -la",
        working_directory="/tmp"
    )

    # 设置环境变量
    output = context.run_command(
        "echo $MY_VAR",
        env_vars={"MY_VAR": "value"}
    )

    return output
```

#### 3.2 异步执行

```python
async def run_command_async_example(context: SkillContext):
    # 异步执行命令
    task = context.run_command_async("long_running_command")
    # 等待完成
    output = await task.wait()
    # 检查状态
    status = task.get_status()
    # 取消任务
    task.cancel()
```
```

##### 4. Git 工具#

###### 4.1 Git 操作

```
python复制def git_operations_example(context: SkillContext):
    # 获取 Git 状态
    status = context.git_status()

    # 获取当前分支
    branch = context.git_current_branch()

    # 获取提交历史
    commits = context.git_log(limit=10)

    # 获取差异
    diff = context.git_diff()

    # 创建提交
    context.git_commit("Commit message")

    # 创建分支
    context.git_create_branch("new-branch")

    # 切换分支
    context.git_checkout("new-branch")

    return status
```

```
def git_operations_example(context: SkillContext):
    # 获取 Git 状态
    status = context.git_status()

    # 获取当前分支
    branch = context.git_current_branch()

    # 获取提交历史
    commits = context.git_log(limit=10)

    # 获取差异
    diff = context.git_diff()

    # 创建提交
    context.git_commit("Commit message")

    # 创建分支
    context.git_create_branch("new-branch")

    # 切换分支
    context.git_checkout("new-branch")

    return status
```

#### 上下文管理 API#

##### 1. 项目上下文#

```
python复制def project_context_example(context: SkillContext):
    # 获取项目信息
    project = context.project
    # 项目名称
    name = project.name
    # 项目路径
    path = project.path
    # 项目类型
    project_type = project.type
    # 技术栈
    tech_stack = project.tech_stack
    # 配置
    config = project.config
    return {
        "name": name,
        "path": path,
        "type": project_type,
        "tech_stack": tech_stack,
        "config": config
    }

### 2. 用户上下文

```python
def user_context_example(context: SkillContext):
    # 获取用户信息
    user = context.user

    # 用户 ID
    user_id = user.id

    # 用户名
    name = user.name

    # 邮箱
    email = user.email

    # 角色
    roles = user.roles

    # 偏好
    preferences = user.preferences

    return {
        "user_id": user_id,
        "name": name,
        "email": email,
        "roles": roles,
        "preferences": preferences
    }

### 3. 环境上下文

def environment_context_example(context: SkillContext):
# 获取环境信息
environment = context.environment
# 环境名称
name = environment.name
# 平台
platform = environment.platform
# Python 版本
python_version = environment.python_version
# 工作目录
working_directory = environment.working_directory
# 环境变量
env_vars = environment.env_vars
return {
"name": name,
"platform": platform,
"python_version": python_version,
"working_directory": working_directory,
"env_vars": env_vars
}

~~~
## 事件处理 API
### 1. 事件监听
~~~
python

from claude_code_sdk import SkillContext

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def setup_event_listeners(self, context: SkillContext):
        # 监听文件变更
        context.on_file_changed(self.handle_file_changed)

        # 监听命令执行
        context.on_command_executed(self.handle_command_executed)

        # 监听错误
        context.on_error(self.handle_error)

    def handle_file_changed(self, file_path: str):
        """处理文件变更事件"""
        context.log(f"File changed: {file_path}")

    def handle_command_executed(self, command: str, output: str):
        """处理命令执行事件"""
        context.log(f"Command executed: {command}")

    def handle_error(self, error: Exception):
        """处理错误事件"""
        context.log(f"Error occurred: {error}", level="error")

### 2. 事件触发

def trigger_events_example(context: SkillContext):
# 触发自定义事件
context.emit_event(
"custom_event",
data={"key": "value"}
)
# 触发进度更新
context.emit_progress(
current=50,
total=100,
message="Processing..."
)
# 触发完成事件
context.emit_completion(
success=True,
message="Task completed"
)

~~~
## 缓存 API
### 1. 缓存操作
~~~
python

def cache_operations_example(context: SkillContext):
    # 设置缓存
    context.cache.set(
        key="my_key",
        value="my_value",
        ttl=3600  # 1 小时
    )

    # 获取缓存
    value = context.cache.get("my_key")

    # 检查缓存是否存在
    exists = context.cache.exists("my_key")

    # 删除缓存
    context.cache.delete("my_key")

    # 清空缓存
    context.cache.clear()

    # 获取缓存统计
    stats = context.cache.get_stats()

    return value

### 2. 缓存策略

def cache_strategy_example(context: SkillContext):
# 使用 LRU 缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="lru",
max_size=100
)
# 使用 TTL 缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="ttl",
ttl=3600
)
# 使用永久缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="permanent"
)

~~~
## 日志 API
### 1. 日志记录
~~~
python

def logging_example(context: SkillContext):
    # 记录不同级别的日志
    context.log("Debug message", level="debug")
    context.log("Info message", level="info")
    context.log("Warning message", level="warning")
    context.log("Error message", level="error")
    context.log("Critical message", level="critical")

    # 使用格式化日志
    context.log(
        "Processing file: {file}",
        level="info",
        file="main.py"
    )

    # 记录结构化数据
    context.log(
        "Processing completed",
        level="info",
        data={
            "files_processed": 10,
            "time_elapsed": 5.2
        }
    )

### 2. 日志配置

```python
def logging_config_example(context: SkillContext):
    # 配置日志级别
    context.set_log_level("debug")
    # 配置日志格式
    context.set_log_format(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    # 配置日志输出
    context.set_log_output(
        file="/var/log/my-skill.log"
    )
```

```
def project_context_example(context: SkillContext):
    # 获取项目信息
    project = context.project
    # 项目名称
    name = project.name
    # 项目路径
    path = project.path
    # 项目类型
    project_type = project.type
    # 技术栈
    tech_stack = project.tech_stack
    # 配置
    config = project.config
    return {
        "name": name,
        "path": path,
        "type": project_type,
        "tech_stack": tech_stack,
        "config": config
    }

### 2. 用户上下文

```python
def user_context_example(context: SkillContext):
    # 获取用户信息
    user = context.user

    # 用户 ID
    user_id = user.id

    # 用户名
    name = user.name

    # 邮箱
    email = user.email

    # 角色
    roles = user.roles

    # 偏好
    preferences = user.preferences

    return {
        "user_id": user_id,
        "name": name,
        "email": email,
        "roles": roles,
        "preferences": preferences
    }

### 3. 环境上下文

def environment_context_example(context: SkillContext):
# 获取环境信息
environment = context.environment
# 环境名称
name = environment.name
# 平台
platform = environment.platform
# Python 版本
python_version = environment.python_version
# 工作目录
working_directory = environment.working_directory
# 环境变量
env_vars = environment.env_vars
return {
"name": name,
"platform": platform,
"python_version": python_version,
"working_directory": working_directory,
"env_vars": env_vars
}

~~~
## 事件处理 API
### 1. 事件监听
~~~
python

from claude_code_sdk import SkillContext

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="0.1.0",
            description="A custom Claude Code skill"
        )

    def setup_event_listeners(self, context: SkillContext):
        # 监听文件变更
        context.on_file_changed(self.handle_file_changed)

        # 监听命令执行
        context.on_command_executed(self.handle_command_executed)

        # 监听错误
        context.on_error(self.handle_error)

    def handle_file_changed(self, file_path: str):
        """处理文件变更事件"""
        context.log(f"File changed: {file_path}")

    def handle_command_executed(self, command: str, output: str):
        """处理命令执行事件"""
        context.log(f"Command executed: {command}")

    def handle_error(self, error: Exception):
        """处理错误事件"""
        context.log(f"Error occurred: {error}", level="error")

### 2. 事件触发

def trigger_events_example(context: SkillContext):
# 触发自定义事件
context.emit_event(
"custom_event",
data={"key": "value"}
)
# 触发进度更新
context.emit_progress(
current=50,
total=100,
message="Processing..."
)
# 触发完成事件
context.emit_completion(
success=True,
message="Task completed"
)

~~~
## 缓存 API
### 1. 缓存操作
~~~
python

def cache_operations_example(context: SkillContext):
    # 设置缓存
    context.cache.set(
        key="my_key",
        value="my_value",
        ttl=3600  # 1 小时
    )

    # 获取缓存
    value = context.cache.get("my_key")

    # 检查缓存是否存在
    exists = context.cache.exists("my_key")

    # 删除缓存
    context.cache.delete("my_key")

    # 清空缓存
    context.cache.clear()

    # 获取缓存统计
    stats = context.cache.get_stats()

    return value

### 2. 缓存策略

def cache_strategy_example(context: SkillContext):
# 使用 LRU 缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="lru",
max_size=100
)
# 使用 TTL 缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="ttl",
ttl=3600
)
# 使用永久缓存
context.cache.set(
key="my_key",
value="my_value",
strategy="permanent"
)

~~~
## 日志 API
### 1. 日志记录
~~~
python

def logging_example(context: SkillContext):
    # 记录不同级别的日志
    context.log("Debug message", level="debug")
    context.log("Info message", level="info")
    context.log("Warning message", level="warning")
    context.log("Error message", level="error")
    context.log("Critical message", level="critical")

    # 使用格式化日志
    context.log(
        "Processing file: {file}",
        level="info",
        file="main.py"
    )

    # 记录结构化数据
    context.log(
        "Processing completed",
        level="info",
        data={
            "files_processed": 10,
            "time_elapsed": 5.2
        }
    )

### 2. 日志配置

```python
def logging_config_example(context: SkillContext):
    # 配置日志级别
    context.set_log_level("debug")
    # 配置日志格式
    context.set_log_format(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    # 配置日志输出
    context.set_log_output(
        file="/var/log/my-skill.log"
    )
```

---

## 4 基本技能示例

**URL**: https://claudecode.tangshuang.net/course/17.4%20%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD%E7%A4%BA%E4%BE%8B

#### 示例概述#

本节将通过几个完整的示例来展示如何开发不同类型的 Skills。这些示例涵盖了常见的使用场景，可以作为开发自己 Skills 的参考。

#### 示例 1：文本处理 Skill#

##### 1.1 Skill 定义#

```
python复制# src/skills/text_processor.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class TextProcessorSkill(Skill):
    """文本处理 Skill"""

    def __init__(self):
        super().__init__(
            name="text-processor",
            version="1.0.0",
            description="Process and transform text"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "Text to process"
                },
                "operations": {
                    "type": "array",
                    "description": "List of operations to apply",
                    "items": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string",
                                "enum": ["uppercase", "lowercase", "title", "reverse", "remove_spaces", "count_words"]
                            },
                            "params": {
                                "type": "object"
                            }
                        }
                    }
                }
            },
            "required": ["text"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            text = parameters["text"]
            operations = parameters.get("operations", [])

            # 应用操作
            result = text
            for operation in operations:
                op_type = operation.get("type")
                op_params = operation.get("params", {})

                result = self.apply_operation(result, op_type, op_params)

            return SkillResult(
                success=True,
                data={
                    "original": text,
                    "processed": result,
                    "operations_applied": len(operations)
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def apply_operation(self, text: str, op_type: str, params: Dict[str, Any]) -> str:
        """应用单个操作"""
        if op_type == "uppercase":
            return text.upper()
        elif op_type == "lowercase":
            return text.lower()
        elif op_type == "title":
            return text.title()
        elif op_type == "reverse":
            return text[::-1]
        elif op_type == "remove_spaces":
            return text.replace(" ", "")
        elif op_type == "count_words":
            return str(len(text.split()))
        else:
            raise ValueError(f"Unknown operation: {op_type}")
```

```
# src/skills/text_processor.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class TextProcessorSkill(Skill):
    """文本处理 Skill"""

    def __init__(self):
        super().__init__(
            name="text-processor",
            version="1.0.0",
            description="Process and transform text"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "Text to process"
                },
                "operations": {
                    "type": "array",
                    "description": "List of operations to apply",
                    "items": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string",
                                "enum": ["uppercase", "lowercase", "title", "reverse", "remove_spaces", "count_words"]
                            },
                            "params": {
                                "type": "object"
                            }
                        }
                    }
                }
            },
            "required": ["text"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            text = parameters["text"]
            operations = parameters.get("operations", [])

            # 应用操作
            result = text
            for operation in operations:
                op_type = operation.get("type")
                op_params = operation.get("params", {})

                result = self.apply_operation(result, op_type, op_params)

            return SkillResult(
                success=True,
                data={
                    "original": text,
                    "processed": result,
                    "operations_applied": len(operations)
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def apply_operation(self, text: str, op_type: str, params: Dict[str, Any]) -> str:
        """应用单个操作"""
        if op_type == "uppercase":
            return text.upper()
        elif op_type == "lowercase":
            return text.lower()
        elif op_type == "title":
            return text.title()
        elif op_type == "reverse":
            return text[::-1]
        elif op_type == "remove_spaces":
            return text.replace(" ", "")
        elif op_type == "count_words":
            return str(len(text.split()))
        else:
            raise ValueError(f"Unknown operation: {op_type}")
```

##### 1.2 使用示例#

```
python复制# examples/text_processor_example.py
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = TextProcessorSkill()
context = SkillContext()

# 示例 1：基本使用
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "uppercase"}
        ]
    },
    context
)

print(result.data["processed"])  # "HELLO WORLD"

# 示例 2：多个操作
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "lowercase"},
            {"type": "remove_spaces"}
        ]
    },
    context
)

print(result.data["processed"])  # "helloworld"

# 示例 3：反转文本
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "reverse"}
        ]
    },
    context
)

print(result.data["processed"])  # "dlroW olleH"
```

```
# examples/text_processor_example.py
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = TextProcessorSkill()
context = SkillContext()

# 示例 1：基本使用
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "uppercase"}
        ]
    },
    context
)

print(result.data["processed"])  # "HELLO WORLD"

# 示例 2：多个操作
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "lowercase"},
            {"type": "remove_spaces"}
        ]
    },
    context
)

print(result.data["processed"])  # "helloworld"

# 示例 3：反转文本
result = skill.execute(
    {
        "text": "Hello World",
        "operations": [
            {"type": "reverse"}
        ]
    },
    context
)

print(result.data["processed"])  # "dlroW olleH"
```

#### 示例 2：代码生成 Skill#

##### 2.1 Skill 定义#

### src/skills/code_generator.py

from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult
class CodeGeneratorSkill(Skill):
"""代码生成 Skill"""
def init(self):
super().init(
name="code-generator",
version="1.0.0",
description="Generate code from specifications"
)
def get_parameters_schema(self) -> Dict[str, Any]:
return {
"type": "object",
"properties": {
"language": {
"type": "string",
"enum": ["python", "javascript", "java", "go"],
"description": "Programming language"
},
"type": {
"type": "string",
"enum": ["function", "class", "interface", "enum"],
"description": "Code type to generate"
},
"name": {
"type": "string",
"description": "Name of the function/class"
},
"description": {
"type": "string",

"description": "Description of what the code should do"
},
"parameters": {
"type": "array",
"description": "List of parameters",
"items": {
"type": "object",
"properties": {
"name": {"type": "string"},
"type": {"type": "string"},
"default": {"type": "string"}
}
}
},
"return_type": {
"type": "string",
"description": "Return type"
}
},
"required": ["language", "type", "name", "description"]
}
def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
language = parameters["language"]
code_type = parameters["type"]
name = parameters["name"]
description = parameters["description"]
params = parameters.get("parameters", [])
return_type = parameters.get("return_type", "void")

### 生成代码

code = self.generate_code(
language, code_type, name, description,
params, return_type
)
return SkillResult(
success=True,
data={
"language": language,
"type": code_type,
"name": name,
"code": code,
"description": description
}
)
except Exception as e:
return SkillResult(
success=False,
error=str(e)
)
def generate_code(self, language: str, code_type: str, name: str,
description: str, params: list, return_type: str) -> str:
"""生成代码"""
generators = {
"python": self.generate_python,
"javascript": self.generate_javascript,
"java": self.generate_java,
"go": self.generate_go
}
generator = generators.get(language)
if not generator:
raise ValueError(f"Unsupported language: {language}")
return generator(code_type, name, description, params, return_type)
def generate_python(self, code_type: str, name: str, description: str,
params: list, return_type: str) -> str:
"""生成 Python 代码"""
param_str = ", ".join([f"{p['name']}: {p['type']}" for p in params])
if code_type == "function":
code = f'''def {name}({param_str}) -> {return_type}:
"""
{description}
"""
pass
'''
elif code_type == "class":
code = f'''class {name}:
"""
{description}
"""
def init(self{self._init_params(params)}):
pass
'''
else:
raise ValueError(f"Unsupported code type: {code_type}")
return code
def generate_javascript(self, code_type: str, name: str, description: str,
params: list, return_type: str) -> str:
"""生成 JavaScript 代码"""
param_str = ", ".join([f"{p['name']}" for p in params])
if code_type == "function":
code = f'''/**

- {description}
- @param {param_str}
- @returns {{{return_type}}}
/
function {name}({param_str}) {{
// TODO: implement
}}
'''
elif code_type == "class":
code = f'''/*
- {description}
/
class {name} {{
constructor({param_str}) {{
// TODO: implement
}}
}}
'''
else:
raise ValueError(f"Unsupported code type: {code_type}")
return code
def generate_java(self, code_type: str, name: str, description: str,
params: list, return_type: str) -> str:
"""生成 Java 代码"""
param_str = ", ".join([f"{p['type']} {p['name']}" for p in params])
if code_type == "function":
code = f'''/*
- {description}
/
public {return_type} {name}({param_str}) {{
// TODO: implement
return null;
}}
'''
elif code_type == "class":
code = f'''/*
- {description}
*/
public class {name} {{
public {name}({param_str}) {{
// TODO: implement
}}
}}
'''
else:
raise ValueError(f"Unsupported code type: {code_type}")
return code
def generate_go(self, code_type: str, name: str, description: str,
params: list, return_type: str) -> str:
"""生成 Go 代码"""
param_str = ", ".join([f"{p['name']} {p['type']}" for p in params])
if code_type == "function":
code = f'''// {description}
func {name}({param_str}) {return_type} {{
// TODO: implement
return
}}
'''
elif code_type == "class":
code = f'''// {description}
type {name} struct {{
// TODO: add fields
}}
// New{Name} creates a new {name}
func New{name}({param_str}) *{name} {{
return &{name}{{
// TODO: initialize fields
}}
}}
'''
else:
raise ValueError(f"Unsupported code type: {code_type}")
return code
def _init_params(self, params: list) -> str:
"""生成初始化参数"""
if not params:
return ""
return ", " + ", ".join([p["name"] for p in params])

```
bash复制### 2.2 使用示例

```python
# examples/code_generator_example.py
from skills.code_generator import CodeGeneratorSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = CodeGeneratorSkill()
context = SkillContext()

# 示例 1：生成 Python 函数
result = skill.execute(
    {
        "language": "python",
        "type": "function",
        "name": "calculate_sum",
        "description": "Calculate the sum of two numbers",
        "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
        ],
        "return_type": "int"
    },
    context
)

print(result.data["code"])

# 示例 2：生成 JavaScript 类
result = skill.execute(
    {
        "language": "javascript",
        "type": "class",
        "name": "User",
        "description": "User class with name and email",
        "parameters": [
            {"name": "name", "type": "string"},
            {"name": "email", "type": "string"}
        ]
    },
    context
)

print(result.data["code"])

# 示例 3：生成 Java 函数
result = skill.execute(
    {
        "language": "java",
        "type": "function",
        "name": "isValidEmail",
        "description": "Validate email address",
        "parameters": [
            {"name": "email", "type": "String"}
        ],
        "return_type": "boolean"
    },
    context
)

print(result.data["code"])
```

## 示例 3：文件分析 Skill

### 3.1 Skill 定义

# src/skills/file_analyzer.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import os
class FileAnalyzerSkill(Skill):
"""文件分析 Skill"""
def __init__(self):
super().__init__(
name="file-analyzer",
version="1.0.0",
description="Analyze files and directories"
)
def get_parameters_schema(self) -> Dict[str, Any]:
return {
"type": "object",
"properties": {
"path": {
"type": "string",
"description": "Path to file or directory"
},
"analysis_type": {
"type": "string",
"enum": ["structure", "size", "content", "all"],
"description": "Type of analysis to perform"
},
"recursive": {
"type": "boolean",
"description": "Analyze recursively for directories",
"default": False
},
"include_patterns": {
"type": "array",
"description": "File patterns to include",
"items": {"type": "string"}
},
"exclude_patterns": {
"type": "array",
"description": "File patterns to exclude",
"items": {"type": "string"}
}
},
"required": ["path"]
}
def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
path = parameters["path"]
analysis_type = parameters.get("analysis_type", "all")
recursive = parameters.get("recursive", False)
include_patterns = parameters.get("include_patterns", [])
exclude_patterns = parameters.get("exclude_patterns", [])
# 检查路径是否存在
if not os.path.exists(path):
return SkillResult(
success=False,
error=f"Path not found: {path}"
)
# 执行分析
if os.path.isfile(path):
result = self.analyze_file(
path, analysis_type, context
)
else:
result = self.analyze_directory(
path, analysis_type, recursive,
include_patterns, exclude_patterns, context
)
return SkillResult(
success=True,
data=result
)
except Exception as e:
return SkillResult(
success=False,
error=str(e)
)
def analyze_file(self, file_path: str, analysis_type: str,
context: SkillContext) -> Dict[str, Any]:
"""分析单个文件"""
result = {
"type": "file",
"path": file_path,
"name": os.path.basename(file_path),
"extension": os.path.splitext(file_path)[1]
}
if analysis_type in ["size", "all"]:
result["size"] = os.path.getsize(file_path)
if analysis_type in ["content", "all"]:
try:
content = context.read_file(file_path)
result["content"] = {
"lines": len(content.split('\n')),
"characters": len(content),
"words": len(content.split())
}
except Exception as e:
result["content"] = {"error": str(e)}
return result
def analyze_directory(self, dir_path: str, analysis_type: str,
recursive: bool, include_patterns: List[str],
exclude_patterns: List[str], context: SkillContext) -> Dict[str, Any]:
"""分析目录"""
result = {
"type": "directory",
"path": dir_path,
"name": os.path.basename(dir_path)
}
# 收集文件
files = []
directories = []
for item in os.listdir(dir_path):
item_path = os.path.join(dir_path, item)
if os.path.isfile(item_path):
if self.should_include(item, include_patterns, exclude_patterns):
files.append(item_path)
elif os.path.isdir(item_path) and recursive:
directories.append(item_path)
# 分析文件
file_analyses = []
for file_path in files:
file_analysis = self.analyze_file(file_path, analysis_type, context)
file_analyses.append(file_analysis)
result["files"] = file_analyses
result["file_count"] = len(files)
# 分析子目录
directory_analyses = []
for dir_path in directories:
dir_analysis = self.analyze_directory(
dir_path, analysis_type, recursive,
include_patterns, exclude_patterns, context
)
directory_analyses.append(dir_analysis)
result["directories"] = directory_analyses
result["directory_count"] = len(directories)
# 计算总大小
if analysis_type in ["size", "all"]:
total_size = sum(f.get("size", 0) for f in file_analyses)
for dir_analysis in directory_analyses:
total_size += dir_analysis.get("total_size", 0)
result["total_size"] = total_size
return result
def should_include(self, filename: str, include_patterns: List[str],
exclude_patterns: List[str]) -> bool:
"""检查文件是否应该包含"""
# 检查排除模式
for pattern in exclude_patterns:
if self.match_pattern(filename, pattern):
return False
# 检查包含模式
if not include_patterns:
return True
for pattern in include_patterns:
if self.match_pattern(filename, pattern):
return True
return False
def match_pattern(self, filename: str, pattern: str) -> bool:
"""匹配文件模式"""
import fnmatch
return fnmatch.fnmatch(filename, pattern)
```

```
### 2.2 使用示例

```python
# examples/code_generator_example.py
from skills.code_generator import CodeGeneratorSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = CodeGeneratorSkill()
context = SkillContext()

# 示例 1：生成 Python 函数
result = skill.execute(
    {
        "language": "python",
        "type": "function",
        "name": "calculate_sum",
        "description": "Calculate the sum of two numbers",
        "parameters": [
            {"name": "a", "type": "int"},
            {"name": "b", "type": "int"}
        ],
        "return_type": "int"
    },
    context
)

print(result.data["code"])

# 示例 2：生成 JavaScript 类
result = skill.execute(
    {
        "language": "javascript",
        "type": "class",
        "name": "User",
        "description": "User class with name and email",
        "parameters": [
            {"name": "name", "type": "string"},
            {"name": "email", "type": "string"}
        ]
    },
    context
)

print(result.data["code"])

# 示例 3：生成 Java 函数
result = skill.execute(
    {
        "language": "java",
        "type": "function",
        "name": "isValidEmail",
        "description": "Validate email address",
        "parameters": [
            {"name": "email", "type": "String"}
        ],
        "return_type": "boolean"
    },
    context
)

print(result.data["code"])
```

## 示例 3：文件分析 Skill

### 3.1 Skill 定义

# src/skills/file_analyzer.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import os
class FileAnalyzerSkill(Skill):
"""文件分析 Skill"""
def __init__(self):
super().__init__(
name="file-analyzer",
version="1.0.0",
description="Analyze files and directories"
)
def get_parameters_schema(self) -> Dict[str, Any]:
return {
"type": "object",
"properties": {
"path": {
"type": "string",
"description": "Path to file or directory"
},
"analysis_type": {
"type": "string",
"enum": ["structure", "size", "content", "all"],
"description": "Type of analysis to perform"
},
"recursive": {
"type": "boolean",
"description": "Analyze recursively for directories",
"default": False
},
"include_patterns": {
"type": "array",
"description": "File patterns to include",
"items": {"type": "string"}
},
"exclude_patterns": {
"type": "array",
"description": "File patterns to exclude",
"items": {"type": "string"}
}
},
"required": ["path"]
}
def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
path = parameters["path"]
analysis_type = parameters.get("analysis_type", "all")
recursive = parameters.get("recursive", False)
include_patterns = parameters.get("include_patterns", [])
exclude_patterns = parameters.get("exclude_patterns", [])
# 检查路径是否存在
if not os.path.exists(path):
return SkillResult(
success=False,
error=f"Path not found: {path}"
)
# 执行分析
if os.path.isfile(path):
result = self.analyze_file(
path, analysis_type, context
)
else:
result = self.analyze_directory(
path, analysis_type, recursive,
include_patterns, exclude_patterns, context
)
return SkillResult(
success=True,
data=result
)
except Exception as e:
return SkillResult(
success=False,
error=str(e)
)
def analyze_file(self, file_path: str, analysis_type: str,
context: SkillContext) -> Dict[str, Any]:
"""分析单个文件"""
result = {
"type": "file",
"path": file_path,
"name": os.path.basename(file_path),
"extension": os.path.splitext(file_path)[1]
}
if analysis_type in ["size", "all"]:
result["size"] = os.path.getsize(file_path)
if analysis_type in ["content", "all"]:
try:
content = context.read_file(file_path)
result["content"] = {
"lines": len(content.split('\n')),
"characters": len(content),
"words": len(content.split())
}
except Exception as e:
result["content"] = {"error": str(e)}
return result
def analyze_directory(self, dir_path: str, analysis_type: str,
recursive: bool, include_patterns: List[str],
exclude_patterns: List[str], context: SkillContext) -> Dict[str, Any]:
"""分析目录"""
result = {
"type": "directory",
"path": dir_path,
"name": os.path.basename(dir_path)
}
# 收集文件
files = []
directories = []
for item in os.listdir(dir_path):
item_path = os.path.join(dir_path, item)
if os.path.isfile(item_path):
if self.should_include(item, include_patterns, exclude_patterns):
files.append(item_path)
elif os.path.isdir(item_path) and recursive:
directories.append(item_path)
# 分析文件
file_analyses = []
for file_path in files:
file_analysis = self.analyze_file(file_path, analysis_type, context)
file_analyses.append(file_analysis)
result["files"] = file_analyses
result["file_count"] = len(files)
# 分析子目录
directory_analyses = []
for dir_path in directories:
dir_analysis = self.analyze_directory(
dir_path, analysis_type, recursive,
include_patterns, exclude_patterns, context
)
directory_analyses.append(dir_analysis)
result["directories"] = directory_analyses
result["directory_count"] = len(directories)
# 计算总大小
if analysis_type in ["size", "all"]:
total_size = sum(f.get("size", 0) for f in file_analyses)
for dir_analysis in directory_analyses:
total_size += dir_analysis.get("total_size", 0)
result["total_size"] = total_size
return result
def should_include(self, filename: str, include_patterns: List[str],
exclude_patterns: List[str]) -> bool:
"""检查文件是否应该包含"""
# 检查排除模式
for pattern in exclude_patterns:
if self.match_pattern(filename, pattern):
return False
# 检查包含模式
if not include_patterns:
return True
for pattern in include_patterns:
if self.match_pattern(filename, pattern):
return True
return False
def match_pattern(self, filename: str, pattern: str) -> bool:
"""匹配文件模式"""
import fnmatch
return fnmatch.fnmatch(filename, pattern)
```

##### 3.2 使用示例#

```
python复制# examples/file_analyzer_example.py
from skills.file_analyzer import FileAnalyzerSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = FileAnalyzerSkill()
context = SkillContext()

# 示例 1：分析单个文件
result = skill.execute(
    {
        "path": "src/main.py",
        "analysis_type": "all"
    },
    context
)
```

```
# examples/file_analyzer_example.py
from skills.file_analyzer import FileAnalyzerSkill
from claude_code_sdk import SkillContext

# 创建 Skill 实例
skill = FileAnalyzerSkill()
context = SkillContext()

# 示例 1：分析单个文件
result = skill.execute(
    {
        "path": "src/main.py",
        "analysis_type": "all"
    },
    context
)
```

print(result.data)

### 示例 2：分析目录

result = skill.execute(
{
"path": "src",
"analysis_type": "size",
"recursive": True
},
context
)

print(f"Total size: {result.data['total_size']} bytes")

### 示例 3：分析特定文件类型

result = skill.execute(
{
"path": "src",
"analysis_type": "structure",
"recursive": True,
"include_patterns": [".py"],
"exclude_patterns": ["pycache", ".pyc"]
},
context
)

print(f"Python files found: {result.data['file_count']}")

#### 示例 4：测试生成 Skill#

##### 4.1 Skill 定义#

### src/skills/test_generator.py

from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult
class TestGeneratorSkill(Skill):
"""测试生成 Skill"""
def init(self):
super().init(
name="test-generator",
version="1.0.0",
description="Generate unit tests from code"
)
def get_parameters_schema(self) -> Dict[str, Any]:
return {
"type": "object",
"properties": {
"file_path": {
"type": "string",
"description": "Path to the source file"
},
"test_framework": {
"type": "string",
"enum": ["pytest", "unittest", "jest"],
"description": "Test framework to use"
},
"include_edge_cases": {
"type": "boolean",
"description": "Include edge case tests",
"default": True
},
"include_mocks": {
"type": "boolean",
"description": "Include mock objects",
"default": False
}
},
"required": ["file_path"]
}
def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
file_path = parameters["file_path"]
test_framework = parameters.get("test_framework", "pytest")
include_edge_cases = parameters.get("include_edge_cases", True)
include_mocks = parameters.get("include_mocks", False)

### 读取源文件

source_code = context.read_file(file_path)

### 分析代码

functions = self.analyze_functions(source_code)

### 生成测试

test_code = self.generate_tests(
file_path, functions, test_framework,
include_edge_cases, include_mocks
)
return SkillResult(
success=True,
data={
"source_file": file_path,
"test_framework": test_framework,
"functions_tested": len(functions),
"test_code": test_code
}
)
except Exception as e:
return SkillResult(
success=False,
error=str(e)
)
def analyze_functions(self, source_code: str) -> list:
"""分析源代码中的函数"""
import re
functions = []
pattern = r'def\s+(\w+)\s*(([^)]*)):'
for match in re.finditer(pattern, source_code):
function_name = match.group(1)
params = match.group(2).strip()
functions.append({
"name": function_name,
"params": [p.strip() for p in params.split(',') if p.strip()]
})
return functions
def generate_tests(self, file_path: str, functions: list,
test_framework: str, include_edge_cases: bool,
include_mocks: bool) -> str:
"""生成测试代码"""
generators = {
"pytest": self.generate_pytest,
"unittest": self.generate_unittest,
"jest": self.generate_jest
}
generator = generators.get(test_framework)
if not generator:
raise ValueError(f"Unsupported test framework: {test_framework}")
return generator(file_path, functions, include_edge_cases, include_mocks)
def generate_pytest(self, file_path: str, functions: list,
include_edge_cases: bool, include_mocks: bool) -> str:
"""生成 pytest 测试"""
import os
module_name = os.path.splitext(os.path.basename(file_path))[0]
test_code = f'''import pytest
from {module_name} import {', '.join([f['name'] for f in functions])}
'''
for func in functions:
test_code += f'''class Test{func['name'].capitalize()}:
"""Test cases for {func['name']}"""
def test_{func['name']}_basic(self):
"""Basic test for {func['name']}"""

### TODO: implement test

pass
'''
if include_edge_cases:
test_code += f'''
def test_{func['name']}_edge_cases(self):
"""Edge case tests for {func['name']}"""

### TODO: implement edge case tests

pass
'''
if include_mocks:
test_code += f'''
def test_{func['name']}_with_mocks(self):
"""Test {func['name']} with mocks"""

### TODO: implement tests with mocks

pass
'''
return test_code
def generate_unittest(self, file_path: str, functions: list,
include_edge_cases: bool, include_mocks: bool) -> str:
"""生成 unittest 测试"""
import os
module_name = os.path.splitext(os.path.basename(file_path))[0]
test_code = f'''import unittest
from {module_name} import {', '.join([f['name'] for f in functions])}
class Test{module_name.capitalize()}(unittest.TestCase):
"""Test cases for {module_name}"""
'''
for func in functions:
test_code += f'''
def test_{func['name']}(self):
"""Test {func['name']}"""

### TODO: implement test

pass
'''
if include_edge_cases:
test_code += f'''
def test_{func['name']}_edge_cases(self):
"""Test {func['name']} edge cases"""

### TODO: implement edge case tests

pass
'''
test_code += '''
if name == 'main':
unittest.main()
'''
return test_code
def generate_jest(self, file_path: str, functions: list,
include_edge_cases: bool, include_mocks: bool) -> str:
"""生成 Jest 测试"""
import os
module_name = os.path.splitext(os.path.basename(file_path))[0]
test_code = f'''const {{ {', '.join([f['name'] for f in functions])} }} = require('./{module_name}');
'''
for func in functions:
test_code += f'''describe('{func['name']}', () => {{
test('basic test', () => {{
// TODO: implement test
}});
'''
if include_edge_cases:
test_code += f'''
test('edge cases', () => {{
// TODO: implement edge case tests
}});
'''
if include_mocks:
test_code += f'''
test('with mocks', () => {{
// TODO: implement tests with mocks
}});
'''
test_code += '});\n'
return test_code

```
bash复制### 4.2 使用示例
```

```
### 4.2 使用示例
```

python

### examples/test_generator_example.py

from skills.test_generator import TestGeneratorSkill
from claude_code_sdk import SkillContext

### 创建 Skill 实例

skill = TestGeneratorSkill()
context = SkillContext()

### 示例 1：生成 pytest 测试

result = skill.execute(
{
"file_path": "src/utils.py",
"test_framework": "pytest",
"include_edge_cases": True,
"include_mocks": False
},
context
)

print(result.data["test_code"])

### 示例 2：生成 unittest 测试

result = skill.execute(
{
"file_path": "src/utils.py",
"test_framework": "unittest"
},
context
)

print(result.data["test_code"])

### 示例 3：生成 Jest 测试

result = skill.execute(
{
"file_path": "src/utils.js",
"test_framework": "jest"
},
context
)

print(result.data["test_code"])

```
bash复制
## 总结

通过这些示例，我们可以看到如何开发不同类型的 Skills：

1. **文本处理 Skill**：展示基本的文本转换操作
2. **代码生成 Skill**：展示如何根据规范生成代码
3. **文件分析 Skill**：展示如何分析文件和目录结构
4. **测试生成 Skill**：展示如何自动生成测试代码

这些示例可以作为开发自己 Skills 的起点和参考。

在下一节中，我们将探讨 Skills 的测试与调试方法。

~~~
```

```
## 总结

通过这些示例，我们可以看到如何开发不同类型的 Skills：

1. **文本处理 Skill**：展示基本的文本转换操作
2. **代码生成 Skill**：展示如何根据规范生成代码
3. **文件分析 Skill**：展示如何分析文件和目录结构
4. **测试生成 Skill**：展示如何自动生成测试代码

这些示例可以作为开发自己 Skills 的起点和参考。

在下一节中，我们将探讨 Skills 的测试与调试方法。

~~~
```

---

## 5 Skills 测试与调试

**URL**: https://claudecode.tangshuang.net/course/17.5%20Skills%20%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95

#### 测试与调试概述#

测试和调试是开发高质量 Skills 的关键环节。本节将详细介绍 Skills 的测试方法、调试技巧和最佳实践。

#### 测试策略#

##### 1. 单元测试#

###### 1.1 基本测试

```
python复制# tests/test_text_processor.py
import pytest
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestTextProcessorSkill:
    """文本处理 Skill 测试"""

    def setup_method(self):
        """设置方法"""
        self.skill = TextProcessorSkill()
        self.context = SkillContext()

    def test_skill_initialization(self):
        """测试 Skill 初始化"""
        assert self.skill.name == "text-processor"
        assert self.skill.version == "1.0.0"
        assert self.skill.description == "Process and transform text"

    def test_get_parameters_schema(self):
        """测试获取参数模式"""
        schema = self.skill.get_parameters_schema()

        assert "properties" in schema
        assert "text" in schema["properties"]
        assert "operations" in schema["properties"]
        assert "required" in schema
        assert "text" in schema["required"]

    def test_execute_uppercase(self):
        """测试大写转换"""
        result = self.skill.execute(
            {
                "text": "hello world",
                "operations": [{"type": "uppercase"}]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "HELLO WORLD"

    def test_execute_lowercase(self):
        """测试小写转换"""
        result = self.skill.execute(
            {
                "text": "HELLO WORLD",
                "operations": [{"type": "lowercase"}]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "hello world"

    def test_execute_multiple_operations(self):
        """测试多个操作"""
        result = self.skill.execute(
            {
                "text": "Hello World",
                "operations": [
                    {"type": "lowercase"},
                    {"type": "remove_spaces"}
                ]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "helloworld"

    def test_execute_missing_text(self):
        """测试缺少必需参数"""
        result = self.skill.execute(
            {"operations": [{"type": "uppercase"}]},
            self.context
        )

        assert not result.success
        assert "error" in result.data

    def test_execute_invalid_operation(self):
        """测试无效操作"""
        result = self.skill.execute(
            {
                "text": "hello",
                "operations": [{"type": "invalid"}]
            },
            self.context
        )

        assert not result.success
        assert "error" in result.data
```

```
# tests/test_text_processor.py
import pytest
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestTextProcessorSkill:
    """文本处理 Skill 测试"""

    def setup_method(self):
        """设置方法"""
        self.skill = TextProcessorSkill()
        self.context = SkillContext()

    def test_skill_initialization(self):
        """测试 Skill 初始化"""
        assert self.skill.name == "text-processor"
        assert self.skill.version == "1.0.0"
        assert self.skill.description == "Process and transform text"

    def test_get_parameters_schema(self):
        """测试获取参数模式"""
        schema = self.skill.get_parameters_schema()

        assert "properties" in schema
        assert "text" in schema["properties"]
        assert "operations" in schema["properties"]
        assert "required" in schema
        assert "text" in schema["required"]

    def test_execute_uppercase(self):
        """测试大写转换"""
        result = self.skill.execute(
            {
                "text": "hello world",
                "operations": [{"type": "uppercase"}]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "HELLO WORLD"

    def test_execute_lowercase(self):
        """测试小写转换"""
        result = self.skill.execute(
            {
                "text": "HELLO WORLD",
                "operations": [{"type": "lowercase"}]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "hello world"

    def test_execute_multiple_operations(self):
        """测试多个操作"""
        result = self.skill.execute(
            {
                "text": "Hello World",
                "operations": [
                    {"type": "lowercase"},
                    {"type": "remove_spaces"}
                ]
            },
            self.context
        )

        assert result.success
        assert result.data["processed"] == "helloworld"

    def test_execute_missing_text(self):
        """测试缺少必需参数"""
        result = self.skill.execute(
            {"operations": [{"type": "uppercase"}]},
            self.context
        )

        assert not result.success
        assert "error" in result.data

    def test_execute_invalid_operation(self):
        """测试无效操作"""
        result = self.skill.execute(
            {
                "text": "hello",
                "operations": [{"type": "invalid"}]
            },
            self.context
        )

        assert not result.success
        assert "error" in result.data
```

###### 1.2 使用固件

```
python复制# tests/conftest.py
import pytest
from claude_code_sdk import SkillContext
from skills.text_processor import TextProcessorSkill

@pytest.fixture
def skill():
    """Skill 固件"""
    return TextProcessorSkill()

@pytest.fixture
def context():
    """上下文固件"""
    return SkillContext()

@pytest.fixture
def sample_text():
    """示例文本固件"""
    return "Hello World"

@pytest.fixture
def sample_operations():
    """示例操作固件"""
```

```
# tests/conftest.py
import pytest
from claude_code_sdk import SkillContext
from skills.text_processor import TextProcessorSkill

@pytest.fixture
def skill():
    """Skill 固件"""
    return TextProcessorSkill()

@pytest.fixture
def context():
    """上下文固件"""
    return SkillContext()

@pytest.fixture
def sample_text():
    """示例文本固件"""
    return "Hello World"

@pytest.fixture
def sample_operations():
    """示例操作固件"""
```

```
bash复制return [
    {"type": "uppercase"}
]
```

```
return [
    {"type": "uppercase"}
]
```

@pytest.fixture
def mock_context(mocker):
"""模拟上下文固件"""
context = mocker.Mock(spec=SkillContext)
return context

```
bash复制
#### 1.3 参数化测试

```python
# tests/test_text_processor_parametrized.py
import pytest
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestTextProcessorParametrized:
    """参数化测试"""
    @pytest.mark.parametrize("input_text,operation,expected_output", [
        ("hello", "uppercase", "HELLO"),
        ("HELLO", "lowercase", "hello"),
        ("hello", "title", "Hello"),
        ("hello", "reverse", "olleh"),
        ("hello world", "remove_spaces", "helloworld")
    ])
    def test_operations(self, input_text, operation, expected_output):
        """参数化操作测试"""
        skill = TextProcessorSkill()
        context = SkillContext()
        result = skill.execute(
            {
                "text": input_text,
                "operations": [{"type": operation}]
            },
            context
        )
        assert result.success
        assert result.data["processed"] == expected_output
```

```
#### 1.3 参数化测试

```python
# tests/test_text_processor_parametrized.py
import pytest
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestTextProcessorParametrized:
    """参数化测试"""
    @pytest.mark.parametrize("input_text,operation,expected_output", [
        ("hello", "uppercase", "HELLO"),
        ("HELLO", "lowercase", "hello"),
        ("hello", "title", "Hello"),
        ("hello", "reverse", "olleh"),
        ("hello world", "remove_spaces", "helloworld")
    ])
    def test_operations(self, input_text, operation, expected_output):
        """参数化操作测试"""
        skill = TextProcessorSkill()
        context = SkillContext()
        result = skill.execute(
            {
                "text": input_text,
                "operations": [{"type": operation}]
            },
            context
        )
        assert result.success
        assert result.data["processed"] == expected_output
```

```
bash复制### 2. 集成测试
#### 2.1 文件系统集成测试
```

```
### 2. 集成测试
#### 2.1 文件系统集成测试
```

python

### tests/test_file_analyzer_integration.py

import pytest
import os
import tempfile
from skills.file_analyzer import FileAnalyzerSkill
from claude_code_sdk import SkillContext

class TestFileAnalyzerIntegration:
"""文件分析 Skill 集成测试"""

```
bash复制def setup_method(self):
    """设置方法"""
    self.skill = FileAnalyzerSkill()
    self.context = SkillContext()

    # 创建临时目录
    self.temp_dir = tempfile.mkdtemp()

    # 创建测试文件
    self.test_file = os.path.join(self.temp_dir, "test.txt")
    with open(self.test_file, 'w') as f:
        f.write("Hello World\nThis is a test file\n")

def teardown_method(self):
    """清理方法"""
    # 删除临时目录
    import shutil
    shutil.rmtree(self.temp_dir)

def test_analyze_file(self):
    """测试文件分析"""
    result = self.skill.execute(
        {
            "path": self.test_file,
            "analysis_type": "all"
        },
        self.context
    )

    assert result.success
    assert result.data["type"] == "file"
    assert result.data["name"] == "test.txt"
    assert "size" in result.data
    assert "content" in result.data

def test_analyze_directory(self):
    """测试目录分析"""
    result = self.skill.execute(
        {
            "path": self.temp_dir,
            "analysis_type": "structure"
        },
        self.context
    )

    assert result.success
    assert result.data["type"] == "directory"
    assert result.data["file_count"] == 1

def test_analyze_nonexistent_path(self):
    """测试不存在的路径"""
    result = self.skill.execute(
        {
            "path": "/nonexistent/path",
            "analysis_type": "all"
        },
        self.context
    )

    assert not result.success
    assert "error" in result.data
```

```
def setup_method(self):
    """设置方法"""
    self.skill = FileAnalyzerSkill()
    self.context = SkillContext()

    # 创建临时目录
    self.temp_dir = tempfile.mkdtemp()

    # 创建测试文件
    self.test_file = os.path.join(self.temp_dir, "test.txt")
    with open(self.test_file, 'w') as f:
        f.write("Hello World\nThis is a test file\n")

def teardown_method(self):
    """清理方法"""
    # 删除临时目录
    import shutil
    shutil.rmtree(self.temp_dir)

def test_analyze_file(self):
    """测试文件分析"""
    result = self.skill.execute(
        {
            "path": self.test_file,
            "analysis_type": "all"
        },
        self.context
    )

    assert result.success
    assert result.data["type"] == "file"
    assert result.data["name"] == "test.txt"
    assert "size" in result.data
    assert "content" in result.data

def test_analyze_directory(self):
    """测试目录分析"""
    result = self.skill.execute(
        {
            "path": self.temp_dir,
            "analysis_type": "structure"
        },
        self.context
    )

    assert result.success
    assert result.data["type"] == "directory"
    assert result.data["file_count"] == 1

def test_analyze_nonexistent_path(self):
    """测试不存在的路径"""
    result = self.skill.execute(
        {
            "path": "/nonexistent/path",
            "analysis_type": "all"
        },
        self.context
    )

    assert not result.success
    assert "error" in result.data
```

###### 2.2 上下文集成测试

### tests/test_context_integration.py

import pytest
from claude_code_sdk import SkillContext
class TestContextIntegration:
"""上下文集成测试"""
def test_context_file_operations(self, tmp_path):
"""测试上下文文件操作"""
context = SkillContext()

### 写入文件

test_file = tmp_path / "test.txt"
context.write_file(str(test_file), "Hello World")

### 读取文件

content = context.read_file(str(test_file))
assert content == "Hello World"

### 检查文件存在

assert context.file_exists(str(test_file))
def test_context_search_operations(self, tmp_path):
"""测试上下文搜索操作"""
context = SkillContext()

### 创建测试文件

test_file = tmp_path / "test.py"
test_file.write_text("def test_function():\n    pass\n")

### 搜索代码

results = context.search_codebase("test_function", str(tmp_path))
assert len(results) > 0
def test_context_command_operations(self):
"""测试上下文命令操作"""
context = SkillContext()

### 执行命令

output = context.run_command("echo 'Hello'")
assert "Hello" in output

```
bash复制### 3. 端到端测试
#### 3.1 完整工作流测试

```python
# tests/test_e2e.py
import pytest
import os
import tempfile
from skills.code_generator import CodeGeneratorSkill
from skills.test_generator import TestGeneratorSkill
from claude_code_sdk import SkillContext

class TestEndToEnd:
    """端到端测试"""

    def setup_method(self):
        """设置方法"""
        self.context = SkillContext()
        self.temp_dir = tempfile.mkdtemp()

    def teardown_method(self):
        """清理方法"""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_code_generation_to_test_generation(self):
        """测试代码生成到测试生成的完整流程"""
        # 步骤 1：生成代码
        code_generator = CodeGeneratorSkill()
        code_result = code_generator.execute(
            {
                "language": "python",
                "type": "function",
                "name": "calculate_sum",
                "description": "Calculate sum of two numbers",
                "parameters": [
                    {"name": "a", "type": "int"},
                    {"name": "b", "type": "int"}
                ],
                "return_type": "int"
            },
            self.context
        )

        assert code_result.success

        # 步骤 2：保存生成的代码
        code_file = os.path.join(self.temp_dir, "utils.py")
        self.context.write_file(code_file, code_result.data["code"])

        # 步骤 3：生成测试
        test_generator = TestGeneratorSkill()
        test_result = test_generator.execute(
            {
                "file_path": code_file,
                "test_framework": "pytest"
            },
            self.context
        )

        assert test_result.success
        assert "test_code" in test_result.data

        # 步骤 4：保存测试代码
        test_file = os.path.join(self.temp_dir, "test_utils.py")
        self.context.write_file(test_file, test_result.data["test_code"])

        # 验证文件存在
        assert os.path.exists(code_file)
        assert os.path.exists(test_file)
```

## 调试技巧

### 1. 日志调试

#### 1.1 添加日志

```python
# src/skills/my_skill.py
import logging

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="1.0.0",
            description="A custom Claude Code skill"
        )
        # 设置日志
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)

    def execute(self, parameters, context):
        self.logger.debug("Starting execution")
        self.logger.debug(f"Parameters: {parameters}")
        try:
            # 处理逻辑
            result = self.process(parameters)
            self.logger.debug(f"Result: {result}")
            return result
        except Exception as e:
            self.logger.error(f"Error: {e}", exc_info=True)
            raise
```

#### 1.2 配置日志

```python
# src/skills/logger_config.py
import logging
import sys

def setup_logging(level=logging.DEBUG):
    """设置日志"""
    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # 创建控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)

    # 配置根日志记录器
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.addHandler(console_handler)

    # 配置文件处理器
    file_handler = logging.FileHandler('debug.log')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    root_logger.addHandler(file_handler)

# 在 Skill 初始化时调用
setup_logging()
```

### 2. 断点调试

#### 2.1 使用 pdb

```python
# src/skills/my_skill.py
import pdb

class MySkill(Skill):
    def execute(self, parameters, context):
        # 设置断点
        pdb.set_trace()
        # 处理逻辑
        result = self.process(parameters)
        return result
```

#### 2.2 使用 ipdb

```python
# src/skills/my_skill.py
import ipdb

class MySkill(Skill):
    def execute(self, parameters, context):
        # 设置断点
        ipdb.set_trace()

        # 处理逻辑
        result = self.process(parameters)

        return result
```

#### 2.3 使用 VS Code 调试器

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Debug Skill",
            "type": "python",
            "request": "launch",
            "module": "pytest",
            "args": [
                "tests/test_my_skill.py::TestMySkill::test_execute"
            ],
            "console": "integratedTerminal",
            "env": {
                "PYTHONPATH": "${workspaceFolder}/src"
            }
        }
    ]
}
```

### 3. Mock 和 Stub
#### 3.1 Mock 上下文

```python
# tests/test_my_skill_mock.py
import pytest
from unittest.mock import Mock, MagicMock
from skills.my_skill import MySkill

class TestMySkillMock:
    """使用 Mock 的测试"""

    def test_execute_with_mock_context(self):
        """使用模拟上下文测试"""
        skill = MySkill()

        # 创建模拟上下文
        mock_context = Mock()
        mock_context.read_file.return_value = "file content"
        mock_context.write_file.return_value = None

        # 执行 Skill
        result = skill.execute(
            {"input": "test"},
            mock_context
        )

        # 验证结果
        assert result.success

        # 验证模拟对象被调用
        mock_context.read_file.assert_called_once()
```

#### 3.2 Mock 外部依赖

```python
# tests/test_my_skill_external.py
import pytest
from unittest.mock import patch
from skills.my_skill import MySkill

class TestMySkillExternal:
    """测试外部依赖"""
    @patch('skills.my_skill.external_api_call')
    def test_execute_with_external_api(self, mock_api):
        """使用外部 API 的测试"""
        skill = MySkill()
        # 设置模拟返回值
        mock_api.return_value = {"status": "success"}
        # 执行 Skill
        result = skill.execute({"input": "test"}, Mock())
        # 验证结果
        assert result.success
        # 验证 API 被调用
        mock_api.assert_called_once()
```
```

```
### 3. 端到端测试
#### 3.1 完整工作流测试

```python
# tests/test_e2e.py
import pytest
import os
import tempfile
from skills.code_generator import CodeGeneratorSkill
from skills.test_generator import TestGeneratorSkill
from claude_code_sdk import SkillContext

class TestEndToEnd:
    """端到端测试"""

    def setup_method(self):
        """设置方法"""
        self.context = SkillContext()
        self.temp_dir = tempfile.mkdtemp()

    def teardown_method(self):
        """清理方法"""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_code_generation_to_test_generation(self):
        """测试代码生成到测试生成的完整流程"""
        # 步骤 1：生成代码
        code_generator = CodeGeneratorSkill()
        code_result = code_generator.execute(
            {
                "language": "python",
                "type": "function",
                "name": "calculate_sum",
                "description": "Calculate sum of two numbers",
                "parameters": [
                    {"name": "a", "type": "int"},
                    {"name": "b", "type": "int"}
                ],
                "return_type": "int"
            },
            self.context
        )

        assert code_result.success

        # 步骤 2：保存生成的代码
        code_file = os.path.join(self.temp_dir, "utils.py")
        self.context.write_file(code_file, code_result.data["code"])

        # 步骤 3：生成测试
        test_generator = TestGeneratorSkill()
        test_result = test_generator.execute(
            {
                "file_path": code_file,
                "test_framework": "pytest"
            },
            self.context
        )

        assert test_result.success
        assert "test_code" in test_result.data

        # 步骤 4：保存测试代码
        test_file = os.path.join(self.temp_dir, "test_utils.py")
        self.context.write_file(test_file, test_result.data["test_code"])

        # 验证文件存在
        assert os.path.exists(code_file)
        assert os.path.exists(test_file)
```

## 调试技巧

### 1. 日志调试

#### 1.1 添加日志

```python
# src/skills/my_skill.py
import logging

class MySkill(Skill):
    def __init__(self):
        super().__init__(
            name="my-skill",
            version="1.0.0",
            description="A custom Claude Code skill"
        )
        # 设置日志
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)

    def execute(self, parameters, context):
        self.logger.debug("Starting execution")
        self.logger.debug(f"Parameters: {parameters}")
        try:
            # 处理逻辑
            result = self.process(parameters)
            self.logger.debug(f"Result: {result}")
            return result
        except Exception as e:
            self.logger.error(f"Error: {e}", exc_info=True)
            raise
```

#### 1.2 配置日志

```python
# src/skills/logger_config.py
import logging
import sys

def setup_logging(level=logging.DEBUG):
    """设置日志"""
    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # 创建控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)

    # 配置根日志记录器
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.addHandler(console_handler)

    # 配置文件处理器
    file_handler = logging.FileHandler('debug.log')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    root_logger.addHandler(file_handler)

# 在 Skill 初始化时调用
setup_logging()
```

### 2. 断点调试

#### 2.1 使用 pdb

```python
# src/skills/my_skill.py
import pdb

class MySkill(Skill):
    def execute(self, parameters, context):
        # 设置断点
        pdb.set_trace()
        # 处理逻辑
        result = self.process(parameters)
        return result
```

#### 2.2 使用 ipdb

```python
# src/skills/my_skill.py
import ipdb

class MySkill(Skill):
    def execute(self, parameters, context):
        # 设置断点
        ipdb.set_trace()

        # 处理逻辑
        result = self.process(parameters)

        return result
```

#### 2.3 使用 VS Code 调试器

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Debug Skill",
            "type": "python",
            "request": "launch",
            "module": "pytest",
            "args": [
                "tests/test_my_skill.py::TestMySkill::test_execute"
            ],
            "console": "integratedTerminal",
            "env": {
                "PYTHONPATH": "${workspaceFolder}/src"
            }
        }
    ]
}
```

### 3. Mock 和 Stub
#### 3.1 Mock 上下文

```python
# tests/test_my_skill_mock.py
import pytest
from unittest.mock import Mock, MagicMock
from skills.my_skill import MySkill

class TestMySkillMock:
    """使用 Mock 的测试"""

    def test_execute_with_mock_context(self):
        """使用模拟上下文测试"""
        skill = MySkill()

        # 创建模拟上下文
        mock_context = Mock()
        mock_context.read_file.return_value = "file content"
        mock_context.write_file.return_value = None

        # 执行 Skill
        result = skill.execute(
            {"input": "test"},
            mock_context
        )

        # 验证结果
        assert result.success

        # 验证模拟对象被调用
        mock_context.read_file.assert_called_once()
```

#### 3.2 Mock 外部依赖

```python
# tests/test_my_skill_external.py
import pytest
from unittest.mock import patch
from skills.my_skill import MySkill

class TestMySkillExternal:
    """测试外部依赖"""
    @patch('skills.my_skill.external_api_call')
    def test_execute_with_external_api(self, mock_api):
        """使用外部 API 的测试"""
        skill = MySkill()
        # 设置模拟返回值
        mock_api.return_value = {"status": "success"}
        # 执行 Skill
        result = skill.execute({"input": "test"}, Mock())
        # 验证结果
        assert result.success
        # 验证 API 被调用
        mock_api.assert_called_once()
```
```

#### 性能测试#

##### 1. 基准测试#

```
python复制# tests/test_performance.py
import pytest
import time
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestPerformance:
    """性能测试"""

    def test_text_processing_performance(self):
        """测试文本处理性能"""
        skill = TextProcessorSkill()
        context = SkillContext()

        # 准备测试数据
        large_text = "hello " * 10000

        # 测量执行时间
        start_time = time.time()
        result = skill.execute(
            {
                "text": large_text,
                "operations": [{"type": "uppercase"}]
            },
            context
        )
        end_time = time.time()

        # 验证结果
        assert result.success

        # 验证性能（应该在 1 秒内完成）
        execution_time = end_time - start_time
        assert execution_time < 1.0, f"Execution took {execution_time} seconds"

    def test_file_analysis_performance(self, tmp_path):
        """测试文件分析性能"""
        from skills.file_analyzer import FileAnalyzerSkill

        skill = FileAnalyzerSkill()
        context = SkillContext()

        # 创建测试文件
        test_file = tmp_path / "test.txt"
        test_file.write_text("x" * 1000000)

        # 测量执行时间
        start_time = time.time()
        result = skill.execute(
            {
                "path": str(test_file),
                "analysis_type": "size"
            },
            context
        )
        end_time = time.time()

        # 验证结果
        assert result.success

        # 验证性能
        execution_time = end_time - start_time
        assert execution_time < 0.5, f"Execution took {execution_time} seconds"
```

```
# tests/test_performance.py
import pytest
import time
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestPerformance:
    """性能测试"""

    def test_text_processing_performance(self):
        """测试文本处理性能"""
        skill = TextProcessorSkill()
        context = SkillContext()

        # 准备测试数据
        large_text = "hello " * 10000

        # 测量执行时间
        start_time = time.time()
        result = skill.execute(
            {
                "text": large_text,
                "operations": [{"type": "uppercase"}]
            },
            context
        )
        end_time = time.time()

        # 验证结果
        assert result.success

        # 验证性能（应该在 1 秒内完成）
        execution_time = end_time - start_time
        assert execution_time < 1.0, f"Execution took {execution_time} seconds"

    def test_file_analysis_performance(self, tmp_path):
        """测试文件分析性能"""
        from skills.file_analyzer import FileAnalyzerSkill

        skill = FileAnalyzerSkill()
        context = SkillContext()

        # 创建测试文件
        test_file = tmp_path / "test.txt"
        test_file.write_text("x" * 1000000)

        # 测量执行时间
        start_time = time.time()
        result = skill.execute(
            {
                "path": str(test_file),
                "analysis_type": "size"
            },
            context
        )
        end_time = time.time()

        # 验证结果
        assert result.success

        # 验证性能
        execution_time = end_time - start_time
        assert execution_time < 0.5, f"Execution took {execution_time} seconds"
```

##### 2. 内存测试#

```
python复制# tests/test_memory.py
import pytest
import tracemalloc
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestMemory:
    """内存测试"""
    def test_memory_usage(self):
        """测试内存使用"""
        skill = TextProcessorSkill()
        context = SkillContext()
        # 开始内存跟踪
        tracemalloc.start()
        # 执行操作
        for i in range(100):
            skill.execute(
                {
                    "text": "hello world " * 100,
                    "operations": [{"type": "uppercase"}]
                },
                context
            )
        # 获取内存使用情况
        current, peak = tracemalloc.get_traced_memory()
        # 停止内存跟踪
        tracemalloc.stop()
        # 验证内存使用（峰值应该小于 10MB）
        peak_mb = peak / 1024 / 1024
        assert peak_mb < 10, f"Peak memory usage: {peak_mb} MB"
```

```
# tests/test_memory.py
import pytest
import tracemalloc
from skills.text_processor import TextProcessorSkill
from claude_code_sdk import SkillContext

class TestMemory:
    """内存测试"""
    def test_memory_usage(self):
        """测试内存使用"""
        skill = TextProcessorSkill()
        context = SkillContext()
        # 开始内存跟踪
        tracemalloc.start()
        # 执行操作
        for i in range(100):
            skill.execute(
                {
                    "text": "hello world " * 100,
                    "operations": [{"type": "uppercase"}]
                },
                context
            )
        # 获取内存使用情况
        current, peak = tracemalloc.get_traced_memory()
        # 停止内存跟踪
        tracemalloc.stop()
        # 验证内存使用（峰值应该小于 10MB）
        peak_mb = peak / 1024 / 1024
        assert peak_mb < 10, f"Peak memory usage: {peak_mb} MB"
```

```
bash复制## 测试覆盖率
### 1. 生成覆盖率报告

```bash
# 运行测试并生成覆盖率报告
pytest --cov=src/skills --cov-report=html --cov-report=term

# 查看覆盖率报告
open htmlcov/index.html
```

### 2. 配置覆盖率

```ini
# .coveragerc
[run]
source = src/skills
omit =
    */tests/*
    */__pycache__/*
    */site-packages/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:

[html]
directory = htmlcov
```

## 调试工具
### 1. 使用 pytest-debug

```bash
# 安装 pytest-debug
pip install pytest-debug

# 在测试失败时进入调试器
pytest --pdb
```

### 2. 使用 pytest-pdb

```bash
# 安装 pytest-pdb
pip install pytest-pdb

# 在测试失败时自动进入 pdb
pytest --pdb
```

### 3. 使用 pytest-sugar

```bash
# 安装 pytest-sugar
pip install pytest-sugar

# 使用更友好的输出
pytest -v
```

## 最佳实践

### 1. 测试编写原则

#### 1.1 独立性
- 每个测试应该独立运行
- 不依赖其他测试的状态
- 使用 setup 和 teardown 方法

#### 1.2 可重复性
- 测试应该可以重复运行
- 不依赖外部状态
- 使用固定的测试数据

#### 1.3 快速性
- 测试应该快速执行
- 避免不必要的等待
- 使用 Mock 隔离外部依赖

#### 1.4 可读性
- 测试名称应该清晰
- 使用描述性的断言
- 添加必要的注释

### 2. 调试技巧

#### 2.1 分而治之
- 将复杂问题分解为小问题
- 逐个测试每个组件
- 使用单元测试隔离问题

#### 2.2 添加日志
- 在关键位置添加日志
- 记录输入和输出
- 使用不同的日志级别

#### 2.3 使用断点
- 在可疑位置设置断点
- 检查变量值
- 单步执行代码

#### 2.4 使用 Mock
- Mock 外部依赖
- 控制测试环境
- 简化测试场景

## 总结

测试和调试是开发高质量 Skills 的关键环节。通过合理的测试策略、有效的调试技巧和完善的工具支持，可以显著提高 Skills 的质量和可靠性。

在下一章中，我们将探讨 Skills 的实际应用，展示如何在不同场景中使用 Skills。
```

```
## 测试覆盖率
### 1. 生成覆盖率报告

```bash
# 运行测试并生成覆盖率报告
pytest --cov=src/skills --cov-report=html --cov-report=term

# 查看覆盖率报告
open htmlcov/index.html
```

### 2. 配置覆盖率

```ini
# .coveragerc
[run]
source = src/skills
omit =
    */tests/*
    */__pycache__/*
    */site-packages/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:

[html]
directory = htmlcov
```

## 调试工具
### 1. 使用 pytest-debug

```bash
# 安装 pytest-debug
pip install pytest-debug

# 在测试失败时进入调试器
pytest --pdb
```

### 2. 使用 pytest-pdb

```bash
# 安装 pytest-pdb
pip install pytest-pdb

# 在测试失败时自动进入 pdb
pytest --pdb
```

### 3. 使用 pytest-sugar

```bash
# 安装 pytest-sugar
pip install pytest-sugar

# 使用更友好的输出
pytest -v
```

## 最佳实践

### 1. 测试编写原则

#### 1.1 独立性
- 每个测试应该独立运行
- 不依赖其他测试的状态
- 使用 setup 和 teardown 方法

#### 1.2 可重复性
- 测试应该可以重复运行
- 不依赖外部状态
- 使用固定的测试数据

#### 1.3 快速性
- 测试应该快速执行
- 避免不必要的等待
- 使用 Mock 隔离外部依赖

#### 1.4 可读性
- 测试名称应该清晰
- 使用描述性的断言
- 添加必要的注释

### 2. 调试技巧

#### 2.1 分而治之
- 将复杂问题分解为小问题
- 逐个测试每个组件
- 使用单元测试隔离问题

#### 2.2 添加日志
- 在关键位置添加日志
- 记录输入和输出
- 使用不同的日志级别

#### 2.3 使用断点
- 在可疑位置设置断点
- 检查变量值
- 单步执行代码

#### 2.4 使用 Mock
- Mock 外部依赖
- 控制测试环境
- 简化测试场景

## 总结

测试和调试是开发高质量 Skills 的关键环节。通过合理的测试策略、有效的调试技巧和完善的工具支持，可以显著提高 Skills 的质量和可靠性。

在下一章中，我们将探讨 Skills 的实际应用，展示如何在不同场景中使用 Skills。
```

---

# 第 18 章

## 1 代码生成技能

**URL**: https://claudecode.tangshuang.net/course/18.1%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E8%83%BD

#### 代码生成技能概述#

代码生成技能是 Claude Code Skills 中最常用和最强大的类型之一。它可以根据需求自动生成各种类型的代码，显著提高开发效率。

#### 技能类型#

##### 1. 模板代码生成#

###### 1.1 项目模板生成

```
python复制# src/skills/project_template_generator.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class ProjectTemplateGeneratorSkill(Skill):
    """项目模板生成技能"""

    def __init__(self):
        super().__init__(
            name="project-template-generator",
            version="1.0.0",
            description="Generate project templates"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "project_type": {
                    "type": "string",
                    "enum": ["web-app", "cli-tool", "library", "microservice"],
                    "description": "Type of project to generate"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "framework": {
                    "type": "string",
```

```
# src/skills/project_template_generator.py
from typing import Dict, Any
from claude_code_sdk import Skill, SkillContext, SkillResult

class ProjectTemplateGeneratorSkill(Skill):
    """项目模板生成技能"""

    def __init__(self):
        super().__init__(
            name="project-template-generator",
            version="1.0.0",
            description="Generate project templates"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "project_type": {
                    "type": "string",
                    "enum": ["web-app", "cli-tool", "library", "microservice"],
                    "description": "Type of project to generate"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "framework": {
                    "type": "string",
```

```
bash复制                "description": "Framework to use"
            },
            "project_name": {
                "type": "string",
                "description": "Name of the project"
            },
            "output_dir": {
                "type": "string",
                "description": "Output directory"
            }
        },
        "required": ["project_type", "language", "project_name"]
    }

def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
    try:
        project_type = parameters["project_type"]
        language = parameters["language"]
        project_name = parameters["project_name"]
        framework = parameters.get("framework")
        output_dir = parameters.get("output_dir", ".")

        # 生成项目结构
        structure = self.generate_structure(
            project_type, language, framework, project_name
        )

        # 创建文件
        created_files = []
        for file_path, content in structure.items():
            full_path = context.join_path(output_dir, file_path)
            context.write_file(full_path, content)
            created_files.append(full_path)

        return SkillResult(
            success=True,
            data={
                "project_name": project_name,
                "project_type": project_type,
                "language": language,
                "framework": framework,
                "files_created": created_files,
                "structure": structure
            }
        )
    except Exception as e:
        return SkillResult(
            success=False,
            error=str(e)
        )

def generate_structure(self, project_type: str, language: str,
                      framework: str, project_name: str) -> Dict[str, str]:
    """生成项目结构"""
    generators = {
        "web-app": self.generate_web_app,
        "cli-tool": self.generate_cli_tool,
        "library": self.generate_library,
        "microservice": self.generate_microservice
    }

    generator = generators.get(project_type)
    if not generator:
        raise ValueError(f"Unsupported project type: {project_type}")

    return generator(language, framework, project_name)

def generate_web_app(self, language: str, framework: str,
                    project_name: str) -> Dict[str, str]:
    """生成 Web 应用项目"""
    structure = {}

    if language == "python":
        structure = self.generate_python_web_app(framework, project_name)
    elif language == "javascript":
        structure = self.generate_javascript_web_app(framework, project_name)

    return structure

def generate_python_web_app(self, framework: str,
                           project_name: str) -> Dict[str, str]:
    """生成 Python Web 应用"""
    structure = {
        f"{project_name}/": "",
        f"{project_name}/__init__.py": "",
        f"{project_name}/app.py": self.generate_flask_app(project_name),
        f"{project_name}/requirements.txt": self.generate_requirements(framework),
        f"{project_name}/config.py": self.generate_config(),
        f"{project_name}/templates/": "",
        f"{project_name}/templates/index.html": self.generate_html_template(),
        f"{project_name}/static/": "",
        f"{project_name}/static/css/": "",
        f"{project_name}/static/css/style.css": self.generate_css(),
        f"{project_name}/tests/": "",
        f"{project_name}/tests/__init__.py": "",
        f"{project_name}/tests/test_app.py": self.generate_test_file(),
        "README.md": self.generate_readme(project_name),
        ".gitignore": self.generate_gitignore()
    }

    return structure

def generate_flask_app(self, project_name: str) -> str:
    """生成 Flask 应用代码"""
    return f'''from flask import Flask, render_template, jsonify
```

```
"description": "Framework to use"
            },
            "project_name": {
                "type": "string",
                "description": "Name of the project"
            },
            "output_dir": {
                "type": "string",
                "description": "Output directory"
            }
        },
        "required": ["project_type", "language", "project_name"]
    }

def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
    try:
        project_type = parameters["project_type"]
        language = parameters["language"]
        project_name = parameters["project_name"]
        framework = parameters.get("framework")
        output_dir = parameters.get("output_dir", ".")

        # 生成项目结构
        structure = self.generate_structure(
            project_type, language, framework, project_name
        )

        # 创建文件
        created_files = []
        for file_path, content in structure.items():
            full_path = context.join_path(output_dir, file_path)
            context.write_file(full_path, content)
            created_files.append(full_path)

        return SkillResult(
            success=True,
            data={
                "project_name": project_name,
                "project_type": project_type,
                "language": language,
                "framework": framework,
                "files_created": created_files,
                "structure": structure
            }
        )
    except Exception as e:
        return SkillResult(
            success=False,
            error=str(e)
        )

def generate_structure(self, project_type: str, language: str,
                      framework: str, project_name: str) -> Dict[str, str]:
    """生成项目结构"""
    generators = {
        "web-app": self.generate_web_app,
        "cli-tool": self.generate_cli_tool,
        "library": self.generate_library,
        "microservice": self.generate_microservice
    }

    generator = generators.get(project_type)
    if not generator:
        raise ValueError(f"Unsupported project type: {project_type}")

    return generator(language, framework, project_name)

def generate_web_app(self, language: str, framework: str,
                    project_name: str) -> Dict[str, str]:
    """生成 Web 应用项目"""
    structure = {}

    if language == "python":
        structure = self.generate_python_web_app(framework, project_name)
    elif language == "javascript":
        structure = self.generate_javascript_web_app(framework, project_name)

    return structure

def generate_python_web_app(self, framework: str,
                           project_name: str) -> Dict[str, str]:
    """生成 Python Web 应用"""
    structure = {
        f"{project_name}/": "",
        f"{project_name}/__init__.py": "",
        f"{project_name}/app.py": self.generate_flask_app(project_name),
        f"{project_name}/requirements.txt": self.generate_requirements(framework),
        f"{project_name}/config.py": self.generate_config(),
        f"{project_name}/templates/": "",
        f"{project_name}/templates/index.html": self.generate_html_template(),
        f"{project_name}/static/": "",
        f"{project_name}/static/css/": "",
        f"{project_name}/static/css/style.css": self.generate_css(),
        f"{project_name}/tests/": "",
        f"{project_name}/tests/__init__.py": "",
        f"{project_name}/tests/test_app.py": self.generate_test_file(),
        "README.md": self.generate_readme(project_name),
        ".gitignore": self.generate_gitignore()
    }

    return structure

def generate_flask_app(self, project_name: str) -> str:
    """生成 Flask 应用代码"""
    return f'''from flask import Flask, render_template, jsonify
```

app = Flask(name)

@app.route('/')
def index():
"""Home page"""
return render_template('index.html')

@app.route('/api/health')
def health():
"""Health check endpoint"""
return jsonify({{"status": "healthy"}})

if name == 'main':
app.run(debug=True)
'''

```
bash复制def generate_requirements(self, framework: str) -> str:
    """生成 requirements.txt"""
    return f'''{framework}>=2.0.0
```

```
def generate_requirements(self, framework: str) -> str:
    """生成 requirements.txt"""
    return f'''{framework}>=2.0.0
```

pytest>=7.0.0
python-dotenv>=0.19.0
'''

```
bash复制def generate_config(self) -> str:
    """生成配置文件"""
    return '''import os
```

```
def generate_config(self) -> str:
    """生成配置文件"""
    return '''import os
```

class Config:
"""Application configuration"""
SECRET_KEY = os.getenv('SECRET_KEY', 'dev-secret-key')
DEBUG = os.getenv('DEBUG', 'True').lower() == 'true'
'''

```
bash复制def generate_html_template(self) -> str:
    """生成 HTML 模板"""
    return '''<!DOCTYPE html>
```

```
def generate_html_template(self) -> str:
    """生成 HTML 模板"""
    return '''<!DOCTYPE html>
```

```
bash复制def generate_css(self) -> str:
    """生成 CSS 文件"""
    return '''body {
font-family: Arial, sans-serif;
margin: 0;
padding: 0;
```

```
def generate_css(self) -> str:
    """生成 CSS 文件"""
    return '''body {
font-family: Arial, sans-serif;
margin: 0;
padding: 0;
```

.container {
max-width: 1200px;
margin: 0 auto;
padding: 20px;
}

h1 {
color: #333;
}
'''

```
bash复制def generate_test_file(self) -> str:
    """生成测试文件"""
    return '''import pytest
```

```
def generate_test_file(self) -> str:
    """生成测试文件"""
    return '''import pytest
```

from app import app

@pytest.fixture
def client():
app.config['TESTING'] = True
with app.test_client() as client:
yield client

def test_index(client):
"""Test index page"""
response = client.get('/')
assert response.status_code == 200

def test_health(client):
"""Test health endpoint"""
response = client.get('/api/health')
assert response.status_code == 200
assert response.json['status'] == 'healthy'
'''

```
bash复制def generate_readme(self, project_name: str) -> str:
    """生成 README"""
    return f'''# {project_name}
```

```
def generate_readme(self, project_name: str) -> str:
    """生成 README"""
    return f'''# {project_name}
```

A web application built with Flask.

#### Installation#

```
bash复制pip install -r requirements.txt
```

```
pip install -r requirements.txt
```

#### Running#

```
bash复制python app.py
```

```
python app.py
```

#### Testing#

```
bash复制pytest
```

```
pytest
```

```
bash复制def generate_gitignore(self) -> str:
    """生成 .gitignore"""
    return '''__pycache__/
```

```
def generate_gitignore(self) -> str:
    """生成 .gitignore"""
    return '''__pycache__/
```

*.py[cod]
*$py.class
.env
.venv/
venv/
'''

```
bash复制
### 2. API 端点生成

#### 2.1 REST API 生成

```python
# src/skills/api_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult

class APIGeneratorSkill(Skill):
    """API 端点生成技能"""

    def __init__(self):
        super().__init__(
            name="api-generator",
            version="1.0.0",
            description="Generate REST API endpoints from data models"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "models": {
                    "type": "array",
                    "description": "Data models to generate APIs for",
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "fields": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "name": {"type": "string"},
                                        "type": {"type": "string"},
                                        "required": {"type": "boolean"}
                                    }
                                }
                            }
                        }
                    }
                },
                "framework": {
                    "type": "string",
                    "enum": ["flask", "fastapi", "express"],
                    "description": "Framework to use"
                },
                "include_crud": {
                    "type": "boolean",
                    "description": "Include CRUD operations",
                    "default": True
                }
            },
            "required": ["models", "framework"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            models = parameters["models"]
            framework = parameters["framework"]
            include_crud = parameters.get("include_crud", True)

            # 生成 API 代码
            api_code = self.generate_api(models, framework, include_crud)

            return SkillResult(
                success=True,
                data={
                    "framework": framework,
                    "models": models,
                    "include_crud": include_crud,
                    "api_code": api_code
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def generate_api(self, models: List[Dict], framework: str,
                     include_crud: bool) -> str:
"""生成 API 代码"""
generators = {
"flask": self.generate_flask_api,
"fastapi": self.generate_fastapi_api,
"express": self.generate_express_api
}
generator = generators.get(framework)
if not generator:
raise ValueError(f"Unsupported framework: {framework}")
return generator(models, include_crud)

    def generate_flask_api(self, models: List[Dict], include_crud: bool) -> str:
"""生成 Flask API"""
imports = '''from flask import Flask, request, jsonify
from typing import Dict, Any
'''
app_code = '''
app = Flask(__name__)
# In-memory storage (replace with database in production)
storage = {}
'''
routes = []
for model in models:
model_name = model["name"]
model_name_lower = model_name.lower()
if include_crud:
# CREATE
routes.append(f'''@app.route('/api/{model_name_lower}', methods=['POST'])
def create_{model_name_lower}():
"""Create a new {model_name}"""
data = request.get_json()
{model_name_lower}_id = len(storage.get('{model_name_lower}', [])) + 1
data['id'] = {model_name_lower}_id
if '{model_name_lower}' not in storage:
storage['{model_name_lower}'] = []
storage['{model_name_lower}'].append(data)
return jsonify(data), 201
''')
# READ ALL
routes.append(f'''@app.route('/api/{model_name_lower}', methods=['GET'])
def get_{model_name_lower}s():
"""Get all {model_name}s"""
return jsonify(storage.get('{model_name_lower}', []))
''')
# READ ONE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['GET'])
def get_{model_name_lower}({model_name_lower}_id):
"""Get a specific {model_name}"""
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
return jsonify(item)
return jsonify({{"error": "{model_name} not found"}}), 404
''')
# UPDATE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['PUT'])
def update_{model_name_lower}({model_name_lower}_id):
"""Update a {model_name}"""
data = request.get_json()
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
item.update(data)
return jsonify(item)
return jsonify({{"error": "{model_name} not found"}}), 404
''')
# DELETE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['DELETE'])
def delete_{model_name_lower}({model_name_lower}_id):
"""Delete a {model_name}"""
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
items.remove(item)
return jsonify({{"message": "{model_name} deleted"}})
return jsonify({{"error": "{model_name} not found"}}), 404
''')
main_code = '''
if __name__ == '__main__':
app.run(debug=True)
'''
return imports + app_code + ''.join(routes) + main_code
```

```
### 2. API 端点生成

#### 2.1 REST API 生成

```python
# src/skills/api_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult

class APIGeneratorSkill(Skill):
    """API 端点生成技能"""

    def __init__(self):
        super().__init__(
            name="api-generator",
            version="1.0.0",
            description="Generate REST API endpoints from data models"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "models": {
                    "type": "array",
                    "description": "Data models to generate APIs for",
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "fields": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "name": {"type": "string"},
                                        "type": {"type": "string"},
                                        "required": {"type": "boolean"}
                                    }
                                }
                            }
                        }
                    }
                },
                "framework": {
                    "type": "string",
                    "enum": ["flask", "fastapi", "express"],
                    "description": "Framework to use"
                },
                "include_crud": {
                    "type": "boolean",
                    "description": "Include CRUD operations",
                    "default": True
                }
            },
            "required": ["models", "framework"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            models = parameters["models"]
            framework = parameters["framework"]
            include_crud = parameters.get("include_crud", True)

            # 生成 API 代码
            api_code = self.generate_api(models, framework, include_crud)

            return SkillResult(
                success=True,
                data={
                    "framework": framework,
                    "models": models,
                    "include_crud": include_crud,
                    "api_code": api_code
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def generate_api(self, models: List[Dict], framework: str,
                     include_crud: bool) -> str:
"""生成 API 代码"""
generators = {
"flask": self.generate_flask_api,
"fastapi": self.generate_fastapi_api,
"express": self.generate_express_api
}
generator = generators.get(framework)
if not generator:
raise ValueError(f"Unsupported framework: {framework}")
return generator(models, include_crud)

    def generate_flask_api(self, models: List[Dict], include_crud: bool) -> str:
"""生成 Flask API"""
imports = '''from flask import Flask, request, jsonify
from typing import Dict, Any
'''
app_code = '''
app = Flask(__name__)
# In-memory storage (replace with database in production)
storage = {}
'''
routes = []
for model in models:
model_name = model["name"]
model_name_lower = model_name.lower()
if include_crud:
# CREATE
routes.append(f'''@app.route('/api/{model_name_lower}', methods=['POST'])
def create_{model_name_lower}():
"""Create a new {model_name}"""
data = request.get_json()
{model_name_lower}_id = len(storage.get('{model_name_lower}', [])) + 1
data['id'] = {model_name_lower}_id
if '{model_name_lower}' not in storage:
storage['{model_name_lower}'] = []
storage['{model_name_lower}'].append(data)
return jsonify(data), 201
''')
# READ ALL
routes.append(f'''@app.route('/api/{model_name_lower}', methods=['GET'])
def get_{model_name_lower}s():
"""Get all {model_name}s"""
return jsonify(storage.get('{model_name_lower}', []))
''')
# READ ONE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['GET'])
def get_{model_name_lower}({model_name_lower}_id):
"""Get a specific {model_name}"""
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
return jsonify(item)
return jsonify({{"error": "{model_name} not found"}}), 404
''')
# UPDATE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['PUT'])
def update_{model_name_lower}({model_name_lower}_id):
"""Update a {model_name}"""
data = request.get_json()
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
item.update(data)
return jsonify(item)
return jsonify({{"error": "{model_name} not found"}}), 404
''')
# DELETE
routes.append(f'''@app.route('/api/{model_name_lower}/<int:{model_name_lower}_id>', methods=['DELETE'])
def delete_{model_name_lower}({model_name_lower}_id):
"""Delete a {model_name}"""
items = storage.get('{model_name_lower}', [])
item = next((i for i in items if i['id'] == {model_name_lower}_id), None)
if item:
items.remove(item)
return jsonify({{"message": "{model_name} deleted"}})
return jsonify({{"error": "{model_name} not found"}}), 404
''')
main_code = '''
if __name__ == '__main__':
app.run(debug=True)
'''
return imports + app_code + ''.join(routes) + main_code
```

##### 3. 数据模型生成#

###### 3.1 ORM 模型生成

```
python复制# src/skills/model_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult

class ModelGeneratorSkill(Skill):
    """数据模型生成技能"""

    def __init__(self):
        super().__init__(
            name="model-generator",
            version="1.0.0",
            description="Generate ORM models from schema definitions"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "schema": {
                    "type": "object",
                    "description": "Database schema definition"
                },
                "orm": {
                    "type": "string",
                    "enum": ["sqlalchemy", "django", "mongoose"],
                    "description": "ORM to use"
                }
            },
            "required": ["schema", "orm"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            schema = parameters["schema"]
            orm = parameters["orm"]

            # 生成模型代码
            model_code = self.generate_models(schema, orm)

            return SkillResult(
                success=True,
                data={
                    "orm": orm,
                    "schema": schema,
                    "model_code": model_code
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def generate_models(self, schema: Dict, orm: str) -> str:
        """生成模型代码"""
        generators = {
            "sqlalchemy": self.generate_sqlalchemy_models,
            "django": self.generate_django_models,
            "mongoose": self.generate_mongoose_models
        }

        generator = generators.get(orm)
        if not generator:
            raise ValueError(f"Unsupported ORM: {orm}")

        return generator(schema)

    def generate_sqlalchemy_models(self, schema: Dict) -> str:
        """生成 SQLAlchemy 模型"""
        code = '''from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

'''

        for table_name, table_def in schema.items():
            fields = table_def.get("fields", [])

            code += f'''class {self.to_camel_case(table_name)}(Base):
    """{table_name} model"""
    __tablename__ = '{table_name}'

    id = Column(Integer, primary_key=True)

'''

            for field in fields:
                field_name = field["name"]
                field_type = field["type"]
                field_required = field.get("required", False)

                column_type = self.get_sqlalchemy_type(field_type)
                nullable = not field_required

                code += f'    {field_name} = Column({column_type}, nullable={nullable})\n'

            code += '\n'

        return code

    def get_sqlalchemy_type(self, field_type: str) -> str:
        """获取 SQLAlchemy 类型"""
        type_mapping = {
            "string": "String(255)",
            "text": "String)",
            "integer": "Integer",
            "float": "Float",
            "boolean": "Boolean",
            "datetime": "DateTime",
            "date": "Date"
        }
        return type_mapping.get(field_type, "String(255)")

    def to_camel_case(self, snake_str: str) -> str:
        """转换为驼峰命名"""
        components = snake_str.split('_')
        return ''.join(x.title() for x in components)

## 使用示例

### 1. 生成 Web 应用

```python
# examples/generate_web_app.py
from skills.project_template_generator import ProjectTemplateGeneratorSkill
from claude_code_sdk import SkillContext
skill = ProjectTemplateGeneratorSkill()
context = SkillContext()
result = skill.execute(
{
"project_type": "web-app",
"language": "python",
"framework": "flask",
"project_name": "my-web-app",
"output_dir": "./projects"
},
context
)
print(f"Created {len(result.data['files_created'])} files")
for file_path in result.data['files_created']:
print(f"  - {file_path}")
```

```
# src/skills/model_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult

class ModelGeneratorSkill(Skill):
    """数据模型生成技能"""

    def __init__(self):
        super().__init__(
            name="model-generator",
            version="1.0.0",
            description="Generate ORM models from schema definitions"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "schema": {
                    "type": "object",
                    "description": "Database schema definition"
                },
                "orm": {
                    "type": "string",
                    "enum": ["sqlalchemy", "django", "mongoose"],
                    "description": "ORM to use"
                }
            },
            "required": ["schema", "orm"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            schema = parameters["schema"]
            orm = parameters["orm"]

            # 生成模型代码
            model_code = self.generate_models(schema, orm)

            return SkillResult(
                success=True,
                data={
                    "orm": orm,
                    "schema": schema,
                    "model_code": model_code
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def generate_models(self, schema: Dict, orm: str) -> str:
        """生成模型代码"""
        generators = {
            "sqlalchemy": self.generate_sqlalchemy_models,
            "django": self.generate_django_models,
            "mongoose": self.generate_mongoose_models
        }

        generator = generators.get(orm)
        if not generator:
            raise ValueError(f"Unsupported ORM: {orm}")

        return generator(schema)

    def generate_sqlalchemy_models(self, schema: Dict) -> str:
        """生成 SQLAlchemy 模型"""
        code = '''from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

'''

        for table_name, table_def in schema.items():
            fields = table_def.get("fields", [])

            code += f'''class {self.to_camel_case(table_name)}(Base):
    """{table_name} model"""
    __tablename__ = '{table_name}'

    id = Column(Integer, primary_key=True)

'''

            for field in fields:
                field_name = field["name"]
                field_type = field["type"]
                field_required = field.get("required", False)

                column_type = self.get_sqlalchemy_type(field_type)
                nullable = not field_required

                code += f'    {field_name} = Column({column_type}, nullable={nullable})\n'

            code += '\n'

        return code

    def get_sqlalchemy_type(self, field_type: str) -> str:
        """获取 SQLAlchemy 类型"""
        type_mapping = {
            "string": "String(255)",
            "text": "String)",
            "integer": "Integer",
            "float": "Float",
            "boolean": "Boolean",
            "datetime": "DateTime",
            "date": "Date"
        }
        return type_mapping.get(field_type, "String(255)")

    def to_camel_case(self, snake_str: str) -> str:
        """转换为驼峰命名"""
        components = snake_str.split('_')
        return ''.join(x.title() for x in components)

## 使用示例

### 1. 生成 Web 应用

```python
# examples/generate_web_app.py
from skills.project_template_generator import ProjectTemplateGeneratorSkill
from claude_code_sdk import SkillContext
skill = ProjectTemplateGeneratorSkill()
context = SkillContext()
result = skill.execute(
{
"project_type": "web-app",
"language": "python",
"framework": "flask",
"project_name": "my-web-app",
"output_dir": "./projects"
},
context
)
print(f"Created {len(result.data['files_created'])} files")
for file_path in result.data['files_created']:
print(f"  - {file_path}")
```

##### 2. 生成 API 端点#

```
python复制# examples/generate_api.py
from skills.api_generator import APIGeneratorSkill
from claude_code_sdk import SkillContext

skill = APIGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "models": [
            {
                "name": "User",
                "fields": [
                    {"name": "username", "type": "string", "required": True},
                    {"name": "email", "type": "string", "required": True},
                    {"name": "age", "type": "integer", "required": False}
                ]
            },
            {
                "name": "Product",
                "fields": [
                    {"name": "name", "type": "string", "required": True},
                    {"name": "price", "type": "float", "required": True},
                    {"name": "description", "type": "text", "required": False}
                ]
            }
        ],
        "framework": "flask",
        "include_crud": True
    },
    context
)

print(result.data["api_code"])
```

```
# examples/generate_api.py
from skills.api_generator import APIGeneratorSkill
from claude_code_sdk import SkillContext

skill = APIGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "models": [
            {
                "name": "User",
                "fields": [
                    {"name": "username", "type": "string", "required": True},
                    {"name": "email", "type": "string", "required": True},
                    {"name": "age", "type": "integer", "required": False}
                ]
            },
            {
                "name": "Product",
                "fields": [
                    {"name": "name", "type": "string", "required": True},
                    {"name": "price", "type": "float", "required": True},
                    {"name": "description", "type": "text", "required": False}
                ]
            }
        ],
        "framework": "flask",
        "include_crud": True
    },
    context
)

print(result.data["api_code"])
```

##### 3. 生成数据模型#

```
python复制# examples/generate_models.py
from skills.model_generator import ModelGeneratorSkill
from claude_code_sdk import SkillContext

skill = ModelGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "schema": {
            "users": {
                "fields": [
                    {"name": "username", "type": "string", "required": True},
                    {"name": "email", "type": "string", "required": True},
                    {"name": "created_at", "type": "datetime", "required": True}
                ]
            },
            "products": {
                "fields": [
                    {"name": "name", "type": "string", "required": True},
                    {"name": "price", "type": "float", "required": True},
                    {"name": "stock", "type": "integer", "required": False}
                ]
            }
        },
        "orm": "sqlalchemy"
    },
    context
)

print(result.data["model_code"])
```

```
# examples/generate_models.py
from skills.model_generator import ModelGeneratorSkill
from claude_code_sdk import SkillContext

skill = ModelGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "schema": {
            "users": {
                "fields": [
                    {"name": "username", "type": "string", "required": True},
                    {"name": "email", "type": "string", "required": True},
                    {"name": "created_at", "type": "datetime", "required": True}
                ]
            },
            "products": {
                "fields": [
                    {"name": "name", "type": "string", "required": True},
                    {"name": "price", "type": "float", "required": True},
                    {"name": "stock", "type": "integer", "required": False}
                ]
            }
        },
        "orm": "sqlalchemy"
    },
    context
)

print(result.data["model_code"])
```

#### 最佳实践#

##### 1. 模板设计#

###### 模板设计原则

###### 1. 可配置性

- 使用参数化模板
- 提供多种选项
- 支持自定义

###### 2. 可扩展性

- 模块化设计
- 易于添加新功能
- 支持插件机制

###### 3. 最佳实践

- 遵循框架规范
- 包含安全措施
- 添加文档注释

##### 2. 代码生成策略#

###### 1. 增量生成

- 只生成必要的文件
- 避免覆盖现有代码
- 提供合并选项

###### 2. 代码质量

- 遵循编码规范
- 包含类型注解
- 添加文档字符串

###### 3. 可维护性

- 生成清晰的代码
- 添加注释说明
- 提供修改指南

---

## 2 代码审查技能

**URL**: https://claudecode.tangshuang.net/course/18.2%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%8A%80%E8%83%BD

#### 代码审查技能概述#

代码审查技能是 Claude Code Skills 中用于自动化代码审查的重要工具。它可以帮助开发者快速识别代码中的问题，提高代码质量和可维护性。

#### 审查类型#

##### 1. 静态代码分析#

###### 1.1 代码质量检查

```
python复制# src/skills/code_reviewer.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class CodeReviewerSkill(Skill):
    """代码审查技能"""

    def __init__(self):
        super().__init__(
            name="code-reviewer",
            version="1.0.0",
            description="Automated code review skill"
        )

        # 定义审查规则
        self.rules = {
            "naming": self.check_naming_conventions,
            "complexity": self.check_complexity,
            "security": self.check_security,
            "performance": self.check_performance,
            "documentation": self.check_documentation
        }

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to review"
                },
                "code": {
                    "type": "string",
                    "description": "Code to review (alternative to file_path)"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "rules": {
                    "type": "array",
                    "description": "Rules to apply",
                    "items": {
                        "type": "string",
                        "enum": ["naming", "complexity", "security", "performance", "documentation"]
                    }
                },
                "severity": {
                    "type": "string",
                    "enum": ["all", "error", "warning", "info"],
                    "description": "Minimum severity level"
                }
            },
            "required": ["language"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            language = parameters["language"]
            rules_to_apply = parameters.get("rules", list(self.rules.keys()))
            severity = parameters.get("severity", "all")

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
```

```
# src/skills/code_reviewer.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class CodeReviewerSkill(Skill):
    """代码审查技能"""

    def __init__(self):
        super().__init__(
            name="code-reviewer",
            version="1.0.0",
            description="Automated code review skill"
        )

        # 定义审查规则
        self.rules = {
            "naming": self.check_naming_conventions,
            "complexity": self.check_complexity,
            "security": self.check_security,
            "performance": self.check_performance,
            "documentation": self.check_documentation
        }

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to review"
                },
                "code": {
                    "type": "string",
                    "description": "Code to review (alternative to file_path)"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "rules": {
                    "type": "array",
                    "description": "Rules to apply",
                    "items": {
                        "type": "string",
                        "enum": ["naming", "complexity", "security", "performance", "documentation"]
                    }
                },
                "severity": {
                    "type": "string",
                    "enum": ["all", "error", "warning", "info"],
                    "description": "Minimum severity level"
                }
            },
            "required": ["language"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            language = parameters["language"]
            rules_to_apply = parameters.get("rules", list(self.rules.keys()))
            severity = parameters.get("severity", "all")

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
```

```
bash复制                success=False,
                error="Either file_path or code must be provided"
            )

        # 执行审查
        issues = []
        for rule_name in rules_to_apply:
            if rule_name in self.rules:
                rule_func = self.rules[rule_name]
                rule_issues = rule_func(code, language)
                issues.extend(rule_issues)

        # 过滤严重性
        if severity != "all":
            severity_levels = {"error": 3, "warning": 2, "info": 1}
            min_level = severity_levels.get(severity, 0)
            issues = [
                issue for issue in issues
                if severity_levels.get(issue["severity"], 0) >= min_level
            ]

        # 生成报告
        report = self.generate_report(code, issues, file_path)

        return SkillResult(
            success=True,
            data={
                "file_path": file_path,
                "language": language,
                "rules_applied": rules_to_apply,
                "issues": issues,
                "issue_count": len(issues),
                "report": report
            }
        )
    except Exception as e:
        return SkillResult(
            success=False,
            error=str(e)
        )

def check_naming_conventions(self, code: str, language: str) -> List[Dict]:
    """检查命名规范"""
    issues = []

    if language == "python":
        # 检查函数名（应该是 snake_case）
        func_pattern = r'def\s+([A-Z][a-zA-Z0-9_]*)\s*\('
        for match in re.finditer(func_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "warning",
                "line": line_num,
                "message": f"Function name '{match.group(1)}' should use snake_case",
                "suggestion": match.group(1).lower()
            })

        # 检查类名（应该是 CamelCase）
        class_pattern = r'class\s+([a-z][a-zA-Z0-9_]*)\s*[:\(]'
        for match in re.finditer(class_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "warning",
                "line": line_num,
                "message": f"Class name '{match.group(1)}' should use CamelCase",
                "suggestion": match.group(1).title()
            })

    elif language == "javascript":
        # 检查常量（应该是 UPPER_CASE）
        const_pattern = r'const\s+([a-z][a-zA-Z0-9_]*)\s*='
        for match in re.finditer(const_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "info",
                "line": line_num,
                "message": f"Constant '{match.group(1)}' should use UPPER_CASE",
                "suggestion": match.group(1).upper()
            })

    return issues

def check_complexity(self, code: str, language: str) -> List[Dict]:
    """检查复杂度"""
    issues = []
    lines = code.split('\n')

    for i, line in enumerate(lines, 1):
        # 计算缩进级别
        indent = len(line) - len(line.lstrip())

        # 检查过深的嵌套
        if indent > 24:
            issues.append({
                "type": "complexity",
                "severity": "warning",
                "line": i,
                "message": f"Deep nesting detected (indent level: {indent // 4})",
                "suggestion": "Consider refactoring to reduce nesting"
            })

        # 检查长行
        if len(line) > 120:
            issues.append({
                "type": "complexity",
                "severity": "info",
                "line": i,
                "message": f"Line too long ({len(line)} characters)",
                "suggestion": "Break the line into multiple lines"
            })

    return issues
```

```
success=False,
                error="Either file_path or code must be provided"
            )

        # 执行审查
        issues = []
        for rule_name in rules_to_apply:
            if rule_name in self.rules:
                rule_func = self.rules[rule_name]
                rule_issues = rule_func(code, language)
                issues.extend(rule_issues)

        # 过滤严重性
        if severity != "all":
            severity_levels = {"error": 3, "warning": 2, "info": 1}
            min_level = severity_levels.get(severity, 0)
            issues = [
                issue for issue in issues
                if severity_levels.get(issue["severity"], 0) >= min_level
            ]

        # 生成报告
        report = self.generate_report(code, issues, file_path)

        return SkillResult(
            success=True,
            data={
                "file_path": file_path,
                "language": language,
                "rules_applied": rules_to_apply,
                "issues": issues,
                "issue_count": len(issues),
                "report": report
            }
        )
    except Exception as e:
        return SkillResult(
            success=False,
            error=str(e)
        )

def check_naming_conventions(self, code: str, language: str) -> List[Dict]:
    """检查命名规范"""
    issues = []

    if language == "python":
        # 检查函数名（应该是 snake_case）
        func_pattern = r'def\s+([A-Z][a-zA-Z0-9_]*)\s*\('
        for match in re.finditer(func_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "warning",
                "line": line_num,
                "message": f"Function name '{match.group(1)}' should use snake_case",
                "suggestion": match.group(1).lower()
            })

        # 检查类名（应该是 CamelCase）
        class_pattern = r'class\s+([a-z][a-zA-Z0-9_]*)\s*[:\(]'
        for match in re.finditer(class_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "warning",
                "line": line_num,
                "message": f"Class name '{match.group(1)}' should use CamelCase",
                "suggestion": match.group(1).title()
            })

    elif language == "javascript":
        # 检查常量（应该是 UPPER_CASE）
        const_pattern = r'const\s+([a-z][a-zA-Z0-9_]*)\s*='
        for match in re.finditer(const_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "naming",
                "severity": "info",
                "line": line_num,
                "message": f"Constant '{match.group(1)}' should use UPPER_CASE",
                "suggestion": match.group(1).upper()
            })

    return issues

def check_complexity(self, code: str, language: str) -> List[Dict]:
    """检查复杂度"""
    issues = []
    lines = code.split('\n')

    for i, line in enumerate(lines, 1):
        # 计算缩进级别
        indent = len(line) - len(line.lstrip())

        # 检查过深的嵌套
        if indent > 24:
            issues.append({
                "type": "complexity",
                "severity": "warning",
                "line": i,
                "message": f"Deep nesting detected (indent level: {indent // 4})",
                "suggestion": "Consider refactoring to reduce nesting"
            })

        # 检查长行
        if len(line) > 120:
            issues.append({
                "type": "complexity",
                "severity": "info",
                "line": i,
                "message": f"Line too long ({len(line)} characters)",
                "suggestion": "Break the line into multiple lines"
            })

    return issues
```

```
python复制def check_security(self, code: str, language: str) -> List[Dict]:
    """检查安全问题"""
    issues = []

    if language == "python":
        # 检查 eval 使用
        eval_pattern = r'\beval\s*\('
        for match in re.finditer(eval_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "error",
                "line": line_num,
                "message": "Use of eval() is dangerous",
                "suggestion": "Use ast.literal_eval() or alternative safe methods"
            })

        # 检查 exec 使用
        exec_pattern = r'\bexec\s*\('
        for match in re.finditer(exec_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "error",
                "line": line_num,
                "message": "Use of exec() is dangerous",
                "suggestion": "Avoid using exec() for security reasons"
            })

        # 检查硬编码密码
        password_pattern = r'(password|passwd|pwd)\s*=\s*["\'][^"\']+["\']'
        for match in re.finditer(password_pattern, code, re.IGNORECASE):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "warning",
                "line": line_num,
                "message": "Hardcoded password detected",
                "suggestion": "Use environment variables or configuration files"
            })

    elif language == "javascript":
        # 检查 innerHTML 使用
        innerhtml_pattern = r'\.innerHTML\s*='
        for match in re.finditer(innerhtml_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "warning",
                "line": line_num,
                "message": "Use of innerHTML can lead to XSS vulnerabilities",
                "suggestion": "Use textContent or sanitize input"
            })

    return issues

def check_performance(self, code: str, language: str) -> List[Dict]:
    """检查性能问题"""
    issues = []

    if language == "python":
        # 检查循环中的字符串拼接
        lines = code.split('\n')
        in_loop = False
        loop_indent = 0

        for i, line in enumerate(lines, 1):
            # 检测循环
            if re.match(r'\s*(for|while)\s+', line):
                in_loop = True
                loop_indent = len(line) - len(line.lstrip())
            elif in_loop and len(line) - len(line.lstrip()) <= loop_indent:
                in_loop = False

            # 检查字符串拼接
            if in_loop and '+=' in line and '"' in line and "'" in line:
                issues.append({
                    "type": "performance",
                    "severity": "warning",
                    "line": i,
                    "message": "String concatenation in loop may be inefficient",
                    "suggestion": "Use list and join() for better performance"
                })

    return issues

def check_documentation(self, code: str, language: str) -> List[Dict]:
    """检查文档"""
    issues = []

    if language == "python":
        # 检查函数是否有文档字符串
        func_pattern = r'def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, code):
            func_name = match.group(1)
            func_start = match.end()
```

```
def check_security(self, code: str, language: str) -> List[Dict]:
    """检查安全问题"""
    issues = []

    if language == "python":
        # 检查 eval 使用
        eval_pattern = r'\beval\s*\('
        for match in re.finditer(eval_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "error",
                "line": line_num,
                "message": "Use of eval() is dangerous",
                "suggestion": "Use ast.literal_eval() or alternative safe methods"
            })

        # 检查 exec 使用
        exec_pattern = r'\bexec\s*\('
        for match in re.finditer(exec_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "error",
                "line": line_num,
                "message": "Use of exec() is dangerous",
                "suggestion": "Avoid using exec() for security reasons"
            })

        # 检查硬编码密码
        password_pattern = r'(password|passwd|pwd)\s*=\s*["\'][^"\']+["\']'
        for match in re.finditer(password_pattern, code, re.IGNORECASE):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "warning",
                "line": line_num,
                "message": "Hardcoded password detected",
                "suggestion": "Use environment variables or configuration files"
            })

    elif language == "javascript":
        # 检查 innerHTML 使用
        innerhtml_pattern = r'\.innerHTML\s*='
        for match in re.finditer(innerhtml_pattern, code):
            line_num = code[:match.start()].count('\n') + 1
            issues.append({
                "type": "security",
                "severity": "warning",
                "line": line_num,
                "message": "Use of innerHTML can lead to XSS vulnerabilities",
                "suggestion": "Use textContent or sanitize input"
            })

    return issues

def check_performance(self, code: str, language: str) -> List[Dict]:
    """检查性能问题"""
    issues = []

    if language == "python":
        # 检查循环中的字符串拼接
        lines = code.split('\n')
        in_loop = False
        loop_indent = 0

        for i, line in enumerate(lines, 1):
            # 检测循环
            if re.match(r'\s*(for|while)\s+', line):
                in_loop = True
                loop_indent = len(line) - len(line.lstrip())
            elif in_loop and len(line) - len(line.lstrip()) <= loop_indent:
                in_loop = False

            # 检查字符串拼接
            if in_loop and '+=' in line and '"' in line and "'" in line:
                issues.append({
                    "type": "performance",
                    "severity": "warning",
                    "line": i,
                    "message": "String concatenation in loop may be inefficient",
                    "suggestion": "Use list and join() for better performance"
                })

    return issues

def check_documentation(self, code: str, language: str) -> List[Dict]:
    """检查文档"""
    issues = []

    if language == "python":
        # 检查函数是否有文档字符串
        func_pattern = r'def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, code):
            func_name = match.group(1)
            func_start = match.end()
```

### 检查下一行是否有文档字符串

remaining_code = code[func_start:func_start + 100]
if not re.search(r'\s*"""', remaining_code):
line_num = code[:match.start()].count('\n') + 1
issues.append({
"type": "documentation",
"severity": "info",
"line": line_num,
"message": f"Function '{func_name}' lacks docstring",
"suggestion": "Add a docstring to describe the function"
})

return issues

def generate_report(self, code: str, issues: List[Dict], file_path: str) -> str:
"""生成审查报告"""
report = f"# Code Review Report for {file_path}\n\n"

### 统计

error_count = sum(1 for i in issues if i["severity"] == "error")
warning_count = sum(1 for i in issues if i["severity"] == "warning")
info_count = sum(1 for i in issues if i["severity"] == "info")

report += f"## Summary\n\n"
report += f"- Total Issues: {len(issues)}\n"
report += f"- Errors: {error_count}\n"
report += f"- Warnings: {warning_count}\n"
report += f"- Info: {info_count}\n\n"

### 按类型分组

issues_by_type = {}
for issue in issues:
issue_type = issue["type"]
if issue_type not in issues_by_type:
issues_by_type[issue_type] = []
issues_by_type[issue_type].append(issue)

### 详细问题

for issue_type, type_issues in issues_by_type.items():
report += f"## {issue_type.title()} Issues ({len(type_issues)})\n\n"

for issue in type_issues:
severity_icon = {
"error": "❌",
"warning": "⚠️",
"info": "ℹ️"
}.get(issue["severity"], "•")

report += f"{severity_icon} Line {issue['line']}: {issue['message']}\n"
if "suggestion" in issue:
report += f"   💡 Suggestion: {issue['suggestion']}\n"
report += "\n"

return report

##### 2. 代码风格检查#

###### 2.1 PEP 8 检查

```
bash复制python

# src/skills/pep8_checker.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class PEP8CheckerSkill(Skill):
    """PEP 8 代码风格检查技能"""

    def __init__(self):
        super().__init__(
            name="pep8-checker",
            version="1.0.0",
            description="PEP 8 style checker"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to check"
                },
                "code": {
                    "type": "string",
                    "description": "Code to check"
                },
                "max_line_length": {
                    "type": "integer",
                    "description": "Maximum line length",
                    "default": 79
                }
            }
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            max_line_length = parameters.get("max_line_length", 79)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 执行检查
            violations = self.check_pep8(code, max_line_length)

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "max_line_length": max_line_length,
                    "violations": violations,
                    "violation_count": len(violations)
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def check_pep8(self, code: str, max_line_length: int) -> List[Dict]:
        """检查 PEP 8 规范"""
        violations = []
        lines = code.split('\n')

        for i, line in enumerate(lines, 1):
            # 检查行长度
            if len(line) > max_line_length:
                violations.append({
                    "line": i,
                    "code": "E501",
                    "message": f"Line too long ({len(line)} > {max_line_length} characters)",
                    "severity": "warning"
                })

            # 检查尾随空格
            if line.rstrip() != line.rstrip('\n').rstrip('\r'):
                violations.append({
                    "line": i,
                    "code": "W291",
                    "message": "Trailing whitespace",
                    "severity": "warning"
                })

            # 检查空行
            if line.strip() == "" and i < len(lines):
                # 检查连续空行
                if i > 1 and lines[i-2].strip() == "" and lines[i-1].strip() == "":
                    violations.append({
                        "line": i,
                        "code": "E303",
                        "message": "Too many blank lines",
                        "severity": "info"
                    })

            # 检查导入顺序
            if line.strip().startswith("import ") or line.strip().startswith("from "):
                if i > 1 and lines[i-2].strip() and not (
                    lines[i-2].strip().startswith("import ") or
                    lines[i-2].strip().startswith("from ")
                ):
                    violations.append({
                        "line": i,
                        "code": "E402",
                        "message": "Module level import not at top of file",
                        "severity": "error"
                    })

        return violations

### 3. 代码重复检测

#### 3.1 重复代码检查

```python
# src/skills/duplicate_detector.py
from typing import Dict, Any, List, Tuple
from claude_code_sdk import Skill, SkillContext, SkillResult
import difflib


class DuplicateDetectorSkill(Skill):
    """重复代码检测技能"""

    def __init__(self):
        super().__init__(
            name="duplicate-detector",
            version="1.0.0",
            description="Detect duplicate code blocks"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to check"
                },
                "code": {
                    "type": "string",
                    "description": "Code to check"
                },
                "min_lines": {
                    "type": "integer",
                    "description": "Minimum number of lines to consider as duplicate",
                    "default": 5
                },
                "similarity_threshold": {
                    "type": "number",
                    "description": "Similarity threshold (0.0 to 1.0)",
                    "default": 0.8
                }
            }
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
min_lines = parameters.get("min_lines", 5)
similarity_threshold = parameters.get("similarity_threshold", 0.8)

            # 获取代码
if "file_path" in parameters:
code = context.read_file(parameters["file_path"])
file_path = parameters["file_path"]
elif "code" in parameters:
code = parameters["code"]
file_path = "<inline>"
else:
return SkillResult(
success=False,
error="Either file_path or code must be provided"
        )

            # 检测重复
duplicates = self.detect_duplicates(code, min_lines, similarity_threshold)
return SkillResult(
success=True,
data={
"file_path": file_path,
"min_lines": min_lines,
"similarity_threshold": similarity_threshold,
"duplicates": duplicates,
"duplicate_count": len(duplicates)
        }
    )
except Exception as e:
return SkillResult(
success=False,
error=str(e)
    )

    def detect_duplicates(self, code: str, min_lines: int,
                     similarity_threshold: float) -> List[Dict]:
        """检测重复代码块"""
        lines = code.split('\n')
        duplicates = []

        # 提取代码块
blocks = self.extract_blocks(lines, min_lines)
# 比较所有块对
for i, block1 in enumerate(blocks):
for j, block2 in enumerate(blocks):
if i >= j:
continue
similarity = self.calculate_similarity(block1["code"], block2["code"])
if similarity >= similarity_threshold:
            duplicates.append({
"block1": {
"start_line": block1["start_line"],
"end_line": block1["end_line"],
"code": block1["code"]
},
"block2": {
"start_line": block2["start_line"],
"end_line": block2["end_line"],
"code": block2["code"]
},
"similarity": similarity,
"suggestion": "Consider extracting common code into a function"
        })

        return duplicates

    def extract_blocks(self, lines: List[str], min_lines: int) -> List[Dict]:
"""提取代码块"""
blocks = []
for i in range(len(lines) - min_lines + 1):
block_code = '\n'.join(lines[i:i+min_lines])
blocks.append({
"start_line": i + 1,
"end_line": i + min_lines,
"code": block_code
})
return blocks
def calculate_similarity(self, code1: str, code2: str) -> float:
"""计算代码相似度"""
# 使用序列匹配器
matcher = difflib.SequenceMatcher(None, code1, code2)
return matcher.ratio()
```

```
python

# src/skills/pep8_checker.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class PEP8CheckerSkill(Skill):
    """PEP 8 代码风格检查技能"""

    def __init__(self):
        super().__init__(
            name="pep8-checker",
            version="1.0.0",
            description="PEP 8 style checker"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to check"
                },
                "code": {
                    "type": "string",
                    "description": "Code to check"
                },
                "max_line_length": {
                    "type": "integer",
                    "description": "Maximum line length",
                    "default": 79
                }
            }
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            max_line_length = parameters.get("max_line_length", 79)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 执行检查
            violations = self.check_pep8(code, max_line_length)

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "max_line_length": max_line_length,
                    "violations": violations,
                    "violation_count": len(violations)
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def check_pep8(self, code: str, max_line_length: int) -> List[Dict]:
        """检查 PEP 8 规范"""
        violations = []
        lines = code.split('\n')

        for i, line in enumerate(lines, 1):
            # 检查行长度
            if len(line) > max_line_length:
                violations.append({
                    "line": i,
                    "code": "E501",
                    "message": f"Line too long ({len(line)} > {max_line_length} characters)",
                    "severity": "warning"
                })

            # 检查尾随空格
            if line.rstrip() != line.rstrip('\n').rstrip('\r'):
                violations.append({
                    "line": i,
                    "code": "W291",
                    "message": "Trailing whitespace",
                    "severity": "warning"
                })

            # 检查空行
            if line.strip() == "" and i < len(lines):
                # 检查连续空行
                if i > 1 and lines[i-2].strip() == "" and lines[i-1].strip() == "":
                    violations.append({
                        "line": i,
                        "code": "E303",
                        "message": "Too many blank lines",
                        "severity": "info"
                    })

            # 检查导入顺序
            if line.strip().startswith("import ") or line.strip().startswith("from "):
                if i > 1 and lines[i-2].strip() and not (
                    lines[i-2].strip().startswith("import ") or
                    lines[i-2].strip().startswith("from ")
                ):
                    violations.append({
                        "line": i,
                        "code": "E402",
                        "message": "Module level import not at top of file",
                        "severity": "error"
                    })

        return violations

### 3. 代码重复检测

#### 3.1 重复代码检查

```python
# src/skills/duplicate_detector.py
from typing import Dict, Any, List, Tuple
from claude_code_sdk import Skill, SkillContext, SkillResult
import difflib


class DuplicateDetectorSkill(Skill):
    """重复代码检测技能"""

    def __init__(self):
        super().__init__(
            name="duplicate-detector",
            version="1.0.0",
            description="Detect duplicate code blocks"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the file to check"
                },
                "code": {
                    "type": "string",
                    "description": "Code to check"
                },
                "min_lines": {
                    "type": "integer",
                    "description": "Minimum number of lines to consider as duplicate",
                    "default": 5
                },
                "similarity_threshold": {
                    "type": "number",
                    "description": "Similarity threshold (0.0 to 1.0)",
                    "default": 0.8
                }
            }
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
try:
min_lines = parameters.get("min_lines", 5)
similarity_threshold = parameters.get("similarity_threshold", 0.8)

            # 获取代码
if "file_path" in parameters:
code = context.read_file(parameters["file_path"])
file_path = parameters["file_path"]
elif "code" in parameters:
code = parameters["code"]
file_path = "<inline>"
else:
return SkillResult(
success=False,
error="Either file_path or code must be provided"
        )

            # 检测重复
duplicates = self.detect_duplicates(code, min_lines, similarity_threshold)
return SkillResult(
success=True,
data={
"file_path": file_path,
"min_lines": min_lines,
"similarity_threshold": similarity_threshold,
"duplicates": duplicates,
"duplicate_count": len(duplicates)
        }
    )
except Exception as e:
return SkillResult(
success=False,
error=str(e)
    )

    def detect_duplicates(self, code: str, min_lines: int,
                     similarity_threshold: float) -> List[Dict]:
        """检测重复代码块"""
        lines = code.split('\n')
        duplicates = []

        # 提取代码块
blocks = self.extract_blocks(lines, min_lines)
# 比较所有块对
for i, block1 in enumerate(blocks):
for j, block2 in enumerate(blocks):
if i >= j:
continue
similarity = self.calculate_similarity(block1["code"], block2["code"])
if similarity >= similarity_threshold:
            duplicates.append({
"block1": {
"start_line": block1["start_line"],
"end_line": block1["end_line"],
"code": block1["code"]
},
"block2": {
"start_line": block2["start_line"],
"end_line": block2["end_line"],
"code": block2["code"]
},
"similarity": similarity,
"suggestion": "Consider extracting common code into a function"
        })

        return duplicates

    def extract_blocks(self, lines: List[str], min_lines: int) -> List[Dict]:
"""提取代码块"""
blocks = []
for i in range(len(lines) - min_lines + 1):
block_code = '\n'.join(lines[i:i+min_lines])
blocks.append({
"start_line": i + 1,
"end_line": i + min_lines,
"code": block_code
})
return blocks
def calculate_similarity(self, code1: str, code2: str) -> float:
"""计算代码相似度"""
# 使用序列匹配器
matcher = difflib.SequenceMatcher(None, code1, code2)
return matcher.ratio()
```

#### 使用示例#

##### 1. 完整代码审查#

```
bash复制python

# examples/code_review.py
from skills.code_reviewer import CodeReviewerSkill
from claude_code_sdk import SkillContext

skill = CodeReviewerSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/main.py",
        "language": "python",
        "rules": ["naming", "complexity", "security", "performance", "documentation"],
        "severity": "all"
    },
    context
)

print(f"Found {result.data['issue_count']} issues")
print(result.data["report"])
```

```
python

# examples/code_review.py
from skills.code_reviewer import CodeReviewerSkill
from claude_code_sdk import SkillContext

skill = CodeReviewerSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/main.py",
        "language": "python",
        "rules": ["naming", "complexity", "security", "performance", "documentation"],
        "severity": "all"
    },
    context
)

print(f"Found {result.data['issue_count']} issues")
print(result.data["report"])
```

##### 2. PEP 8 检查#

```
python复制# examples/pep8_check.py
from skills.pep8_checker import PEP8CheckerSkill
from claude_code_sdk import SkillContext

skill = PEP8CheckerSkill()
context = SkillContext()

result = skill.execute(
    {
"file_path": "src/main.py",
"max_line_length": 79
},
context
)
print(f"Found {result.data['violation_count']} PEP 8 violations")
for violation in result.data["violations"]:
print(f"Line {violation['line']}: {violation['message']}")
```

```
# examples/pep8_check.py
from skills.pep8_checker import PEP8CheckerSkill
from claude_code_sdk import SkillContext

skill = PEP8CheckerSkill()
context = SkillContext()

result = skill.execute(
    {
"file_path": "src/main.py",
"max_line_length": 79
},
context
)
print(f"Found {result.data['violation_count']} PEP 8 violations")
for violation in result.data["violations"]:
print(f"Line {violation['line']}: {violation['message']}")
```

##### 3. 重复代码检测#

```
bash复制python

# examples/duplicate_detection.py
from skills.duplicate_detector import DuplicateDetectorSkill
from claude_code_sdk import SkillContext

skill = DuplicateDetectorSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/main.py",
        "min_lines": 5,
        "similarity_threshold": 0.8
    },
    context
)

print(f"Found {result.data['duplicate_count']} duplicate blocks")
for duplicate in result.data["duplicates"]:
    print(f"Lines {duplicate['block1']['start_line']}-{duplicate['block1']['end_line']} "
          f"similar to lines {duplicate['block2']['start_line']}-{duplicate['block2']['end_line']} "
          f"(similarity: {duplicate['similarity']:.2f})")

## 最佳实践

### 1. 审查规则配置

#### 1. 规则优先级
- 安全规则：最高优先级
- 性能规则：高优先级
- 代码质量：中优先级
- 代码风格：低优先级
### 2. 规则定制
- 根据项目需求定制规则
- 考虑团队编码规范
- 逐步引入新规则
### 3. 规则例外
- 提供规则例外机制
- 记录例外原因
- 定期审查例外
```

```
python

# examples/duplicate_detection.py
from skills.duplicate_detector import DuplicateDetectorSkill
from claude_code_sdk import SkillContext

skill = DuplicateDetectorSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/main.py",
        "min_lines": 5,
        "similarity_threshold": 0.8
    },
    context
)

print(f"Found {result.data['duplicate_count']} duplicate blocks")
for duplicate in result.data["duplicates"]:
    print(f"Lines {duplicate['block1']['start_line']}-{duplicate['block1']['end_line']} "
          f"similar to lines {duplicate['block2']['start_line']}-{duplicate['block2']['end_line']} "
          f"(similarity: {duplicate['similarity']:.2f})")

## 最佳实践

### 1. 审查规则配置

#### 1. 规则优先级
- 安全规则：最高优先级
- 性能规则：高优先级
- 代码质量：中优先级
- 代码风格：低优先级
### 2. 规则定制
- 根据项目需求定制规则
- 考虑团队编码规范
- 逐步引入新规则
### 3. 规则例外
- 提供规则例外机制
- 记录例外原因
- 定期审查例外
```

##### 2. 审查流程#

```
bash复制markdown

#### 1. 自动审查
- 在提交前自动运行
- 集成到 CI/CD 流程
- 阻止不符合规范的代码

### 2. 人工审查
- 审查自动审查结果
- 关注复杂逻辑
- 提供建设性反馈

### 3. 持续改进
- 收集审查反馈
- 优化审查规则
- 提高审查效率
```

```
markdown

#### 1. 自动审查
- 在提交前自动运行
- 集成到 CI/CD 流程
- 阻止不符合规范的代码

### 2. 人工审查
- 审查自动审查结果
- 关注复杂逻辑
- 提供建设性反馈

### 3. 持续改进
- 收集审查反馈
- 优化审查规则
- 提高审查效率
```

#### 总结#

代码审查技能可以帮助团队自动化代码审查流程，提高代码质量和一致性。通过合理配置审查规则和流程，可以显著减少代码中的问题，提高开发效率。

在下一节中，我们将探讨文档生成技能。

---

## 3 文档生成技能

**URL**: https://claudecode.tangshuang.net/course/18.3%20%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E6%8A%80%E8%83%BD

#### 文档生成技能概述#

文档生成技能是 Claude Code Skills 中用于自动化生成各种类型文档的重要工具。它可以根据代码、注释和配置自动生成高质量的文档，显著减少手动编写文档的工作量。

#### 文档类型#

##### 1. API 文档生成#

###### 1.1 REST API 文档

```
python复制# src/skills/api_documentation_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class APIDocumentationGeneratorSkill(Skill):
    """API 文档生成技能"""

    def __init__(self):
        super().__init__(
            name="api-documentation-generator",
            version="1.0.0",
            description="Generate API documentation from code"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the API file"
                },
                "code": {
                    "type": "string",
                    "description": "API code to document"
                },
                "framework": {
                    "type": "string",
                    "enum": ["flask", "fastapi", "express", "django"],
                    "description": "Framework used"
                },
                "output_format": {
                    "type": "string",
                    "enum": ["markdown", "html", "openapi"],
                    "description": "Output format"
                },
                "include_examples": {
                    "type": "boolean",
                    "description": "Include usage examples",
                    "default": True
                }
            },
            "required": ["framework"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            framework = parameters["framework"]
            output_format = parameters.get("output_format", "markdown")
            include_examples = parameters.get("include_examples", True)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 解析 API
            endpoints = self.parse_api(code, framework)

            # 生成文档
            documentation = self.generate_documentation(
                endpoints, framework, output_format, include_examples
            )

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "framework": framework,
                    "output_format": output_format,
                    "endpoints": endpoints,
                    "endpoint_count": len(endpoints),
                    "documentation": documentation
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )
```

```
# src/skills/api_documentation_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class APIDocumentationGeneratorSkill(Skill):
    """API 文档生成技能"""

    def __init__(self):
        super().__init__(
            name="api-documentation-generator",
            version="1.0.0",
            description="Generate API documentation from code"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the API file"
                },
                "code": {
                    "type": "string",
                    "description": "API code to document"
                },
                "framework": {
                    "type": "string",
                    "enum": ["flask", "fastapi", "express", "django"],
                    "description": "Framework used"
                },
                "output_format": {
                    "type": "string",
                    "enum": ["markdown", "html", "openapi"],
                    "description": "Output format"
                },
                "include_examples": {
                    "type": "boolean",
                    "description": "Include usage examples",
                    "default": True
                }
            },
            "required": ["framework"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            framework = parameters["framework"]
            output_format = parameters.get("output_format", "markdown")
            include_examples = parameters.get("include_examples", True)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 解析 API
            endpoints = self.parse_api(code, framework)

            # 生成文档
            documentation = self.generate_documentation(
                endpoints, framework, output_format, include_examples
            )

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "framework": framework,
                    "output_format": output_format,
                    "endpoints": endpoints,
                    "endpoint_count": len(endpoints),
                    "documentation": documentation
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )
```

def parse_api(self, code: str, framework: str) -> List[Dict]:
"""解析 API 端点"""
parsers = {
"flask": self.parse_flask,
"fastapi": self.parse_fastapi,
"express": self.parse_express,
"django": self.parse_django
}

parser = parsers.get(framework)
if not parser:
raise ValueError(f"Unsupported framework: {framework}")

return parser(code)

def parse_flask(self, code: str) -> List[Dict]:
"""解析 Flask 路由"""

endpoints = []

### 匹配路由装饰器

route_pattern = r'@app.route('"['"]\s*,\s*methods=[([^]]+)])'

for match in re.finditer(route_pattern, code):
path = match.group(1)
methods_str = match.group(2)

### 解析方法

methods = [m.strip().strip(''"') for m in methods_str.split(',')]

### 获取函数定义

func_start = match.end()
func_pattern = r'def\s+(\w+)\s*([^)]*):'
func_match = re.search(func_pattern, code[func_start:func_start + 100])

if func_match:
func_name = func_match.group(1)

### 提取文档字符串

docstring = self.extract_docstring(code, func_start + func_match.end())

### 提取参数

params = self.extract_flask_params(code, func_start + func_match.end())

endpoints.append({
"path": path,
"methods": methods,
"function": func_name,
"description": docstring,
"parameters": params
})

return endpoints

def parse_fastapi(self, code: str) -> List[Dict]:
"""解析 FastAPI 路由"""
endpoints = []

### 匹配路由装饰器

route_pattern = r'@(app.|router.)?(get|post|put|delete|patch)('"['"])'

for match in re.finditer(route_pattern, code):
method = match.group(2).upper()
path = match.group(3)

### 获取函数定义

func_start = match.end()
func_pattern = r'async\s+def\s+(\w+)\s*(([^)]*)):'
func_match = re.search(func_pattern, code[func_start:func_start + 200])

if func_match:
func_name = func_match.group(1)
params_str = func_match.group(2)

### 提取文档字符串

docstring = self.extract_docstring(code, func_start + func_match.end())

### 提取参数

params = self.extract_fastapi_params(params_str)

endpoints.append({
"path": path,
"methods": [method],
"function": func_name,
"description": docstring,
"parameters": params
})

return endpoints

def parse_express(self, code: str) -> List[Dict]:
"""解析 Express 路由"""
endpoints = []

### 匹配路由定义

route_pattern = r'app.(get|post|put|delete|patch)('"['"]\s*,\s*(\w+)'

for match in re.finditer(route_pattern, code):
method = match.group(1).upper()
path = match.group(2)
handler = match.group(3)

endpoints.append({
"path": path,
"methods": [method],
"function": handler,
"description": "",
"parameters": []
})

return endpoints

def parse_django(self, code: str) -> List[Dict]:
"""解析 Django 路由"""
endpoints = []

### 匹配 URL 模式

url_pattern = r'path('"['"]\s*,\s*(\w+).as_view()'

for match in re.finditer(url_pattern, code):
path = match.group(1)
view = match.group(2)

endpoints.append({
"path": path,
"methods": ["GET", "POST", "PUT", "DELETE"],
"function": view,
"description": "",
"parameters": []
})

return endpoints

def extract_docstring(self, code: str, start_pos: int) -> str:
"""提取文档字符串"""

### 查找三引号字符串

docstring_pattern = r'"""([^"]*)"""'
match = re.search(docstring_pattern, code[start_pos:start_pos + 500])

if match:
return match.group(1).strip()

return ""

def extract_flask_params(self, code: str, start_pos: int) -> List[Dict]:
"""提取 Flask 参数"""
params = []

### 查找 request.json 或 request.form

json_pattern = r'request.json.get('"['"]'
for match in re.finditer(json_pattern, code[start_pos:start_pos + 500]):
params.append({
"name": match.group(1),
"type": "object",
"required": False,
"description": ""
})

return params

def extract_fastapi_params(self, params_str: str) -> List[Dict]:
"""提取 FastAPI 参数"""
params = []

### 解析函数参数

param_pattern = r'(\w+):\s*(\w+)'
for match in re.finditer(param_pattern, params_str):
param_name = match.group(1)
param_type = match.group(2)

if param_name not in ["self", "request"]:
params.append({
"name": param_name,
"type": param_type,
"required": False,
"description": ""
})

return params

def generate_documentation(self, endpoints: List[Dict], framework: str,
output_format: str, include_examples: bool) -> str:
"""生成文档"""
generators = {
"markdown": self.generate_markdown,
"html": self.generate_html,
"openapi": self.generate_openapi
}

generator = generators.get(output_format)
if not generator:
raise ValueError(f"Unsupported output format: {output_format}")

return generator(endpoints, framework, include_examples)

def generate_markdown(self, endpoints: List[Dict], framework: str,
include_examples: bool) -> str:
"""生成 Markdown 文档"""
doc = f"# API Documentation\n\n"
doc += f"Framework: {framework}\n\n"
doc += f"## Endpoints\n\n"

for endpoint in endpoints:
methods = ", ".join(endpoint["methods"])
doc += f"### {methods} {endpoint['path']}\n\n"

if endpoint["description"]:
doc += f"{endpoint['description']}\n\n"

if endpoint["parameters"]:
doc += "#### Parameters\n\n"
doc += "| Name | Type | Required | Description |\n"
doc += "|------|------|----------|-------------|\n"

for param in endpoint["parameters"]:
required = "Yes" if param.get("required") else "No"
doc += f"| {param['name']} | {param['type']} | {required} | {param.get('description', '')} |\n"

doc += "\n"

if include_examples:
doc += "#### Example Request\n\n"
doc += f"bash\n" method = endpoint["methods"][0] if endpoint["methods"] else "GET" doc += f"curl -X {method} http://localhost:8000{endpoint['path']}\n" doc += f"\n\n"

```
bash\n" method = endpoint["methods"][0] if endpoint["methods"] else "GET" doc += f"curl -X {method} http://localhost:8000{endpoint['path']}\n" doc += f"
```

return doc

def generate_html(self, endpoints: List[Dict], framework: str,
include_examples: bool) -> str:
"""生成 HTML 文档"""
html = f"""<!DOCTYPE html>

for endpoint in endpoints:
methods = ", ".join(endpoint["methods"])
html += f"""

if endpoint["description"]:
html += f"        <p>{endpoint['description']}</p>\n"

if endpoint["parameters"]:
html += "        <h4>Parameters</h4>\n"
html += "        <table>\n"
html += "            <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>\n"

for param in endpoint["parameters"]:
required = "Yes" if param.get("required") else "No"
html += f"            <tr><td>{param['name']}</td><td>{param['type']}</td><td>{required}</td><td>{param.get('description', '')}</td></tr>\n"

html += "        </table>\n"

html += "    </div>\n"

html += """

return html

def generate_openapi(self, endpoints: List[Dict], framework: str,
include_examples: bool) -> str:
"""生成 OpenAPI 规范"""
openapi = {
"openapi": "3.0.0",
"info": {
"title": "API Documentation",
"version": "1.0.0"
},
"paths": {}
}

for endpoint in endpoints:
path = endpoint["path"]
openapi["paths"][path] = {}

for method in endpoint["methods"]:
method_lower = method.lower()
openapi["paths"][path][method_lower] = {
"summary": endpoint["description"],
"responses": {
"200": {
"description": "Success"
}
}
}

if endpoint["parameters"]:
openapi["paths"][path][method_lower]["parameters"] = []
for param in endpoint["parameters"]:
openapi["paths"][path][method_lower]["parameters"].append({
"name": param["name"],
"in": "query",
"required": param.get("required", False),
"schema": {
"type": param["type"]
}
})

import json
return json.dumps(openapi, indent=2)

##### 2. 代码文档生成#

###### 2.1 函数和类文档

```
bash复制python

# src/skills/code_documentation_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class CodeDocumentationGeneratorSkill(Skill):
    """代码文档生成技能"""

    def __init__(self):
        super().__init__(
            name="code-documentation-generator",
            version="1.0.0",
            description="Generate code documentation"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the code file"
                },
                "code": {
                    "type": "string",
                    "description": "Code to document"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "output_format": {
                    "type": "string",
                    "enum": ["markdown", "html"],
                    "description": "Output format"
                },
                "include_private": {
                    "type": "boolean",
                    "description": "Include private members",
                    "default": False
                }
            },
            "required": ["language"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            language = parameters["language"]
            output_format = parameters.get("output_format", "markdown")
            include_private = parameters.get("include_private", False)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 解析代码
            elements = self.parse_code(code, language, include_private)

            # 生成文档
            documentation = self.generate_documentation(
                elements, language, output_format
            )

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "language": language,
                    "output_format": output_format,
                    "elements": elements,
                    "element_count": len(elements),
                    "documentation": documentation
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def parse_code(self, code: str, language: str,
                  include_private: bool) -> List[Dict]:
        """解析代码元素"""
        parsers = {
            "python": self.parse_python,
            "javascript": self.parse_javascript,
            "java": self.parse_java,
            "go": self.parse_go
        }

        parser = parsers.get(language)
        if not parser:
            raise ValueError(f"Unsupported language: {language}")

        return parser(code, include_private)

    def parse_python(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Python 代码"""
        elements = []

        # 解析类
        class_pattern = r'class\s+(\w+)\s*(?:\([^)]*\))?:'
        for match in re.finditer(class_pattern, code):
            class_name = match.group(1)

            # 检查是否为私有类
            if not include_private and class_name.startswith('_'):
                continue

            # 提取类文档字符串
            docstring = self.extract_docstring(code, match.end())

            # 解析方法
            methods = self.parse_python_methods(code, match.end(), include_private)

            elements.append({
                "type": "class",
                "name": class_name,
                "description": docstring,
                "methods": methods
            })

        # 解析函数
        func_pattern = r'^def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, code, re.MULTILINE):
            func_name = match.group(1)

            # 检查是否为私有函数
            if not include_private and func_name.startswith('_'):
                continue

            # 提取函数文档字符串
            docstring = self.extract_docstring(code, match.end())

            # 提取参数
            params = self.extract_python_params(code, match.end())

            elements.append({
                "type": "function",
                "name": func_name,
                "description": docstring,
                "parameters": params
            })

        return elements

    def parse_python_methods(self, code: str, start_pos: int,
                            include_private: bool) -> List[Dict]:
        """解析 Python 方法"""
        methods = []

        # 在类定义范围内查找方法
        class_end = self.find_class_end(code, start_pos)
        class_code = code[start_pos:class_end]

        func_pattern = r'def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, class_code):
            method_name = match.group(1)

            # 检查是否为私有方法
            if not include_private and method_name.startswith('_'):
                continue

            # 提取方法文档字符串
            docstring = self.extract_docstring(class_code, match.end())

            # 提取参数
            params = self.extract_python_params(class_code, match.end())

            methods.append({
                "name": method_name,
                "description": docstring,
                "parameters": params
            })

        return methods

    def extract_python_params(self, code: str, start_pos: int) -> List[Dict]:
        """提取 Python 参数"""
        params = []

        # 查找函数定义中的参数
        func_def = code[start_pos:start_pos + 200]
        param_pattern = r'(\w+)\s*(?::\s*(\w+))?'

        # 在括号内查找参数
        match = re.search(r'\(([^)]*)\)', func_def)
        if match:
            params_str = match.group(1)
            for param_match in re.finditer(param_pattern, params_str):
                param_name = param_match.group(1)
                param_type = param_match.group(2) or "Any"

                if param_name not in ["self", "cls"]:
                    params.append({
                        "name": param_name,
                        "type": param_type,
                        "description": ""
                    })

        return params

    def find_class_end(self, code: str, start_pos: int) -> int:
        """查找类定义结束位置"""
        lines = code[start_pos:].split('\n')
        base_indent = len(lines[0]) - len(lines[0].lstrip())

        for i, line in enumerate(lines[1:], 1):
            if line.strip() and not line.strip().startswith('#'):
                indent = len(line) - len(line.lstrip())
                if indent <= base_indent:
                    return start_pos + sum(len(l) + 1 for l in lines[:i])

        return len(code)

    def parse_javascript(self, code: str, include_private: bool) -> List[Dict]:
        """解析 JavaScript 代码"""
        elements = []

        # 解析类
        class_pattern = r'class\s+(\w+)\s*\{'
        for match in re.finditer(class_pattern, code):
            class_name = match.group(1)

            # 检查是否为私有类
            if not include_private and class_name.startswith('_'):
                continue

            # 提取类注释
            comment = self.extract_js_comment(code, match.start())

            # 解析方法
            methods = self.parse_js_methods(code, match.end(), include_private)

            elements.append({
                "type": "class",
                "name": class_name,
                "description": comment,
                "methods": methods
            })

        # 解析函数
        func_pattern = r'function\s+(\w+)\s*\(|const\s+(\w+)\s*=\s*\([^)]*\)\s*=>'
        for match in re.finditer(func_pattern, code):
            func_name = match.group(1) or match.group(2)

            # 检查是否为私有函数
            if not include_private and func_name.startswith('_'):
                continue

            # 提取函数注释
            comment = self.extract_js_comment(code, match.start())

            elements.append({
                "type": "function",
                "name": func_name,
                "description": comment,
                "parameters": []
            })

        return elements

    def parse_js_methods(self, code: str, start_pos: int,
                        include_private: bool) -> List[Dict]:
        """解析 JavaScript 方法"""
        methods = []

        # 在类定义范围内查找方法
        class_end = self.find_js_class_end(code, start_pos)
        class_code = code[start_pos:class_end]

        method_pattern = r'(\w+)\s*\([^)]*\)\s*\{'
        for match in re.finditer(method_pattern, class_code):
            method_name = match.group(1)

            # 检查是否为私有方法
            if not include_private and method_name.startswith('_'):
                continue

            # 提取方法注释
            comment = self.extract_js_comment(class_code, match.start())

            methods.append({
                "name": method_name,
                "description": comment,
                "parameters": []
            })

        return methods

    def extract_js_comment(self, code: str, pos: int) -> str:
        """提取 JavaScript 注释"""
        # 查找 JSDoc 注释
        comment_pattern = r'/\*\*([^*]|\*[^/])*\*/'
        match = re.search(comment_pattern, code[max(0, pos - 500):pos])

        if match:
            comment = match.group(0)
            # 移除注释标记
            comment = re.sub(r'/\*\*|\*/|\*\s?', '', comment)
            return comment.strip()

        return ""

    def find_js_class_end(self, code: str, start_pos: int) -> int:
        """查找 JavaScript 类定义结束位置"""
        brace_count = 1
        i = start_pos

        while i < len(code) and brace_count > 0:
            if code[i] == '{':
                brace_count += 1
            elif code[i] == '}':
                brace_count -= 1
            i += 1

        return i

    def parse_java(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Java 代码"""
        # 简化实现
        return []

    def parse_go(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Go 代码"""
        # 简化实现
        return []

    def generate_documentation(self, elements: List[Dict], language: str,
                               output_format: str) -> str:
        """生成文档"""
        if output_format == "markdown":
            return self.generate_markdown(elements, language)
        elif output_format == "html":
            return self.generate_html(elements, language)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")

    def generate_markdown(self, elements: List[Dict], language: str) -> str:
        """生成 Markdown 文档"""
        doc = f"# Code Documentation\n\n"
        doc += f"Language: {language}\n\n"

        for element in elements:
            if element["type"] == "class":
                doc += f"## Class: {element['name']}\n\n"

                if element["description"]:
                    doc += f"{element['description']}\n\n"

                if element["methods"]:
                    doc += "### Methods\n\n"
                    for method in element["methods"]:
                        doc += f"#### {method['name']}\n\n"
                        if method["description"]:
                            doc += f"{method['description']}\n\n"

                        if method["parameters"]:
                            doc += "**Parameters:**\n\n"
                            for param in method["parameters"]:
                                doc += f"- `{param['name']}` ({param['type']}): {param.get('description', '')}\n"
                            doc += "\n"

            elif element["type"] == "function":
                doc += f"## Function: {element['name']}\n\n"

                if element["description"]:
                    doc += f"{element['description']}\n\n"

                if element["parameters"]:
                    doc += "**Parameters:**\n\n"
                    for param in element["parameters"]:
                        doc += f"- `{param['name']}` ({param['type']}): {param.get('description', '')}\n"
                    doc += "\n"

        return doc

    def generate_html(self, elements: List[Dict], language: str) -> str:
        """生成 HTML 文档"""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Code Documentation</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .class, .function {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; }}
        .method {{ margin: 10px 0; padding: 10px; border-left: 3px solid #007bff; }}
        code {{ background-color: #f4f4f4; padding: 2px 5px; }}
    </style>
</head>
<body>
    <h1>Code Documentation</h1>
    <p>Language: {language}</p>
"""

        for element in elements:
            if element["type"] == "class":
                html += f"""
    <div class="class">
        <h2>Class: {element['name']}</h2>
"""
                if element["description"]:
                    html += f"        <p>{element['description']}</p>\n"

                if element["methods"]:
                    html += "        <h3>Methods</h3>\n"
                    for method in element["methods"]:
                        html += f"""
        <div class="method">
            <h4>{method['name']}</h4>
"""
                        if method["description"]:
                            html += f"            <p>{method['description']}</p>\n"

                        if method["parameters"]:
                            html += "            <p><strong>Parameters:</strong></p>\n"
                            html += "            <ul>\n"
                            for param in method["parameters"]:
                                html += f"                <li><code>{param['name']}</code> ({param['type']}): {param.get('description', '')}</li>\n"
                            html += "            </ul>\n"

                        html += "        </div>\n"

                html += "    </div>\n"

            elif element["type"] == "function":
                html += f"""
    <div class="function">
        <h2>Function: {element['name']}</h2>
"""
                if element["description"]:
                    html += f"        <p>{element['description']}</p>\n"

                if element["parameters"]:
                    html += "        <p><strong>Parameters:</strong></p>\n"
                    html += "        <ul>\n"
                    for param in element["parameters"]:
                        html += f"            <li><code>{param['name']}</code> ({param['type']}): {param.get('description', '')}</li>\n"
                    html += "        </ul>\n"

                html += "    </div>\n"

        html += """
</body>
</html>
"""

        return html

## 使用示例

### 1. 生成 API 文档

# examples/generate_api_docs.py
from skills.api_documentation_generator import APIDocumentationGeneratorSkill
from claude_code_sdk import SkillContext
skill = APIDocumentationGeneratorSkill()
context = SkillContext()
result = skill.execute(
{
"file_path": "src/api.py",
"framework": "flask",
"output_format": "markdown",
"include_examples": True
},
context
)
print(result.data["documentation"])
```

```
python

# src/skills/code_documentation_generator.py
from typing import Dict, Any, List
from claude_code_sdk import Skill, SkillContext, SkillResult
import re

class CodeDocumentationGeneratorSkill(Skill):
    """代码文档生成技能"""

    def __init__(self):
        super().__init__(
            name="code-documentation-generator",
            version="1.0.0",
            description="Generate code documentation"
        )

    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "file_path": {
                    "type": "string",
                    "description": "Path to the code file"
                },
                "code": {
                    "type": "string",
                    "description": "Code to document"
                },
                "language": {
                    "type": "string",
                    "enum": ["python", "javascript", "java", "go"],
                    "description": "Programming language"
                },
                "output_format": {
                    "type": "string",
                    "enum": ["markdown", "html"],
                    "description": "Output format"
                },
                "include_private": {
                    "type": "boolean",
                    "description": "Include private members",
                    "default": False
                }
            },
            "required": ["language"]
        }

    def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
        try:
            language = parameters["language"]
            output_format = parameters.get("output_format", "markdown")
            include_private = parameters.get("include_private", False)

            # 获取代码
            if "file_path" in parameters:
                code = context.read_file(parameters["file_path"])
                file_path = parameters["file_path"]
            elif "code" in parameters:
                code = parameters["code"]
                file_path = "<inline>"
            else:
                return SkillResult(
                    success=False,
                    error="Either file_path or code must be provided"
                )

            # 解析代码
            elements = self.parse_code(code, language, include_private)

            # 生成文档
            documentation = self.generate_documentation(
                elements, language, output_format
            )

            return SkillResult(
                success=True,
                data={
                    "file_path": file_path,
                    "language": language,
                    "output_format": output_format,
                    "elements": elements,
                    "element_count": len(elements),
                    "documentation": documentation
                }
            )
        except Exception as e:
            return SkillResult(
                success=False,
                error=str(e)
            )

    def parse_code(self, code: str, language: str,
                  include_private: bool) -> List[Dict]:
        """解析代码元素"""
        parsers = {
            "python": self.parse_python,
            "javascript": self.parse_javascript,
            "java": self.parse_java,
            "go": self.parse_go
        }

        parser = parsers.get(language)
        if not parser:
            raise ValueError(f"Unsupported language: {language}")

        return parser(code, include_private)

    def parse_python(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Python 代码"""
        elements = []

        # 解析类
        class_pattern = r'class\s+(\w+)\s*(?:\([^)]*\))?:'
        for match in re.finditer(class_pattern, code):
            class_name = match.group(1)

            # 检查是否为私有类
            if not include_private and class_name.startswith('_'):
                continue

            # 提取类文档字符串
            docstring = self.extract_docstring(code, match.end())

            # 解析方法
            methods = self.parse_python_methods(code, match.end(), include_private)

            elements.append({
                "type": "class",
                "name": class_name,
                "description": docstring,
                "methods": methods
            })

        # 解析函数
        func_pattern = r'^def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, code, re.MULTILINE):
            func_name = match.group(1)

            # 检查是否为私有函数
            if not include_private and func_name.startswith('_'):
                continue

            # 提取函数文档字符串
            docstring = self.extract_docstring(code, match.end())

            # 提取参数
            params = self.extract_python_params(code, match.end())

            elements.append({
                "type": "function",
                "name": func_name,
                "description": docstring,
                "parameters": params
            })

        return elements

    def parse_python_methods(self, code: str, start_pos: int,
                            include_private: bool) -> List[Dict]:
        """解析 Python 方法"""
        methods = []

        # 在类定义范围内查找方法
        class_end = self.find_class_end(code, start_pos)
        class_code = code[start_pos:class_end]

        func_pattern = r'def\s+(\w+)\s*\([^)]*\):'
        for match in re.finditer(func_pattern, class_code):
            method_name = match.group(1)

            # 检查是否为私有方法
            if not include_private and method_name.startswith('_'):
                continue

            # 提取方法文档字符串
            docstring = self.extract_docstring(class_code, match.end())

            # 提取参数
            params = self.extract_python_params(class_code, match.end())

            methods.append({
                "name": method_name,
                "description": docstring,
                "parameters": params
            })

        return methods

    def extract_python_params(self, code: str, start_pos: int) -> List[Dict]:
        """提取 Python 参数"""
        params = []

        # 查找函数定义中的参数
        func_def = code[start_pos:start_pos + 200]
        param_pattern = r'(\w+)\s*(?::\s*(\w+))?'

        # 在括号内查找参数
        match = re.search(r'\(([^)]*)\)', func_def)
        if match:
            params_str = match.group(1)
            for param_match in re.finditer(param_pattern, params_str):
                param_name = param_match.group(1)
                param_type = param_match.group(2) or "Any"

                if param_name not in ["self", "cls"]:
                    params.append({
                        "name": param_name,
                        "type": param_type,
                        "description": ""
                    })

        return params

    def find_class_end(self, code: str, start_pos: int) -> int:
        """查找类定义结束位置"""
        lines = code[start_pos:].split('\n')
        base_indent = len(lines[0]) - len(lines[0].lstrip())

        for i, line in enumerate(lines[1:], 1):
            if line.strip() and not line.strip().startswith('#'):
                indent = len(line) - len(line.lstrip())
                if indent <= base_indent:
                    return start_pos + sum(len(l) + 1 for l in lines[:i])

        return len(code)

    def parse_javascript(self, code: str, include_private: bool) -> List[Dict]:
        """解析 JavaScript 代码"""
        elements = []

        # 解析类
        class_pattern = r'class\s+(\w+)\s*\{'
        for match in re.finditer(class_pattern, code):
            class_name = match.group(1)

            # 检查是否为私有类
            if not include_private and class_name.startswith('_'):
                continue

            # 提取类注释
            comment = self.extract_js_comment(code, match.start())

            # 解析方法
            methods = self.parse_js_methods(code, match.end(), include_private)

            elements.append({
                "type": "class",
                "name": class_name,
                "description": comment,
                "methods": methods
            })

        # 解析函数
        func_pattern = r'function\s+(\w+)\s*\(|const\s+(\w+)\s*=\s*\([^)]*\)\s*=>'
        for match in re.finditer(func_pattern, code):
            func_name = match.group(1) or match.group(2)

            # 检查是否为私有函数
            if not include_private and func_name.startswith('_'):
                continue

            # 提取函数注释
            comment = self.extract_js_comment(code, match.start())

            elements.append({
                "type": "function",
                "name": func_name,
                "description": comment,
                "parameters": []
            })

        return elements

    def parse_js_methods(self, code: str, start_pos: int,
                        include_private: bool) -> List[Dict]:
        """解析 JavaScript 方法"""
        methods = []

        # 在类定义范围内查找方法
        class_end = self.find_js_class_end(code, start_pos)
        class_code = code[start_pos:class_end]

        method_pattern = r'(\w+)\s*\([^)]*\)\s*\{'
        for match in re.finditer(method_pattern, class_code):
            method_name = match.group(1)

            # 检查是否为私有方法
            if not include_private and method_name.startswith('_'):
                continue

            # 提取方法注释
            comment = self.extract_js_comment(class_code, match.start())

            methods.append({
                "name": method_name,
                "description": comment,
                "parameters": []
            })

        return methods

    def extract_js_comment(self, code: str, pos: int) -> str:
        """提取 JavaScript 注释"""
        # 查找 JSDoc 注释
        comment_pattern = r'/\*\*([^*]|\*[^/])*\*/'
        match = re.search(comment_pattern, code[max(0, pos - 500):pos])

        if match:
            comment = match.group(0)
            # 移除注释标记
            comment = re.sub(r'/\*\*|\*/|\*\s?', '', comment)
            return comment.strip()

        return ""

    def find_js_class_end(self, code: str, start_pos: int) -> int:
        """查找 JavaScript 类定义结束位置"""
        brace_count = 1
        i = start_pos

        while i < len(code) and brace_count > 0:
            if code[i] == '{':
                brace_count += 1
            elif code[i] == '}':
                brace_count -= 1
            i += 1

        return i

    def parse_java(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Java 代码"""
        # 简化实现
        return []

    def parse_go(self, code: str, include_private: bool) -> List[Dict]:
        """解析 Go 代码"""
        # 简化实现
        return []

    def generate_documentation(self, elements: List[Dict], language: str,
                               output_format: str) -> str:
        """生成文档"""
        if output_format == "markdown":
            return self.generate_markdown(elements, language)
        elif output_format == "html":
            return self.generate_html(elements, language)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")

    def generate_markdown(self, elements: List[Dict], language: str) -> str:
        """生成 Markdown 文档"""
        doc = f"# Code Documentation\n\n"
        doc += f"Language: {language}\n\n"

        for element in elements:
            if element["type"] == "class":
                doc += f"## Class: {element['name']}\n\n"

                if element["description"]:
                    doc += f"{element['description']}\n\n"

                if element["methods"]:
                    doc += "### Methods\n\n"
                    for method in element["methods"]:
                        doc += f"#### {method['name']}\n\n"
                        if method["description"]:
                            doc += f"{method['description']}\n\n"

                        if method["parameters"]:
                            doc += "**Parameters:**\n\n"
                            for param in method["parameters"]:
                                doc += f"- `{param['name']}` ({param['type']}): {param.get('description', '')}\n"
                            doc += "\n"

            elif element["type"] == "function":
                doc += f"## Function: {element['name']}\n\n"

                if element["description"]:
                    doc += f"{element['description']}\n\n"

                if element["parameters"]:
                    doc += "**Parameters:**\n\n"
                    for param in element["parameters"]:
                        doc += f"- `{param['name']}` ({param['type']}): {param.get('description', '')}\n"
                    doc += "\n"

        return doc

    def generate_html(self, elements: List[Dict], language: str) -> str:
        """生成 HTML 文档"""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Code Documentation</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .class, .function {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; }}
        .method {{ margin: 10px 0; padding: 10px; border-left: 3px solid #007bff; }}
        code {{ background-color: #f4f4f4; padding: 2px 5px; }}
    </style>
</head>
<body>
    <h1>Code Documentation</h1>
    <p>Language: {language}</p>
"""

        for element in elements:
            if element["type"] == "class":
                html += f"""
    <div class="class">
        <h2>Class: {element['name']}</h2>
"""
                if element["description"]:
                    html += f"        <p>{element['description']}</p>\n"

                if element["methods"]:
                    html += "        <h3>Methods</h3>\n"
                    for method in element["methods"]:
                        html += f"""
        <div class="method">
            <h4>{method['name']}</h4>
"""
                        if method["description"]:
                            html += f"            <p>{method['description']}</p>\n"

                        if method["parameters"]:
                            html += "            <p><strong>Parameters:</strong></p>\n"
                            html += "            <ul>\n"
                            for param in method["parameters"]:
                                html += f"                <li><code>{param['name']}</code> ({param['type']}): {param.get('description', '')}</li>\n"
                            html += "            </ul>\n"

                        html += "        </div>\n"

                html += "    </div>\n"

            elif element["type"] == "function":
                html += f"""
    <div class="function">
        <h2>Function: {element['name']}</h2>
"""
                if element["description"]:
                    html += f"        <p>{element['description']}</p>\n"

                if element["parameters"]:
                    html += "        <p><strong>Parameters:</strong></p>\n"
                    html += "        <ul>\n"
                    for param in element["parameters"]:
                        html += f"            <li><code>{param['name']}</code> ({param['type']}): {param.get('description', '')}</li>\n"
                    html += "        </ul>\n"

                html += "    </div>\n"

        html += """
</body>
</html>
"""

        return html

## 使用示例

### 1. 生成 API 文档

# examples/generate_api_docs.py
from skills.api_documentation_generator import APIDocumentationGeneratorSkill
from claude_code_sdk import SkillContext
skill = APIDocumentationGeneratorSkill()
context = SkillContext()
result = skill.execute(
{
"file_path": "src/api.py",
"framework": "flask",
"output_format": "markdown",
"include_examples": True
},
context
)
print(result.data["documentation"])
```

##### 2. 生成代码文档#

```
bash复制python

# examples/generate_code_docs.py
from skills.code_documentation_generator import CodeDocumentationGeneratorSkill
from claude_code_sdk import SkillContext

skill = CodeDocumentationGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/utils.py",
        "language": "python",
        "output_format": "html",
        "include_private": False
    },
    context
)

print(result.data["documentation"])

## 最佳实践

### 1. 文档编写规范

#### 1. 注释质量
- 使用清晰的语言
- 描述"为什么"而不是"是什么"
- 保持注释与代码同步
### 2. 文档结构
- 提供概述
- 包含示例
- 添加使用说明
### 3. 文档更新
- 及时更新文档
- 记录变更历史
- 维护版本信息
```

```
python

# examples/generate_code_docs.py
from skills.code_documentation_generator import CodeDocumentationGeneratorSkill
from claude_code_sdk import SkillContext

skill = CodeDocumentationGeneratorSkill()
context = SkillContext()

result = skill.execute(
    {
        "file_path": "src/utils.py",
        "language": "python",
        "output_format": "html",
        "include_private": False
    },
    context
)

print(result.data["documentation"])

## 最佳实践

### 1. 文档编写规范

#### 1. 注释质量
- 使用清晰的语言
- 描述"为什么"而不是"是什么"
- 保持注释与代码同步
### 2. 文档结构
- 提供概述
- 包含示例
- 添加使用说明
### 3. 文档更新
- 及时更新文档
- 记录变更历史
- 维护版本信息
```

##### 2. 自动化文档生成#

```
bash复制markdown

#### 1. 集成到构建流程
- 在构建时生成文档
- 部署到文档服务器
- 自动更新文档

### 2. 持续集成
- 检查文档完整性
- 验证文档格式
- 生成文档报告

### 3. 文档审查
- 审查生成的文档
- 补充缺失信息
- 修正错误内容
```

```
markdown

#### 1. 集成到构建流程
- 在构建时生成文档
- 部署到文档服务器
- 自动更新文档

### 2. 持续集成
- 检查文档完整性
- 验证文档格式
- 生成文档报告

### 3. 文档审查
- 审查生成的文档
- 补充缺失信息
- 修正错误内容
```

#### 总结#

文档生成技能可以显著减少手动编写文档的工作量，提高文档质量和一致性。通过自动化文档生成，开发者可以专注于代码编写，同时确保文档的及时更新和准确性。

在下一节中，我们将探讨测试生成技能。

---

# 第 19 章

## 1 核心概念对比

**URL**: https://claudecode.tangshuang.net/course/19.1%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94

#### 核心概念概述#

Skills 和插件都是 Claude Code 中用于扩展功能的重要机制，但它们在设计理念、实现方式和应用场景上有显著差异。本节将从核心概念层面对比两者。

#### 定义对比#

##### 1. Skills 定义#

##### 概念#

Skills 是基于自然语言和示例驱动的任务封装机制，用于自动化特定的工作流程和知识应用。

##### 特点#

- 自然语言定义：使用自然语言描述任务和规则
- 示例驱动：通过输入输出示例定义行为
- 灵活性强：易于理解和修改
- 快速开发：无需编写复杂代码

##### 适用场景#

- 需要快速实现功能
- 任务逻辑复杂且多变
- 需要频繁调整
- 非技术用户使用

##### 2. 插件定义#

##### 概念#

插件是基于编程代码的功能扩展机制，用于实现系统集成和复杂逻辑。

##### 特点#

- 代码实现：使用编程语言编写
- 精确控制：对执行过程有完全控制
- 高性能：编译执行，效率高
- 复杂功能：适合实现复杂功能

##### 适用场景#

- 需要精确控制执行过程
- 性能要求高
- 需要与外部系统集成
- 长期维护的功能

#### 设计理念对比#

##### 1. 设计目标#

###### Skills 设计目标

##### 1. 易用性#

- 降低使用门槛
- 自然语言交互
- 直观的配置

##### 2. 灵活性#

- 快速适应变化
- 易于定制
- 支持多种场景

##### 3. 可理解性#

- 清晰的任务描述
- 明确的输入输出
- 易于维护

##### 4. 快速迭代#

- 快速开发
- 快速测试
- 快速部署

###### 插件设计目标

##### 1. 性能#

- 高效执行
- 资源优化
- 低延迟

##### 2. 可靠性#

- 稳定运行
- 错误处理
- 容错机制

##### 3. 可扩展性#

- 模块化设计
- 接口清晰
- 易于扩展

##### 4. 集成性#

- 与系统深度集成
- 访问底层功能
- 完整的功能访问

##### 2. 架构设计#

###### Skills 架构

##### 分层架构#

```
bash复制┌─────────────────────────┐
│   用户交互层           │
│  (自然语言/示例)       │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   解释执行层           │
│  (LLM 理解和执行)     │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   工具调用层           │
│  (文件/命令/搜索)      │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   系统集成层           │
│  (Claude Code API)     │
└─────────────────────────┘
```

```
┌─────────────────────────┐
│   用户交互层           │
│  (自然语言/示例)       │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   解释执行层           │
│  (LLM 理解和执行)     │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   工具调用层           │
│  (文件/命令/搜索)      │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   系统集成层           │
│  (Claude Code API)     │
└─────────────────────────┘
```

##### 特点#

- 解释执行
- 动态理解
- 灵活适应

```
bash复制#### 插件架构
### 分层架构
```

```
#### 插件架构
### 分层架构
```

┌─────────────────────────┐
│   API 接口层           │
│  (标准插件接口)         │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   业务逻辑层           │
│  (自定义实现)           │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   系统调用层           │
│  (直接系统调用)         │
└──────────┬──────────────┘
│
┌──────────▼──────────────┐
│   操作系统层           │
│  (文件/网络/进程)       │
└─────────────────────────┘

```
bash复制- 编译执行
- 直接调用
- 高效执行
```

```
- 编译执行
- 直接调用
- 高效执行
```

#### 功能对比#

##### 1. 功能范围#

###### Skills 功能

#### Skills 功能范围#

##### 核心功能#

- 任务自动化
- 代码生成
- 代码审查
- 文档生成
- 测试生成

##### 扩展功能#

- 自然语言处理
- 示例学习
- 上下文理解
- 智能推理

##### 限制#

- 执行速度较慢
- 确定性较低
- 资源消耗较大
- 调试困难

```
bash复制#### 插件功能
```

```
#### 插件功能
```

markdown

#### 插件功能范围#

##### 核心功能#

- 系统集成
- 外部服务调用
- 数据处理
- 性能优化
- 复杂算法

##### 扩展功能#

- 自定义工具
- 事件处理
- 状态管理
- 持久化

##### 限制#

- 开发成本高
- 需要编程知识
- 维护复杂
- 灵活性较低

##### 2. 能力对比#

#### 能力对比表#

```
bash复制## 实现方式对比
### 1. 定义方式
#### Skills 定义
```python

# Skills 定义示例

## Skill: 代码审查

### 功能
自动审查代码质量，检查安全性、性能和最佳实践。

### 输入
- 代码文件路径
- 审查标准（可选）
- 严格程度（可选）

### 执行步骤

### 示例

输入：
```python
```python

def calculate_sum(numbers):
    total = 0
    for n in numbers:
        total += n
    return total

输出：
- ✅ 代码结构清晰
- ✅ 变量命名合理
- 💡 建议使用内置 sum() 函数

#### 插件定义

```python

# 插件定义示例

from claude_code_plugin import Plugin, PluginContext, PluginResult

class CodeReviewPlugin(Plugin):
    """代码审查插件"""

    def __init__(self):
        super().__init__(
            name="code-review",
            version="1.0.0",
            description="Automated code review plugin"
        )

    def execute(self, parameters: dict, context: PluginContext) -> PluginResult:
        """执行代码审查"""
        file_path = parameters["file_path"]

        # 读取文件
        with open(file_path, 'r') as f:
            code = f.read()

        # 分析代码
        issues = self.analyze_code(code)

        # 返回结果
        return PluginResult(
            success=True,
            data={
                "file_path": file_path,
                "issues": issues
            }
        )

    def analyze_code(self, code: str) -> list:
        """分析代码"""
        issues = []

        # 检查代码长度
        if len(code) > 1000:
            issues.append({
                "type": "complexity",
                "severity": "medium",
                "message": "代码过长，建议拆分"
            })

        # 检查注释
        if '"""' not in code and "'''" not in code:
            issues.append({
                "type": "documentation",
                "severity": "low",
                "message": "缺少文档字符串"
            })

        return issues

### 2. 执行方式

#### Skills 执行

## Skills 执行流程
### 1. 理解阶段
- 解析自然语言描述
- 理解示例输入输出
- 构建任务模型
### 2. 规划阶段
- 分解任务为步骤
- 确定执行顺序
- 选择合适的工具
### 3. 执行阶段
- 调用工具执行
- 处理中间结果
- 调整执行策略
### 4. 输出生成
- 整合执行结果
- 格式化输出
- 生成最终响应
### 特点
- 动态解释
- 灵活适应
- 可能产生不同结果
```

```
## 实现方式对比
### 1. 定义方式
#### Skills 定义
```python

# Skills 定义示例

## Skill: 代码审查

### 功能
自动审查代码质量，检查安全性、性能和最佳实践。

### 输入
- 代码文件路径
- 审查标准（可选）
- 严格程度（可选）

### 执行步骤

### 示例

输入：
```python
```python

def calculate_sum(numbers):
    total = 0
    for n in numbers:
        total += n
    return total

输出：
- ✅ 代码结构清晰
- ✅ 变量命名合理
- 💡 建议使用内置 sum() 函数

#### 插件定义

```python

# 插件定义示例

from claude_code_plugin import Plugin, PluginContext, PluginResult

class CodeReviewPlugin(Plugin):
    """代码审查插件"""

    def __init__(self):
        super().__init__(
            name="code-review",
            version="1.0.0",
            description="Automated code review plugin"
        )

    def execute(self, parameters: dict, context: PluginContext) -> PluginResult:
        """执行代码审查"""
        file_path = parameters["file_path"]

        # 读取文件
        with open(file_path, 'r') as f:
            code = f.read()

        # 分析代码
        issues = self.analyze_code(code)

        # 返回结果
        return PluginResult(
            success=True,
            data={
                "file_path": file_path,
                "issues": issues
            }
        )

    def analyze_code(self, code: str) -> list:
        """分析代码"""
        issues = []

        # 检查代码长度
        if len(code) > 1000:
            issues.append({
                "type": "complexity",
                "severity": "medium",
                "message": "代码过长，建议拆分"
            })

        # 检查注释
        if '"""' not in code and "'''" not in code:
            issues.append({
                "type": "documentation",
                "severity": "low",
                "message": "缺少文档字符串"
            })

        return issues

### 2. 执行方式

#### Skills 执行

## Skills 执行流程
### 1. 理解阶段
- 解析自然语言描述
- 理解示例输入输出
- 构建任务模型
### 2. 规划阶段
- 分解任务为步骤
- 确定执行顺序
- 选择合适的工具
### 3. 执行阶段
- 调用工具执行
- 处理中间结果
- 调整执行策略
### 4. 输出生成
- 整合执行结果
- 格式化输出
- 生成最终响应
### 特点
- 动态解释
- 灵活适应
- 可能产生不同结果
```

###### 插件执行

```
bash复制markdown

## 插件执行流程

### 1. 初始化阶段
- 加载插件代码
- 初始化插件实例
- 准备执行环境

### 2. 参数验证
- 验证输入参数
- 检查前置条件
- 准备执行资源

### 3. 执行阶段
- 执行预定义逻辑
- 调用系统 API
- 处理执行结果

### 4. 结果返回
- 格式化结果
- 错误处理
- 清理资源

### 特点
- 确定性执行
- 固定流程
- 结果可预测

## 学习曲线对比

### 1. Skills 学习曲线

## Skills 学习曲线
### 入门阶段（1-2 天）
- 理解基本概念
- 学习自然语言描述
- 掌握示例编写
- 完成简单 Skill
### 进阶阶段（3-7 天）
- 理解上下文管理
- 学习工具调用
- 掌握参数配置
- 完成中等复杂度 Skill
### 精通阶段（2-4 周）
- 理解高级特性
- 掌握性能优化
- 学习最佳实践
- 完成复杂 Skill
### 特点
- 入门快
- 进阶平滑
- 实践为主
- 边学边用
```

```
markdown

## 插件执行流程

### 1. 初始化阶段
- 加载插件代码
- 初始化插件实例
- 准备执行环境

### 2. 参数验证
- 验证输入参数
- 检查前置条件
- 准备执行资源

### 3. 执行阶段
- 执行预定义逻辑
- 调用系统 API
- 处理执行结果

### 4. 结果返回
- 格式化结果
- 错误处理
- 清理资源

### 特点
- 确定性执行
- 固定流程
- 结果可预测

## 学习曲线对比

### 1. Skills 学习曲线

## Skills 学习曲线
### 入门阶段（1-2 天）
- 理解基本概念
- 学习自然语言描述
- 掌握示例编写
- 完成简单 Skill
### 进阶阶段（3-7 天）
- 理解上下文管理
- 学习工具调用
- 掌握参数配置
- 完成中等复杂度 Skill
### 精通阶段（2-4 周）
- 理解高级特性
- 掌握性能优化
- 学习最佳实践
- 完成复杂 Skill
### 特点
- 入门快
- 进阶平滑
- 实践为主
- 边学边用
```

##### 2. 插件学习曲线#

```
bash复制markdown

## 插件学习曲线

### 入门阶段（1-2 周）
- 学习编程语言
- 理解插件架构
- 学习 API 使用
- 完成简单插件

### 进阶阶段（1-2 个月）
- 理解系统架构
- 学习高级 API
- 掌握性能优化
- 完成中等复杂度插件

### 精通阶段（3-6 个月）
- 理解底层机制
- 掌握系统优化
- 学习最佳实践
- 完成复杂插件

### 特点
- 入门慢
- 需要编程基础
- 理论与实践并重
- 需要持续学习
```

```
markdown

## 插件学习曲线

### 入门阶段（1-2 周）
- 学习编程语言
- 理解插件架构
- 学习 API 使用
- 完成简单插件

### 进阶阶段（1-2 个月）
- 理解系统架构
- 学习高级 API
- 掌握性能优化
- 完成中等复杂度插件

### 精通阶段（3-6 个月）
- 理解底层机制
- 掌握系统优化
- 学习最佳实践
- 完成复杂插件

### 特点
- 入门慢
- 需要编程基础
- 理论与实践并重
- 需要持续学习
```

#### 总结#

Skills 和插件在设计理念上有根本差异：

True. Skills：注重易用性和灵活性，适合快速开发和频繁调整
True. 插件：注重性能和可靠性，适合长期维护和复杂功能

选择哪种方式取决于具体需求、开发者的技能水平和项目的特点。

在下一节中，我们将对比两者的适用场景。

---

## 2 适用场景对比

**URL**: https://claudecode.tangshuang.net/course/19.2%20%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94

#### 19.2.1 Skills 的典型应用场景#

##### 1. 快速原型开发#

Skills 非常适合快速原型开发，因为它们可以通过自然语言描述快速创建和修改。

场景示例：
用户：创建一个技能，用于将 Markdown 文档转换为 HTML 文档

Claude Code：我会创建一个 Markdown 转 HTML 的技能。

- 名称：markdown-to-html
- 描述：将 Markdown 格式转换为 HTML 格式
- 输入：Markdown 文本
- 输出：HTML 文本

使用示例：
请将以下 Markdown 转换为 HTML：

### 标题

- 无需编写代码即可创建功能
- 快速迭代和调整
- 适合探索性开发

##### 2. 知识封装与复用#

Skills 适合封装特定的知识和经验，使其可以在不同的上下文中复用。

```
python复制# 技能：代码审查标准
class CodeReviewSkill(Skill):
    def execute(self, parameters, context):
        code = parameters["code"]
        language = parameters["language"]

        # 应用代码审查标准
        issues = self.check_code_quality(code, language)
        suggestions = self.provide_improvements(code, language)

        return SkillResult(
            success=True,
            data={
                "issues": issues,
                "suggestions": suggestions,
                "score": self.calculate_quality_score(code, language)
            }
        )
```

```
# 技能：代码审查标准
class CodeReviewSkill(Skill):
    def execute(self, parameters, context):
        code = parameters["code"]
        language = parameters["language"]

        # 应用代码审查标准
        issues = self.check_code_quality(code, language)
        suggestions = self.provide_improvements(code, language)

        return SkillResult(
            success=True,
            data={
                "issues": issues,
                "suggestions": suggestions,
                "score": self.calculate_quality_score(code, language)
            }
        )
```

- 封装团队最佳实践
- 跨项目复用
- 保持一致性

##### 3. 自然语言处理任务#

Skills 特别适合需要理解自然语言的任务，因为它们可以利用 Claude 的语言理解能力。

场景示例：
技能：需求分析助手
功能：

- 分析用户需求文档
- 识别功能点
- 提取技术约束
- 生成用户故事
输入：需求文档文本
输出：结构化需求分析

- 强大的语言理解能力
- 处理非结构化文本
- 灵活的输入输出

##### 4. 教育与培训#

Skills 可以作为教学工具，帮助学习者理解和应用特定概念。

```
python复制# 技能：编程导师
class ProgrammingTutorSkill(Skill):
    def execute(self, parameters, context):
        topic = parameters["topic"]
        difficulty = parameters["difficulty"]

        # 根据主题和难度提供教学
        explanation = self.explain_concept(topic, difficulty)
        examples = self.generate_examples(topic, difficulty)
        exercises = self.create_exercises(topic, difficulty)

        return SkillResult(
            success=True,
            data={
                "explanation": explanation,
                "examples": examples,
```

```
# 技能：编程导师
class ProgrammingTutorSkill(Skill):
    def execute(self, parameters, context):
        topic = parameters["topic"]
        difficulty = parameters["difficulty"]

        # 根据主题和难度提供教学
        explanation = self.explain_concept(topic, difficulty)
        examples = self.generate_examples(topic, difficulty)
        exercises = self.create_exercises(topic, difficulty)

        return SkillResult(
            success=True,
            data={
                "explanation": explanation,
                "examples": examples,
```

```
bash复制            "exercises": exercises
        }
    )
```

```
"exercises": exercises
        }
    )
```

```
bash复制            }
        )

**优势**：
- 个性化学习体验
- 即时反馈
- 自适应难度

### 5. 辅助决策

Skills 可以帮助用户做出更明智的决策，通过分析数据提供建议。

> **场景示例**：
技能：技术选型顾问
功能：
- 分析项目需求
- 评估技术方案
- 提供选型建议
- 列出优缺点
输入：项目需求文档
输出：技术选型建议报告
```

```
}
        )

**优势**：
- 个性化学习体验
- 即时反馈
- 自适应难度

### 5. 辅助决策

Skills 可以帮助用户做出更明智的决策，通过分析数据提供建议。

> **场景示例**：
技能：技术选型顾问
功能：
- 分析项目需求
- 评估技术方案
- 提供选型建议
- 列出优缺点
输入：项目需求文档
输出：技术选型建议报告
```

- 综合分析能力
- 基于数据的建议
- 多方案对比

#### 19.2.2 插件的典型应用场景#

##### 1. 系统级集成#

插件适合需要与操作系统、数据库或其他系统进行深度集成的场景。
场景示例：

```
python复制
# 插件：数据库连接器
class DatabaseConnectorPlugin(Plugin):
    def __init__(self):
        super().__init__(
            name="database-connector",
            version="1.0.0"
        )

        self.connection_pool = None

    def connect(self, config):
        """建立数据库连接"""
        self.connection_pool = create_connection_pool(config)
        return True

    def execute_query(self, query, params=None):
        """执行查询"""
        with self.connection_pool.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or {})
            return cursor.fetchall()

    def close(self):
        """关闭连接"""
        if self.connection_pool:
            self.connection_pool.close()

**优势**：
- 直接访问系统资源
- 高性能执行
- 精确控制

### 2. 复杂业务逻辑

插件适合实现复杂的业务逻辑，特别是需要高性能和确定性的场景。

> **场景示例**：
# 插件：支付处理
class PaymentProcessorPlugin(Plugin):
def process_payment(self, payment_data):
"""处理支付"""
# 1. 验证支付数据
self.validate_payment(payment_data)
# 2. 创建支付记录
payment_id = self.create_payment_record(payment_data)
# 3. 调用支付网关
gateway_response = self.call_payment_gateway(payment_data)
# 4. 更新支付状态
self.update_payment_status(payment_id, gateway_response)
# 5. 发送通知
self.send_payment_notification(payment_id, gateway_response)
return {
"payment_id": payment_id,
"status": gateway_response["status"],
"transaction_id": gateway_response["transaction_id"]
}
```

```
# 插件：数据库连接器
class DatabaseConnectorPlugin(Plugin):
    def __init__(self):
        super().__init__(
            name="database-connector",
            version="1.0.0"
        )

        self.connection_pool = None

    def connect(self, config):
        """建立数据库连接"""
        self.connection_pool = create_connection_pool(config)
        return True

    def execute_query(self, query, params=None):
        """执行查询"""
        with self.connection_pool.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or {})
            return cursor.fetchall()

    def close(self):
        """关闭连接"""
        if self.connection_pool:
            self.connection_pool.close()

**优势**：
- 直接访问系统资源
- 高性能执行
- 精确控制

### 2. 复杂业务逻辑

插件适合实现复杂的业务逻辑，特别是需要高性能和确定性的场景。

> **场景示例**：
# 插件：支付处理
class PaymentProcessorPlugin(Plugin):
def process_payment(self, payment_data):
"""处理支付"""
# 1. 验证支付数据
self.validate_payment(payment_data)
# 2. 创建支付记录
payment_id = self.create_payment_record(payment_data)
# 3. 调用支付网关
gateway_response = self.call_payment_gateway(payment_data)
# 4. 更新支付状态
self.update_payment_status(payment_id, gateway_response)
# 5. 发送通知
self.send_payment_notification(payment_id, gateway_response)
return {
"payment_id": payment_id,
"status": gateway_response["status"],
"transaction_id": gateway_response["transaction_id"]
}
```

- 确定性执行
- 事务处理
- 错误处理

##### 3. 高性能计算#

插件适合需要高性能计算的场景，特别是涉及大量数据处理或复杂算法的场景。
场景示例：

```
python复制
# 插件：图像处理
class ImageProcessorPlugin(Plugin):
    def process_image(self, image_path, operations):
        """处理图像"""
        # 使用 OpenCV 进行高性能图像处理
        import cv2
        import numpy as np

        # 读取图像
        image = cv2.imread(image_path)

        # 应用操作
        for operation in operations:
            if operation["type"] == "resize":
                image = cv2.resize(image, operation["size"])
            elif operation["type"] == "blur":
                image = cv2.GaussianBlur(image, operation["kernel"], 0)
            elif operation["type"] == "edge_detection":
                image = cv2.Canny(image, 100, 200)

        return image

**优势**：
- 使用原生库
- 优化性能
- 并行处理

### 4. 安全敏感操作

插件适合需要严格安全控制的场景，特别是涉及敏感数据或关键操作的场景。

> **场景示例**：
# 插件：加密服务
class EncryptionServicePlugin(Plugin):
def __init__(self, key):
super().__init__(name="encryption-service")
self.key = key
def encrypt(self, data):
"""加密数据"""
from cryptography.fernet import Fernet
f = Fernet(self.key)
return f.encrypt(data.encode())
def decrypt(self, encrypted_data):
"""解密数据"""
from cryptography.fernet import Fernet
f = Fernet(self.key)
return f.decrypt(encrypted_data).decode()
```

```
# 插件：图像处理
class ImageProcessorPlugin(Plugin):
    def process_image(self, image_path, operations):
        """处理图像"""
        # 使用 OpenCV 进行高性能图像处理
        import cv2
        import numpy as np

        # 读取图像
        image = cv2.imread(image_path)

        # 应用操作
        for operation in operations:
            if operation["type"] == "resize":
                image = cv2.resize(image, operation["size"])
            elif operation["type"] == "blur":
                image = cv2.GaussianBlur(image, operation["kernel"], 0)
            elif operation["type"] == "edge_detection":
                image = cv2.Canny(image, 100, 200)

        return image

**优势**：
- 使用原生库
- 优化性能
- 并行处理

### 4. 安全敏感操作

插件适合需要严格安全控制的场景，特别是涉及敏感数据或关键操作的场景。

> **场景示例**：
# 插件：加密服务
class EncryptionServicePlugin(Plugin):
def __init__(self, key):
super().__init__(name="encryption-service")
self.key = key
def encrypt(self, data):
"""加密数据"""
from cryptography.fernet import Fernet
f = Fernet(self.key)
return f.encrypt(data.encode())
def decrypt(self, encrypted_data):
"""解密数据"""
from cryptography.fernet import Fernet
f = Fernet(self.key)
return f.decrypt(encrypted_data).decode()
```

- 严格的访问控制
- 审计日志
- 安全合规

##### 5. 第三方服务集成#

插件适合与第三方服务集成，特别是需要复杂认证和错误处理的场景。
场景示例：

```
python复制
# 插件：AWS S3 集成
class S3IntegrationPlugin(Plugin):
    def __init__(self, access_key, secret_key, region):
        super().__init__(name="s3-integration")
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key,
            region_name=region
        )

    def upload_file(self, bucket, key, file_path):
        """上传文件到 S3"""
        try:
            self.s3_client.upload_file(file_path, bucket, key)
            return {"success": True, "key": key}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def download_file(self, bucket, key, file_path):
        """从 S3 下载文件"""
        try:
            self.s3_client.download_file(bucket, key, file_path)
            return {"success": True, "path": file_path}
        except Exception as e:
            return {"success": False, "error": str(e)}

**优势**：
- 复杂认证处理
- 重试机制
- 错误恢复

## 19.2.3 场景对比表

| 场景 | Skills | 插件 | 推荐 |
|------|--------|------|------|
| 快速原型开发 | ✓✓✓ | ✓ | Skills |
| 知识封装 | ✓✓✓ | ✓✓ | Skills |
| 自然语言处理 | ✓✓✓ | ✗ | Skills |
| 教育培训 | ✓✓✓ | ✓ | Skills |
| 辅助决策 | ✓✓✓ | ✓✓ | Skills |
| 系统级集成 | ✓ | ✓✓✓ | 插件 |
| 复杂业务逻辑 | ✓ | ✓✓✓ | 插件 |
| 高性能计算 | ✓ | ✓✓✓ | 插件 |
| 安全敏感操作 | ✓ | ✓✓✓ | 插件 |
| 第三方服务集成 | ✓✓ | ✓✓✓ | 插件 |
| 代码生成 | ✓✓✓ | ✓✓ | Skills |
| 代码审查 | ✓✓✓ | ✓✓ | Skills |
| 数据转换 | ✓✓ | ✓✓✓ | 插件 |
| 文档生成 | ✓✓✓ | ✓✓ | Skills |
| 自动化测试 | ✓✓ | ✓✓✓ | 插件 |
| 监控告警 | ✓✓ | ✓✓✓ | 插件 |
| 日志分析 | ✓✓✓ | ✓✓ | Skills |
| 配置管理 | ✓✓ | ✓✓✓ | 插件 |
| 部署自动化 | ✓✓ | ✓✓✓ | 插件 |

## 19.2.4 混合使用场景

在实际应用中，Skills 和插件经常需要配合使用，发挥各自的优势。

### 示例 1：代码审查流程

# 插件：Git 集成
class GitIntegrationPlugin(Plugin):
def get_changed_files(self, branch):
"""获取变更的文件"""
return run_git_command(['diff', '--name-only', branch])
# 技能：代码审查
class CodeReviewSkill(Skill):
def execute(self, parameters, context):
# 使用插件获取变更的文件
git_plugin = context.get_plugin("git-integration")
changed_files = git_plugin.get_changed_files(parameters["branch"])
# 对每个文件进行审查
reviews = []
for file_path in changed_files:
code = read_file(file_path)
review = self.review_code(code, file_path)
reviews.append(review)
return SkillResult(success=True, data={"reviews": reviews})
```

```
# 插件：AWS S3 集成
class S3IntegrationPlugin(Plugin):
    def __init__(self, access_key, secret_key, region):
        super().__init__(name="s3-integration")
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key,
            region_name=region
        )

    def upload_file(self, bucket, key, file_path):
        """上传文件到 S3"""
        try:
            self.s3_client.upload_file(file_path, bucket, key)
            return {"success": True, "key": key}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def download_file(self, bucket, key, file_path):
        """从 S3 下载文件"""
        try:
            self.s3_client.download_file(bucket, key, file_path)
            return {"success": True, "path": file_path}
        except Exception as e:
            return {"success": False, "error": str(e)}

**优势**：
- 复杂认证处理
- 重试机制
- 错误恢复

## 19.2.3 场景对比表

| 场景 | Skills | 插件 | 推荐 |
|------|--------|------|------|
| 快速原型开发 | ✓✓✓ | ✓ | Skills |
| 知识封装 | ✓✓✓ | ✓✓ | Skills |
| 自然语言处理 | ✓✓✓ | ✗ | Skills |
| 教育培训 | ✓✓✓ | ✓ | Skills |
| 辅助决策 | ✓✓✓ | ✓✓ | Skills |
| 系统级集成 | ✓ | ✓✓✓ | 插件 |
| 复杂业务逻辑 | ✓ | ✓✓✓ | 插件 |
| 高性能计算 | ✓ | ✓✓✓ | 插件 |
| 安全敏感操作 | ✓ | ✓✓✓ | 插件 |
| 第三方服务集成 | ✓✓ | ✓✓✓ | 插件 |
| 代码生成 | ✓✓✓ | ✓✓ | Skills |
| 代码审查 | ✓✓✓ | ✓✓ | Skills |
| 数据转换 | ✓✓ | ✓✓✓ | 插件 |
| 文档生成 | ✓✓✓ | ✓✓ | Skills |
| 自动化测试 | ✓✓ | ✓✓✓ | 插件 |
| 监控告警 | ✓✓ | ✓✓✓ | 插件 |
| 日志分析 | ✓✓✓ | ✓✓ | Skills |
| 配置管理 | ✓✓ | ✓✓✓ | 插件 |
| 部署自动化 | ✓✓ | ✓✓✓ | 插件 |

## 19.2.4 混合使用场景

在实际应用中，Skills 和插件经常需要配合使用，发挥各自的优势。

### 示例 1：代码审查流程

# 插件：Git 集成
class GitIntegrationPlugin(Plugin):
def get_changed_files(self, branch):
"""获取变更的文件"""
return run_git_command(['diff', '--name-only', branch])
# 技能：代码审查
class CodeReviewSkill(Skill):
def execute(self, parameters, context):
# 使用插件获取变更的文件
git_plugin = context.get_plugin("git-integration")
changed_files = git_plugin.get_changed_files(parameters["branch"])
# 对每个文件进行审查
reviews = []
for file_path in changed_files:
code = read_file(file_path)
review = self.review_code(code, file_path)
reviews.append(review)
return SkillResult(success=True, data={"reviews": reviews})
```

##### 示例 2：数据处理流程#

```
python复制
# 插件：数据库访问
class DatabasePlugin(Plugin):
    def query_data(self, query):
        """查询数据"""
        return execute_sql_query(query)

# 技能：数据分析
class DataAnalysisSkill(Skill):
    def execute(self, parameters, context):
        # 使用插件获取数据
        db_plugin = context.get_plugin("database")
        data = db_plugin.query_data(parameters["query"])

        # 使用 Claude 分析数据
        analysis = self.analyze_data(data, parameters["analysis_type"])

        return SkillResult(success=True, data={"analysis": analysis})
```

```
# 插件：数据库访问
class DatabasePlugin(Plugin):
    def query_data(self, query):
        """查询数据"""
        return execute_sql_query(query)

# 技能：数据分析
class DataAnalysisSkill(Skill):
    def execute(self, parameters, context):
        # 使用插件获取数据
        db_plugin = context.get_plugin("database")
        data = db_plugin.query_data(parameters["query"])

        # 使用 Claude 分析数据
        analysis = self.analyze_data(data, parameters["analysis_type"])

        return SkillResult(success=True, data={"analysis": analysis})
```

#### 19.2.5 选择建议#

##### 选择 Skills 的场景#

True. 需要快速迭代：当需求经常变化，需要快速调整时
True. 依赖语言理解：当任务需要理解自然语言时
True. 知识密集型：当任务需要应用特定知识或经验时
True. 探索性开发：当在探索解决方案，不确定最佳实现时
True. 教育目的：当目标是教学或学习时

##### 选择插件的场景#

True. 性能关键：当需要高性能或实时处理时
True. 系统集成：当需要与操作系统或外部系统深度集成时
True. 安全敏感：当涉及敏感数据或关键操作时
True. 确定性要求：当需要精确控制和可预测结果时
True. 复杂逻辑：当需要实现复杂的业务逻辑时

##### 混合使用的场景#

True. 需要两者优势：当任务既需要语言理解又需要高性能时
True. 分层架构：当可以分层处理，上层用 Skills，下层用插件时
True. 渐进式开发：当先用 Skills 原型，后用插件优化时

---

## 3 实现机制对比

**URL**: https://claudecode.tangshuang.net/course/19.3%20%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94

#### 19.3.1 Skills 的实现机制#

##### 1. 基于 LLM 的执行模型#

Skills 的核心实现依赖于大语言模型（LLM）的理解和生成能力。

执行流程：
用户请求
↓
自然语言解析（LLM）
↓
意图识别
↓
参数提取
↓
技能选择
↓
技能执行
↓
结果生成（LLM）
↓
返回用户

```
python复制class SkillExecutor:
    def __init__(self, llm_client):
        self.llm_client = llm_client
        self.skills = {}

    def register_skill(self, skill):
        """注册技能"""
        self.skills[skill.name] = skill

    def execute(self, user_input):
        """执行技能"""
        # 1. 使用 LLM 解析用户意图
        intent = self.parse_intent(user_input)

        # 2. 选择合适的技能
        skill = self.select_skill(intent)

        # 3. 提取参数
        parameters = self.extract_parameters(user_input, skill)

        # 4. 执行技能
        result = skill.execute(parameters)

        # 5. 使用 LLM 格式化结果
        formatted_result = self.format_result(result)

        return formatted_result

    def parse_intent(self, user_input):
        """解析用户意图"""
        prompt = f"""
        分析以下用户请求的意图：
        {user_input}

        返回意图类型和关键信息。
        """
        response = self.llm_client.complete(prompt)
        return parse_intent_response(response)
```

```
class SkillExecutor:
    def __init__(self, llm_client):
        self.llm_client = llm_client
        self.skills = {}

    def register_skill(self, skill):
        """注册技能"""
        self.skills[skill.name] = skill

    def execute(self, user_input):
        """执行技能"""
        # 1. 使用 LLM 解析用户意图
        intent = self.parse_intent(user_input)

        # 2. 选择合适的技能
        skill = self.select_skill(intent)

        # 3. 提取参数
        parameters = self.extract_parameters(user_input, skill)

        # 4. 执行技能
        result = skill.execute(parameters)

        # 5. 使用 LLM 格式化结果
        formatted_result = self.format_result(result)

        return formatted_result

    def parse_intent(self, user_input):
        """解析用户意图"""
        prompt = f"""
        分析以下用户请求的意图：
        {user_input}

        返回意图类型和关键信息。
        """
        response = self.llm_client.complete(prompt)
        return parse_intent_response(response)
```

##### 2. 上下文感知机制#

Skills 能够感知和利用上下文信息，提供更智能的响应。

上下文类型：

```
python复制class SkillContext:
    def __init__(self):
        self.conversation_history = []      # 对话历史
        self.project_context = {}           # 项目上下文
        self.user_preferences = {}          # 用户偏好
        self.environment_variables = {}     # 环境变量
        self.available_tools = []           # 可用工具
        self.available_plugins = []         # 可用插件

    def get_conversation_history(self, limit=10):
        """获取对话历史"""
        return self.conversation_history[-limit:]

    def get_project_info(self):
        """获取项目信息"""
        return self.project_context

    def get_user_preference(self, key):
        """获取用户偏好"""
        return self.user_preferences.get(key)

    def get_tool(self, name):
        """获取工具"""
        for tool in self.available_tools:
            if tool.name == name:
                return tool
        return None
```

```
class SkillContext:
    def __init__(self):
        self.conversation_history = []      # 对话历史
        self.project_context = {}           # 项目上下文
        self.user_preferences = {}          # 用户偏好
        self.environment_variables = {}     # 环境变量
        self.available_tools = []           # 可用工具
        self.available_plugins = []         # 可用插件

    def get_conversation_history(self, limit=10):
        """获取对话历史"""
        return self.conversation_history[-limit:]

    def get_project_info(self):
        """获取项目信息"""
        return self.project_context

    def get_user_preference(self, key):
        """获取用户偏好"""
        return self.user_preferences.get(key)

    def get_tool(self, name):
        """获取工具"""
        for tool in self.available_tools:
            if tool.name == name:
                return tool
        return None
```

##### 3. 示例学习机制#

Skills 可以通过示例学习，提高执行准确性和一致性。

```
yaml复制```yaml

# skill.yaml
name: code-reviewer
version: 1.0.0
description: 代码审查技能

examples:
  - input: |
      请审查以下 Python 代码：
      def calculate_sum(a, b):
          return a + b
    output: |
      代码审查结果：
      - 代码结构清晰
      - 函数命名规范
      - 缺少类型注解
      - 建议添加文档字符串

  - input: |
      审查这段 JavaScript 代码：
      function getData() {
          fetch('/api/data')
              .then(response => response.json())
              .then(data => console.log(data));
      }
    output: |
      代码审查结果：
      - 缺少错误处理
      - 建议使用 async/await
      - 缺少加载状态处理
      - 建议添加类型检查

```> **示例学习实现**：
class ExampleBasedSkill(Skill):
def __init__(self, examples):
super().__init__()
self.examples = examples
def execute(self, parameters, context):
# 1. 查找相似示例
similar_examples = self.find_similar_examples(parameters["input"])
# 2. 构建提示
prompt = self.build_prompt(parameters["input"], similar_examples)
# 3. 使用 LLM 生成响应
```

```
```yaml

# skill.yaml
name: code-reviewer
version: 1.0.0
description: 代码审查技能

examples:
  - input: |
      请审查以下 Python 代码：
      def calculate_sum(a, b):
          return a + b
    output: |
      代码审查结果：
      - 代码结构清晰
      - 函数命名规范
      - 缺少类型注解
      - 建议添加文档字符串

  - input: |
      审查这段 JavaScript 代码：
      function getData() {
          fetch('/api/data')
              .then(response => response.json())
              .then(data => console.log(data));
      }
    output: |
      代码审查结果：
      - 缺少错误处理
      - 建议使用 async/await
      - 缺少加载状态处理
      - 建议添加类型检查

```> **示例学习实现**：
class ExampleBasedSkill(Skill):
def __init__(self, examples):
super().__init__()
self.examples = examples
def execute(self, parameters, context):
# 1. 查找相似示例
similar_examples = self.find_similar_examples(parameters["input"])
# 2. 构建提示
prompt = self.build_prompt(parameters["input"], similar_examples)
# 3. 使用 LLM 生成响应
```

response = context.llm_client.complete(prompt)
return SkillResult(success=True, data={"response": response})
def find_similar_examples(self, input_text):
"""查找相似示例"""

### 使用嵌入向量查找相似示例

input_embedding = self.get_embedding(input_text)
similarities = []
for example in self.examples:
example_embedding = self.get_embedding(example["input"])
similarity = cosine_similarity(input_embedding, example_embedding)
similarities.append((example, similarity))

### 返回最相似的 k 个示例

similarities.sort(key=lambda x: x[1], reverse=True)
return [example for example, _ in similarities[:3]]

```
bash复制### 4. 动态参数解析

Skills 能够动态解析用户输入中的参数，无需预先定义严格的参数结构。

> **参数解析示例**：
```python
```python

class DynamicParameterParser:
    def parse_parameters(self, user_input, skill_schema):
        """动态解析参数"""
        prompt = f"""
        从以下用户输入中提取参数：
        用户输入：{user_input}

        技能参数模式：
        {json.dumps(skill_schema, indent=2)}

        返回提取的参数 JSON。
        """

        response = self.llm_client.complete(prompt)
        return json.loads(response)

# 使用示例
parser = DynamicParameterParser(llm_client)

skill_schema = {
    "name": "code-generator",
    "parameters": {
        "language": {"type": "string", "description": "编程语言"},
        "functionality": {"type": "string", "description": "功能描述"},
        "style": {"type": "string", "description": "代码风格", "optional": True}
    }
}

user_input = "用 Python 写一个快速排序算法，使用函数式编程风格"
parameters = parser.parse_parameters(user_input, skill_schema)
```

```
### 4. 动态参数解析

Skills 能够动态解析用户输入中的参数，无需预先定义严格的参数结构。

> **参数解析示例**：
```python
```python

class DynamicParameterParser:
    def parse_parameters(self, user_input, skill_schema):
        """动态解析参数"""
        prompt = f"""
        从以下用户输入中提取参数：
        用户输入：{user_input}

        技能参数模式：
        {json.dumps(skill_schema, indent=2)}

        返回提取的参数 JSON。
        """

        response = self.llm_client.complete(prompt)
        return json.loads(response)

# 使用示例
parser = DynamicParameterParser(llm_client)

skill_schema = {
    "name": "code-generator",
    "parameters": {
        "language": {"type": "string", "description": "编程语言"},
        "functionality": {"type": "string", "description": "功能描述"},
        "style": {"type": "string", "description": "代码风格", "optional": True}
    }
}

user_input = "用 Python 写一个快速排序算法，使用函数式编程风格"
parameters = parser.parse_parameters(user_input, skill_schema)
```

### 结果：

### {

### "language": "Python",

### "functionality": "快速排序算法",

### "style": "函数式编程"

### }

```
bash复制
### 1. 基于代码的执行模型

插件通过直接执行代码来实现功能，具有确定性和高性能。

> **执行流程**：
用户请求
↓
参数验证
↓
方法调用
↓
代码执行
↓
结果处理
↓
返回用户
```

```
### 1. 基于代码的执行模型

插件通过直接执行代码来实现功能，具有确定性和高性能。

> **执行流程**：
用户请求
↓
参数验证
↓
方法调用
↓
代码执行
↓
结果处理
↓
返回用户
```

```
python复制
class PluginExecutor:
    def __init__(self):
        self.plugins = {}

    def register_plugin(self, plugin):
        """注册插件"""
        self.plugins[plugin.name] = plugin

    def execute(self, plugin_name, method_name, parameters):
        """执行插件方法"""
        # 1. 获取插件
        plugin = self.plugins.get(plugin_name)
        if not plugin:
            raise PluginNotFoundError(plugin_name)

        # 2. 获取方法
        method = getattr(plugin, method_name)
        if not method:
            raise MethodNotFoundError(method_name)

        # 3. 验证参数
        self.validate_parameters(method, parameters)

        # 4. 执行方法
        try:
            result = method(**parameters)
            return {
                "success": True,
                "data": result
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def validate_parameters(self, method, parameters):
        """验证参数"""
        import inspect
        sig = inspect.signature(method)

        for param_name, param in sig.parameters.items():
            if param_name == "self":
                continue

            if param.default == param.empty and param_name not in parameters:
                raise MissingParameterError(param_name)

### 2. 类型安全机制

插件通过类型系统确保代码的健壮性和可维护性。

> **类型定义示例**：
from typing import TypedDict, List, Optional
from pydantic import BaseModel, validator
class PaymentRequest(BaseModel):
"""支付请求"""
amount: float
currency: str
payment_method: str
card_number: Optional[str] = None
expiry_date: Optional[str] = None
cvv: Optional[str] = None
@validator('amount')
def amount_must_be_positive(cls, v):
if v <= 0:
raise ValueError('金额必须大于零')
return v
@validator('currency')
def currency_must_be_valid(cls, v):
valid_currencies = ['USD', 'EUR', 'CNY']
if v not in valid_currencies:
raise ValueError(f'货币必须是以下之一：{valid_currencies}')
return v
class PaymentResponse(BaseModel):
"""支付响应"""
success: bool
transaction_id: Optional[str] = None
error_message: Optional[str] = None
class PaymentPlugin(Plugin):
def process_payment(self, request: PaymentRequest) -> PaymentResponse:
"""处理支付"""
# 类型自动验证
try:
# 处理支付逻辑
transaction_id = self.call_payment_gateway(request)
return PaymentResponse(
success=True,
transaction_id=transaction_id
)
except Exception as e:
return PaymentResponse(
success=False,
error_message=str(e)
)
```

```
class PluginExecutor:
    def __init__(self):
        self.plugins = {}

    def register_plugin(self, plugin):
        """注册插件"""
        self.plugins[plugin.name] = plugin

    def execute(self, plugin_name, method_name, parameters):
        """执行插件方法"""
        # 1. 获取插件
        plugin = self.plugins.get(plugin_name)
        if not plugin:
            raise PluginNotFoundError(plugin_name)

        # 2. 获取方法
        method = getattr(plugin, method_name)
        if not method:
            raise MethodNotFoundError(method_name)

        # 3. 验证参数
        self.validate_parameters(method, parameters)

        # 4. 执行方法
        try:
            result = method(**parameters)
            return {
                "success": True,
                "data": result
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def validate_parameters(self, method, parameters):
        """验证参数"""
        import inspect
        sig = inspect.signature(method)

        for param_name, param in sig.parameters.items():
            if param_name == "self":
                continue

            if param.default == param.empty and param_name not in parameters:
                raise MissingParameterError(param_name)

### 2. 类型安全机制

插件通过类型系统确保代码的健壮性和可维护性。

> **类型定义示例**：
from typing import TypedDict, List, Optional
from pydantic import BaseModel, validator
class PaymentRequest(BaseModel):
"""支付请求"""
amount: float
currency: str
payment_method: str
card_number: Optional[str] = None
expiry_date: Optional[str] = None
cvv: Optional[str] = None
@validator('amount')
def amount_must_be_positive(cls, v):
if v <= 0:
raise ValueError('金额必须大于零')
return v
@validator('currency')
def currency_must_be_valid(cls, v):
valid_currencies = ['USD', 'EUR', 'CNY']
if v not in valid_currencies:
raise ValueError(f'货币必须是以下之一：{valid_currencies}')
return v
class PaymentResponse(BaseModel):
"""支付响应"""
success: bool
transaction_id: Optional[str] = None
error_message: Optional[str] = None
class PaymentPlugin(Plugin):
def process_payment(self, request: PaymentRequest) -> PaymentResponse:
"""处理支付"""
# 类型自动验证
try:
# 处理支付逻辑
transaction_id = self.call_payment_gateway(request)
return PaymentResponse(
success=True,
transaction_id=transaction_id
)
except Exception as e:
return PaymentResponse(
success=False,
error_message=str(e)
)
```

##### 3. 依赖注入机制#

插件通过依赖注入实现松耦合和可测试性。
依赖注入示例：

```
python复制
from dependency_injector import containers, providers

class Container(containers.DeclarativeContainer):
    """依赖容器"""

    # 配置
    config = providers.Configuration()

    # 数据库连接
    database = providers.Singleton(
        DatabaseConnection,
        host=config.db.host,
        port=config.db.port,
        username=config.db.username,
        password=config.db.password
    )

    # 缓存服务
    cache = providers.Singleton(
        CacheService,
        host=config.cache.host,
        port=config.cache.port
    )

    # 支付网关
    payment_gateway = providers.Singleton(
        PaymentGateway,
        api_key=config.payment.api_key,
        environment=config.payment.environment
    )

    # 支付插件
    payment_plugin = providers.Factory(
        PaymentPlugin,
        database=database,
        cache=cache,
        payment_gateway=payment_gateway
    )

# 使用示例
container = Container()
container.config.from_yaml('config.yaml')

payment_plugin = container.payment_plugin()
result = payment_plugin.process_payment(payment_request)

### 4. 生命周期管理

插件具有完整的生命周期管理，包括初始化、启动、停止和销毁。

> **生命周期示例**：
class PluginLifecycle:
"""插件生命周期"""
def __init__(self):
self.state = "uninitialized"
self.dependencies = []
def initialize(self, config):
"""初始化插件"""
if self.state != "uninitialized":
raise PluginError("插件已初始化")
# 加载配置
self.config = config
# 初始化依赖
self.initialize_dependencies()
self.state = "initialized"
logger.info(f"插件 {self.name} 初始化完成")
def start(self):
"""启动插件"""
if self.state != "initialized":
raise PluginError("插件未初始化")
# 启动依赖
self.start_dependencies()
# 执行启动逻辑
self.on_start()
self.state = "running"
logger.info(f"插件 {self.name} 启动完成")
def stop(self):
"""停止插件"""
if self.state != "running":
raise PluginError("插件未运行")
# 执行停止逻辑
self.on_stop()
# 停止依赖
self.stop_dependencies()
self.state = "stopped"
logger.info(f"插件 {self.name} 停止完成")
def destroy(self):
"""销毁插件"""
if self.state not in ["initialized", "stopped"]:
raise PluginError("插件状态不正确")
# 销毁依赖
self.destroy_dependencies()
self.state = "destroyed"
logger.info(f"插件 {self.name} 销毁完成")
def on_start(self):
"""启动钩子"""
pass
def on_stop(self):
"""停止钩子"""
pass
```

```
from dependency_injector import containers, providers

class Container(containers.DeclarativeContainer):
    """依赖容器"""

    # 配置
    config = providers.Configuration()

    # 数据库连接
    database = providers.Singleton(
        DatabaseConnection,
        host=config.db.host,
        port=config.db.port,
        username=config.db.username,
        password=config.db.password
    )

    # 缓存服务
    cache = providers.Singleton(
        CacheService,
        host=config.cache.host,
        port=config.cache.port
    )

    # 支付网关
    payment_gateway = providers.Singleton(
        PaymentGateway,
        api_key=config.payment.api_key,
        environment=config.payment.environment
    )

    # 支付插件
    payment_plugin = providers.Factory(
        PaymentPlugin,
        database=database,
        cache=cache,
        payment_gateway=payment_gateway
    )

# 使用示例
container = Container()
container.config.from_yaml('config.yaml')

payment_plugin = container.payment_plugin()
result = payment_plugin.process_payment(payment_request)

### 4. 生命周期管理

插件具有完整的生命周期管理，包括初始化、启动、停止和销毁。

> **生命周期示例**：
class PluginLifecycle:
"""插件生命周期"""
def __init__(self):
self.state = "uninitialized"
self.dependencies = []
def initialize(self, config):
"""初始化插件"""
if self.state != "uninitialized":
raise PluginError("插件已初始化")
# 加载配置
self.config = config
# 初始化依赖
self.initialize_dependencies()
self.state = "initialized"
logger.info(f"插件 {self.name} 初始化完成")
def start(self):
"""启动插件"""
if self.state != "initialized":
raise PluginError("插件未初始化")
# 启动依赖
self.start_dependencies()
# 执行启动逻辑
self.on_start()
self.state = "running"
logger.info(f"插件 {self.name} 启动完成")
def stop(self):
"""停止插件"""
if self.state != "running":
raise PluginError("插件未运行")
# 执行停止逻辑
self.on_stop()
# 停止依赖
self.stop_dependencies()
self.state = "stopped"
logger.info(f"插件 {self.name} 停止完成")
def destroy(self):
"""销毁插件"""
if self.state not in ["initialized", "stopped"]:
raise PluginError("插件状态不正确")
# 销毁依赖
self.destroy_dependencies()
self.state = "destroyed"
logger.info(f"插件 {self.name} 销毁完成")
def on_start(self):
"""启动钩子"""
pass
def on_stop(self):
"""停止钩子"""
pass
```

#### 19.3.3 实现机制对比表#

#### 19.3.4 技术栈对比#

##### Skills 技术栈#

```
bash复制yaml

核心技术:
  - 大语言模型 (LLM)
  - 自然语言处理 (NLP)
  - 提示工程 (Prompt Engineering)
  - 嵌入向量 (Embeddings)

辅助技术:
  - 向量数据库 (Vector Database)
  - 语义搜索 (Semantic Search)
  - 上下文管理 (Context Management)
  - 示例学习 (Few-shot Learning)

开发工具:
  - LLM API (OpenAI, Anthropic, etc.)
  - 提示模板引擎
  - 嵌入模型
  - 向量存储

### 插件技术栈

核心技术:
- 编程语言 (Python, JavaScript, etc.)
- 框架 (Flask, Express, etc.)
- 数据库 (SQL, NoSQL)
- API 设计
辅助技术:
- 类型系统 (TypeScript, Pydantic)
- 依赖注入 (Dependency Injection)
- 测试框架 (pytest, Jest)
- 容器化 (Docker, Kubernetes)
开发工具:
- IDE (VS Code, IntelliJ)
- 版本控制 (Git)
- 包管理器 (npm, pip)
- CI/CD (GitHub Actions, Jenkins)
```

```
yaml

核心技术:
  - 大语言模型 (LLM)
  - 自然语言处理 (NLP)
  - 提示工程 (Prompt Engineering)
  - 嵌入向量 (Embeddings)

辅助技术:
  - 向量数据库 (Vector Database)
  - 语义搜索 (Semantic Search)
  - 上下文管理 (Context Management)
  - 示例学习 (Few-shot Learning)

开发工具:
  - LLM API (OpenAI, Anthropic, etc.)
  - 提示模板引擎
  - 嵌入模型
  - 向量存储

### 插件技术栈

核心技术:
- 编程语言 (Python, JavaScript, etc.)
- 框架 (Flask, Express, etc.)
- 数据库 (SQL, NoSQL)
- API 设计
辅助技术:
- 类型系统 (TypeScript, Pydantic)
- 依赖注入 (Dependency Injection)
- 测试框架 (pytest, Jest)
- 容器化 (Docker, Kubernetes)
开发工具:
- IDE (VS Code, IntelliJ)
- 版本控制 (Git)
- 包管理器 (npm, pip)
- CI/CD (GitHub Actions, Jenkins)
```

#### 19.3.5 性能对比#

##### 执行时间对比#

```
python复制
# Skills 执行时间
def execute_skill(user_input):
    start_time = time.time()

    # LLM 解析：~500ms
    intent = parse_intent(user_input)

    # 参数提取：~300ms
    parameters = extract_parameters(user_input)

    # 技能执行：~200ms
    result = execute_skill_logic(parameters)

    # 结果生成：~500ms
    formatted_result = format_result(result)

    end_time = time.time()
    return end_time - start_time  # ~1.5s

# 插件执行时间
def execute_plugin(method_name, parameters):
    start_time = time.time()

    # 参数验证：~10ms
    validate_parameters(parameters)

    # 方法执行：~50ms
    result = execute_method(method_name, parameters)

    # 结果处理：~10ms
    formatted_result = process_result(result)

    end_time = time.time()
    return end_time - start_time  # ~70ms

### 资源消耗对比

| 资源类型 | Skills | 插件 |
|----------|--------|------|
| CPU 使用 | 中等 | 低 |
| 内存使用 | 高 | 低 |
| 网络带宽 | 高 | 低 |
| 磁盘 I/O | 低 | 中 |
| GPU 使用 | 高 | 低 |
| 并发能力 | 低 | 高 |

## 19.3.6 可维护性对比

### Skills 可维护性

> **优势**：
- 代码量少，易于理解
- 自然语言描述，易于修改
- 无需编译，快速迭代

> **劣势**：
- 依赖 LLM 行为，难以预测
- 调试困难，难以定位问题
- 版本控制复杂，提示变化影响大

### 插件可维护性

> **优势**：
- 代码结构清晰，易于理解
- 调试工具完善，易于定位问题
- 版本控制成熟，变更可追踪

> **劣势**：
- 代码量大，维护成本高
- 需要编译和测试，迭代较慢
- 依赖管理复杂

## 19.3.7 可扩展性对比

### Skills 可扩展性

# 扩展 Skills：添加新功能
class ExtendedSkill(Skill):
def __init__(self):
super().__init__()
self.new_feature = None
def add_feature(self, feature):
"""添加新功能"""
self.new_feature = feature
return True
def execute(self, parameters, context):
# 使用新功能
if self.new_feature:
result = self.new_feature.process(parameters)
else:
result = super().execute(parameters, context)
return result
```

```
# Skills 执行时间
def execute_skill(user_input):
    start_time = time.time()

    # LLM 解析：~500ms
    intent = parse_intent(user_input)

    # 参数提取：~300ms
    parameters = extract_parameters(user_input)

    # 技能执行：~200ms
    result = execute_skill_logic(parameters)

    # 结果生成：~500ms
    formatted_result = format_result(result)

    end_time = time.time()
    return end_time - start_time  # ~1.5s

# 插件执行时间
def execute_plugin(method_name, parameters):
    start_time = time.time()

    # 参数验证：~10ms
    validate_parameters(parameters)

    # 方法执行：~50ms
    result = execute_method(method_name, parameters)

    # 结果处理：~10ms
    formatted_result = process_result(result)

    end_time = time.time()
    return end_time - start_time  # ~70ms

### 资源消耗对比

| 资源类型 | Skills | 插件 |
|----------|--------|------|
| CPU 使用 | 中等 | 低 |
| 内存使用 | 高 | 低 |
| 网络带宽 | 高 | 低 |
| 磁盘 I/O | 低 | 中 |
| GPU 使用 | 高 | 低 |
| 并发能力 | 低 | 高 |

## 19.3.6 可维护性对比

### Skills 可维护性

> **优势**：
- 代码量少，易于理解
- 自然语言描述，易于修改
- 无需编译，快速迭代

> **劣势**：
- 依赖 LLM 行为，难以预测
- 调试困难，难以定位问题
- 版本控制复杂，提示变化影响大

### 插件可维护性

> **优势**：
- 代码结构清晰，易于理解
- 调试工具完善，易于定位问题
- 版本控制成熟，变更可追踪

> **劣势**：
- 代码量大，维护成本高
- 需要编译和测试，迭代较慢
- 依赖管理复杂

## 19.3.7 可扩展性对比

### Skills 可扩展性

# 扩展 Skills：添加新功能
class ExtendedSkill(Skill):
def __init__(self):
super().__init__()
self.new_feature = None
def add_feature(self, feature):
"""添加新功能"""
self.new_feature = feature
return True
def execute(self, parameters, context):
# 使用新功能
if self.new_feature:
result = self.new_feature.process(parameters)
else:
result = super().execute(parameters, context)
return result
```

##### 插件可扩展性#

```
python复制
# 扩展插件：添加新功能
class ExtendedPlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.features = {}

    def register_feature(self, name, feature):
        """注册新功能"""
        self.features[name] = feature
        return True

    def execute_feature(self, name, parameters):
        """执行功能"""
        feature = self.features.get(name)
        if not feature:
            raise FeatureNotFoundError(name)

        return feature.execute(parameters)

## 19.3.8 安全性对比

### Skills 安全性

> **安全挑战**：
- 提示注入攻击
- 敏感信息泄露
- 不可预测的行为
- 难以审计

> **安全措施**：
class SecureSkill(Skill):
def sanitize_input(self, user_input):
"""清理输入"""
# 移除敏感信息
sanitized = self.remove_sensitive_info(user_input)
# 检测注入攻击
if self.detect_injection(sanitized):
raise SecurityError("检测到注入攻击")
return sanitized
def sanitize_output(self, output):
"""清理输出"""
# 移除敏感信息
sanitized = self.remove_sensitive_info(output)
# 添加安全警告
if self.contains_potentially_harmful_content(sanitized):
sanitized = self.add_security_warning(sanitized)
return sanitized
```

```
# 扩展插件：添加新功能
class ExtendedPlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.features = {}

    def register_feature(self, name, feature):
        """注册新功能"""
        self.features[name] = feature
        return True

    def execute_feature(self, name, parameters):
        """执行功能"""
        feature = self.features.get(name)
        if not feature:
            raise FeatureNotFoundError(name)

        return feature.execute(parameters)

## 19.3.8 安全性对比

### Skills 安全性

> **安全挑战**：
- 提示注入攻击
- 敏感信息泄露
- 不可预测的行为
- 难以审计

> **安全措施**：
class SecureSkill(Skill):
def sanitize_input(self, user_input):
"""清理输入"""
# 移除敏感信息
sanitized = self.remove_sensitive_info(user_input)
# 检测注入攻击
if self.detect_injection(sanitized):
raise SecurityError("检测到注入攻击")
return sanitized
def sanitize_output(self, output):
"""清理输出"""
# 移除敏感信息
sanitized = self.remove_sensitive_info(output)
# 添加安全警告
if self.contains_potentially_harmful_content(sanitized):
sanitized = self.add_security_warning(sanitized)
return sanitized
```

##### 插件安全性#

- 代码静态分析
- 类型安全
- 访问控制
- 审计日志
安全措施：

```
python复制
class SecurePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.access_control = AccessControl()
        self.audit_logger = AuditLogger()

    def execute(self, method_name, parameters, user):
        """执行方法"""
        # 检查访问权限
        if not self.access_control.check_permission(user, method_name):
            raise PermissionError("无权限访问")

        # 记录审计日志
        self.audit_logger.log(user, method_name, parameters)

        # 执行方法
        result = super().execute(method_name, parameters)

        return result
```

```
class SecurePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.access_control = AccessControl()
        self.audit_logger = AuditLogger()

    def execute(self, method_name, parameters, user):
        """执行方法"""
        # 检查访问权限
        if not self.access_control.check_permission(user, method_name):
            raise PermissionError("无权限访问")

        # 记录审计日志
        self.audit_logger.log(user, method_name, parameters)

        # 执行方法
        result = super().execute(method_name, parameters)

        return result
```

---

## 4 性能与安全对比

**URL**: https://claudecode.tangshuang.net/course/19.4%20%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8%E5%AF%B9%E6%AF%94

#### 19.4.1 性能对比#

##### 1. 执行性能#

###### Skills 执行性能

Skills 的执行性能主要受限于 LLM 的推理时间和网络延迟。

```
python复制# Skills 执行时间分解
class SkillPerformanceMetrics:
    def __init__(self):
        self.metrics = {
            "intent_parsing": 0,      # 意图解析时间
            "parameter_extraction": 0,  # 参数提取时间
            "skill_execution": 0,       # 技能执行时间
            "result_generation": 0,     # 结果生成时间
            "total_time": 0            # 总时间
        }

    def measure_execution(self, skill, user_input):
        """测量执行时间"""
        start_time = time.time()

        # 意图解析
        intent_start = time.time()
        intent = self.parse_intent(user_input)
        self.metrics["intent_parsing"] = time.time() - intent_start

        # 参数提取
        param_start = time.time()
        parameters = self.extract_parameters(user_input, intent)
        self.metrics["parameter_extraction"] = time.time() - param_start

        # 技能执行
        exec_start = time.time()
        result = skill.execute(parameters)
        self.metrics["skill_execution"] = time.time() - exec_start

        # 结果生成
        gen_start = time.time()
        formatted_result = self.format_result(result)
        self.metrics["result_generation"] = time.time() - gen_start

        self.metrics["total_time"] = time.time() - start_time

        return formatted_result
```

```
# Skills 执行时间分解
class SkillPerformanceMetrics:
    def __init__(self):
        self.metrics = {
            "intent_parsing": 0,      # 意图解析时间
            "parameter_extraction": 0,  # 参数提取时间
            "skill_execution": 0,       # 技能执行时间
            "result_generation": 0,     # 结果生成时间
            "total_time": 0            # 总时间
        }

    def measure_execution(self, skill, user_input):
        """测量执行时间"""
        start_time = time.time()

        # 意图解析
        intent_start = time.time()
        intent = self.parse_intent(user_input)
        self.metrics["intent_parsing"] = time.time() - intent_start

        # 参数提取
        param_start = time.time()
        parameters = self.extract_parameters(user_input, intent)
        self.metrics["parameter_extraction"] = time.time() - param_start

        # 技能执行
        exec_start = time.time()
        result = skill.execute(parameters)
        self.metrics["skill_execution"] = time.time() - exec_start

        # 结果生成
        gen_start = time.time()
        formatted_result = self.format_result(result)
        self.metrics["result_generation"] = time.time() - gen_start

        self.metrics["total_time"] = time.time() - start_time

        return formatted_result
```

### 典型执行时间（毫秒）

### 意图解析：300-500ms

### 参数提取：200-400ms

### 技能执行：100-300ms

### 结果生成：400-600ms

### 总时间：1000-1800ms

性能优化策略：

```
python复制class OptimizedSkill(Skill):
    def __init__(self):
        super().__init__()
        self.cache = {}  # 缓存常用请求
        self.intent_classifier = self.load_intent_classifier()  # 预训练分类器

    def parse_intent(self, user_input):
        """优化意图解析"""
        # 1. 检查缓存
        cache_key = self.get_cache_key(user_input)
        if cache_key in self.cache:
            return self.cache[cache_key]

        # 2. 使用预训练分类器（快速）
        intent = self.intent_classifier.predict(user_input)

        # 3. 缓存结果
        self.cache[cache_key] = intent

        return intent

    def execute(self, parameters, context):
        """优化执行"""
        # 批处理请求
        if isinstance(parameters, list):
            return self.batch_execute(parameters, context)

        # 单个请求执行
        return super().execute(parameters, context)

    def batch_execute(self, parameters_list, context):
        """批量执行"""
        results = []
        for parameters in parameters_list:
            result = super().execute(parameters, context)
            results.append(result)
        return results
```

```
class OptimizedSkill(Skill):
    def __init__(self):
        super().__init__()
        self.cache = {}  # 缓存常用请求
        self.intent_classifier = self.load_intent_classifier()  # 预训练分类器

    def parse_intent(self, user_input):
        """优化意图解析"""
        # 1. 检查缓存
        cache_key = self.get_cache_key(user_input)
        if cache_key in self.cache:
            return self.cache[cache_key]

        # 2. 使用预训练分类器（快速）
        intent = self.intent_classifier.predict(user_input)

        # 3. 缓存结果
        self.cache[cache_key] = intent

        return intent

    def execute(self, parameters, context):
        """优化执行"""
        # 批处理请求
        if isinstance(parameters, list):
            return self.batch_execute(parameters, context)

        # 单个请求执行
        return super().execute(parameters, context)

    def batch_execute(self, parameters_list, context):
        """批量执行"""
        results = []
        for parameters in parameters_list:
            result = super().execute(parameters, context)
            results.append(result)
        return results
```

###### 插件执行性能

插件的执行性能主要取决于代码效率和系统资源。

### 插件执行时间分解

class PluginPerformanceMetrics:
def init(self):
self.metrics = {
"parameter_validation": 0,  # 参数验证时间
"method_execution": 0,      # 方法执行时间
"result_processing": 0,     # 结果处理时间
"total_time": 0             # 总时间
}
def measure_execution(self, plugin, method_name, parameters):
"""测量执行时间"""
start_time = time.time()

### 参数验证

valid_start = time.time()
self.validate_parameters(plugin, method_name, parameters)
self.metrics["parameter_validation"] = time.time() - valid_start

### 方法执行

exec_start = time.time()
result = getattr(plugin, method_name)(**parameters)
self.metrics["method_execution"] = time.time() - exec_start

### 结果处理

proc_start = time.time()
formatted_result = self.process_result(result)
self.metrics["result_processing"] = time.time() - proc_start
self.metrics["total_time"] = time.time() - start_time
return formatted_result

### 典型执行时间（毫秒）

### 参数验证：5-15ms

### 方法执行：20-100ms

### 结果处理：5-10ms

### 总时间：30-125ms

```
bash复制**性能优化策略**：
```python

class OptimizedPlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.cache = LRUCache(maxsize=1000)  # LRU 缓存
        self.connection_pool = ConnectionPool(size=10)  # 连接池
        self.thread_pool = ThreadPoolExecutor(max_workers=4)  # 线程池

    def execute(self, method_name, parameters):
        """优化执行"""
        # 1. 检查缓存
        cache_key = self.get_cache_key(method_name, parameters)
        cached_result = self.cache.get(cache_key)
        if cached_result:
            return cached_result

        # 2. 使用连接池
```

```
**性能优化策略**：
```python

class OptimizedPlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.cache = LRUCache(maxsize=1000)  # LRU 缓存
        self.connection_pool = ConnectionPool(size=10)  # 连接池
        self.thread_pool = ThreadPoolExecutor(max_workers=4)  # 线程池

    def execute(self, method_name, parameters):
        """优化执行"""
        # 1. 检查缓存
        cache_key = self.get_cache_key(method_name, parameters)
        cached_result = self.cache.get(cache_key)
        if cached_result:
            return cached_result

        # 2. 使用连接池
```

```
bash复制    with self.connection_pool.get_connection() as conn:
        # 3. 异步执行
        future = self.thread_pool.submit(
            self._execute_method,
            method_name,
            parameters,
            conn
        )
        result = future.result(timeout=10)

    # 4. 缓存结果
    self.cache.set(cache_key, result)

    return result

def _execute_method(self, method_name, parameters, conn):
    """执行方法"""
    method = getattr(self, method_name)
    return method(**parameters, connection=conn)
```

```
with self.connection_pool.get_connection() as conn:
        # 3. 异步执行
        future = self.thread_pool.submit(
            self._execute_method,
            method_name,
            parameters,
            conn
        )
        result = future.result(timeout=10)

    # 4. 缓存结果
    self.cache.set(cache_key, result)

    return result

def _execute_method(self, method_name, parameters, conn):
    """执行方法"""
    method = getattr(self, method_name)
    return method(**parameters, connection=conn)
```

##### 2. 并发性能#

###### Skills 并发性能

Skills 的并发性能受限于 LLM API 的并发限制。

class SkillConcurrencyManager:
def init(self, max_concurrent=5):
self.semaphore = asyncio.Semaphore(max_concurrent)
self.request_queue = asyncio.Queue()
async def execute_skill(self, skill, user_input):
"""异步执行技能"""
async with self.semaphore:
return await skill.execute_async(user_input)
async def batch_execute(self, skill, user_inputs):
"""批量执行"""
tasks = [
self.execute_skill(skill, user_input)
for user_input in user_inputs
]
return await asyncio.gather(*tasks)

```
bash复制# 性能指标
# 单个请求：1000-1800ms
# 并发 5 个：1200-2000ms（每个）
# 并发 10 个：1500-2500ms（每个）
# 并发 20 个：2000-3500ms（每个）
```

```
# 性能指标
# 单个请求：1000-1800ms
# 并发 5 个：1200-2000ms（每个）
# 并发 10 个：1500-2500ms（每个）
# 并发 20 个：2000-3500ms（每个）
```

###### 插件并发性能

插件的并发性能主要取决于系统资源和代码设计。

```
python复制
class PluginConcurrencyManager:
    def __init__(self, max_workers=10):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.async_executor = ProcessPoolExecutor(max_workers=max_workers)

    def execute_plugin(self, plugin, method_name, parameters):
        """同步执行"""
        future = self.executor.submit(
            self._execute_sync,
            plugin,
            method_name,
            parameters
        )
        return future.result(timeout=30)

    async def execute_plugin_async(self, plugin, method_name, parameters):
        """异步执行"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            self.executor,
            self._execute_sync,
            plugin,
            method_name,
            parameters
        )

    def batch_execute(self, plugin, method_name, parameters_list):
        """批量执行"""
        futures = [
            self.executor.submit(
                self._execute_sync,
                plugin,
                method_name,
                parameters
            )
            for parameters in parameters_list
        ]
        return [future.result() for future in futures]
```

```
class PluginConcurrencyManager:
    def __init__(self, max_workers=10):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.async_executor = ProcessPoolExecutor(max_workers=max_workers)

    def execute_plugin(self, plugin, method_name, parameters):
        """同步执行"""
        future = self.executor.submit(
            self._execute_sync,
            plugin,
            method_name,
            parameters
        )
        return future.result(timeout=30)

    async def execute_plugin_async(self, plugin, method_name, parameters):
        """异步执行"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            self.executor,
            self._execute_sync,
            plugin,
            method_name,
            parameters
        )

    def batch_execute(self, plugin, method_name, parameters_list):
        """批量执行"""
        futures = [
            self.executor.submit(
                self._execute_sync,
                plugin,
                method_name,
                parameters
            )
            for parameters in parameters_list
        ]
        return [future.result() for future in futures]
```

### 性能指标

### 单个请求：30-125ms

### 并发 10 个：40-150ms（每个）

### 并发 50 个：60-200ms（每个）

### 并发 100 个：100-300ms（每个）

##### 3. 资源消耗#

###### Skills 资源消耗

class SkillResourceMonitor:
def init(self):
self.metrics = {
"cpu_usage": [],      # CPU 使用率
"memory_usage": [],    # 内存使用
"network_io": [],     # 网络 I/O
"api_calls": 0        # API 调用次数
}
def monitor_execution(self, skill, user_input):
"""监控执行过程"""
import psutil

### 记录初始状态

process = psutil.Process()
initial_cpu = process.cpu_percent()
initial_memory = process.memory_info().rss

### 执行技能

result = skill.execute(user_input)

### 记录最终状态

final_cpu = process.cpu_percent()
final_memory = process.memory_info().rss

### 计算资源消耗

self.metrics["cpu_usage"].append(final_cpu - initial_cpu)
self.metrics["memory_usage"].append(final_memory - initial_memory)
self.metrics["api_calls"] += 1
return result

### 典型资源消耗

### CPU 使用率：10-30%

### 内存使用：100-500MB

### 网络 I/O：1-5MB/请求

### API 调用：2-4 次/请求

```
bash复制#### 插件资源消耗
```python

class PluginResourceMonitor:
    def __init__(self):
        self.metrics = {
            "cpu_usage": [],      # CPU 使用率
            "memory_usage": [],    # 内存使用
            "disk_io": [],        # 磁盘 I/O
            "network_io": []      # 网络 I/O
        }

    def monitor_execution(self, plugin, method_name, parameters):
        """监控执行过程"""
        import psutil

        # 记录初始状态
        process = psutil.Process()
        initial_cpu = process.cpu_percent()
        initial_memory = process.memory_info().rss
        initial_disk_io = process.io_counters()
        initial_network_io = psutil.net_io_counters()

        # 执行插件方法
        result = getattr(plugin, method_name)(**parameters)

        # 记录最终状态
        final_cpu = process.cpu_percent()
        final_memory = process.memory_info().rss
        final_disk_io = process.io_counters()
        final_network_io = psutil.net_io_counters()

        # 计算资源消耗
        self.metrics["cpu_usage"].append(final_cpu - initial_cpu)
        self.metrics["memory_usage"].append(final_memory - initial_memory)
        self.metrics["disk_io"].append(
            final_disk_io.write_bytes - initial_disk_io.write_bytes
        )
        self.metrics["network_io"].append(
            final_network_io.bytes_sent - initial_network_io.bytes_sent
        )

        return result
```

```
#### 插件资源消耗
```python

class PluginResourceMonitor:
    def __init__(self):
        self.metrics = {
            "cpu_usage": [],      # CPU 使用率
            "memory_usage": [],    # 内存使用
            "disk_io": [],        # 磁盘 I/O
            "network_io": []      # 网络 I/O
        }

    def monitor_execution(self, plugin, method_name, parameters):
        """监控执行过程"""
        import psutil

        # 记录初始状态
        process = psutil.Process()
        initial_cpu = process.cpu_percent()
        initial_memory = process.memory_info().rss
        initial_disk_io = process.io_counters()
        initial_network_io = psutil.net_io_counters()

        # 执行插件方法
        result = getattr(plugin, method_name)(**parameters)

        # 记录最终状态
        final_cpu = process.cpu_percent()
        final_memory = process.memory_info().rss
        final_disk_io = process.io_counters()
        final_network_io = psutil.net_io_counters()

        # 计算资源消耗
        self.metrics["cpu_usage"].append(final_cpu - initial_cpu)
        self.metrics["memory_usage"].append(final_memory - initial_memory)
        self.metrics["disk_io"].append(
            final_disk_io.write_bytes - initial_disk_io.write_bytes
        )
        self.metrics["network_io"].append(
            final_network_io.bytes_sent - initial_network_io.bytes_sent
        )

        return result
```

### 典型资源消耗

### CPU 使用率：5-15%

### 内存使用：50-200MB

### 磁盘 I/O：100KB-10MB/请求

### 网络 I/O：100KB-1MB/请求

##### 4. 性能对比表#

#### 19.4.2 安全对比#

##### 1. 输入安全#

###### Skills 输入安全

Skills 需要防范提示注入攻击和敏感信息泄露。

class SkillInputSecurity:
def init(self):
self.injection_patterns = [
r"ignore.*instructions",
r"forget.*previous",
r"new.*instructions",
r"override.*system"
]
self.sensitive_keywords = [
"password", "token", "api_key",
"secret", "credential"
]
def sanitize_input(self, user_input):
"""清理输入"""
import re

### 1. 检测注入攻击

for pattern in self.injection_patterns:
if re.search(pattern, user_input, re.IGNORECASE):
raise SecurityError("检测到潜在的注入攻击")

### 2. 移除敏感信息

sanitized = user_input
for keyword in self.sensitive_keywords:

### 使用占位符替换敏感信息

pattern = rf"{keyword}\s*[:=]\s*[^\s]+"
sanitized = re.sub(pattern, f"{keyword}=REDACTED", sanitized, flags=re.IGNORECASE)

### 3. 限制输入长度

max_length = 10000
if len(sanitized) > max_length:
sanitized = sanitized[:max_length]
return sanitized
def validate_input(self, user_input):
"""验证输入"""

### 检查恶意代码

if self.contains_malicious_code(user_input):
raise SecurityError("输入包含恶意代码")

### 检查特殊字符

if self.contains_dangerous_characters(user_input):
raise SecurityError("输入包含危险字符")
return True

```
bash复制#### 插件输入安全
插件通过类型系统和验证规则确保输入安全。
```python

from pydantic import BaseModel, validator, constr
from typing import Optional

class SecureInput(BaseModel):
    """安全输入模型"""
    username: constr(min_length=3, max_length=50)
    email: str
    message: constr(max_length=1000)

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        return v

    @validator('email')
    def email_valid(cls, v):
        import re
        if not re.match(r'^[^@]+@[^@]+\.[^@]+$', v):
            raise ValueError('邮箱格式无效')
        return v

    @validator('message')
    def message_safe(cls, v):
        # 检查 XSS 攻击
        dangerous_patterns = ['<script>', 'javascript:', 'onerror=']
        for pattern in dangerous_patterns:
            if pattern.lower() in v.lower():
                raise ValueError('消息包含潜在危险内容')
        return v

class PluginInputSecurity:
    def __init__(self):
        self.input_model = SecureInput

    def validate_input(self, parameters):
        """验证输入"""
        try:
            validated = self.input_model(**parameters)
            return validated.dict()
        except Exception as e:
            raise SecurityError(f"输入验证失败: {str(e)}")

### 2. 输出安全

#### Skills 输出安全

Skills 需要防止输出敏感信息和有害内容。

class SkillOutputSecurity:
def __init__(self):
self.sensitive_patterns = [
r"password\s*[:=]\s*\S+",
r"token\s*[:=]\s*\S+",
r"api[_-]?key\s*[:=]\s*\S+"
]
self.harmful_categories = [
"violence", "hate", "sexual",
"self-harm", "illegal"
]
def sanitize_output(self, output):
"""清理输出"""
import re
# 1. 移除敏感信息
sanitized = output
for pattern in self.sensitive_patterns:
sanitized = re.sub(pattern, "***REDACTED***", sanitized, flags=re.IGNORECASE)
# 2. 检查有害内容
if self.contains_harmful_content(sanitized):
sanitized = self.add_warning(sanitized, "内容可能包含有害信息")
# 3. 限制输出长度
max_length = 50000
if len(sanitized) > max_length:
sanitized = sanitized[:max_length] + "\n\n[输出已截断]"
return sanitized
def contains_harmful_content(self, text):
"""检查有害内容"""
```

```
#### 插件输入安全
插件通过类型系统和验证规则确保输入安全。
```python

from pydantic import BaseModel, validator, constr
from typing import Optional

class SecureInput(BaseModel):
    """安全输入模型"""
    username: constr(min_length=3, max_length=50)
    email: str
    message: constr(max_length=1000)

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        return v

    @validator('email')
    def email_valid(cls, v):
        import re
        if not re.match(r'^[^@]+@[^@]+\.[^@]+$', v):
            raise ValueError('邮箱格式无效')
        return v

    @validator('message')
    def message_safe(cls, v):
        # 检查 XSS 攻击
        dangerous_patterns = ['<script>', 'javascript:', 'onerror=']
        for pattern in dangerous_patterns:
            if pattern.lower() in v.lower():
                raise ValueError('消息包含潜在危险内容')
        return v

class PluginInputSecurity:
    def __init__(self):
        self.input_model = SecureInput

    def validate_input(self, parameters):
        """验证输入"""
        try:
            validated = self.input_model(**parameters)
            return validated.dict()
        except Exception as e:
            raise SecurityError(f"输入验证失败: {str(e)}")

### 2. 输出安全

#### Skills 输出安全

Skills 需要防止输出敏感信息和有害内容。

class SkillOutputSecurity:
def __init__(self):
self.sensitive_patterns = [
r"password\s*[:=]\s*\S+",
r"token\s*[:=]\s*\S+",
r"api[_-]?key\s*[:=]\s*\S+"
]
self.harmful_categories = [
"violence", "hate", "sexual",
"self-harm", "illegal"
]
def sanitize_output(self, output):
"""清理输出"""
import re
# 1. 移除敏感信息
sanitized = output
for pattern in self.sensitive_patterns:
sanitized = re.sub(pattern, "***REDACTED***", sanitized, flags=re.IGNORECASE)
# 2. 检查有害内容
if self.contains_harmful_content(sanitized):
sanitized = self.add_warning(sanitized, "内容可能包含有害信息")
# 3. 限制输出长度
max_length = 50000
if len(sanitized) > max_length:
sanitized = sanitized[:max_length] + "\n\n[输出已截断]"
return sanitized
def contains_harmful_content(self, text):
"""检查有害内容"""
```

### 使用内容审核 API

### 这里简化实现

harmful_keywords = ["暴力", "仇恨", "非法"]
for keyword in harmful_keywords:
if keyword in text:
return True
return False
def add_warning(self, text, warning):
"""添加警告"""
return f"[警告: {warning}]\n\n{text}"

```
bash复制#### 插件输出安全
插件通过数据过滤和编码确保输出安全。
```python

class PluginOutputSecurity:
    def __init__(self):
        self.html_escape_map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;'
        }

    def sanitize_output(self, output):
        """清理输出"""
        # 1. HTML 转义
        if isinstance(output, str):
            output = self.html_escape(output)

        # 2. JSON 编码
        if isinstance(output, dict):
            output = self.json_encode(output)

        # 3. 移除敏感字段
        if isinstance(output, dict):
            output = self.remove_sensitive_fields(output)

        return output

    def html_escape(self, text):
        """HTML 转义"""
        result = []
        for char in text:
            result.append(self.html_escape_map.get(char, char))
        return ''.join(result)

    def json_encode(self, data):
        """JSON 编码"""
        import json
        return json.dumps(data, ensure_ascii=False)

    def remove_sensitive_fields(self, data):
        """移除敏感字段"""
        sensitive_fields = ['password', 'token', 'secret']
        return {
            k: v for k, v in data.items()
            if k not in sensitive_fields
        }

### 3. 访问控制

#### Skills 访问控制

Skills 的访问控制相对宽松，主要依赖 LLM 的理解能力。

class SkillAccessControl:
def __init__(self):
self.permissions = {
"admin": ["all"],
"user": ["read", "write"],
"guest": ["read"]
}
def check_permission(self, user, skill_name, action):
"""检查权限"""
user_role = user.get("role", "guest")
user_permissions = self.permissions.get(user_role, [])
if "all" in user_permissions:
return True
if action in user_permissions:
return True
raise PermissionError(f"用户 {user['username']} 无权限执行 {action}")
def filter_sensitive_data(self, user, data):
"""过滤敏感数据"""
user_role = user.get("role", "guest")
if user_role == "admin":
return data
# 移除敏感字段
filtered = data.copy()
sensitive_fields = ["internal_notes", "admin_only"]
for field in sensitive_fields:
filtered.pop(field, None)
return filtered
```

```
#### 插件输出安全
插件通过数据过滤和编码确保输出安全。
```python

class PluginOutputSecurity:
    def __init__(self):
        self.html_escape_map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;'
        }

    def sanitize_output(self, output):
        """清理输出"""
        # 1. HTML 转义
        if isinstance(output, str):
            output = self.html_escape(output)

        # 2. JSON 编码
        if isinstance(output, dict):
            output = self.json_encode(output)

        # 3. 移除敏感字段
        if isinstance(output, dict):
            output = self.remove_sensitive_fields(output)

        return output

    def html_escape(self, text):
        """HTML 转义"""
        result = []
        for char in text:
            result.append(self.html_escape_map.get(char, char))
        return ''.join(result)

    def json_encode(self, data):
        """JSON 编码"""
        import json
        return json.dumps(data, ensure_ascii=False)

    def remove_sensitive_fields(self, data):
        """移除敏感字段"""
        sensitive_fields = ['password', 'token', 'secret']
        return {
            k: v for k, v in data.items()
            if k not in sensitive_fields
        }

### 3. 访问控制

#### Skills 访问控制

Skills 的访问控制相对宽松，主要依赖 LLM 的理解能力。

class SkillAccessControl:
def __init__(self):
self.permissions = {
"admin": ["all"],
"user": ["read", "write"],
"guest": ["read"]
}
def check_permission(self, user, skill_name, action):
"""检查权限"""
user_role = user.get("role", "guest")
user_permissions = self.permissions.get(user_role, [])
if "all" in user_permissions:
return True
if action in user_permissions:
return True
raise PermissionError(f"用户 {user['username']} 无权限执行 {action}")
def filter_sensitive_data(self, user, data):
"""过滤敏感数据"""
user_role = user.get("role", "guest")
if user_role == "admin":
return data
# 移除敏感字段
filtered = data.copy()
sensitive_fields = ["internal_notes", "admin_only"]
for field in sensitive_fields:
filtered.pop(field, None)
return filtered
```

###### 插件访问控制

插件可以实现细粒度的访问控制。

```
python复制
from functools import wraps

class PluginAccessControl:
    def __init__(self):
        self.roles = {
            "admin": {"priority": 100},
            "user": {"priority": 50},
            "guest": {"priority": 10}
        }
        self.permissions = {}

    def require_permission(self, permission):
        """权限装饰器"""
        def decorator(func):
            @wraps(func)
            def wrapper(self, *args, **kwargs):
                user = kwargs.get('user', None)
                if not user:
                    raise PermissionError("需要用户认证")

                if not self.has_permission(user, permission):
                    raise PermissionError(f"缺少权限: {permission}")

                return func(self, *args, **kwargs)
            return wrapper
        return decorator

    def has_permission(self, user, permission):
        """检查权限"""
        user_role = user.get("role", "guest")
        role_info = self.roles.get(user_role, {})
        user_permissions = self.permissions.get(user_role, set())

        return permission in user_permissions or "all" in user_permissions

    def add_permission(self, role, permission):
        """添加权限"""
        if role not in self.permissions:
            self.permissions[role] = set()
        self.permissions[role].add(permission)

# 使用示例
class SecurePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.access_control = PluginAccessControl()

    @PluginAccessControl.require_permission("read")
    def read_data(self, user, data_id):
        """读取数据"""
        return self._read_data(data_id)

    @PluginAccessControl.require_permission("write")
    def write_data(self, user, data_id, data):
        """写入数据"""
        return self._write_data(data_id, data)

### 4. 审计日志

#### Skills 审计日志

class SkillAuditLogger:
def __init__(self):
self.logs = []
def log_execution(self, skill_name, user_input, result, user):
"""记录执行"""
log_entry = {
"timestamp": datetime.now().isoformat(),
"skill_name": skill_name,
"user": user.get("username", "anonymous"),
"input": self.sanitize_input(user_input),
"output": self.sanitize_output(result),
"success": result.get("success", False),
"duration": result.get("duration", 0)
}
self.logs.append(log_entry)
def get_logs(self, user=None, skill_name=None, start_time=None, end_time=None):
"""获取日志"""
filtered_logs = self.logs
if user:
filtered_logs = [log for log in filtered_logs if log["user"] == user]
if skill_name:
filtered_logs = [log for log in filtered_logs if log["skill_name"] == skill_name]
if start_time:
filtered_logs = [log for log in filtered_logs if log["timestamp"] >= start_time]
if end_time:
filtered_logs = [log for log in filtered_logs if log["timestamp"] <= end_time]
return filtered_logs
```

```
from functools import wraps

class PluginAccessControl:
    def __init__(self):
        self.roles = {
            "admin": {"priority": 100},
            "user": {"priority": 50},
            "guest": {"priority": 10}
        }
        self.permissions = {}

    def require_permission(self, permission):
        """权限装饰器"""
        def decorator(func):
            @wraps(func)
            def wrapper(self, *args, **kwargs):
                user = kwargs.get('user', None)
                if not user:
                    raise PermissionError("需要用户认证")

                if not self.has_permission(user, permission):
                    raise PermissionError(f"缺少权限: {permission}")

                return func(self, *args, **kwargs)
            return wrapper
        return decorator

    def has_permission(self, user, permission):
        """检查权限"""
        user_role = user.get("role", "guest")
        role_info = self.roles.get(user_role, {})
        user_permissions = self.permissions.get(user_role, set())

        return permission in user_permissions or "all" in user_permissions

    def add_permission(self, role, permission):
        """添加权限"""
        if role not in self.permissions:
            self.permissions[role] = set()
        self.permissions[role].add(permission)

# 使用示例
class SecurePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.access_control = PluginAccessControl()

    @PluginAccessControl.require_permission("read")
    def read_data(self, user, data_id):
        """读取数据"""
        return self._read_data(data_id)

    @PluginAccessControl.require_permission("write")
    def write_data(self, user, data_id, data):
        """写入数据"""
        return self._write_data(data_id, data)

### 4. 审计日志

#### Skills 审计日志

class SkillAuditLogger:
def __init__(self):
self.logs = []
def log_execution(self, skill_name, user_input, result, user):
"""记录执行"""
log_entry = {
"timestamp": datetime.now().isoformat(),
"skill_name": skill_name,
"user": user.get("username", "anonymous"),
"input": self.sanitize_input(user_input),
"output": self.sanitize_output(result),
"success": result.get("success", False),
"duration": result.get("duration", 0)
}
self.logs.append(log_entry)
def get_logs(self, user=None, skill_name=None, start_time=None, end_time=None):
"""获取日志"""
filtered_logs = self.logs
if user:
filtered_logs = [log for log in filtered_logs if log["user"] == user]
if skill_name:
filtered_logs = [log for log in filtered_logs if log["skill_name"] == skill_name]
if start_time:
filtered_logs = [log for log in filtered_logs if log["timestamp"] >= start_time]
if end_time:
filtered_logs = [log for log in filtered_logs if log["timestamp"] <= end_time]
return filtered_logs
```

###### 插件审计日志

```
python复制
class PluginAuditLogger:
    def __init__(self):
        self.logs = []
        self.max_logs = 10000

    def log_execution(self, plugin_name, method_name, parameters, result, user):
        """记录执行"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "plugin_name": plugin_name,
            "method_name": method_name,
            "user": user.get("username", "anonymous"),
            "parameters": self.sanitize_parameters(parameters),
            "result": self.sanitize_result(result),
            "success": result.get("success", False),
            "duration": result.get("duration", 0),
            "ip_address": user.get("ip_address", "unknown")
        }

        self.logs.append(log_entry)

        # 限制日志数量
        if len(self.logs) > self.max_logs:
            self.logs = self.logs[-self.max_logs:]

    def export_logs(self, format="json"):
        """导出日志"""
        if format == "json":
            import json
            return json.dumps(self.logs, indent=2)
        elif format == "csv":
            import csv
            import io
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=self.logs[0].keys())
            writer.writeheader()
            writer.writerows(self.logs)
            return output.getvalue()
```

```
class PluginAuditLogger:
    def __init__(self):
        self.logs = []
        self.max_logs = 10000

    def log_execution(self, plugin_name, method_name, parameters, result, user):
        """记录执行"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "plugin_name": plugin_name,
            "method_name": method_name,
            "user": user.get("username", "anonymous"),
            "parameters": self.sanitize_parameters(parameters),
            "result": self.sanitize_result(result),
            "success": result.get("success", False),
            "duration": result.get("duration", 0),
            "ip_address": user.get("ip_address", "unknown")
        }

        self.logs.append(log_entry)

        # 限制日志数量
        if len(self.logs) > self.max_logs:
            self.logs = self.logs[-self.max_logs:]

    def export_logs(self, format="json"):
        """导出日志"""
        if format == "json":
            import json
            return json.dumps(self.logs, indent=2)
        elif format == "csv":
            import csv
            import io
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=self.logs[0].keys())
            writer.writeheader()
            writer.writerows(self.logs)
            return output.getvalue()
```

##### 5. 安全对比表#

---

## 5 选择建议

**URL**: https://claudecode.tangshuang.net/course/19.5%20%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE

#### 19.5.1 决策框架#

##### 1. 评估维度#

在选择使用 Skills 还是插件时，需要从多个维度进行评估：

```
python复制class DecisionFramework:
    def __init__(self):
        self.weights = {
            "development_speed": 0.25,    # 开发速度
            "performance": 0.20,          # 性能
            "maintainability": 0.15,      # 可维护性
            "flexibility": 0.15,          # 灵活性
            "security": 0.10,             # 安全性
            "scalability": 0.10,          # 可扩展性
            "learning_curve": 0.05        # 学习曲线
        }

    def evaluate(self, requirements):
        """评估方案"""
        scores = {
            "skills": self._evaluate_skills(requirements),
            "plugin": self._evaluate_plugin(requirements)
        }

        # 计算加权分数
        weighted_scores = {}
        for option, score in scores.items():
            weighted_score = sum(
                score[dim] * self.weights[dim]
                for dim in score
            )
            weighted_scores[option] = weighted_score

        return weighted_scores

    def _evaluate_skills(self, requirements):
        """评估 Skills"""
        return {
            "development_speed": 0.9,    # 开发速度快
            "performance": 0.4,          # 性能一般
            "maintainability": 0.6,      # 可维护性中等
            "flexibility": 0.9,          # 灵活性高
            "security": 0.5,             # 安全性中等
            "scalability": 0.5,          # 可扩展性中等
            "learning_curve": 0.8        # 学习曲线平缓
        }

    def _evaluate_plugin(self, requirements):
        """评估插件"""
        return {
            "development_speed": 0.5,    # 开发速度中等
            "performance": 0.9,          # 性能高
            "maintainability": 0.8,      # 可维护性高
            "flexibility": 0.6,          # 灵活性中等
            "security": 0.9,             # 安全性高
            "scalability": 0.9,          # 可扩展性高
            "learning_curve": 0.4        # 学习曲线陡峭
        }
```

```
class DecisionFramework:
    def __init__(self):
        self.weights = {
            "development_speed": 0.25,    # 开发速度
            "performance": 0.20,          # 性能
            "maintainability": 0.15,      # 可维护性
            "flexibility": 0.15,          # 灵活性
            "security": 0.10,             # 安全性
            "scalability": 0.10,          # 可扩展性
            "learning_curve": 0.05        # 学习曲线
        }

    def evaluate(self, requirements):
        """评估方案"""
        scores = {
            "skills": self._evaluate_skills(requirements),
            "plugin": self._evaluate_plugin(requirements)
        }

        # 计算加权分数
        weighted_scores = {}
        for option, score in scores.items():
            weighted_score = sum(
                score[dim] * self.weights[dim]
                for dim in score
            )
            weighted_scores[option] = weighted_score

        return weighted_scores

    def _evaluate_skills(self, requirements):
        """评估 Skills"""
        return {
            "development_speed": 0.9,    # 开发速度快
            "performance": 0.4,          # 性能一般
            "maintainability": 0.6,      # 可维护性中等
            "flexibility": 0.9,          # 灵活性高
            "security": 0.5,             # 安全性中等
            "scalability": 0.5,          # 可扩展性中等
            "learning_curve": 0.8        # 学习曲线平缓
        }

    def _evaluate_plugin(self, requirements):
        """评估插件"""
        return {
            "development_speed": 0.5,    # 开发速度中等
            "performance": 0.9,          # 性能高
            "maintainability": 0.8,      # 可维护性高
            "flexibility": 0.6,          # 灵活性中等
            "security": 0.9,             # 安全性高
            "scalability": 0.9,          # 可扩展性高
            "learning_curve": 0.4        # 学习曲线陡峭
        }
```

##### 2. 决策树#

```
python复制class DecisionTree:
    def __init__(self):
        self.tree = self._build_tree()

    def _build_tree(self):
        """构建决策树"""
        return {
            "question": "是否需要快速原型开发？",
            "yes": {
                "question": "是否依赖自然语言理解？",
                "yes": "Skills",
                "no": {
                    "question": "性能是否是关键因素？",
                    "yes": "插件",
                    "no": "Skills"
                }
            },
            "no": {
                "question": "是否需要高性能执行？",
                "yes": {
                    "question": "是否需要严格的安全控制？",
                    "yes": "插件",
                    "no": {
                        "question": "是否需要与系统深度集成？",
                        "yes": "插件",
                        "no": "Skills"
                    }
                },
                "no": {
                    "question": "是否需要封装特定知识？",
                    "yes": "Skills",
                    "no": {
                        "question": "是否需要确定性执行？",
                        "yes": "插件",
                        "no": "Skills"
                    }
                }
            }
        }

    def decide(self, requirements):
        """决策"""
        node = self.tree
        while isinstance(node, dict):
            question = node["question"]
            answer = self._answer_question(question, requirements)
            node = node[answer]
        return node

    def _answer_question(self, question, requirements):
        """回答问题"""
        # 简化实现，实际应该根据 requirements 判断
        if "快速原型" in question:
            return "yes" if requirements.get("rapid_prototyping") else "no"
        elif "自然语言" in question:
            return "yes" if requirements.get("nlp_required") else "no"
        elif "性能" in question:
            return "yes" if requirements.get("high_performance") else "no"
        elif "安全" in question:
            return "yes" if requirements.get("high_security") else "no"
        elif "集成" in question:
            return "yes" if requirements.get("deep_integration") else "no"
        elif "知识" in question:
            return "yes" if requirements.get("knowledge_encapsulation") else "no"
        elif "确定性" in question:
            return "yes" if requirements.get("deterministic") else "no"
        return "no"

## 19.5.2 场景化建议

#### 场景 1：快速原型开发

> **特征**：
- 需求不明确，经常变化
- 需要快速验证想法
- 开发时间有限

> **示例**：
用户：我需要创建一个技能，用于分析用户反馈，提取关键问题和建议
Claude Code：我会创建一个用户反馈分析技能。
技能配置：
- 名称：feedback-analyzer
- 描述：分析用户反馈，提取关键问题和建议
- 输入：用户反馈文本
- 输出：关键问题列表、建议列表、情感分析
使用示例：
请分析以下用户反馈：
"产品很好用，但是加载速度有点慢。希望增加导出功能。"
```

```
class DecisionTree:
    def __init__(self):
        self.tree = self._build_tree()

    def _build_tree(self):
        """构建决策树"""
        return {
            "question": "是否需要快速原型开发？",
            "yes": {
                "question": "是否依赖自然语言理解？",
                "yes": "Skills",
                "no": {
                    "question": "性能是否是关键因素？",
                    "yes": "插件",
                    "no": "Skills"
                }
            },
            "no": {
                "question": "是否需要高性能执行？",
                "yes": {
                    "question": "是否需要严格的安全控制？",
                    "yes": "插件",
                    "no": {
                        "question": "是否需要与系统深度集成？",
                        "yes": "插件",
                        "no": "Skills"
                    }
                },
                "no": {
                    "question": "是否需要封装特定知识？",
                    "yes": "Skills",
                    "no": {
                        "question": "是否需要确定性执行？",
                        "yes": "插件",
                        "no": "Skills"
                    }
                }
            }
        }

    def decide(self, requirements):
        """决策"""
        node = self.tree
        while isinstance(node, dict):
            question = node["question"]
            answer = self._answer_question(question, requirements)
            node = node[answer]
        return node

    def _answer_question(self, question, requirements):
        """回答问题"""
        # 简化实现，实际应该根据 requirements 判断
        if "快速原型" in question:
            return "yes" if requirements.get("rapid_prototyping") else "no"
        elif "自然语言" in question:
            return "yes" if requirements.get("nlp_required") else "no"
        elif "性能" in question:
            return "yes" if requirements.get("high_performance") else "no"
        elif "安全" in question:
            return "yes" if requirements.get("high_security") else "no"
        elif "集成" in question:
            return "yes" if requirements.get("deep_integration") else "no"
        elif "知识" in question:
            return "yes" if requirements.get("knowledge_encapsulation") else "no"
        elif "确定性" in question:
            return "yes" if requirements.get("deterministic") else "no"
        return "no"

## 19.5.2 场景化建议

#### 场景 1：快速原型开发

> **特征**：
- 需求不明确，经常变化
- 需要快速验证想法
- 开发时间有限

> **示例**：
用户：我需要创建一个技能，用于分析用户反馈，提取关键问题和建议
Claude Code：我会创建一个用户反馈分析技能。
技能配置：
- 名称：feedback-analyzer
- 描述：分析用户反馈，提取关键问题和建议
- 输入：用户反馈文本
- 输出：关键问题列表、建议列表、情感分析
使用示例：
请分析以下用户反馈：
"产品很好用，但是加载速度有点慢。希望增加导出功能。"
```

- 无需编写代码
- 快速迭代
- 易于调整

###### 场景 2：知识密集型任务

- 需要应用特定领域知识
- 需要理解和推理
- 需要灵活的输出格式
示例：

```
python复制
# 技能：法律文档分析
class LegalDocumentSkill(Skill):
    def execute(self, parameters, context):
        document = parameters["document"]
        analysis_type = parameters["analysis_type"]

        if analysis_type == "risk_assessment":
            return self.assess_risks(document)
        elif analysis_type == "clause_extraction":
            return self.extract_clauses(document)
        elif analysis_type == "compliance_check":
            return self.check_compliance(document)

**优势**：
- 强大的理解能力
- 灵活的知识应用
- 适应性强

#### 场景 3：教育和培训

> **特征**：
- 需要解释和说明
- 需要个性化反馈
- 需要适应不同水平

> **示例**：
技能：编程导师
功能：
- 解释编程概念
- 提供代码示例
- 生成练习题
- 评估代码质量
使用场景：
- 新手学习编程
- 代码审查指导
- 最佳实践教学
```

```
# 技能：法律文档分析
class LegalDocumentSkill(Skill):
    def execute(self, parameters, context):
        document = parameters["document"]
        analysis_type = parameters["analysis_type"]

        if analysis_type == "risk_assessment":
            return self.assess_risks(document)
        elif analysis_type == "clause_extraction":
            return self.extract_clauses(document)
        elif analysis_type == "compliance_check":
            return self.check_compliance(document)

**优势**：
- 强大的理解能力
- 灵活的知识应用
- 适应性强

#### 场景 3：教育和培训

> **特征**：
- 需要解释和说明
- 需要个性化反馈
- 需要适应不同水平

> **示例**：
技能：编程导师
功能：
- 解释编程概念
- 提供代码示例
- 生成练习题
- 评估代码质量
使用场景：
- 新手学习编程
- 代码审查指导
- 最佳实践教学
```

- 个性化教学
- 即时反馈
- 自适应难度

##### 2. 推荐使用插件的场景#

###### 场景 1：高性能计算

- 需要处理大量数据
- 需要实时响应
- 性能是关键因素
示例：

```
python复制
# 插件：高性能数据处理
class HighPerformancePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.thread_pool = ThreadPoolExecutor(max_workers=8)
        self.process_pool = ProcessPoolExecutor(max_workers=4)

    def process_large_dataset(self, data_path):
        """处理大数据集"""
        # 使用多进程处理
        chunks = self.split_dataset(data_path, chunk_size=10000)

        futures = [
            self.process_pool.submit(self.process_chunk, chunk)
            for chunk in chunks
        ]

        results = [future.result() for future in futures]
        return self.merge_results(results)

**优势**：
- 高性能执行
- 并行处理
- 资源优化

#### 场景 2：系统集成

> **特征**：
- 需要与操作系统交互
- 需要访问系统资源
- 需要精确控制

> **示例**：
# 插件：文件系统集成
class FileSystemPlugin(Plugin):
def __init__(self):
super().__init__()
self.permission_checker = PermissionChecker()
def copy_file(self, source, destination, user):
"""复制文件"""
# 检查权限
if not self.permission_checker.check_read_permission(user, source):
raise PermissionError("无读取权限")
if not self.permission_checker.check_write_permission(user, destination):
raise PermissionError("无写入权限")
# 执行复制
import shutil
shutil.copy2(source, destination)
# 记录审计日志
self.audit_logger.log("copy_file", user, {
"source": source,
"destination": destination
})
return {"success": True}
```

```
# 插件：高性能数据处理
class HighPerformancePlugin(Plugin):
    def __init__(self):
        super().__init__()
        self.thread_pool = ThreadPoolExecutor(max_workers=8)
        self.process_pool = ProcessPoolExecutor(max_workers=4)

    def process_large_dataset(self, data_path):
        """处理大数据集"""
        # 使用多进程处理
        chunks = self.split_dataset(data_path, chunk_size=10000)

        futures = [
            self.process_pool.submit(self.process_chunk, chunk)
            for chunk in chunks
        ]

        results = [future.result() for future in futures]
        return self.merge_results(results)

**优势**：
- 高性能执行
- 并行处理
- 资源优化

#### 场景 2：系统集成

> **特征**：
- 需要与操作系统交互
- 需要访问系统资源
- 需要精确控制

> **示例**：
# 插件：文件系统集成
class FileSystemPlugin(Plugin):
def __init__(self):
super().__init__()
self.permission_checker = PermissionChecker()
def copy_file(self, source, destination, user):
"""复制文件"""
# 检查权限
if not self.permission_checker.check_read_permission(user, source):
raise PermissionError("无读取权限")
if not self.permission_checker.check_write_permission(user, destination):
raise PermissionError("无写入权限")
# 执行复制
import shutil
shutil.copy2(source, destination)
# 记录审计日志
self.audit_logger.log("copy_file", user, {
"source": source,
"destination": destination
})
return {"success": True}
```

- 直接系统访问
- 精确权限控制
- 完整的审计日志

###### 场景 3：安全敏感操作

- 涉及敏感数据
- 需要严格的安全控制
- 需要合规性
示例：

```
python复制
# 插件：加密服务
class EncryptionPlugin(Plugin):
    def __init__(self, key_store):
        super().__init__()
        self.key_store = key_store
        self.audit_logger = AuditLogger()

    def encrypt_data(self, data, user, key_id):
        """加密数据"""
        # 检查权限
        if not self.check_encryption_permission(user, key_id):
            raise PermissionError("无加密权限")

        # 获取密钥
        key = self.key_store.get_key(key_id)

        # 加密数据
        from cryptography.fernet import Fernet
        f = Fernet(key)
        encrypted = f.encrypt(data.encode())

        # 记录审计日志
        self.audit_logger.log("encrypt_data", user, {
            "key_id": key_id,
            "data_size": len(data)
        })

        return encrypted

    def decrypt_data(self, encrypted_data, user, key_id):
        """解密数据"""
        # 检查权限
        if not self.check_decryption_permission(user, key_id):
            raise PermissionError("无解密权限")

        # 获取密钥
        key = self.key_store.get_key(key_id)

        # 解密数据
        from cryptography.fernet import Fernet
        f = Fernet(key)
        decrypted = f.decrypt(encrypted_data).decode()

        # 记录审计日志
        self.audit_logger.log("decrypt_data", user, {
            "key_id": key_id,
            "data_size": len(decrypted)
        })

        return decrypted

**优势**：
- 严格的安全控制
- 完整的审计追踪
- 合规性支持

### 3. 混合使用的场景

#### 场景 1：代码审查流程

# 插件：Git 集成
class GitPlugin(Plugin):
def get_changed_files(self, branch):
"""获取变更的文件"""
import subprocess
result = subprocess.run(
['git', 'diff', '--name-only', branch],
capture_output=True,
text=True
)
return result.stdout.splitlines()
def get_file_content(self, file_path):
"""获取文件内容"""
with open(file_path, 'r') as f:
return f.read()
# 技能：代码审查
class CodeReviewSkill(Skill):
def execute(self, parameters, context):
# 使用插件获取变更的文件
git_plugin = context.get_plugin("git")
changed_files = git_plugin.get_changed_files(parameters["branch"])
# 对每个文件进行审查
reviews = []
for file_path in changed_files:
content = git_plugin.get_file_content(file_path)
review = self.review_code(content, file_path)
reviews.append(review)
return SkillResult(success=True, data={"reviews": reviews})
```

```
# 插件：加密服务
class EncryptionPlugin(Plugin):
    def __init__(self, key_store):
        super().__init__()
        self.key_store = key_store
        self.audit_logger = AuditLogger()

    def encrypt_data(self, data, user, key_id):
        """加密数据"""
        # 检查权限
        if not self.check_encryption_permission(user, key_id):
            raise PermissionError("无加密权限")

        # 获取密钥
        key = self.key_store.get_key(key_id)

        # 加密数据
        from cryptography.fernet import Fernet
        f = Fernet(key)
        encrypted = f.encrypt(data.encode())

        # 记录审计日志
        self.audit_logger.log("encrypt_data", user, {
            "key_id": key_id,
            "data_size": len(data)
        })

        return encrypted

    def decrypt_data(self, encrypted_data, user, key_id):
        """解密数据"""
        # 检查权限
        if not self.check_decryption_permission(user, key_id):
            raise PermissionError("无解密权限")

        # 获取密钥
        key = self.key_store.get_key(key_id)

        # 解密数据
        from cryptography.fernet import Fernet
        f = Fernet(key)
        decrypted = f.decrypt(encrypted_data).decode()

        # 记录审计日志
        self.audit_logger.log("decrypt_data", user, {
            "key_id": key_id,
            "data_size": len(decrypted)
        })

        return decrypted

**优势**：
- 严格的安全控制
- 完整的审计追踪
- 合规性支持

### 3. 混合使用的场景

#### 场景 1：代码审查流程

# 插件：Git 集成
class GitPlugin(Plugin):
def get_changed_files(self, branch):
"""获取变更的文件"""
import subprocess
result = subprocess.run(
['git', 'diff', '--name-only', branch],
capture_output=True,
text=True
)
return result.stdout.splitlines()
def get_file_content(self, file_path):
"""获取文件内容"""
with open(file_path, 'r') as f:
return f.read()
# 技能：代码审查
class CodeReviewSkill(Skill):
def execute(self, parameters, context):
# 使用插件获取变更的文件
git_plugin = context.get_plugin("git")
changed_files = git_plugin.get_changed_files(parameters["branch"])
# 对每个文件进行审查
reviews = []
for file_path in changed_files:
content = git_plugin.get_file_content(file_path)
review = self.review_code(content, file_path)
reviews.append(review)
return SkillResult(success=True, data={"reviews": reviews})
```

###### 场景 2：数据分析流程

```
python复制
# 插件：数据库访问
class DatabasePlugin(Plugin):
    def query_data(self, query, params=None):
        """查询数据"""
        import sqlite3
        conn = sqlite3.connect('database.db')
        cursor = conn.cursor()
        cursor.execute(query, params or ())
        results = cursor.fetchall()
        conn.close()
        return results

# 技能：数据分析
class DataAnalysisSkill(Skill):
    def execute(self, parameters, context):
        # 使用插件获取数据
        db_plugin = context.get_plugin("database")
        data = db_plugin.query_data(parameters["query"])

        # 使用 Claude 分析数据
        analysis = self.analyze_data(data, parameters["analysis_type"])

        return SkillResult(success=True, data={"analysis": analysis})

## 19.5.3 迁移策略

### 1. 从 Skills 迁移到插件

> **迁移场景**：
- Skills 性能不足
- 需要更严格的安全控制
- 需要更好的可维护性

> **迁移步骤**：
# 1. 分析 Skills 的行为
class SkillAnalyzer:
def analyze(self, skill):
"""分析技能"""
analysis = {
"inputs": self.extract_input_patterns(skill),
"outputs": self.extract_output_patterns(skill),
"logic": self.extract_logic_patterns(skill),
"dependencies": self.extract_dependencies(skill)
}
return analysis
# 2. 设计插件接口
class PluginDesigner:
def design(self, skill_analysis):
"""设计插件"""
design = {
"methods": self.design_methods(skill_analysis),
"data_structures": self.design_data_structures(skill_analysis),
"apis": self.design_apis(skill_analysis)
}
return design
# 3. 实现插件
class PluginMigrator:
def migrate(self, skill, plugin_design):
"""迁移到插件"""
# 创建插件类
plugin_class = self.create_plugin_class(plugin_design)
# 实现方法
for method_design in plugin_design["methods"]:
self.implement_method(plugin_class, method_design)
# 测试插件
self.test_plugin(plugin_class, skill)
return plugin_class
```

```
# 插件：数据库访问
class DatabasePlugin(Plugin):
    def query_data(self, query, params=None):
        """查询数据"""
        import sqlite3
        conn = sqlite3.connect('database.db')
        cursor = conn.cursor()
        cursor.execute(query, params or ())
        results = cursor.fetchall()
        conn.close()
        return results

# 技能：数据分析
class DataAnalysisSkill(Skill):
    def execute(self, parameters, context):
        # 使用插件获取数据
        db_plugin = context.get_plugin("database")
        data = db_plugin.query_data(parameters["query"])

        # 使用 Claude 分析数据
        analysis = self.analyze_data(data, parameters["analysis_type"])

        return SkillResult(success=True, data={"analysis": analysis})

## 19.5.3 迁移策略

### 1. 从 Skills 迁移到插件

> **迁移场景**：
- Skills 性能不足
- 需要更严格的安全控制
- 需要更好的可维护性

> **迁移步骤**：
# 1. 分析 Skills 的行为
class SkillAnalyzer:
def analyze(self, skill):
"""分析技能"""
analysis = {
"inputs": self.extract_input_patterns(skill),
"outputs": self.extract_output_patterns(skill),
"logic": self.extract_logic_patterns(skill),
"dependencies": self.extract_dependencies(skill)
}
return analysis
# 2. 设计插件接口
class PluginDesigner:
def design(self, skill_analysis):
"""设计插件"""
design = {
"methods": self.design_methods(skill_analysis),
"data_structures": self.design_data_structures(skill_analysis),
"apis": self.design_apis(skill_analysis)
}
return design
# 3. 实现插件
class PluginMigrator:
def migrate(self, skill, plugin_design):
"""迁移到插件"""
# 创建插件类
plugin_class = self.create_plugin_class(plugin_design)
# 实现方法
for method_design in plugin_design["methods"]:
self.implement_method(plugin_class, method_design)
# 测试插件
self.test_plugin(plugin_class, skill)
return plugin_class
```

##### 2. 从插件迁移到 Skills#

- 需要更灵活的交互
- 需要自然语言理解
- 需要快速迭代
迁移步骤：

```
python复制
# 1. 分析插件的功能
class PluginAnalyzer:
    def analyze(self, plugin):
        """分析插件"""
        analysis = {
            "methods": self.extract_methods(plugin),
            "parameters": self.extract_parameters(plugin),
            "logic": self.extract_logic(plugin),
            "use_cases": self.extract_use_cases(plugin)
        }
        return analysis

# 2. 设计 Skills
class SkillDesigner:
    def design(self, plugin_analysis):
        """设计技能"""
        design = {
            "name": self.generate_name(plugin_analysis),
            "description": self.generate_description(plugin_analysis),
            "examples": self.generate_examples(plugin_analysis),
            "prompts": self.generate_prompts(plugin_analysis)
        }
        return design

# 3. 创建 Skills
class SkillCreator:
    def create(self, skill_design):
        """创建技能"""
        skill = Skill(
            name=skill_design["name"],
            description=skill_design["description"]
        )

        # 添加示例
        for example in skill_design["examples"]:
            skill.add_example(example)

        # 配置提示
        skill.set_prompts(skill_design["prompts"])

        # 测试技能
        self.test_skill(skill)

        return skill

## 19.5.4 最佳实践

### 1. Skills 最佳实践

class SkillBestPractices:
"""Skills 最佳实践"""
# 1. 清晰的描述
def create_skill_with_clear_description(self):
return Skill(
name="code-reviewer",
description="""
代码审查技能，用于分析代码质量、识别潜在问题、提供改进建议。
功能：
- 代码质量评估
- 潜在问题识别
- 最佳实践建议
- 性能优化建议
"""
)
# 2. 丰富的示例
def create_skill_with_examples(self):
skill = Skill(name="code-reviewer")
skill.add_example({
"input": "def add(a, b): return a + b",
"output": """
代码审查结果：
- 代码简洁清晰
- 建议添加类型注解
- 建议添加文档字符串
"""
})
return skill
# 3. 上下文感知
def create_context_aware_skill(self):
skill = Skill(name="context-aware")
def execute(parameters, context):
# 利用上下文信息
project_info = context.get_project_info()
user_preferences = context.get_user_preferences()
# 根据上下文调整行为
if user_preferences.get("strict_mode"):
return self.strict_review(parameters["code"])
else:
return self.relaxed_review(parameters["code"])
skill.execute = execute
return skill
```

```
# 1. 分析插件的功能
class PluginAnalyzer:
    def analyze(self, plugin):
        """分析插件"""
        analysis = {
            "methods": self.extract_methods(plugin),
            "parameters": self.extract_parameters(plugin),
            "logic": self.extract_logic(plugin),
            "use_cases": self.extract_use_cases(plugin)
        }
        return analysis

# 2. 设计 Skills
class SkillDesigner:
    def design(self, plugin_analysis):
        """设计技能"""
        design = {
            "name": self.generate_name(plugin_analysis),
            "description": self.generate_description(plugin_analysis),
            "examples": self.generate_examples(plugin_analysis),
            "prompts": self.generate_prompts(plugin_analysis)
        }
        return design

# 3. 创建 Skills
class SkillCreator:
    def create(self, skill_design):
        """创建技能"""
        skill = Skill(
            name=skill_design["name"],
            description=skill_design["description"]
        )

        # 添加示例
        for example in skill_design["examples"]:
            skill.add_example(example)

        # 配置提示
        skill.set_prompts(skill_design["prompts"])

        # 测试技能
        self.test_skill(skill)

        return skill

## 19.5.4 最佳实践

### 1. Skills 最佳实践

class SkillBestPractices:
"""Skills 最佳实践"""
# 1. 清晰的描述
def create_skill_with_clear_description(self):
return Skill(
name="code-reviewer",
description="""
代码审查技能，用于分析代码质量、识别潜在问题、提供改进建议。
功能：
- 代码质量评估
- 潜在问题识别
- 最佳实践建议
- 性能优化建议
"""
)
# 2. 丰富的示例
def create_skill_with_examples(self):
skill = Skill(name="code-reviewer")
skill.add_example({
"input": "def add(a, b): return a + b",
"output": """
代码审查结果：
- 代码简洁清晰
- 建议添加类型注解
- 建议添加文档字符串
"""
})
return skill
# 3. 上下文感知
def create_context_aware_skill(self):
skill = Skill(name="context-aware")
def execute(parameters, context):
# 利用上下文信息
project_info = context.get_project_info()
user_preferences = context.get_user_preferences()
# 根据上下文调整行为
if user_preferences.get("strict_mode"):
return self.strict_review(parameters["code"])
else:
return self.relaxed_review(parameters["code"])
skill.execute = execute
return skill
```

##### 2. 插件最佳实践#

```
python复制
class PluginBestPractices:
    """插件最佳实践"""

    # 1. 类型安全
    def create_type_safe_plugin(self):
        from pydantic import BaseModel, validator

        class PluginInput(BaseModel):
            """插件输入"""
            value: int
            name: str

            @validator('value')
            def value_positive(cls, v):
                if v <= 0:
                    raise ValueError('值必须大于零')
                return v

        class TypeSafePlugin(Plugin):
            def process(self, input_data: PluginInput):
                """处理输入"""
                return {"result": input_data.value * 2}

        return TypeSafePlugin()

    # 2. 错误处理
    def create_robust_plugin(self):
        class RobustPlugin(Plugin):
            def process(self, parameters):
                """处理参数"""
                try:
                    # 验证参数
                    self.validate_parameters(parameters)

                    # 执行逻辑
                    result = self.execute_logic(parameters)

                    return {"success": True, "data": result}

                except ValidationError as e:
                    return {"success": False, "error": f"参数验证失败: {e}"}

                except Exception as e:
                    # 记录错误
                    self.logger.error(f"处理失败: {e}")
                    return {"success": False, "error": "处理失败"}

        return RobustPlugin()

    # 3. 资源管理
    def create_resource_managed_plugin(self):
        class ResourceManagedPlugin(Plugin):
            def __init__(self):
                super().__init__()
                self.connection_pool = None
                self.cache = None

            def initialize(self, config):
                """初始化资源"""
                # 创建连接池
                self.connection_pool = ConnectionPool(
                    max_size=config.get("pool_size", 10)
                )

                # 创建缓存
                self.cache = LRUCache(maxsize=1000)

            def process(self, parameters):
                """处理参数"""
                # 使用连接池
                with self.connection_pool.get_connection() as conn:
                    # 检查缓存
                    cache_key = self.get_cache_key(parameters)
                    cached_result = self.cache.get(cache_key)

                    if cached_result:
                        return cached_result

                    # 执行逻辑
                    result = self.execute_logic(parameters, conn)

                    # 缓存结果
                    self.cache.set(cache_key, result)

                    return result

            def cleanup(self):
                """清理资源"""
                if self.connection_pool:
                    self.connection_pool.close()
                if self.cache:
                    self.cache.clear()

        return ResourceManagedPlugin()
```

```
class PluginBestPractices:
    """插件最佳实践"""

    # 1. 类型安全
    def create_type_safe_plugin(self):
        from pydantic import BaseModel, validator

        class PluginInput(BaseModel):
            """插件输入"""
            value: int
            name: str

            @validator('value')
            def value_positive(cls, v):
                if v <= 0:
                    raise ValueError('值必须大于零')
                return v

        class TypeSafePlugin(Plugin):
            def process(self, input_data: PluginInput):
                """处理输入"""
                return {"result": input_data.value * 2}

        return TypeSafePlugin()

    # 2. 错误处理
    def create_robust_plugin(self):
        class RobustPlugin(Plugin):
            def process(self, parameters):
                """处理参数"""
                try:
                    # 验证参数
                    self.validate_parameters(parameters)

                    # 执行逻辑
                    result = self.execute_logic(parameters)

                    return {"success": True, "data": result}

                except ValidationError as e:
                    return {"success": False, "error": f"参数验证失败: {e}"}

                except Exception as e:
                    # 记录错误
                    self.logger.error(f"处理失败: {e}")
                    return {"success": False, "error": "处理失败"}

        return RobustPlugin()

    # 3. 资源管理
    def create_resource_managed_plugin(self):
        class ResourceManagedPlugin(Plugin):
            def __init__(self):
                super().__init__()
                self.connection_pool = None
                self.cache = None

            def initialize(self, config):
                """初始化资源"""
                # 创建连接池
                self.connection_pool = ConnectionPool(
                    max_size=config.get("pool_size", 10)
                )

                # 创建缓存
                self.cache = LRUCache(maxsize=1000)

            def process(self, parameters):
                """处理参数"""
                # 使用连接池
                with self.connection_pool.get_connection() as conn:
                    # 检查缓存
                    cache_key = self.get_cache_key(parameters)
                    cached_result = self.cache.get(cache_key)

                    if cached_result:
                        return cached_result

                    # 执行逻辑
                    result = self.execute_logic(parameters, conn)

                    # 缓存结果
                    self.cache.set(cache_key, result)

                    return result

            def cleanup(self):
                """清理资源"""
                if self.connection_pool:
                    self.connection_pool.close()
                if self.cache:
                    self.cache.clear()

        return ResourceManagedPlugin()
```

#### 19.5.5 总结#

##### 选择指南#

##### 决策流程#

True. 评估需求：明确功能需求、性能要求、安全要求
True. 分析约束：考虑开发时间、资源限制、团队能力
True. 选择方案：根据决策框架选择合适的方案
True. 实施验证：实现原型并进行验证
True. 迭代优化：根据反馈持续优化

##### 关键原则#

True. 从简单开始：优先选择 Skills 进行快速验证
True. 按需优化：当性能或安全成为瓶颈时，考虑迁移到插件
True. 灵活组合：不要局限于单一方案，灵活组合使用
True. 持续评估：定期评估现有方案，根据需求变化调整

---

# 第 20 章

## 1 插件系统介绍

**URL**: https://claudecode.tangshuang.net/course/20.1%20%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D

#### 什么是插件系统#

插件系统是 Claude Code 的核心扩展机制，允许开发者通过安装和使用第三方插件来增强 Claude Code 的功能。插件系统提供了一种灵活的方式来扩展 Claude Code 的能力，使其能够适应不同的开发需求和工作流。

#### 插件系统的核心特性#

##### 1. 模块化设计#

- 每个插件专注于解决特定的问题或提供特定的功能
- 插件之间相互独立，便于维护和更新
- 支持按需加载，不影响核心系统性能

##### 2. 丰富的扩展点#

- 命令扩展：添加新的 CLI 命令和斜杠命令
- 工具扩展：添加新的内置工具和外部集成
- UI 扩展：自定义 Claude Code 的界面元素
- 功能扩展：增强或替换核心功能

##### 3. 安全沙箱#

- 插件运行在隔离的沙箱环境中
- 严格的权限控制机制
- 防止恶意插件访问敏感数据

##### 4. 市场生态#

- 官方插件市场提供丰富的插件资源
- 支持第三方插件市场
- 开发者可以发布和共享自己的插件

#### 插件系统架构#

```
bash复制┌─────────────────┐
│   Claude Code   │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│   Plugin API    │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│  Plugin Host    │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│   Plugins       │
└─────────────────┘
```

```
┌─────────────────┐
│   Claude Code   │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│   Plugin API    │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│  Plugin Host    │
└─────────────────┘
          ▲
          │
┌─────────────────┐
│   Plugins       │
└─────────────────┘
```

#### 插件类型#

##### 1. 官方插件#

- 由 Claude Code 团队开发和维护
- 经过严格的安全和质量测试
- 提供核心功能扩展

##### 2. 社区插件#

- 由第三方开发者贡献
- 覆盖各种领域和用途
- 丰富的选择和创新

##### 3. 企业插件#

- 为企业定制的专用插件
- 支持企业级安全和集成
- 提供专业的技术支持

#### 插件系统的优势#

##### 1. 灵活性#

- 按需选择所需功能
- 自定义开发环境
- 适应不同的工作流

##### 2. 可扩展性#

- 轻松添加新功能
- 无需修改核心代码
- 支持持续进化

##### 3. 社区驱动#

- 活跃的开发者社区
- 丰富的插件资源
- 快速的功能迭代

##### 4. 标准化#

- 统一的开发接口
- 一致的用户体验
- 简化的学习曲线

#### 插件系统的应用场景#

##### 1. 开发效率提升#

- 代码格式化和linting
- 自动补全和智能提示
- 快速代码生成

##### 2. 工作流自动化#

- 自动化测试和部署
- 持续集成和交付
- 代码审查和质量控制

##### 3. 跨平台集成#

- 与其他开发工具集成
- 支持多种编程语言
- 连接云服务和API

##### 4. 个性化定制#

- 自定义界面主题
- 个性化快捷键
- 定制化工作流

#### 小结#

插件系统是 Claude Code 强大扩展性的核心，通过插件系统，开发者可以根据自己的需求定制开发环境，提高开发效率，实现工作流自动化。下一节我们将介绍如何使用插件市场来发现和安装插件。

---

## 2 插件市场使用

**URL**: https://claudecode.tangshuang.net/course/20.2%20%E6%8F%92%E4%BB%B6%E5%B8%82%E5%9C%BA%E4%BD%BF%E7%94%A8

#### 什么是插件市场#

插件市场是 Claude Code 提供的插件分发平台，开发者可以在市场中发现、安装和管理各种插件。插件市场提供了丰富的插件资源，覆盖了开发过程中的各个方面。

#### 访问插件市场#

##### 1. 命令行访问#

```
bash复制# 打开插件市场
claude plugin marketplace

# 列出可用插件市场
claude plugin marketplace list

# 添加新的插件市场
claude plugin marketplace add your-org/claude-plugins

# 移除插件市场
claude plugin marketplace remove your-org/claude-plugins
```

```
# 打开插件市场
claude plugin marketplace

# 列出可用插件市场
claude plugin marketplace list

# 添加新的插件市场
claude plugin marketplace add your-org/claude-plugins

# 移除插件市场
claude plugin marketplace remove your-org/claude-plugins
```

##### 2. 斜杠命令访问#

```
bash复制# 打开插件市场
/plugin marketplace

# 列出可用插件
/plugin list

# 搜索插件
/plugin search keyword
```

```
# 打开插件市场
/plugin marketplace

# 列出可用插件
/plugin list

# 搜索插件
/plugin search keyword
```

##### 3. UI 界面访问#

- 在 Claude Code 界面中点击插件图标
- 浏览插件分类和推荐
- 使用搜索功能查找特定插件

#### 浏览插件#

##### 1. 分类浏览#

- 开发工具：代码编辑器、调试工具、构建工具
- 代码质量：linting、格式化、静态分析
- 测试工具：单元测试、集成测试、端到端测试
- 部署工具：CI/CD、容器化、云部署
- 文档工具：文档生成、API 文档、知识库
- 协作工具：版本控制、团队协作、项目管理

##### 2. 推荐系统#

- 基于使用历史的个性化推荐
- 热门插件排行榜
- 新上架插件推荐
- 编辑精选插件

##### 3. 插件详情#

```
bash复制插件详情页面包含以下信息：
- 插件名称和版本
- 开发者信息
- 插件描述和功能
- 安装和使用说明
- 评分和评论
- 更新历史
- 许可证信息
```

```
插件详情页面包含以下信息：
- 插件名称和版本
- 开发者信息
- 插件描述和功能
- 安装和使用说明
- 评分和评论
- 更新历史
- 许可证信息
```

#### 安装插件#

##### 1. 命令行安装#

```
bash复制# 安装最新版本
claude plugin install formatter@your-org

# 安装指定版本
claude plugin install formatter@your-org@1.0.0

# 从本地文件安装
claude plugin install ./formatter-plugin.zip

# 从 Git 仓库安装
claude plugin install git://github.com/your-org/formatter-plugin.git
```

```
# 安装最新版本
claude plugin install formatter@your-org

# 安装指定版本
claude plugin install formatter@your-org@1.0.0

# 从本地文件安装
claude plugin install ./formatter-plugin.zip

# 从 Git 仓库安装
claude plugin install git://github.com/your-org/formatter-plugin.git
```

##### 2. 斜杠命令安装#

```
bash复制# 安装插件
/plugin install formatter@your-org

# 安装指定版本
/plugin install formatter@your-org@1.0.0
```

```
# 安装插件
/plugin install formatter@your-org

# 安装指定版本
/plugin install formatter@your-org@1.0.0
```

##### 3. UI 界面安装#

- 在插件详情页面点击"安装"按钮
- 确认安装权限
- 等待安装完成

#### 管理插件#

##### 1. 列出已安装插件#

```
bash复制# 列出所有已安装插件
claude plugin list

# 列出已启用的插件
claude plugin list --enabled

# 列出已禁用的插件
claude plugin list --disabled
```

```
# 列出所有已安装插件
claude plugin list

# 列出已启用的插件
claude plugin list --enabled

# 列出已禁用的插件
claude plugin list --disabled
```

##### 2. 启用和禁用插件#

```
bash复制# 启用插件
claude plugin enable formatter@your-org

# 禁用插件
claude plugin disable formatter@your-org

# 临时启用插件（仅当前会话有效）
claude plugin enable --temporary formatter@your-org
```

```
# 启用插件
claude plugin enable formatter@your-org

# 禁用插件
claude plugin disable formatter@your-org

# 临时启用插件（仅当前会话有效）
claude plugin enable --temporary formatter@your-org
```

##### 3. 更新插件#

```
bash复制# 更新单个插件
claude plugin update formatter@your-org

# 更新所有插件
claude plugin update --all

# 检查插件更新
claude plugin check-updates
```

```
# 更新单个插件
claude plugin update formatter@your-org

# 更新所有插件
claude plugin update --all

# 检查插件更新
claude plugin check-updates
```

##### 4. 卸载插件#

```
bash复制# 卸载插件
claude plugin uninstall formatter@your-org

# 强制卸载插件（即使有依赖）
claude plugin uninstall --force formatter@your-org
```

```
# 卸载插件
claude plugin uninstall formatter@your-org

# 强制卸载插件（即使有依赖）
claude plugin uninstall --force formatter@your-org
```

#### 插件权限管理#

##### 1. 权限类型#

- 文件系统访问：读取、写入、执行文件
- 网络访问：发起 HTTP 请求、访问外部 API
- 命令执行：执行系统命令和脚本
- 系统资源：访问 CPU、内存、磁盘等资源
- 敏感数据：访问环境变量、配置文件等

##### 2. 权限请求流程#

```
bash复制┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Plugin       │────▶│  Permission    │────▶│   User          │
│  requests      │     │   System       │     │  grants or      │
│  permission    │     │                │     │  denies         │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Plugin       │────▶│  Permission    │────▶│   User          │
│  requests      │     │   System       │     │  grants or      │
│  permission    │     │                │     │  denies         │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

##### 3. 管理权限#

```
bash复制# 查看插件权限
claude plugin permissions formatter@your-org

# 修改插件权限
claude plugin permissions --allow file:read formatter@your-org
claude plugin permissions --deny network:http formatter@your-org

# 重置插件权限
claude plugin permissions --reset formatter@your-org
```

```
# 查看插件权限
claude plugin permissions formatter@your-org

# 修改插件权限
claude plugin permissions --allow file:read formatter@your-org
claude plugin permissions --deny network:http formatter@your-org

# 重置插件权限
claude plugin permissions --reset formatter@your-org
```

#### 插件市场最佳实践#

##### 1. 安全使用#

- 只安装来自可信来源的插件
- 仔细审查插件权限请求
- 定期更新插件到最新版本
- 移除不再使用的插件

##### 2. 性能优化#

- 避免安装过多插件
- 禁用不常用的插件
- 定期清理插件缓存
- 优化插件加载顺序

##### 3. 社区参与#

- 为喜欢的插件评分和评论
- 报告插件问题和建议
- 贡献自己的插件
- 参与插件开发讨论

#### 常见问题#

##### Q: 插件安装失败怎么办？#

A: 检查网络连接、插件市场地址、插件依赖和系统兼容性。查看错误日志获取详细信息。

##### Q: 插件冲突如何解决？#

A: 禁用冲突的插件，更新到最新版本，或者联系插件开发者获取支持。

##### Q: 如何备份插件配置？#

A: 使用 claude plugin export 命令导出插件配置，使用 claude plugin import 命令导入配置。

```
claude plugin export
```

```
claude plugin import
```

##### Q: 插件市场无法访问怎么办？#

A: 检查网络设置、代理配置和防火墙规则。可以尝试使用备用插件市场地址。

#### 小结#

插件市场是 Claude Code 生态系统的重要组成部分，通过插件市场，开发者可以轻松发现和安装各种插件，扩展 Claude Code 的功能。合理使用插件市场可以提高开发效率，优化工作流，实现个性化的开发环境。

---

## 3 安装与管理插件

**URL**: https://claudecode.tangshuang.net/course/20.3%20%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6

#### 插件安装基础#

##### 1. 安装前准备#

```
bash复制# 检查系统要求
```

```
# 检查系统要求
```

claude plugin requirements

### 更新 Claude Code 到最新版本

claude update

### 检查插件市场连接

claude plugin marketplace ping

```
bash复制
### 2. 安装方式比较

| 安装方式 | 优点 | 缺点 | 使用场景 |
|---------|------|------|----------|
| **命令行安装** | 灵活、自动化、脚本化 | 需要记住命令 | 批量安装、自动化脚本 |
| **斜杠命令安装** | 快捷、交互式 | 功能有限 | 快速安装单个插件 |
| **UI 界面安装** | 直观、易用 | 手动操作 | 探索和发现插件 |
| **本地文件安装** | 离线可用、自定义 | 需要手动管理版本 | 开发和测试插件 |

## 高级安装选项

### 1. 版本管理
```bash
# 安装特定版本
claude plugin install formatter@your-org@1.0.0

# 安装最新版本
claude plugin install formatter@your-org@latest

# 安装预发布版本
claude plugin install formatter@your-org@beta

# 安装特定范围的版本
claude plugin install formatter@your-org@"^1.0.0"
claude plugin install formatter@your-org@">=1.0.0 <2.0.0"
```

```
### 2. 安装方式比较

| 安装方式 | 优点 | 缺点 | 使用场景 |
|---------|------|------|----------|
| **命令行安装** | 灵活、自动化、脚本化 | 需要记住命令 | 批量安装、自动化脚本 |
| **斜杠命令安装** | 快捷、交互式 | 功能有限 | 快速安装单个插件 |
| **UI 界面安装** | 直观、易用 | 手动操作 | 探索和发现插件 |
| **本地文件安装** | 离线可用、自定义 | 需要手动管理版本 | 开发和测试插件 |

## 高级安装选项

### 1. 版本管理
```bash
# 安装特定版本
claude plugin install formatter@your-org@1.0.0

# 安装最新版本
claude plugin install formatter@your-org@latest

# 安装预发布版本
claude plugin install formatter@your-org@beta

# 安装特定范围的版本
claude plugin install formatter@your-org@"^1.0.0"
claude plugin install formatter@your-org@">=1.0.0 <2.0.0"
```

##### 2. 安装源管理#

```
bash复制# 从官方市场安装
claude plugin install formatter@anthropic

# 从自定义市场安装
claude plugin install formatter@your-org

# 从 Git 仓库安装
claude plugin install git://github.com/your-org/formatter-plugin.git
claude plugin install git://github.com/your-org/formatter-plugin.git#branch-name
claude plugin install git://github.com/your-org/formatter-plugin.git#tag-name

# 从本地目录安装
claude plugin install ./formatter-plugin

# 从压缩包安装
claude plugin install ./formatter-plugin.zip
```

```
# 从官方市场安装
claude plugin install formatter@anthropic

# 从自定义市场安装
claude plugin install formatter@your-org

# 从 Git 仓库安装
claude plugin install git://github.com/your-org/formatter-plugin.git
claude plugin install git://github.com/your-org/formatter-plugin.git#branch-name
claude plugin install git://github.com/your-org/formatter-plugin.git#tag-name

# 从本地目录安装
claude plugin install ./formatter-plugin

# 从压缩包安装
claude plugin install ./formatter-plugin.zip
```

##### 3. 批量安装#

```
bash复制# 从文件批量安装插件
claude plugin install --file plugins.txt

# plugins.txt 格式：
# formatter@your-org@1.0.0
# linter@your-org@2.5.0
# tester@your-org@3.1.0
```

```
# 从文件批量安装插件
claude plugin install --file plugins.txt

# plugins.txt 格式：
# formatter@your-org@1.0.0
# linter@your-org@2.5.0
# tester@your-org@3.1.0
```

#### 插件管理高级功能#

##### 1. 插件状态管理#

```
bash复制# 查看插件状态
claude plugin status formatter@your-org

# 插件状态说明：
# - installed: 已安装但未启用
# - enabled: 已启用并正在运行
# - disabled: 已禁用
# - outdated: 需要更新
# - error: 安装或运行出错

# 查看所有插件状态
claude plugin status --all
```

```
# 查看插件状态
claude plugin status formatter@your-org

# 插件状态说明：
# - installed: 已安装但未启用
# - enabled: 已启用并正在运行
# - disabled: 已禁用
# - outdated: 需要更新
# - error: 安装或运行出错

# 查看所有插件状态
claude plugin status --all
```

##### 2. 插件配置#

```
bash复制# 查看插件配置
claude plugin config formatter@your-org

# 修改插件配置
claude plugin config formatter@your-org --set indent_size=4
claude plugin config formatter@your-org --set line_length=120

# 重置插件配置
claude plugin config formatter@your-org --reset

# 导出插件配置
claude plugin config formatter@your-org --export config.json

# 导入插件配置
claude plugin config formatter@your-org --import config.json
```

```
# 查看插件配置
claude plugin config formatter@your-org

# 修改插件配置
claude plugin config formatter@your-org --set indent_size=4
claude plugin config formatter@your-org --set line_length=120

# 重置插件配置
claude plugin config formatter@your-org --reset

# 导出插件配置
claude plugin config formatter@your-org --export config.json

# 导入插件配置
claude plugin config formatter@your-org --import config.json
```

##### 3. 插件依赖管理#

```
bash复制# 查看插件依赖
claude plugin dependencies formatter@your-org

# 安装插件依赖
claude plugin dependencies --install formatter@your-org

# 检查依赖冲突
claude plugin dependencies --check formatter@your-org

# 解决依赖冲突
claude plugin dependencies --resolve formatter@your-org
```

```
# 查看插件依赖
claude plugin dependencies formatter@your-org

# 安装插件依赖
claude plugin dependencies --install formatter@your-org

# 检查依赖冲突
claude plugin dependencies --check formatter@your-org

# 解决依赖冲突
claude plugin dependencies --resolve formatter@your-org
```

##### 4. 插件日志管理#

```
bash复制# 查看插件日志
claude plugin logs formatter@your-org

# 查看实时日志
claude plugin logs --follow formatter@your-org

# 过滤日志级别
claude plugin logs --level error formatter@your-org
claude plugin logs --level warning formatter@your-org
claude plugin logs --level info formatter@your-org

# 导出日志
claude plugin logs --export logs.txt formatter@your-org
```

```
# 查看插件日志
claude plugin logs formatter@your-org

# 查看实时日志
claude plugin logs --follow formatter@your-org

# 过滤日志级别
claude plugin logs --level error formatter@your-org
claude plugin logs --level warning formatter@your-org
claude plugin logs --level info formatter@your-org

# 导出日志
claude plugin logs --export logs.txt formatter@your-org
```

#### 插件生命周期管理#

##### 1. 安装阶段#

```
bash复制┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   User          │────▶│  Plugin        │────▶│  Plugin        │
│  initiates      │     │   Manager      │     │   Repository   │
│  installation   │     │                │     │                │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Download       │     │  Verify        │     │  Extract        │
│  plugin         │     │  integrity     │     │  plugin files   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Install        │     │  Register      │     │  Notify         │
│  dependencies   │     │  plugin        │     │  user           │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   User          │────▶│  Plugin        │────▶│  Plugin        │
│  initiates      │     │   Manager      │     │   Repository   │
│  installation   │     │                │     │                │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Download       │     │  Verify        │     │  Extract        │
│  plugin         │     │  integrity     │     │  plugin files   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Install        │     │  Register      │     │  Notify         │
│  dependencies   │     │  plugin        │     │  user           │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

##### 2. 启用阶段#

```
bash复制# 启用插件时的操作：
# 1. 加载插件代码
# 2. 初始化插件上下文
# 3. 注册插件扩展点
# 4. 启动插件服务
# 5. 通知插件已启用
```

```
# 启用插件时的操作：
# 1. 加载插件代码
# 2. 初始化插件上下文
# 3. 注册插件扩展点
# 4. 启动插件服务
# 5. 通知插件已启用
```

##### 3. 运行阶段#

```
bash复制# 插件运行时监控：
claude plugin monitor formatter@your-org

# 监控指标：
# - CPU 使用率
# - 内存占用
# - 响应时间
# - 错误率
# - 吞吐量
```

```
# 插件运行时监控：
claude plugin monitor formatter@your-org

# 监控指标：
# - CPU 使用率
# - 内存占用
# - 响应时间
# - 错误率
# - 吞吐量
```

##### 4. 卸载阶段#

```
bash复制# 卸载插件时的操作：
# 1. 停止插件服务
# 2. 注销插件扩展点
# 3. 清理插件文件
# 4. 移除插件配置
# 5. 通知插件已卸载
```

```
# 卸载插件时的操作：
# 1. 停止插件服务
# 2. 注销插件扩展点
# 3. 清理插件文件
# 4. 移除插件配置
# 5. 通知插件已卸载
```

#### 插件管理最佳实践#

##### 1. 组织插件#

```
bash复制# 创建插件组
claude plugin group create development "开发工具"
claude plugin group create testing "测试工具"
claude plugin group create deployment "部署工具"

# 将插件添加到组
claude plugin group add development formatter@your-org
claude plugin group add development linter@your-org
claude plugin group add development debugger@your-org

# 批量管理组内插件
claude plugin group enable development
claude plugin group disable development
claude plugin group update development
```

```
# 创建插件组
claude plugin group create development "开发工具"
claude plugin group create testing "测试工具"
claude plugin group create deployment "部署工具"

# 将插件添加到组
claude plugin group add development formatter@your-org
claude plugin group add development linter@your-org
claude plugin group add development debugger@your-org

# 批量管理组内插件
claude plugin group enable development
claude plugin group disable development
claude plugin group update development
```

##### 2. 自动化管理#

```
bash复制# 插件管理脚本示例
#!/bin/bash

# 备份当前插件配置
claude plugin export plugins-backup.json

# 更新所有插件
claude plugin update --all

# 检查插件状态
claude plugin status --all > plugins-status.txt

# 清理未使用的插件
claude plugin prune
```

```
# 插件管理脚本示例
#!/bin/bash

# 备份当前插件配置
claude plugin export plugins-backup.json

# 更新所有插件
claude plugin update --all

# 检查插件状态
claude plugin status --all > plugins-status.txt

# 清理未使用的插件
claude plugin prune
```

##### 3. 版本控制策略#

```
bash复制# 稳定版本策略
claude plugin install formatter@your-org@"~1.0.0"  # 安装 1.0.x 系列的最新版本

# 自动更新策略
claude plugin install formatter@your-org@"^1.0.0"  # 安装 >=1.0.0 <2.0.0 的最新版本

# 固定版本策略
claude plugin install formatter@your-org@1.0.0      # 精确安装 1.0.0 版本
```

```
# 稳定版本策略
claude plugin install formatter@your-org@"~1.0.0"  # 安装 1.0.x 系列的最新版本

# 自动更新策略
claude plugin install formatter@your-org@"^1.0.0"  # 安装 >=1.0.0 <2.0.0 的最新版本

# 固定版本策略
claude plugin install formatter@your-org@1.0.0      # 精确安装 1.0.0 版本
```

#### 故障排除#

##### 1. 常见安装错误#

###### 错误：依赖冲突

```
bash复制Error: Dependency conflict: plugin A requires version 1.0.0 of library X, but plugin B requires version 2.0.0
```

```
Error: Dependency conflict: plugin A requires version 1.0.0 of library X, but plugin B requires version 2.0.0
```

```
bash复制# 检查依赖树
claude plugin dependencies --tree plugin-a
claude plugin dependencies --tree plugin-b

# 尝试安装兼容版本
claude plugin install plugin-a@1.0.0
claude plugin install plugin-b@2.0.0

# 或者使用隔离模式
claude plugin install --isolated plugin-a
```

```
# 检查依赖树
claude plugin dependencies --tree plugin-a
claude plugin dependencies --tree plugin-b

# 尝试安装兼容版本
claude plugin install plugin-a@1.0.0
claude plugin install plugin-b@2.0.0

# 或者使用隔离模式
claude plugin install --isolated plugin-a
```

###### 错误：权限不足

```
bash复制Error: Permission denied: plugin requires file system access
```

```
Error: Permission denied: plugin requires file system access
```

```
bash复制# 查看权限请求
claude plugin permissions plugin-name

# 授予权限
claude plugin permissions --allow file:read plugin-name
```

```
# 查看权限请求
claude plugin permissions plugin-name

# 授予权限
claude plugin permissions --allow file:read plugin-name
```

###### 错误：网络问题

```
bash复制Error: Network error: unable to connect to plugin marketplace
```

```
Error: Network error: unable to connect to plugin marketplace
```

```
bash复制# 检查网络连接
claude plugin marketplace ping

# 使用代理
claude plugin marketplace --proxy http://proxy:port

# 从本地安装
claude plugin install ./plugin-file.zip
```

```
# 检查网络连接
claude plugin marketplace ping

# 使用代理
claude plugin marketplace --proxy http://proxy:port

# 从本地安装
claude plugin install ./plugin-file.zip
```

##### 2. 插件诊断工具#

```
bash复制# 运行插件诊断
claude plugin diagnose plugin-name

# 诊断内容包括：
# - 插件状态检查
# - 依赖检查
# - 权限检查
# - 配置检查
# - 日志分析

# 生成诊断报告
claude plugin diagnose --report plugin-name > plugin-diagnosis.txt
```

```
# 运行插件诊断
claude plugin diagnose plugin-name

# 诊断内容包括：
# - 插件状态检查
# - 依赖检查
# - 权限检查
# - 配置检查
# - 日志分析

# 生成诊断报告
claude plugin diagnose --report plugin-name > plugin-diagnosis.txt
```

#### 插件管理自动化#

##### 1. CI/CD 集成#

```
yaml复制# GitHub Actions 示例
name: Install Plugins
on: [push]

jobs:
  install:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Claude Code
        run: curl -sSL https://claude.ai/install | sh
      - name: Install plugins
        run: claude plugin install --file plugins.txt
```

```
# GitHub Actions 示例
name: Install Plugins
on: [push]

jobs:
  install:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Claude Code
        run: curl -sSL https://claude.ai/install | sh
      - name: Install plugins
        run: claude plugin install --file plugins.txt
```

##### 2. 配置即代码#

```
json复制// plugins.json
{
  "plugins": [
    {
      "name": "formatter@your-org",
      "version": "1.0.0",
      "enabled": true,
      "config": {
        "indent_size": 4,
        "line_length": 120
      }
    },
    {
      "name": "linter@your-org",
      "version": "2.5.0",
      "enabled": true
    }
  ]
}
```

```
// plugins.json
{
  "plugins": [
    {
      "name": "formatter@your-org",
      "version": "1.0.0",
      "enabled": true,
      "config": {
        "indent_size": 4,
        "line_length": 120
      }
    },
    {
      "name": "linter@your-org",
      "version": "2.5.0",
      "enabled": true
    }
  ]
}
```

```
bash复制# 从配置文件安装插件
claude plugin import plugins.json
```

```
# 从配置文件安装插件
claude plugin import plugins.json
```

#### 小结#

插件的安装与管理是 Claude Code 扩展功能的核心技能。通过掌握不同的安装方式、版本管理策略和自动化技巧，开发者可以高效地管理插件生态系统，保持开发环境的稳定性和安全性。

下一节我们将介绍插件权限管理的重要性和最佳实践。

---

## 4 插件权限管理

**URL**: https://claudecode.tangshuang.net/course/20.4%20%E6%8F%92%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86

#### 插件权限基础#

##### 1. 为什么需要权限管理#

- 安全防护：防止恶意插件访问敏感数据
- 隐私保护：控制插件对个人信息的访问
- 资源控制：限制插件对系统资源的使用
- 合规要求：满足企业安全和合规标准

##### 2. 权限模型#

```
bash复制Claude Code 插件权限模型基于以下原则：
```

```
Claude Code 插件权限模型基于以下原则：
```

- 最小权限原则：插件只能获得完成其功能所需的最小权限
- 显式授权：用户必须明确授予插件权限
- 权限隔离：插件之间的权限相互隔离
- 动态调整：权限可以随时授予或撤销

```
bash复制
## 权限类型

### 1. 文件系统权限
```bash
# 文件读取权限
file:read
file:read:limited  # 只能读取特定目录

# 文件写入权限
file:write
file:write:limited  # 只能写入特定目录

# 文件执行权限
file:execute
file:execute:limited  # 只能执行特定类型的文件

# 目录访问权限
dir:list
dir:read
dir:write
```

```
## 权限类型

### 1. 文件系统权限
```bash
# 文件读取权限
file:read
file:read:limited  # 只能读取特定目录

# 文件写入权限
file:write
file:write:limited  # 只能写入特定目录

# 文件执行权限
file:execute
file:execute:limited  # 只能执行特定类型的文件

# 目录访问权限
dir:list
dir:read
dir:write
```

##### 2. 网络权限#

```
bash复制# HTTP 请求权限
network:http
network:http:limited  # 只能访问特定域名

# HTTPS 请求权限
network:https
network:https:limited  # 只能访问特定域名

# 网络套接字权限
network:socket
network:socket:limited  # 只能连接特定端口

# 代理权限
network:proxy
```

```
# HTTP 请求权限
network:http
network:http:limited  # 只能访问特定域名

# HTTPS 请求权限
network:https
network:https:limited  # 只能访问特定域名

# 网络套接字权限
network:socket
network:socket:limited  # 只能连接特定端口

# 代理权限
network:proxy
```

##### 3. 系统权限#

```
bash复制# 命令执行权限
system:command
system:command:limited  # 只能执行特定命令

# 进程管理权限
system:process
system:process:limited  # 只能管理特定进程

# 系统信息权限
system:info

# 环境变量权限
system:env
```

```
# 命令执行权限
system:command
system:command:limited  # 只能执行特定命令

# 进程管理权限
system:process
system:process:limited  # 只能管理特定进程

# 系统信息权限
system:info

# 环境变量权限
system:env
```

##### 4. 数据权限#

```
bash复制# 配置数据权限
data:config
data:config:read
data:config:write

# 历史数据权限
data:history
data:history:read
data:history:write

# 缓存数据权限
data:cache
data:cache:read
data:cache:write

# 敏感数据权限
data:sensitive  # 需要特殊授权
```

```
# 配置数据权限
data:config
data:config:read
data:config:write

# 历史数据权限
data:history
data:history:read
data:history:write

# 缓存数据权限
data:cache
data:cache:read
data:cache:write

# 敏感数据权限
data:sensitive  # 需要特殊授权
```

##### 5. 插件权限#

```
bash复制# 插件管理权限
plugin:manage
plugin:install
plugin:uninstall
plugin:update

# 插件市场权限
plugin:marketplace
plugin:marketplace:add
plugin:marketplace:remove

# 插件配置权限
plugin:config
plugin:config:read
plugin:config:write
```

```
# 插件管理权限
plugin:manage
plugin:install
plugin:uninstall
plugin:update

# 插件市场权限
plugin:marketplace
plugin:marketplace:add
plugin:marketplace:remove

# 插件配置权限
plugin:config
plugin:config:read
plugin:config:write
```

#### 权限管理流程#

##### 1. 权限请求流程#

```
bash复制┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Plugin       │────▶│  Permission    │────▶│   User          │
│  requests      │     │   System       │     │  reviews and    │
│  permission    │     │                │     │  grants         │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Permission    │     │  Permission    │     │  Permission    │
│  request       │     │  validation    │     │  granted        │
│  generated     │     │                │     │                │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Plugin       │────▶│  Permission    │────▶│   User          │
│  requests      │     │   System       │     │  reviews and    │
│  permission    │     │                │     │  grants         │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Permission    │     │  Permission    │     │  Permission    │
│  request       │     │  validation    │     │  granted        │
│  generated     │     │                │     │                │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

##### 2. 权限授予方式#

###### 命令行方式

```
bash复制# 授予单个权限
claude plugin permissions --allow file:read formatter@your-org

# 授予多个权限
claude plugin permissions --allow file:read --allow file:write formatter@your-org

# 授予所有权限
claude plugin permissions --allow-all formatter@your-org

# 撤销权限
claude plugin permissions --deny file:write formatter@your-org

# 撤销所有权限
claude plugin permissions --deny-all formatter@your-org
```

```
# 授予单个权限
claude plugin permissions --allow file:read formatter@your-org

# 授予多个权限
claude plugin permissions --allow file:read --allow file:write formatter@your-org

# 授予所有权限
claude plugin permissions --allow-all formatter@your-org

# 撤销权限
claude plugin permissions --deny file:write formatter@your-org

# 撤销所有权限
claude plugin permissions --deny-all formatter@your-org
```

###### 交互式方式

```
bash复制# 交互式权限管理
claude plugin permissions formatter@your-org

# 会显示以下提示：
# 插件 formatter@your-org 请求以下权限：
# 1. file:read - 读取文件系统
# 2. network:http - 发起 HTTP 请求
# 
# 是否授予这些权限？(y/n)
```

```
# 交互式权限管理
claude plugin permissions formatter@your-org

# 会显示以下提示：
# 插件 formatter@your-org 请求以下权限：
# 1. file:read - 读取文件系统
# 2. network:http - 发起 HTTP 请求
# 
# 是否授予这些权限？(y/n)
```

###### 配置文件方式

```
json复制// permissions.json
{
  "plugins": {
    "formatter@your-org": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": true
      }
    }
  }
}
```

```
// permissions.json
{
  "plugins": {
    "formatter@your-org": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": true
      }
    }
  }
}
```

```
bash复制# 导入权限配置
claude plugin permissions --import permissions.json
```

```
# 导入权限配置
claude plugin permissions --import permissions.json
```

#### 权限安全#

##### 1. 权限审计#

```
bash复制# 查看权限审计日志
claude plugin audit formatter@your-org

# 过滤审计日志
claude plugin audit --since "2024-01-01" formatter@your-org
claude plugin audit --until "2024-01-31" formatter@your-org
claude plugin audit --action "grant" formatter@your-org
claude plugin audit --action "deny" formatter@your-org

# 导出审计日志
claude plugin audit --export audit-log.txt formatter@your-org
```

```
# 查看权限审计日志
claude plugin audit formatter@your-org

# 过滤审计日志
claude plugin audit --since "2024-01-01" formatter@your-org
claude plugin audit --until "2024-01-31" formatter@your-org
claude plugin audit --action "grant" formatter@your-org
claude plugin audit --action "deny" formatter@your-org

# 导出审计日志
claude plugin audit --export audit-log.txt formatter@your-org
```

##### 2. 权限监控#

```
bash复制# 实时监控权限使用
claude plugin monitor --permissions formatter@your-org

# 设置权限警报
claude plugin alert --permission file:write --threshold 100 formatter@your-org

# 权限使用统计
claude plugin stats --permissions formatter@your-org
```

```
# 实时监控权限使用
claude plugin monitor --permissions formatter@your-org

# 设置权限警报
claude plugin alert --permission file:write --threshold 100 formatter@your-org

# 权限使用统计
claude plugin stats --permissions formatter@your-org
```

##### 3. 权限安全最佳实践#

```
bash复制1. 遵循最小权限原则：只授予插件完成其功能所需的最小权限
2. 定期审查权限：定期检查插件权限，撤销不再需要的权限
3. 监控权限使用：实时监控插件权限使用情况，发现异常及时处理
4. 使用权限隔离：为敏感操作使用专门的插件和权限
5. 定期更新插件：保持插件和权限系统的最新版本
```

```
1. 遵循最小权限原则：只授予插件完成其功能所需的最小权限
2. 定期审查权限：定期检查插件权限，撤销不再需要的权限
3. 监控权限使用：实时监控插件权限使用情况，发现异常及时处理
4. 使用权限隔离：为敏感操作使用专门的插件和权限
5. 定期更新插件：保持插件和权限系统的最新版本
```

#### 企业级权限管理#

##### 1. 集中权限管理#

```
bash复制# 企业级权限管理命令
claude enterprise permissions list
claude enterprise permissions grant plugin-name permission-type
claude enterprise permissions revoke plugin-name permission-type
claude enterprise permissions audit
```

```
# 企业级权限管理命令
claude enterprise permissions list
claude enterprise permissions grant plugin-name permission-type
claude enterprise permissions revoke plugin-name permission-type
claude enterprise permissions audit
```

##### 2. 权限策略#

```
json复制// enterprise-permissions.json
{
  "policies": {
    "default": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": true
      }
    },
    "development": {
      "permissions": {
        "file:read": true,
        "file:write": true,
        "network:http": true,
        "system:command": true
      }
    },
    "production": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": false,
        "system:command": false
      }
    }
  }
}
```

```
// enterprise-permissions.json
{
  "policies": {
    "default": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": true
      }
    },
    "development": {
      "permissions": {
        "file:read": true,
        "file:write": true,
        "network:http": true,
        "system:command": true
      }
    },
    "production": {
      "permissions": {
        "file:read": true,
        "file:write": false,
        "network:http": false,
        "system:command": false
      }
    }
  }
}
```

##### 3. 权限审批流程#

```
bash复制┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Developer    │────▶│  Team Lead     │────▶│  Security      │
│  requests      │     │  reviews       │     │  Team reviews  │
│  permission    │     │  and approves  │     │  and approves  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Permission    │     │  Permission    │     │  Permission    │
│  request       │     │  approved by   │     │  approved by   │
│  submitted     │     │  Team Lead     │     │  Security Team │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Developer    │────▶│  Team Lead     │────▶│  Security      │
│  requests      │     │  reviews       │     │  Team reviews  │
│  permission    │     │  and approves  │     │  and approves  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Permission    │     │  Permission    │     │  Permission    │
│  request       │     │  approved by   │     │  approved by   │
│  submitted     │     │  Team Lead     │     │  Security Team │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

#### 权限故障排除#

##### 1. 常见权限问题#

###### 问题：插件无法读取文件

```
bash复制Error: Permission denied: plugin formatter@your-org does not have file:read permission
```

```
Error: Permission denied: plugin formatter@your-org does not have file:read permission
```

```
bash复制# 查看当前权限
claude plugin permissions formatter@your-org

# 授予文件读取权限
claude plugin permissions --allow file:read formatter@your-org
```

```
# 查看当前权限
claude plugin permissions formatter@your-org

# 授予文件读取权限
claude plugin permissions --allow file:read formatter@your-org
```

###### 问题：插件无法发起网络请求

```
bash复制Error: Permission denied: plugin formatter@your-org does not have network:http permission
```

```
Error: Permission denied: plugin formatter@your-org does not have network:http permission
```

```
bash复制# 查看当前权限
claude plugin permissions formatter@your-org

# 授予网络请求权限
claude plugin permissions --allow network:http formatter@your-org
```

```
# 查看当前权限
claude plugin permissions formatter@your-org

# 授予网络请求权限
claude plugin permissions --allow network:http formatter@your-org
```

###### 问题：权限被意外撤销

```
bash复制Error: Permission denied: plugin formatter@your-org no longer has file:write permission
```

```
Error: Permission denied: plugin formatter@your-org no longer has file:write permission
```

```
bash复制# 查看权限审计日志
claude plugin audit formatter@your-org

# 重新授予权限
claude plugin permissions --allow file:write formatter@your-org

# 设置权限保护
claude plugin permissions --protect file:write formatter@your-org
```

```
# 查看权限审计日志
claude plugin audit formatter@your-org

# 重新授予权限
claude plugin permissions --allow file:write formatter@your-org

# 设置权限保护
claude plugin permissions --protect file:write formatter@your-org
```

##### 2. 权限诊断工具#

```
bash复制# 运行权限诊断
claude plugin diagnose --permissions formatter@your-org

# 诊断内容包括：
# - 插件权限状态
# - 权限使用情况
# - 权限配置问题
# - 安全建议

# 生成权限报告
claude plugin report --permissions formatter@your-org > permissions-report.txt
```

```
# 运行权限诊断
claude plugin diagnose --permissions formatter@your-org

# 诊断内容包括：
# - 插件权限状态
# - 权限使用情况
# - 权限配置问题
# - 安全建议

# 生成权限报告
claude plugin report --permissions formatter@your-org > permissions-report.txt
```

#### 权限管理最佳实践#

##### 1. 开发阶段#

```
bash复制1. 明确插件所需权限
2. 遵循最小权限原则
3. 提供清晰的权限说明
4. 测试权限边界
```

```
1. 明确插件所需权限
2. 遵循最小权限原则
3. 提供清晰的权限说明
4. 测试权限边界
```

##### 2. 部署阶段#

```
bash复制1. 审查插件权限请求
2. 配置适当的权限
3. 监控权限使用
4. 设置权限警报
```

```
1. 审查插件权限请求
2. 配置适当的权限
3. 监控权限使用
4. 设置权限警报
```

##### 3. 维护阶段#

```
bash复制1. 定期审查权限配置
2. 撤销不再需要的权限
3. 更新权限策略
4. 审计权限使用
```

```
1. 定期审查权限配置
2. 撤销不再需要的权限
3. 更新权限策略
4. 审计权限使用
```

#### 小结#

插件权限管理是 Claude Code 安全体系的重要组成部分。通过合理配置和管理插件权限，可以确保插件在完成其功能的同时，不会对系统安全和用户隐私造成威胁。

下一节我们将介绍一些常用插件推荐和使用技巧。

---

## 5 常用插件推荐

**URL**: https://claudecode.tangshuang.net/course/20.5%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90

#### 20.5.1 代码生成类插件#

##### 1. Code Generator#

插件名称: code-generator

```
code-generator
```

描述: 智能代码生成器，支持多种编程语言和框架

- 根据需求描述自动生成代码
- 支持多种编程语言（Python, JavaScript, Java, Go 等）
- 生成测试代码
- 生成文档注释
- 支持代码模板定制

claude plugin install code-generator

```
bash复制python

# 生成 REST API 端点
code_generator.generate(
    description="创建用户管理 API",
    language="python",
    framework="fastapi",
    endpoints=[
        {
            "path": "/users",
            "methods": ["GET", "POST"],
            "description": "用户列表和创建"
        },
        {
            "path": "/users/{id}",
            "methods": ["GET", "PUT", "DELETE"],
            "description": "用户详情和操作"
        }
    ]
)

**配置**:
# config.yaml
code_generator:
default_language: python
default_framework: fastapi
include_tests: true
include_docs: true
template_dir: ./templates
```

```
python

# 生成 REST API 端点
code_generator.generate(
    description="创建用户管理 API",
    language="python",
    framework="fastapi",
    endpoints=[
        {
            "path": "/users",
            "methods": ["GET", "POST"],
            "description": "用户列表和创建"
        },
        {
            "path": "/users/{id}",
            "methods": ["GET", "PUT", "DELETE"],
            "description": "用户详情和操作"
        }
    ]
)

**配置**:
# config.yaml
code_generator:
default_language: python
default_framework: fastapi
include_tests: true
include_docs: true
template_dir: ./templates
```

##### 2. Boilerplate Generator#

插件名称: boilerplate-generator
描述: 快速生成项目脚手架
功能特性:

```
boilerplate-generator
```

- 支持多种框架（React, Vue, Django, Flask 等）
- 自定义模板
- 快速启动项目
- 包含最佳实践配置
安装:

```
bash复制bash

claude plugin install boilerplate-generator

**使用示例**:
# 生成 React 项目
boilerplate_generator create react my-app --template typescript
# 生成 Django 项目
boilerplate_generator create django my-project --include-auth
```

```
bash

claude plugin install boilerplate-generator

**使用示例**:
# 生成 React 项目
boilerplate_generator create react my-app --template typescript
# 生成 Django 项目
boilerplate_generator create django my-project --include-auth
```

##### 3. API Generator#

插件名称: api-generator
描述: 从 OpenAPI 规范生成客户端代码
功能特性:

```
api-generator
```

- 支持 OpenAPI 3.0 规范
- 生成多种语言的客户端代码
- 自动生成类型定义
- 支持异步调用
安装:

```
bash复制bash

claude plugin install api-generator

**使用示例**:
# 从 OpenAPI 规范生成 Python 客户端
api_generator.generate(
spec_file="openapi.yaml",
language="python",
output_dir="./client"
)
```

```
bash

claude plugin install api-generator

**使用示例**:
# 从 OpenAPI 规范生成 Python 客户端
api_generator.generate(
spec_file="openapi.yaml",
language="python",
output_dir="./client"
)
```

#### 20.5.2 测试类插件#

##### 1. Test Runner#

插件名称: test-runner
描述: 自动化测试运行器
功能特性:

```
test-runner
```

- 支持多种测试框架（pytest, unittest, Jest, Mocha 等）
- 并行测试执行
- 生成覆盖率报告
- CI/CD 集成
- 测试结果可视化
安装:

```
bash复制bash

claude plugin install test-runner

**使用示例**:
# 运行所有测试
test-runner run
# 运行特定测试
test-runner run tests/test_example.py
# 生成覆盖率报告
test-runner run --coverage
# 并行运行测试
test-runner run --parallel --workers 4
```

```
bash

claude plugin install test-runner

**使用示例**:
# 运行所有测试
test-runner run
# 运行特定测试
test-runner run tests/test_example.py
# 生成覆盖率报告
test-runner run --coverage
# 并行运行测试
test-runner run --parallel --workers 4
```

```
bash复制yaml

# config.yaml
test_runner:
  framework: pytest
  parallel: true
  workers: 4
  coverage:
    enabled: true
    threshold: 80
  reporting:
    format: html
    output_dir: ./reports

### 2. Mock Generator

> **插件名称**: `mock-generator`

> **描述**: 自动生成 Mock 数据和 Mock 服务

> **功能特性**:
> - 智能生成 Mock 数据
> - 支持多种数据类型
> - 可自定义生成规则
> - Mock 服务器

> **安装**:
claude plugin install mock-generator
```

```
yaml

# config.yaml
test_runner:
  framework: pytest
  parallel: true
  workers: 4
  coverage:
    enabled: true
    threshold: 80
  reporting:
    format: html
    output_dir: ./reports

### 2. Mock Generator

> **插件名称**: `mock-generator`

> **描述**: 自动生成 Mock 数据和 Mock 服务

> **功能特性**:
> - 智能生成 Mock 数据
> - 支持多种数据类型
> - 可自定义生成规则
> - Mock 服务器

> **安装**:
claude plugin install mock-generator
```

```
bash复制python

# 生成 Mock 数据
mock_generator.generate(
    schema={
        "name": "string",
        "age": "integer",
        "email": "email",
        "address": {
            "street": "string",
            "city": "string"
        }
    },
    count=10
)

# 启动 Mock 服务器
mock_generator.server(
    port=3000,
    endpoints=[
        {
            "path": "/api/users",
            "method": "GET",
            "response": {
                "users": mock_generator.generate(schema, count=10)
            }
        }
    ]
)

### 3. Coverage Reporter

> **插件名称**: `coverage-reporter`

> **描述**: 代码覆盖率报告生成器

> **功能特性**:
> - 生成详细的覆盖率报告
> - 支持多种输出格式（HTML, JSON, XML）
> - 覆盖率趋势分析
> - 覆盖率阈值检查

> **安装**:
claude plugin install coverage-reporter
```

```
python

# 生成 Mock 数据
mock_generator.generate(
    schema={
        "name": "string",
        "age": "integer",
        "email": "email",
        "address": {
            "street": "string",
            "city": "string"
        }
    },
    count=10
)

# 启动 Mock 服务器
mock_generator.server(
    port=3000,
    endpoints=[
        {
            "path": "/api/users",
            "method": "GET",
            "response": {
                "users": mock_generator.generate(schema, count=10)
            }
        }
    ]
)

### 3. Coverage Reporter

> **插件名称**: `coverage-reporter`

> **描述**: 代码覆盖率报告生成器

> **功能特性**:
> - 生成详细的覆盖率报告
> - 支持多种输出格式（HTML, JSON, XML）
> - 覆盖率趋势分析
> - 覆盖率阈值检查

> **安装**:
claude plugin install coverage-reporter
```

```
bash复制bash

# 生成覆盖率报告
coverage-reporter generate

# 生成 HTML 报告
coverage-reporter generate --format html --output ./coverage

# 检查覆盖率阈值
coverage-reporter check --threshold 80

## 20.5.3 文档类插件

### 1. Doc Generator

> **插件名称**: `doc-generator`

> **描述**: 自动生成项目文档

> **功能特性**:
> - 从代码注释生成文档
> - 生成 API 文档
> - 生成 README
> - 生成架构文档
> - 支持多种输出格式（Markdown, HTML, PDF）

> **安装**:
claude plugin install doc-generator
```

```
bash

# 生成覆盖率报告
coverage-reporter generate

# 生成 HTML 报告
coverage-reporter generate --format html --output ./coverage

# 检查覆盖率阈值
coverage-reporter check --threshold 80

## 20.5.3 文档类插件

### 1. Doc Generator

> **插件名称**: `doc-generator`

> **描述**: 自动生成项目文档

> **功能特性**:
> - 从代码注释生成文档
> - 生成 API 文档
> - 生成 README
> - 生成架构文档
> - 支持多种输出格式（Markdown, HTML, PDF）

> **安装**:
claude plugin install doc-generator
```

```
bash复制python

# 生成 API 文档
doc_generator.generate_api(
    source_dir="./src",
    output_dir="./docs/api",
    format="markdown"
)

# 生成 README
doc_generator.generate_readme(
    project_name="My Project",
    description="项目描述",
    features=["功能1", "功能2", "功能3"]
)

### 2. API Docs

> **插件名称**: `api-docs`

> **描述**: API 文档生成器

> **功能特性**:
> - 从代码生成 OpenAPI 规范
> - 生成交互式文档
> - 支持多种框架
> - 自动更新文档

> **安装**:
claude plugin install api-docs
```

```
python

# 生成 API 文档
doc_generator.generate_api(
    source_dir="./src",
    output_dir="./docs/api",
    format="markdown"
)

# 生成 README
doc_generator.generate_readme(
    project_name="My Project",
    description="项目描述",
    features=["功能1", "功能2", "功能3"]
)

### 2. API Docs

> **插件名称**: `api-docs`

> **描述**: API 文档生成器

> **功能特性**:
> - 从代码生成 OpenAPI 规范
> - 生成交互式文档
> - 支持多种框架
> - 自动更新文档

> **安装**:
claude plugin install api-docs
```

```
bash复制python

# 从 FastAPI 应用生成文档
api_docs.generate(
    app=fastapi_app,
    output_file="openapi.yaml",
    format="yaml"
)

# 生成交互式文档
api_docs.serve(
    spec_file="openapi.yaml",
    port=8000
)

### 3. Readme Generator

> **插件名称**: `readme-generator`

> **描述**: 自动生成 README 文件

> **功能特性**:
> - 从项目配置生成 README
> - 支持多种模板
> - 自动更新
> - 多语言支持

> **安装**:
claude plugin install readme-generator
```

```
python

# 从 FastAPI 应用生成文档
api_docs.generate(
    app=fastapi_app,
    output_file="openapi.yaml",
    format="yaml"
)

# 生成交互式文档
api_docs.serve(
    spec_file="openapi.yaml",
    port=8000
)

### 3. Readme Generator

> **插件名称**: `readme-generator`

> **描述**: 自动生成 README 文件

> **功能特性**:
> - 从项目配置生成 README
> - 支持多种模板
> - 自动更新
> - 多语言支持

> **安装**:
claude plugin install readme-generator
```

```
bash复制bash

# 生成 README
readme-generator generate

# 使用自定义模板
readme-generator generate --template custom-template.md

# 更新现有 README
readme-generator update

## 20.5.4 集成类插件

### 1. Git Integration

> **插件名称**: `git-integration`

> **描述**: Git 版本控制集成

> **功能特性**:
> - Git 命令集成
> - 代码审查
> - 分支管理
> - 冲突解决
> - 自动提交

> **安装**:
claude plugin install git-integration
```

```
bash

# 生成 README
readme-generator generate

# 使用自定义模板
readme-generator generate --template custom-template.md

# 更新现有 README
readme-generator update

## 20.5.4 集成类插件

### 1. Git Integration

> **插件名称**: `git-integration`

> **描述**: Git 版本控制集成

> **功能特性**:
> - Git 命令集成
> - 代码审查
> - 分支管理
> - 冲突解决
> - 自动提交

> **安装**:
claude plugin install git-integration
```

```
bash复制python

# 查看状态
git_integration.status()

# 创建分支
git_integration.create_branch("feature/new-feature")

# 提交更改
git_integration.commit("Add new feature")

# 推送到远程
git_integration.push()

# 代码审查
git_integration.review(pr_number=123)

### 2. Docker Integration

> **插件名称**: `docker-integration`

> **描述**: Docker 容器集成

> **功能特性**:
> - Docker 镜像构建
> - 容器管理
> - Docker Compose 支持
> - Kubernetes 集成
> - 容器监控

> **安装**:
claude plugin install docker-integration
```

```
python

# 查看状态
git_integration.status()

# 创建分支
git_integration.create_branch("feature/new-feature")

# 提交更改
git_integration.commit("Add new feature")

# 推送到远程
git_integration.push()

# 代码审查
git_integration.review(pr_number=123)

### 2. Docker Integration

> **插件名称**: `docker-integration`

> **描述**: Docker 容器集成

> **功能特性**:
> - Docker 镜像构建
> - 容器管理
> - Docker Compose 支持
> - Kubernetes 集成
> - 容器监控

> **安装**:
claude plugin install docker-integration
```

```
bash复制python

# 构建镜像
docker_integration.build(
    dockerfile="Dockerfile",
    tag="my-app:latest"
)

# 运行容器
docker_integration.run(
    image="my-app:latest",
    ports={"8080": "80"},
    environment={"ENV": "production"}
)

# 使用 Docker Compose
docker_integration.compose_up("docker-compose.yml")

### 3. CI/CD Integration

> **插件名称**: "cicd-integration"

> **描述**: CI/CD 流水线集成

> **功能特性**:
> - 支持 GitHub Actions
> - 支持 GitLab CI
> - 支持 Jenkins
> - 自动化部署
> - 流水线可视化

> **安装**:
claude plugin install cicd-integration
```

```
python

# 构建镜像
docker_integration.build(
    dockerfile="Dockerfile",
    tag="my-app:latest"
)

# 运行容器
docker_integration.run(
    image="my-app:latest",
    ports={"8080": "80"},
    environment={"ENV": "production"}
)

# 使用 Docker Compose
docker_integration.compose_up("docker-compose.yml")

### 3. CI/CD Integration

> **插件名称**: "cicd-integration"

> **描述**: CI/CD 流水线集成

> **功能特性**:
> - 支持 GitHub Actions
> - 支持 GitLab CI
> - 支持 Jenkins
> - 自动化部署
> - 流水线可视化

> **安装**:
claude plugin install cicd-integration
```

```
bash复制python

# 生成 GitHub Actions 工作流
cicd_integration.generate_workflow(
    platform="github",
    stages=["test", "build", "deploy"]
)

# 触发流水线
cicd_integration.trigger(
    pipeline="my-pipeline",
    branch="main"
)

# 查看流水线状态
cicd_integration.status(pipeline_id="123")

## 20.5.5 监控类插件

### 1. Log Monitor

> **插件名称**: `log-monitor`

> **描述**: 日志监控和分析

> **功能特性**:
> - 实时日志监控
> - 日志分析
> - 异常检测
> - 告警通知
> - 日志搜索

> **安装**:
claude plugin install log-monitor
```

```
python

# 生成 GitHub Actions 工作流
cicd_integration.generate_workflow(
    platform="github",
    stages=["test", "build", "deploy"]
)

# 触发流水线
cicd_integration.trigger(
    pipeline="my-pipeline",
    branch="main"
)

# 查看流水线状态
cicd_integration.status(pipeline_id="123")

## 20.5.5 监控类插件

### 1. Log Monitor

> **插件名称**: `log-monitor`

> **描述**: 日志监控和分析

> **功能特性**:
> - 实时日志监控
> - 日志分析
> - 异常检测
> - 告警通知
> - 日志搜索

> **安装**:
claude plugin install log-monitor
```

```
bash复制python

# 监控日志文件
log_monitor.monitor(
    log_file="./app.log",
    patterns=["ERROR", "WARNING"]
)

# 搜索日志
log_monitor.search(
    query="ERROR",
    start_time="2024-01-01",
    end_time="2024-01-31"
)

# 分析日志
log_monitor.analyze(
    log_file="./app.log",
    metrics=["error_rate", "warning_rate"]
)

### 2. Performance Monitor

> **插件名称**: `performance-monitor`

> **描述**: 性能监控工具

> **功能特性**:
> - CPU 监控
> - 内存监控
> - 网络监控
> - 性能分析
> - 性能报告

> **安装**:
claude plugin install performance-monitor
```

```
python

# 监控日志文件
log_monitor.monitor(
    log_file="./app.log",
    patterns=["ERROR", "WARNING"]
)

# 搜索日志
log_monitor.search(
    query="ERROR",
    start_time="2024-01-01",
    end_time="2024-01-31"
)

# 分析日志
log_monitor.analyze(
    log_file="./app.log",
    metrics=["error_rate", "warning_rate"]
)

### 2. Performance Monitor

> **插件名称**: `performance-monitor`

> **描述**: 性能监控工具

> **功能特性**:
> - CPU 监控
> - 内存监控
> - 网络监控
> - 性能分析
> - 性能报告

> **安装**:
claude plugin install performance-monitor
```

```
bash复制python

# 监控性能
performance_monitor.monitor(
    interval=60,
    metrics=["cpu", "memory", "network"]
)

# 生成性能报告
performance_monitor.report(
    start_time="2024-01-01",
    end_time="2024-01-31",
    output="performance-report.pdf"
)

### 3. Alert Manager

> **插件名称**: `alert-manager`

> **描述**: 告警管理器

> **功能特性**:
> - 告警规则配置
> - 多渠道通知（邮件、Slack、短信）
> - 告警聚合
> - 告警历史
> - 告警统计

> **安装**:
claude plugin install alert-manager
```

```
python

# 监控性能
performance_monitor.monitor(
    interval=60,
    metrics=["cpu", "memory", "network"]
)

# 生成性能报告
performance_monitor.report(
    start_time="2024-01-01",
    end_time="2024-01-31",
    output="performance-report.pdf"
)

### 3. Alert Manager

> **插件名称**: `alert-manager`

> **描述**: 告警管理器

> **功能特性**:
> - 告警规则配置
> - 多渠道通知（邮件、Slack、短信）
> - 告警聚合
> - 告警历史
> - 告警统计

> **安装**:
claude plugin install alert-manager
```

```
bash复制python

# 配置告警规则
alert_manager.add_rule(
    name="high_cpu",
    condition="cpu > 80",
    duration="5m",
    notification=["email", "slack"]
)

# 发送测试告警
alert_manager.test(
    rule="high_cpu",
    message="CPU usage is high"
)

## 20.5.6 安全类插件

### 1. Security Scanner

> **插件名称**: `security-scanner`

> **描述**: 安全漏洞扫描器

> **功能特性**:
> - 代码安全扫描
> - 依赖漏洞检测
> - 安全建议
> - 合规性检查
> - 漏洞报告

> **安装**:
claude plugin install security-scanner
```

```
python

# 配置告警规则
alert_manager.add_rule(
    name="high_cpu",
    condition="cpu > 80",
    duration="5m",
    notification=["email", "slack"]
)

# 发送测试告警
alert_manager.test(
    rule="high_cpu",
    message="CPU usage is high"
)

## 20.5.6 安全类插件

### 1. Security Scanner

> **插件名称**: `security-scanner`

> **描述**: 安全漏洞扫描器

> **功能特性**:
> - 代码安全扫描
> - 依赖漏洞检测
> - 安全建议
> - 合规性检查
> - 漏洞报告

> **安装**:
claude plugin install security-scanner
```

```
bash复制python

# 扫描代码
security_scanner.scan(
    source_dir="./src",
    output="security-report.json"
)

# 扫描依赖
security_scanner.scan_dependencies(
    package_file="package.json"
)

# 生成安全报告
security_scanner.report(
    scan_id="123",
    format="pdf"
)

### 2. Vulnerability Checker

> **插件名称**: `vulnerability-checker`

> **描述**: 漏洞检查器

> **功能特性**:
> - 检查已知漏洞
> - 漏洞数据库更新
> - 漏洞严重性评级
> - 修复建议

> **安装**:
claude plugin install vulnerability-checker
```

```
python

# 扫描代码
security_scanner.scan(
    source_dir="./src",
    output="security-report.json"
)

# 扫描依赖
security_scanner.scan_dependencies(
    package_file="package.json"
)

# 生成安全报告
security_scanner.report(
    scan_id="123",
    format="pdf"
)

### 2. Vulnerability Checker

> **插件名称**: `vulnerability-checker`

> **描述**: 漏洞检查器

> **功能特性**:
> - 检查已知漏洞
> - 漏洞数据库更新
> - 漏洞严重性评级
> - 修复建议

> **安装**:
claude plugin install vulnerability-checker
```

```
bash复制python

# 检查漏洞
vulnerability_checker.check(
    package_name="lodash",
    version="4.17.15"
)

# 更新漏洞数据库
vulnerability_checker.update_database()

# 生成漏洞报告
vulnerability_checker.report(
    output="vulnerability-report.json"
)

### 3. Audit Logger

> **插件名称**: `audit-logger`

> **描述**: 审计日志记录器

> **功能特性**:
> - 操作日志记录
> - 审计报告
> - 合规性支持
> - 日志分析
> - 日志导出

> **安装**:
claude plugin install audit-logger
```

```
python

# 检查漏洞
vulnerability_checker.check(
    package_name="lodash",
    version="4.17.15"
)

# 更新漏洞数据库
vulnerability_checker.update_database()

# 生成漏洞报告
vulnerability_checker.report(
    output="vulnerability-report.json"
)

### 3. Audit Logger

> **插件名称**: `audit-logger`

> **描述**: 审计日志记录器

> **功能特性**:
> - 操作日志记录
> - 审计报告
> - 合规性支持
> - 日志分析
> - 日志导出

> **安装**:
claude plugin install audit-logger
```

```
bash复制python

# 记录操作
audit_logger.log(
    action="user_login",
    user="john",
    ip_address="192.168.1.1",
    success=True
)

# 生成审计报告
audit_logger.report(
    start_date="2024-01-01",
    end_date="2024-01-31",
    output="audit-report.pdf"
)

# 导出日志
audit_logger.export(
    format="csv",
    output="audit-logs.csv"
)

## 20.5.7 数据处理类插件

### 1. Data Transformer

> **插件名称**: `data-transformer`

> **描述**: 数据转换工具

> **功能特性**:
> - 多种数据格式支持（JSON, CSV, XML, YAML）
> - 数据转换
> - 数据验证
> - 数据清洗

> **安装**:
claude plugin install data-transformer
```

```
python

# 记录操作
audit_logger.log(
    action="user_login",
    user="john",
    ip_address="192.168.1.1",
    success=True
)

# 生成审计报告
audit_logger.report(
    start_date="2024-01-01",
    end_date="2024-01-31",
    output="audit-report.pdf"
)

# 导出日志
audit_logger.export(
    format="csv",
    output="audit-logs.csv"
)

## 20.5.7 数据处理类插件

### 1. Data Transformer

> **插件名称**: `data-transformer`

> **描述**: 数据转换工具

> **功能特性**:
> - 多种数据格式支持（JSON, CSV, XML, YAML）
> - 数据转换
> - 数据验证
> - 数据清洗

> **安装**:
claude plugin install data-transformer
```

```
bash复制python

# 转换数据格式
data_transformer.convert(
    input_file="data.json",
    output_file="data.csv",
    input_format="json",
    output_format="csv"
)

# 验证数据
data_transformer.validate(
    data_file="data.json",
    schema="schema.json"
)

### 2. Database Connector

> **插件名称**: `database-connector`

> **描述**: 数据库连接器

> **功能特性**:
> - 支持多种数据库（MySQL, PostgreSQL, MongoDB 等）
> - 连接池管理
> - 查询构建器
> - ORM 支持

> **安装**:
claude plugin install database-connector
```

```
python

# 转换数据格式
data_transformer.convert(
    input_file="data.json",
    output_file="data.csv",
    input_format="json",
    output_format="csv"
)

# 验证数据
data_transformer.validate(
    data_file="data.json",
    schema="schema.json"
)

### 2. Database Connector

> **插件名称**: `database-connector`

> **描述**: 数据库连接器

> **功能特性**:
> - 支持多种数据库（MySQL, PostgreSQL, MongoDB 等）
> - 连接池管理
> - 查询构建器
> - ORM 支持

> **安装**:
claude plugin install database-connector
```

```
bash复制python

# 连接数据库
db = database_connector.connect(
    type="postgresql",
    host="localhost",
    port=5432,
    database="mydb",
    user="user",
    password="password"
)

# 执行查询
result = db.query("SELECT * FROM users WHERE age > 18")

# 插入数据
db.insert("users", {"name": "John", "age": 25})

## 20.5.8 开发工具类插件

### 1. Code Formatter

> **插件名称**: `code-formatter`

> **描述**: 代码格式化工具

> **功能特性**:
> - 支持多种编程语言
> - 自定义格式化规则
> - 批量格式化
> - 格式化预览

> **安装**:
claude plugin install code-formatter
```

```
python

# 连接数据库
db = database_connector.connect(
    type="postgresql",
    host="localhost",
    port=5432,
    database="mydb",
    user="user",
    password="password"
)

# 执行查询
result = db.query("SELECT * FROM users WHERE age > 18")

# 插入数据
db.insert("users", {"name": "John", "age": 25})

## 20.5.8 开发工具类插件

### 1. Code Formatter

> **插件名称**: `code-formatter`

> **描述**: 代码格式化工具

> **功能特性**:
> - 支持多种编程语言
> - 自定义格式化规则
> - 批量格式化
> - 格式化预览

> **安装**:
claude plugin install code-formatter
```

```
bash复制bash

# 格式化代码
code-formatter format ./src

# 格式化特定文件
code-formatter format ./src/main.py

# 预览格式化结果
code-formatter format --dry-run ./src/main.py

### 2. Linter

> **插件名称**: `linter`

> **描述**: 代码检查工具

> **功能特性**:
> - 代码质量检查
> - 代码风格检查
> - 潜在错误检测
> - 最佳实践建议

> **安装**:
claude plugin install linter
```

```
bash

# 格式化代码
code-formatter format ./src

# 格式化特定文件
code-formatter format ./src/main.py

# 预览格式化结果
code-formatter format --dry-run ./src/main.py

### 2. Linter

> **插件名称**: `linter`

> **描述**: 代码检查工具

> **功能特性**:
> - 代码质量检查
> - 代码风格检查
> - 潜在错误检测
> - 最佳实践建议

> **安装**:
claude plugin install linter
```

```
bash复制bash

# 检查代码
linter check ./src

# 检查特定文件
linter check ./src/main.py

# 自动修复问题
linter fix ./src

### 3. Debugger

> **插件名称**: `debugger`

> **描述**: 调试工具

> **功能特性**:
> - 断点设置
> - 变量查看
> - 调用栈查看
> - 表达式求值

> **安装**:
claude plugin install debugger
```

```
bash

# 检查代码
linter check ./src

# 检查特定文件
linter check ./src/main.py

# 自动修复问题
linter fix ./src

### 3. Debugger

> **插件名称**: `debugger`

> **描述**: 调试工具

> **功能特性**:
> - 断点设置
> - 变量查看
> - 调用栈查看
> - 表达式求值

> **安装**:
claude plugin install debugger
```

```
bash复制python

# 启动调试器
debugger.start(
    script="./src/main.py",
    breakpoints=[("./src/main.py", 10)]
)

# 查看变量
debugger.inspect_variable("x")

# 查看调用栈
debugger.show_stack()
```

```
python

# 启动调试器
debugger.start(
    script="./src/main.py",
    breakpoints=[("./src/main.py", 10)]
)

# 查看变量
debugger.inspect_variable("x")

# 查看调用栈
debugger.show_stack()
```

#### 20.5.9 插件选择建议#

##### 根据项目类型选择#

##### 根据开发阶段选择#

##### 根据团队规模选择#

---

# 第 21 章

## 1 插件开发环境搭建

**URL**: https://claudecode.tangshuang.net/course/21.1%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA

#### 21.1.1 系统要求#

##### 基本要求#

##### 软件依赖#

#### 21.1.2 安装开发工具#

##### 1. 安装 Node.js#

推荐使用 nvm 进行 Node.js 版本管理：

```
bash复制# 安装 nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
source ~/.bashrc

# 安装并使用 Node.js 18
nvm install 18
nvm use 18

# 验证安装
node --version
npm --version
```

```
# 安装 nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
source ~/.bashrc

# 安装并使用 Node.js 18
nvm install 18
nvm use 18

# 验证安装
node --version
npm --version
```

##### 2. 安装 Python#

###### macOS

```
bash复制brew install python@3.10
```

```
brew install python@3.10
```

###### Ubuntu/Debian

```
bash复制sudo apt update
sudo apt install python3.10 python3.10-venv python3-pip
```

```
sudo apt update
sudo apt install python3.10 python3.10-venv python3-pip
```

###### Windows

从 Python 官方网站 下载安装程序。

```
bash复制# 验证安装
python3 --version
pip3 --version
```

```
# 验证安装
python3 --version
pip3 --version
```

##### 3. 安装 Git#

###### macOS

```
bash复制brew install git
```

```
brew install git
```

###### Ubuntu/Debian

```
bash复制sudo apt install git
```

```
sudo apt install git
```

###### Windows

从 Git 官方网站 下载安装程序。

```
bash复制# 验证安装
git --version
```

```
# 验证安装
git --version
```

##### 4. 安装 Claude Code CLI#

```
bash复制# 使用 npm 安装
npm install -g @anthropic-ai/claude-code

# 验证安装
claude --version
```

```
# 使用 npm 安装
npm install -g @anthropic-ai/claude-code

# 验证安装
claude --version
```

#### 21.1.3 安装插件开发工具#

##### 1. 安装插件脚手架工具#

```
bash复制# 安装插件脚手架
npm install -g @claude-code/plugin-scaffold

# 验证安装
claude-plugin-scaffold --version
```

```
# 安装插件脚手架
npm install -g @claude-code/plugin-scaffold

# 验证安装
claude-plugin-scaffold --version
```

##### 2. 安装插件开发工具#

```
bash复制# 安装开发工具
npm install -g @claude-code/plugin-devtools

# 验证安装
claude-plugin-devtools --version
```

```
# 安装开发工具
npm install -g @claude-code/plugin-devtools

# 验证安装
claude-plugin-devtools --version
```

##### 3. 安装插件测试工具#

```
bash复制# 安装测试工具
npm install -g @claude-code/plugin-test

# 验证安装
claude-plugin-test --version
```

```
# 安装测试工具
npm install -g @claude-code/plugin-test

# 验证安装
claude-plugin-test --version
```

#### 21.1.4 创建开发环境#

##### 1. 创建项目目录#

```
bash复制# 创建插件项目目录
mkdir my-plugin
cd my-plugin

# 初始化项目
npm init -y
```

```
# 创建插件项目目录
mkdir my-plugin
cd my-plugin

# 初始化项目
npm init -y
```

##### 2. 安装开发依赖#

```
bash复制# 安装插件 SDK
npm install @claude-code/plugin-sdk --save-dev

# 安装 TypeScript（推荐）
npm install typescript @types/node --save-dev

# 安装测试框架
npm install jest @types/jest --save-dev

# 安装代码检查工具
npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev
```

```
# 安装插件 SDK
npm install @claude-code/plugin-sdk --save-dev

# 安装 TypeScript（推荐）
npm install typescript @types/node --save-dev

# 安装测试框架
npm install jest @types/jest --save-dev

# 安装代码检查工具
npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev
```

##### 3. 配置 TypeScript#

```
json复制// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

```
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

##### 4. 配置 ESLint#

```
json复制// .eslintrc.json
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn"
  }
}
```

```
// .eslintrc.json
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn"
  }
}
```

##### 5. 配置 Jest#

```
json复制// jest.config.json
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "roots": ["<rootDir>/src"],
  "testMatch": ["**/__tests__/**/*.ts", "**/?(*.)+(spec|test).ts"],
  "collectCoverageFrom": [
    "src/**/*.ts",
    "!src/**/*.d.ts",
    "!src/**/*.test.ts"
  ]
}
```

```
// jest.config.json
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "roots": ["<rootDir>/src"],
  "testMatch": ["**/__tests__/**/*.ts", "**/?(*.)+(spec|test).ts"],
  "collectCoverageFrom": [
    "src/**/*.ts",
    "!src/**/*.d.ts",
    "!src/**/*.test.ts"
  ]
}
```

##### 6. 配置 package.json#

```
json复制{
  "name": "my-plugin",
  "version": "1.0.0",
  "description": "My Claude Code Plugin",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "clean": "rm -rf dist"
  },
  "keywords": [
    "claude-code",
    "plugin"
  ],
  "author": "Your Name",
  "license": "MIT",
  "devDependencies": {
    "@claude-code/plugin-sdk": "^1.0.0",
    "@types/jest": "^29.0.0",
    "@types/node": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.0",
    "jest": "^29.0.0",
    "ts-jest": "^29.0.0",
    "typescript": "^4.9.0"
  }
}
```

```
{
  "name": "my-plugin",
  "version": "1.0.0",
  "description": "My Claude Code Plugin",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "clean": "rm -rf dist"
  },
  "keywords": [
    "claude-code",
    "plugin"
  ],
  "author": "Your Name",
  "license": "MIT",
  "devDependencies": {
    "@claude-code/plugin-sdk": "^1.0.0",
    "@types/jest": "^29.0.0",
    "@types/node": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.0",
    "jest": "^29.0.0",
    "ts-jest": "^29.0.0",
    "typescript": "^4.9.0"
  }
}
```

#### 21.1.5 创建插件项目结构#

##### 标准项目结构#

```
bash复制my-plugin/
├── src/
│   ├── index.ts              # 插件入口
│   ├── plugin.ts            # 插件主类
│   ├── tools/               # 工具定义
│   │   ├── tool1.ts
│   │   └── tool2.ts
│   ├── commands/            # 命令定义
│   │   ├── command1.ts
│   │   └── command2.ts
│   ├── utils/               # 工具函数
│   │   └── helpers.ts
│   └── types/               # 类型定义
│       └── index.ts
├── __tests__/               # 测试文件
│   ├── plugin.test.ts
│   ├── tools/
│   │   └── tool1.test.ts
│   └── commands/
│       └── command1.test.ts
├── dist/                    # 编译输出
├── templates/               # 模板文件
├── docs/                    # 文档
├── examples/                # 示例
├── .eslintrc.json          # ESLint 配置
├── .gitignore              # Git 忽略文件
├── jest.config.json        # Jest 配置
├── package.json            # 项目配置
├── plugin.yaml             # 插件清单
├── tsconfig.json           # TypeScript 配置
└── README.md               # 项目说明
```

```
my-plugin/
├── src/
│   ├── index.ts              # 插件入口
│   ├── plugin.ts            # 插件主类
│   ├── tools/               # 工具定义
│   │   ├── tool1.ts
│   │   └── tool2.ts
│   ├── commands/            # 命令定义
│   │   ├── command1.ts
│   │   └── command2.ts
│   ├── utils/               # 工具函数
│   │   └── helpers.ts
│   └── types/               # 类型定义
│       └── index.ts
├── __tests__/               # 测试文件
│   ├── plugin.test.ts
│   ├── tools/
│   │   └── tool1.test.ts
│   └── commands/
│       └── command1.test.ts
├── dist/                    # 编译输出
├── templates/               # 模板文件
├── docs/                    # 文档
├── examples/                # 示例
├── .eslintrc.json          # ESLint 配置
├── .gitignore              # Git 忽略文件
├── jest.config.json        # Jest 配置
├── package.json            # 项目配置
├── plugin.yaml             # 插件清单
├── tsconfig.json           # TypeScript 配置
└── README.md               # 项目说明
```

##### 创建目录结构#

```
bash复制# 创建目录结构
mkdir -p src/tools src/commands src/utils src/types __tests__/tools __tests__/commands dist templates docs examples

# 创建基本文件
touch src/index.ts src/plugin.ts src/types/index.ts
touch .eslintrc.json jest.config.json tsconfig.json plugin.yaml README.md
touch .gitignore
```

```
# 创建目录结构
mkdir -p src/tools src/commands src/utils src/types __tests__/tools __tests__/commands dist templates docs examples

# 创建基本文件
touch src/index.ts src/plugin.ts src/types/index.ts
touch .eslintrc.json jest.config.json tsconfig.json plugin.yaml README.md
touch .gitignore
```

##### 配置 .gitignore#

```
gitignore复制
# Dependencies
node_modules/

# Build output
dist/

# Test coverage
coverage/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Environment
.env
.env.local

# Temporary files
*.tmp
.cache/
```

```
# Dependencies
node_modules/

# Build output
dist/

# Test coverage
coverage/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Environment
.env
.env.local

# Temporary files
*.tmp
.cache/
```

#### 21.1.6 配置开发环境#

##### 1. 配置 IDE#

###### VS Code 配置

```
json复制// .vscode/settings.json
{
"typescript.tsdk": "node_modules/typescript/lib",
"editor.formatOnSave": true,
"editor.codeActionsOnSave": {
"source.fixAll.eslint": true
},
"files.exclude": {
"**/node_modules": true,
"**/dist": true,
"**/coverage": true
}
}
```

```
// .vscode/settings.json
{
"typescript.tsdk": "node_modules/typescript/lib",
"editor.formatOnSave": true,
"editor.codeActionsOnSave": {
"source.fixAll.eslint": true
},
"files.exclude": {
"**/node_modules": true,
"**/dist": true,
"**/coverage": true
}
}
```

###### VS Code 扩展推荐

```
json复制// .vscode/extensions.json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next"
  ]
}
```

```
// .vscode/extensions.json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next"
  ]
}
```

###### VS Code 任务

```
json复制// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "build",
      "problemMatcher": "$tsc",
      "group": {
        "kind": "build",
        "isDefault": true
      }
    },
    {
      "type": "npm",
      "script": "test",
      "problemMatcher": "$tsc",
      "group": {
        "kind": "test",
        "isDefault": true
      }
    },
    {
      "type": "npm",
      "script": "lint",
      "problemMatcher": "$eslint-stylish",
      "group": "build"
    }
  ]
}
```

```
// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "build",
      "problemMatcher": "$tsc",
      "group": {
        "kind": "build",
        "isDefault": true
      }
    },
    {
      "type": "npm",
      "script": "test",
      "problemMatcher": "$tsc",
      "group": {
        "kind": "test",
        "isDefault": true
      }
    },
    {
      "type": "npm",
      "script": "lint",
      "problemMatcher": "$eslint-stylish",
      "group": "build"
    }
  ]
}
```

##### 2. 配置调试#

```
json复制// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Plugin",
      "type": "node",
      "request": "launch",
      "runtimeExecutable": "npm",
      "runtimeArgs": ["run", "dev"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "name": "Debug Tests",
      "type": "node",
      "request": "launch",
      "runtimeExecutable": "npm",
      "runtimeArgs": ["run", "test:watch"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

```
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Plugin",
      "type": "node",
      "request": "launch",
      "runtimeExecutable": "npm",
      "runtimeArgs": ["run", "dev"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "name": "Debug Tests",
      "type": "node",
      "request": "launch",
      "runtimeExecutable": "npm",
      "runtimeArgs": ["run", "test:watch"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

##### 3. 配置 Git Hooks#

```
bash复制# 安装 husky
npm install husky --save-dev

# 初始化 husky
npx husky install

# 添加 pre-commit hook
npx husky add .husky/pre-commit "npm run lint && npm run test"
```

```
# 安装 husky
npm install husky --save-dev

# 初始化 husky
npx husky install

# 添加 pre-commit hook
npx husky add .husky/pre-commit "npm run lint && npm run test"
```

#### 21.1.7 创建插件清单#

##### plugin.yaml 配置#

```
yaml复制# plugin.yaml
name: my-plugin
version: 1.0.0
description: My Claude Code Plugin
author: Your Name
license: MIT
homepage: https://github.com/yourname/my-plugin
repository: https://github.com/yourname/my-plugin

# 插件入口
main: dist/index.js
types: dist/index.d.ts

# 插件权限
permissions:
  file:
    - read: "/"
  network:
    - https: ["api.example.com"]

# 插件依赖
dependencies:
  claude-code: ">=1.0.0"

# 开发依赖
devDependencies:
  typescript: "^4.9.0"
  jest: "^29.0.0"

# 插件配置
config:
  timeout: 30
  retries: 3

# 插件元数据
metadata:
  category: development
  tags:
    - code-generation
    - productivity
  keywords:
    - plugin
    - claude-code
```

```
# plugin.yaml
name: my-plugin
version: 1.0.0
description: My Claude Code Plugin
author: Your Name
license: MIT
homepage: https://github.com/yourname/my-plugin
repository: https://github.com/yourname/my-plugin

# 插件入口
main: dist/index.js
types: dist/index.d.ts

# 插件权限
permissions:
  file:
    - read: "/"
  network:
    - https: ["api.example.com"]

# 插件依赖
dependencies:
  claude-code: ">=1.0.0"

# 开发依赖
devDependencies:
  typescript: "^4.9.0"
  jest: "^29.0.0"

# 插件配置
config:
  timeout: 30
  retries: 3

# 插件元数据
metadata:
  category: development
  tags:
    - code-generation
    - productivity
  keywords:
    - plugin
    - claude-code
```

#### 21.1.8 验证开发环境#

##### 1. 创建测试文件#

```
typescript复制// src/index.ts
export * from './plugin';
```

```
// src/index.ts
export * from './plugin';
```

```
typescript复制// src/plugin.ts
import { Plugin } from '@claude-code/plugin-sdk';

export class MyPlugin extends Plugin {
  constructor() {
    super({
      name: 'my-plugin',
      version: '1.0.0',
      description: 'My Claude Code Plugin'
    });
  }

  async initialize(): Promise<void> {
    console.log('Plugin initialized');
  }

  async start(): Promise<void> {
    console.log('Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Plugin stopped');
  }
}
```

```
// src/plugin.ts
import { Plugin } from '@claude-code/plugin-sdk';

export class MyPlugin extends Plugin {
  constructor() {
    super({
      name: 'my-plugin',
      version: '1.0.0',
      description: 'My Claude Code Plugin'
    });
  }

  async initialize(): Promise<void> {
    console.log('Plugin initialized');
  }

  async start(): Promise<void> {
    console.log('Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Plugin stopped');
  }
}
```

##### 2. 编译项目#

```
bash复制# 编译 TypeScript
npm run build

# 检查编译输出
ls -la dist/
```

```
# 编译 TypeScript
npm run build

# 检查编译输出
ls -la dist/
```

##### 3. 运行测试#

```
bash复制# 运行测试
npm test

# 运行测试并生成覆盖率报告
npm run test -- --coverage
```

```
# 运行测试
npm test

# 运行测试并生成覆盖率报告
npm run test -- --coverage
```

##### 4. 运行代码检查#

```
bash复制# 运行 ESLint
npm run lint

# 自动修复问题
npm run lint:fix
```

```
# 运行 ESLint
npm run lint

# 自动修复问题
npm run lint:fix
```

#### 21.1.9 开发工作流#

##### 1. 开发流程#

```
bash复制# 1. 创建功能分支
git checkout -b feature/new-feature

# 2. 开发功能
# 编辑代码...

# 3. 运行测试
npm test

# 4. 运行代码检查
npm run lint

# 5. 编译项目
npm run build

# 6. 提交更改
git add .
git commit -m "Add new feature"

# 7. 推送到远程
git push origin feature/new-feature

# 8. 创建 Pull Request
```

```
# 1. 创建功能分支
git checkout -b feature/new-feature

# 2. 开发功能
# 编辑代码...

# 3. 运行测试
npm test

# 4. 运行代码检查
npm run lint

# 5. 编译项目
npm run build

# 6. 提交更改
git add .
git commit -m "Add new feature"

# 7. 推送到远程
git push origin feature/new-feature

# 8. 创建 Pull Request
```

##### 2. 调试流程#

```
bash复制# 1. 启动开发模式
npm run dev
# 2. 在 VS Code 中设置断点
# 3. 按 F5 启动调试
# 4. 在调试控制台中查看输出
```

```
# 1. 启动开发模式
npm run dev
# 2. 在 VS Code 中设置断点
# 3. 按 F5 启动调试
# 4. 在调试控制台中查看输出
```

##### 3. 测试流程#

```
bash复制# 1. 编写测试
# 创建测试文件...

# 2. 运行测试
npm test

# 3. 查看测试覆盖率
npm run test -- --coverage

# 4. 运行特定测试
npm test -- --testNamePattern="MyPlugin"
```

```
# 1. 编写测试
# 创建测试文件...

# 2. 运行测试
npm test

# 3. 查看测试覆盖率
npm run test -- --coverage

# 4. 运行特定测试
npm test -- --testNamePattern="MyPlugin"
```

#### 21.1.10 常见问题解决#

##### 1. TypeScript 编译错误#

```
bash复制# 清理编译缓存
npm run clean
npm run build

# 重新安装依赖
rm -rf node_modules package-lock.json
npm install
```

```
# 清理编译缓存
npm run clean
npm run build

# 重新安装依赖
rm -rf node_modules package-lock.json
npm install
```

##### 2. 测试失败#

```
bash复制# 更新 Jest 配置
npm install --save-dev jest@latest ts-jest@latest

# 清理 Jest 缓存
npm test -- --clearCache
```

```
# 更新 Jest 配置
npm install --save-dev jest@latest ts-jest@latest

# 清理 Jest 缓存
npm test -- --clearCache
```

##### 3. ESLint 错误#

```
bash复制# 自动修复 ESLint 错误
npm run lint:fix

# 更新 ESLint 配置
npm install --save-dev @typescript-eslint/parser@latest @typescript-eslint/eslint-plugin@latest
```

```
# 自动修复 ESLint 错误
npm run lint:fix

# 更新 ESLint 配置
npm install --save-dev @typescript-eslint/parser@latest @typescript-eslint/eslint-plugin@latest
```

##### 4. 插件无法加载#

```
bash复制# 检查插件清单
cat plugin.yaml

# 验证编译输出
ls -la dist/

# 重新编译
npm run clean
npm run build
```

```
# 检查插件清单
cat plugin.yaml

# 验证编译输出
ls -la dist/

# 重新编译
npm run clean
npm run build
```

---

## 2 插件架构与生命周期

**URL**: https://claudecode.tangshuang.net/course/21.2%20%E6%8F%92%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F

#### 21.2.1 插件架构概述#

##### 整体架构#

Claude Code 插件采用分层架构设计，确保模块化和可扩展性。

```
markdown复制┌─────────────────────────────────────────┐
│         Claude Code 核心系统             │
├─────────────────────────────────────────┤
│         插件接口层 (Plugin Interface)     │
├─────────────────────────────────────────┤
│         插件核心层 (Plugin Core)          │
├─────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│  │ 工具层    │  │ 命令层    │  │钩子层   │ │
│  │(Tools)   │  │(Commands)│  │(Hooks) │ │
│  └──────────┘  └──────────┘  └────────┘ │
├─────────────────────────────────────────┤
│         插件基础层 (Plugin Base)          │
├─────────────────────────────────────────┤
│         插件实现层 (Plugin Impl)          │
└─────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────┐
│         Claude Code 核心系统             │
├─────────────────────────────────────────┤
│         插件接口层 (Plugin Interface)     │
├─────────────────────────────────────────┤
│         插件核心层 (Plugin Core)          │
├─────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│  │ 工具层    │  │ 命令层    │  │钩子层   │ │
│  │(Tools)   │  │(Commands)│  │(Hooks) │ │
│  └──────────┘  └──────────┘  └────────┘ │
├─────────────────────────────────────────┤
│         插件基础层 (Plugin Base)          │
├─────────────────────────────────────────┤
│         插件实现层 (Plugin Impl)          │
└─────────────────────────────────────────┘
```

##### 架构组件#

```
typescript复制// 插件架构组件
interface PluginArchitecture {
  // 插件接口层
  interface: {
    IPlugin: PluginInterface;
    ITool: ToolInterface;
    ICommand: CommandInterface;
    IHook: HookInterface;
  };

  // 插件核心层
  core: {
    PluginManager: PluginManager;
    PluginRegistry: PluginRegistry;
    PluginLoader: PluginLoader;
  };

  // 插件功能层
  features: {
    tools: Tool[];
    commands: Command[];
    hooks: Hook[];
  };

  // 插件基础层
  base: {
    Plugin: PluginBase;
    Tool: ToolBase;
    Command: CommandBase;
    Hook: HookBase;
  };
}
```

```
// 插件架构组件
interface PluginArchitecture {
  // 插件接口层
  interface: {
    IPlugin: PluginInterface;
    ITool: ToolInterface;
    ICommand: CommandInterface;
    IHook: HookInterface;
  };

  // 插件核心层
  core: {
    PluginManager: PluginManager;
    PluginRegistry: PluginRegistry;
    PluginLoader: PluginLoader;
  };

  // 插件功能层
  features: {
    tools: Tool[];
    commands: Command[];
    hooks: Hook[];
  };

  // 插件基础层
  base: {
    Plugin: PluginBase;
    Tool: ToolBase;
    Command: CommandBase;
    Hook: HookBase;
  };
}
```

#### 21.2.2 插件接口定义#

##### 1. IPlugin 接口#

```
typescript复制// src/types/index.ts
import { PluginConfig, PluginContext, PluginResult } from '@claude-code/plugin-sdk';

/**
 * 插件接口
 */
export interface IPlugin {
  /**
   * 插件名称
   */
  name: string;

  /**
   * 插件版本
   */
  version: string;

  /**
   * 插件描述
   */
  description: string;

  /**
   * 插件作者
   */
  author?: string;

  /**
   * 插件许可证
   */
  license?: string;

  /**
   * 初始化插件
   */
  initialize(config: PluginConfig): Promise<void>;

  /**
```

```
// src/types/index.ts
import { PluginConfig, PluginContext, PluginResult } from '@claude-code/plugin-sdk';

/**
 * 插件接口
 */
export interface IPlugin {
  /**
   * 插件名称
   */
  name: string;

  /**
   * 插件版本
   */
  version: string;

  /**
   * 插件描述
   */
  description: string;

  /**
   * 插件作者
   */
  author?: string;

  /**
   * 插件许可证
   */
  license?: string;

  /**
   * 初始化插件
   */
  initialize(config: PluginConfig): Promise<void>;

  /**
```

- 启动插件
*/
start(): Promise<void>;

- 停止插件
*/
stop(): Promise<void>;

- 清理插件
*/
cleanup(): Promise<void>;

- 获取插件状态
*/
getStatus(): PluginStatus;
}

```
bash复制
### 2. ITool 接口

```typescript

/**
 * 工具接口
 */
export interface ITool {
  /**
   * 工具名称
   */
  name: string;

  /**
   * 工具描述
   */
  description: string;

  /**
   * 工具参数定义
   */
  parameters: ToolParameter[];

  /**
   * 执行工具
   */
  execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult>;

  /**
   * 验证参数
   */
  validate(params: Record<string, any>): ValidationResult;
}

/**
 * 工具参数定义
 */
export interface ToolParameter {
  /**
   * 参数名称
   */
  name: string;

  /**
   * 参数类型
   */
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';

  /**
   * 参数描述
   */
  description: string;

  /**
   * 是否必需
   */
  required: boolean;

  /**
   * 默认值
   */
  default?: any;

  /**
   * 枚举值
   */
  enum?: any[];
}

/**
 * 工具执行结果
 */
export interface ToolResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 结果数据
   */
  data?: any;

  /**
   * 错误信息
   */
  error?: string;

  /**
   * 执行时间
   */
  executionTime?: number;
}
```

```
### 2. ITool 接口

```typescript

/**
 * 工具接口
 */
export interface ITool {
  /**
   * 工具名称
   */
  name: string;

  /**
   * 工具描述
   */
  description: string;

  /**
   * 工具参数定义
   */
  parameters: ToolParameter[];

  /**
   * 执行工具
   */
  execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult>;

  /**
   * 验证参数
   */
  validate(params: Record<string, any>): ValidationResult;
}

/**
 * 工具参数定义
 */
export interface ToolParameter {
  /**
   * 参数名称
   */
  name: string;

  /**
   * 参数类型
   */
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';

  /**
   * 参数描述
   */
  description: string;

  /**
   * 是否必需
   */
  required: boolean;

  /**
   * 默认值
   */
  default?: any;

  /**
   * 枚举值
   */
  enum?: any[];
}

/**
 * 工具执行结果
 */
export interface ToolResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 结果数据
   */
  data?: any;

  /**
   * 错误信息
   */
  error?: string;

  /**
   * 执行时间
   */
  executionTime?: number;
}
```

##### 3. ICommand 接口#

```
typescript复制/**
 * 命令接口
 */
export interface ICommand {
  /**
   * 命令名称
   */
  name: string;

  /**
   * 命令描述
   */
  description: string;

  /**
   * 命令参数定义
   */
  parameters: CommandParameter[];

  /**
   * 执行命令
   */
  execute(args: string[], context: PluginContext): Promise<CommandResult>;

  /**
   * 显示帮助
   */
  help(): string;
}

/**
 * 命令参数定义
 */
export interface CommandParameter {
  /**
   * 参数名称
   */
  name: string;

  /**
   * 参数类型
   */
  type: 'string' | 'number' | 'boolean' | 'flag';

  /**
   * 参数描述
   */
  description: string;

  /**
   * 是否必需
   */
  required: boolean;

  /**
   * 简写
   */
  short?: string;

  /**
   * 默认值
   */
  default?: any;
}

/**
 * 命令执行结果
 */
export interface CommandResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 输出内容
   */
  output?: string;

  /**
   * 错误信息
   */
  error?: string;

  /**
   * 退出码
   */
  exitCode?: number;
}
```

```
/**
 * 命令接口
 */
export interface ICommand {
  /**
   * 命令名称
   */
  name: string;

  /**
   * 命令描述
   */
  description: string;

  /**
   * 命令参数定义
   */
  parameters: CommandParameter[];

  /**
   * 执行命令
   */
  execute(args: string[], context: PluginContext): Promise<CommandResult>;

  /**
   * 显示帮助
   */
  help(): string;
}

/**
 * 命令参数定义
 */
export interface CommandParameter {
  /**
   * 参数名称
   */
  name: string;

  /**
   * 参数类型
   */
  type: 'string' | 'number' | 'boolean' | 'flag';

  /**
   * 参数描述
   */
  description: string;

  /**
   * 是否必需
   */
  required: boolean;

  /**
   * 简写
   */
  short?: string;

  /**
   * 默认值
   */
  default?: any;
}

/**
 * 命令执行结果
 */
export interface CommandResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 输出内容
   */
  output?: string;

  /**
   * 错误信息
   */
  error?: string;

  /**
   * 退出码
   */
  exitCode?: number;
}
```

##### 4. IHook 接口#

```
typescript复制
/**
 * 钩子接口
 */
export interface IHook {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子类型
   */
  type: HookType;

  /**
   * 钩子描述
   */
  description: string;

  /**
   * 执行钩子
   */
  execute(event: HookEvent, context: PluginContext): Promise<HookResult>;
}

/**
 * 钩子类型
 */
export type HookType =
  | 'before_command'    // 命令执行前
  | 'after_command'     // 命令执行后
  | 'on_error'           // 错误发生时
  | 'on_start'           // 插件启动时
  | 'on_stop'            // 插件停止时
  | 'on_message'         // 消息接收时;

/**
 * 钩子事件
 */
export interface HookEvent {
  /**
   * 事件类型
   */
  type: string;

  /**
   * 事件数据
   */
  data: Record<string, any>;

  /**
   * 事件时间戳
   */
  timestamp: Date;
}

/**
 * 钩子执行结果
 */
export interface HookResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 是否阻止后续处理
   */
  preventDefault?: boolean;

  /**
   * 修改后的事件数据
   */
  modifiedData?: Record<string, any>;

  /**
   * 错误信息
   */
  error?: string;
}
```

```
/**
 * 钩子接口
 */
export interface IHook {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子类型
   */
  type: HookType;

  /**
   * 钩子描述
   */
  description: string;

  /**
   * 执行钩子
   */
  execute(event: HookEvent, context: PluginContext): Promise<HookResult>;
}

/**
 * 钩子类型
 */
export type HookType =
  | 'before_command'    // 命令执行前
  | 'after_command'     // 命令执行后
  | 'on_error'           // 错误发生时
  | 'on_start'           // 插件启动时
  | 'on_stop'            // 插件停止时
  | 'on_message'         // 消息接收时;

/**
 * 钩子事件
 */
export interface HookEvent {
  /**
   * 事件类型
   */
  type: string;

  /**
   * 事件数据
   */
  data: Record<string, any>;

  /**
   * 事件时间戳
   */
  timestamp: Date;
}

/**
 * 钩子执行结果
 */
export interface HookResult {
  /**
   * 是否成功
   */
  success: boolean;

  /**
   * 是否阻止后续处理
   */
  preventDefault?: boolean;

  /**
   * 修改后的事件数据
   */
  modifiedData?: Record<string, any>;

  /**
   * 错误信息
   */
  error?: string;
}
```

#### 21.2.3 插件生命周期#

##### 生命周期阶段#

```
typescript复制/**
 * 插件生命周期阶段
 */
export enum PluginLifecycleStage {
  /**
   * 未加载
   */
  UNLOADED = 'unloaded',
  /**
   * 已加载
   */
  LOADED = 'loaded',
  /**
   * 已初始化
   */
INITIALIZED = 'initialized',
/**
* 运行中
*/
RUNNING = 'running',
/**
* 已停止
*/
STOPPED = 'stopped',
/**
* 已卸载
*/
UNLOADED_FINAL = 'unloaded_final'
}
/**
* 插件状态
*/
export interface PluginStatus {
/**
* 生命周期阶段
*/
stage: PluginLifecycleStage;
/**
* 是否启用
*/
enabled: boolean;
/**
* 错误信息
*/
error?: string;
/**
* 启动时间
*/
startTime?: Date;
/**
* 运行时间
*/
uptime?: number;
}
```

```
/**
 * 插件生命周期阶段
 */
export enum PluginLifecycleStage {
  /**
   * 未加载
   */
  UNLOADED = 'unloaded',
  /**
   * 已加载
   */
  LOADED = 'loaded',
  /**
   * 已初始化
   */
INITIALIZED = 'initialized',
/**
* 运行中
*/
RUNNING = 'running',
/**
* 已停止
*/
STOPPED = 'stopped',
/**
* 已卸载
*/
UNLOADED_FINAL = 'unloaded_final'
}
/**
* 插件状态
*/
export interface PluginStatus {
/**
* 生命周期阶段
*/
stage: PluginLifecycleStage;
/**
* 是否启用
*/
enabled: boolean;
/**
* 错误信息
*/
error?: string;
/**
* 启动时间
*/
startTime?: Date;
/**
* 运行时间
*/
uptime?: number;
}
```

##### 生命周期管理#

```
typescript复制```typescript

// src/plugin.ts
import {
  IPlugin,
  PluginConfig,
  PluginContext,
  PluginResult,
  PluginLifecycleStage,
  PluginStatus
} from '@claude-code/plugin-sdk';

export class Plugin implements IPlugin {
  name: string;
  version: string;
  description: string;
  author?: string;
  license?: string;

  private stage: PluginLifecycleStage = PluginLifecycleStage.UNLOADED;
  private enabled: boolean = false;
  private startTime?: Date;
  private error?: string;

  constructor(config: {
    name: string;
    version: string;
    description: string;
    author?: string;
    license?: string;
  }) {
    this.name = config.name;
    this.version = config.version;
    this.description = config.description;
    this.author = config.author;
    this.license = config.license;
  }

  /**
   * 初始化插件
   */
  async initialize(config: PluginConfig): Promise<void> {
    if (this.stage !== PluginLifecycleStage.UNLOADED) {
      throw new Error(`Plugin ${this.name} is already initialized`);
    }

    try {
      // 加载配置
      this.loadConfig(config);

      // 初始化依赖
      await this.initializeDependencies();

      // 注册工具
      this.registerTools();

      // 注册命令
      this.registerCommands();

      // 注册钩子
      this.registerHooks();

      // 更新状态
      this.stage = PluginLifecycleStage.INITIALIZED;

      console.log(`Plugin ${this.name} initialized`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 启动插件
   */
  async start(): Promise<void> {
    if (this.stage !== PluginLifecycleStage.INITIALIZED) {
      throw new Error(`Plugin ${this.name} is not initialized`);
    }

    try {
      // 启动后台任务
      await this.startBackgroundTasks();

      // 建立连接
      await this.establishConnections();

      // 更新状态
      this.stage = PluginLifecycleStage.RUNNING;
      this.enabled = true;
      this.startTime = new Date();

      console.log(`Plugin ${this.name} started`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 停止插件
   */
  async stop(): Promise<void> {
    if (this.stage !== PluginLifecycleStage.RUNNING) {
      throw new Error(`Plugin ${this.name} is not running`);
    }

    try {
      // 停止后台任务
      await this.stopBackgroundTasks();

      // 关闭连接
      await this.closeConnections();

      // 更新状态
      this.stage = PluginLifecycleStage.STOPPED;
      this.enabled = false;

      console.log(`Plugin ${this.name} stopped`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 清理插件
   */
  async cleanup(): Promise<void> {
    try {
      // 清理资源
      await this.cleanupResources();

      // 注销注册
      this.unregisterAll();

      // 更新状态
      this.stage = PluginLifecycleStage.UNLOADED_FINAL;
      this.error = undefined;

      console.log(`Plugin ${this.name} cleaned up`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 获取插件状态
   */
  getStatus(): PluginStatus {
    const uptime = this.startTime
      ? Date.now() - this.startTime.getTime()
      : 0;

    return {
      stage: this.stage,
      enabled: this.enabled,
      error: this.error,
      startTime: this.startTime,
      uptime
    };
  }

  /**
   * 加载配置
   */
  protected loadConfig(config: PluginConfig): void {
    // 子类实现
  }

  /**
   * 初始化依赖
   */
  protected async initializeDependencies(): Promise<void> {
    // 子类实现
  }

  /**
   * 注册工具
   */
  protected registerTools(): void {
    // 子类实现
  }

  /**
   * 注册命令
   */
  protected registerCommands(): void {
    // 子类实现
  }

  /**
   * 注册钩子
   */
  protected registerHooks(): void {
    // 子类实现
  }

  /**
   * 启动后台任务
   */
  protected async startBackgroundTasks(): Promise<void> {
    // 子类实现
  }

  /**
   * 建立连接
   */
  protected async establishConnections(): Promise<void> {
    // 子类实现
  }

  /**
   * 停止后台任务
   */
  protected async stopBackgroundTasks(): Promise<void> {
    // 子类实现
  }

  /**
   * 关闭连接
   */
  protected async closeConnections(): Promise<void> {
    // 子类实现
  }

  /**
   * 清理资源
   */
  protected async cleanupResources(): Promise<void> {
    // 子类实现
  }

  /**
   * 注销所有注册
   */
  protected unregisterAll(): void {
    // 子类实现
  }
}

```## 21.2.4 生命周期事件

### 事件定义

/**
* 插件生命周期事件
*/
export interface PluginLifecycleEvent {
/**
* 事件类型
*/
type: 'initialize' | 'start' | 'stop' | 'cleanup' | 'error';
/**
* 插件名称
*/
pluginName: string;
/**
* 事件数据
*/
data: {
stage: PluginLifecycleStage;
error?: Error;
timestamp: Date;
};
}
/**
* 事件监听器
*/
export type PluginEventListener = (event: PluginLifecycleEvent) => void;
```

```
```typescript

// src/plugin.ts
import {
  IPlugin,
  PluginConfig,
  PluginContext,
  PluginResult,
  PluginLifecycleStage,
  PluginStatus
} from '@claude-code/plugin-sdk';

export class Plugin implements IPlugin {
  name: string;
  version: string;
  description: string;
  author?: string;
  license?: string;

  private stage: PluginLifecycleStage = PluginLifecycleStage.UNLOADED;
  private enabled: boolean = false;
  private startTime?: Date;
  private error?: string;

  constructor(config: {
    name: string;
    version: string;
    description: string;
    author?: string;
    license?: string;
  }) {
    this.name = config.name;
    this.version = config.version;
    this.description = config.description;
    this.author = config.author;
    this.license = config.license;
  }

  /**
   * 初始化插件
   */
  async initialize(config: PluginConfig): Promise<void> {
    if (this.stage !== PluginLifecycleStage.UNLOADED) {
      throw new Error(`Plugin ${this.name} is already initialized`);
    }

    try {
      // 加载配置
      this.loadConfig(config);

      // 初始化依赖
      await this.initializeDependencies();

      // 注册工具
      this.registerTools();

      // 注册命令
      this.registerCommands();

      // 注册钩子
      this.registerHooks();

      // 更新状态
      this.stage = PluginLifecycleStage.INITIALIZED;

      console.log(`Plugin ${this.name} initialized`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 启动插件
   */
  async start(): Promise<void> {
    if (this.stage !== PluginLifecycleStage.INITIALIZED) {
      throw new Error(`Plugin ${this.name} is not initialized`);
    }

    try {
      // 启动后台任务
      await this.startBackgroundTasks();

      // 建立连接
      await this.establishConnections();

      // 更新状态
      this.stage = PluginLifecycleStage.RUNNING;
      this.enabled = true;
      this.startTime = new Date();

      console.log(`Plugin ${this.name} started`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 停止插件
   */
  async stop(): Promise<void> {
    if (this.stage !== PluginLifecycleStage.RUNNING) {
      throw new Error(`Plugin ${this.name} is not running`);
    }

    try {
      // 停止后台任务
      await this.stopBackgroundTasks();

      // 关闭连接
      await this.closeConnections();

      // 更新状态
      this.stage = PluginLifecycleStage.STOPPED;
      this.enabled = false;

      console.log(`Plugin ${this.name} stopped`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 清理插件
   */
  async cleanup(): Promise<void> {
    try {
      // 清理资源
      await this.cleanupResources();

      // 注销注册
      this.unregisterAll();

      // 更新状态
      this.stage = PluginLifecycleStage.UNLOADED_FINAL;
      this.error = undefined;

      console.log(`Plugin ${this.name} cleaned up`);
    } catch (error) {
      this.error = error.message;
      throw error;
    }
  }

  /**
   * 获取插件状态
   */
  getStatus(): PluginStatus {
    const uptime = this.startTime
      ? Date.now() - this.startTime.getTime()
      : 0;

    return {
      stage: this.stage,
      enabled: this.enabled,
      error: this.error,
      startTime: this.startTime,
      uptime
    };
  }

  /**
   * 加载配置
   */
  protected loadConfig(config: PluginConfig): void {
    // 子类实现
  }

  /**
   * 初始化依赖
   */
  protected async initializeDependencies(): Promise<void> {
    // 子类实现
  }

  /**
   * 注册工具
   */
  protected registerTools(): void {
    // 子类实现
  }

  /**
   * 注册命令
   */
  protected registerCommands(): void {
    // 子类实现
  }

  /**
   * 注册钩子
   */
  protected registerHooks(): void {
    // 子类实现
  }

  /**
   * 启动后台任务
   */
  protected async startBackgroundTasks(): Promise<void> {
    // 子类实现
  }

  /**
   * 建立连接
   */
  protected async establishConnections(): Promise<void> {
    // 子类实现
  }

  /**
   * 停止后台任务
   */
  protected async stopBackgroundTasks(): Promise<void> {
    // 子类实现
  }

  /**
   * 关闭连接
   */
  protected async closeConnections(): Promise<void> {
    // 子类实现
  }

  /**
   * 清理资源
   */
  protected async cleanupResources(): Promise<void> {
    // 子类实现
  }

  /**
   * 注销所有注册
   */
  protected unregisterAll(): void {
    // 子类实现
  }
}

```## 21.2.4 生命周期事件

### 事件定义

/**
* 插件生命周期事件
*/
export interface PluginLifecycleEvent {
/**
* 事件类型
*/
type: 'initialize' | 'start' | 'stop' | 'cleanup' | 'error';
/**
* 插件名称
*/
pluginName: string;
/**
* 事件数据
*/
data: {
stage: PluginLifecycleStage;
error?: Error;
timestamp: Date;
};
}
/**
* 事件监听器
*/
export type PluginEventListener = (event: PluginLifecycleEvent) => void;
```

##### 事件管理#

```
typescript复制```typescript

/**
 * 插件事件管理器
 */
export class PluginEventManager {
  private listeners: Map<string, PluginEventListener[]> = new Map();

  /**
   * 注册事件监听器
   */
  on(eventType: string, listener: PluginEventListener): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);
  }

  /**
   * 移除事件监听器
   */
  off(eventType: string, listener: PluginEventListener): void {
    const listeners = this.listeners.get(eventType);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * 触发事件
   */
  emit(event: PluginLifecycleEvent): void {
    const listeners = this.listeners.get(event.type);
    if (listeners) {
      listeners.forEach(listener => listener(event));
    }
  }
}

```### 事件集成

// src/plugin.ts
import { PluginEventManager, PluginLifecycleEvent } from '@claude-code/plugin-sdk';
export class Plugin implements IPlugin {
private eventManager: PluginEventManager = new PluginEventManager();
/**
* 初始化插件
*/
async initialize(config: PluginConfig): Promise<void> {
try {
// ... 初始化逻辑
// 触发初始化事件
this.emitEvent('initialize', {});
console.log(`Plugin ${this.name} initialized`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 启动插件
*/
async start(): Promise<void> {
try {
// ... 启动逻辑
// 触发启动事件
this.emitEvent('start', {});
console.log(`Plugin ${this.name} started`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 停止插件
*/
async stop(): Promise<void> {
try {
// ... 停止逻辑
// 触发停止事件
this.emitEvent('stop', {});
console.log(`Plugin ${this.name} stopped`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 清理插件
*/
async cleanup(): Promise<void> {
try {
// ... 清理逻辑
// 触发清理事件
this.emitEvent('cleanup', {});
console.log(`Plugin ${this.name} cleaned up`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 触发事件
*/
private emitEvent(
type: 'initialize' | 'start' | 'stop' | 'cleanup' | 'error',
data: Record<string, any>
): void {
const event: PluginLifecycleEvent = {
type,
pluginName: this.name,
data: {
stage: this.stage,
timestamp: new Date(),
...data
}
};
this.eventManager.emit(event);
}
/**
* 注册事件监听器
*/
on(eventType: string, listener: PluginEventListener): void {
this.eventManager.on(eventType, listener);
}
/**
* 移除事件监听器
*/
off(eventType: string, listener: PluginEventListener): void {
this.eventManager.off(eventType, listener);
}
}
```

```
```typescript

/**
 * 插件事件管理器
 */
export class PluginEventManager {
  private listeners: Map<string, PluginEventListener[]> = new Map();

  /**
   * 注册事件监听器
   */
  on(eventType: string, listener: PluginEventListener): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);
  }

  /**
   * 移除事件监听器
   */
  off(eventType: string, listener: PluginEventListener): void {
    const listeners = this.listeners.get(eventType);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * 触发事件
   */
  emit(event: PluginLifecycleEvent): void {
    const listeners = this.listeners.get(event.type);
    if (listeners) {
      listeners.forEach(listener => listener(event));
    }
  }
}

```### 事件集成

// src/plugin.ts
import { PluginEventManager, PluginLifecycleEvent } from '@claude-code/plugin-sdk';
export class Plugin implements IPlugin {
private eventManager: PluginEventManager = new PluginEventManager();
/**
* 初始化插件
*/
async initialize(config: PluginConfig): Promise<void> {
try {
// ... 初始化逻辑
// 触发初始化事件
this.emitEvent('initialize', {});
console.log(`Plugin ${this.name} initialized`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 启动插件
*/
async start(): Promise<void> {
try {
// ... 启动逻辑
// 触发启动事件
this.emitEvent('start', {});
console.log(`Plugin ${this.name} started`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 停止插件
*/
async stop(): Promise<void> {
try {
// ... 停止逻辑
// 触发停止事件
this.emitEvent('stop', {});
console.log(`Plugin ${this.name} stopped`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 清理插件
*/
async cleanup(): Promise<void> {
try {
// ... 清理逻辑
// 触发清理事件
this.emitEvent('cleanup', {});
console.log(`Plugin ${this.name} cleaned up`);
} catch (error) {
// 触发错误事件
this.emitEvent('error', { error });
throw error;
}
}
/**
* 触发事件
*/
private emitEvent(
type: 'initialize' | 'start' | 'stop' | 'cleanup' | 'error',
data: Record<string, any>
): void {
const event: PluginLifecycleEvent = {
type,
pluginName: this.name,
data: {
stage: this.stage,
timestamp: new Date(),
...data
}
};
this.eventManager.emit(event);
}
/**
* 注册事件监听器
*/
on(eventType: string, listener: PluginEventListener): void {
this.eventManager.on(eventType, listener);
}
/**
* 移除事件监听器
*/
off(eventType: string, listener: PluginEventListener): void {
this.eventManager.off(eventType, listener);
}
}
```

#### 21.2.5 生命周期钩子#

##### 钩子定义#

```
typescript复制```typescript

/**
 * 插件生命周期钩子
 */
export interface PluginLifecycleHook {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子阶段
   */
  stage: PluginLifecycleStage;

  /**
   * 钩子函数
   */
  hook: (context: PluginContext) => Promise<void>;

  /**
   * 优先级
   */
  priority?: number;
}

```### 钩子管理

/**
* 插件钩子管理器
*/
export class PluginHookManager {
private hooks: Map<PluginLifecycleStage, PluginLifecycleHook[]> = new Map();
/**
* 注册钩子
*/
register(hook: PluginLifecycleHook): void {
if (!this.hooks.has(hook.stage)) {
this.hooks.set(hook.stage, []);
}
const hooks = this.hooks.get(hook.stage)!;
hooks.push(hook);
// 按优先级排序
hooks.sort((a, b) => (b.priority || 0) - (a.priority || 0));
}
/**
* 执行钩子
*/
async execute(stage: PluginLifecycleStage, context: PluginContext): Promise<void> {
const hooks = this.hooks.get(stage);
if (!hooks) {
return;
}
for (const hook of hooks) {
try {
await hook.hook(context);
} catch (error) {
console.error(`Hook ${hook.name} failed:`, error);
}
}
}
/**
* 移除钩子
*/
unregister(name: string): void {
for (const hooks of this.hooks.values()) {
const index = hooks.findIndex(h => h.name === name);
if (index > -1) {
hooks.splice(index, 1);
}
}
}
}
```

```
```typescript

/**
 * 插件生命周期钩子
 */
export interface PluginLifecycleHook {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子阶段
   */
  stage: PluginLifecycleStage;

  /**
   * 钩子函数
   */
  hook: (context: PluginContext) => Promise<void>;

  /**
   * 优先级
   */
  priority?: number;
}

```### 钩子管理

/**
* 插件钩子管理器
*/
export class PluginHookManager {
private hooks: Map<PluginLifecycleStage, PluginLifecycleHook[]> = new Map();
/**
* 注册钩子
*/
register(hook: PluginLifecycleHook): void {
if (!this.hooks.has(hook.stage)) {
this.hooks.set(hook.stage, []);
}
const hooks = this.hooks.get(hook.stage)!;
hooks.push(hook);
// 按优先级排序
hooks.sort((a, b) => (b.priority || 0) - (a.priority || 0));
}
/**
* 执行钩子
*/
async execute(stage: PluginLifecycleStage, context: PluginContext): Promise<void> {
const hooks = this.hooks.get(stage);
if (!hooks) {
return;
}
for (const hook of hooks) {
try {
await hook.hook(context);
} catch (error) {
console.error(`Hook ${hook.name} failed:`, error);
}
}
}
/**
* 移除钩子
*/
unregister(name: string): void {
for (const hooks of this.hooks.values()) {
const index = hooks.findIndex(h => h.name === name);
if (index > -1) {
hooks.splice(index, 1);
}
}
}
}
```

##### 钩子集成#

```
typescript复制```typescript

// src/plugin.ts
import { PluginHookManager, PluginLifecycleHook } from '@claude-code/plugin-sdk';

export class Plugin implements IPlugin {
  private hookManager: PluginHookManager = new PluginHookManager();

  /**
   * 注册生命周期钩子
   */
  registerLifecycleHook(hook: PluginLifecycleHook): void {
    this.hookManager.register(hook);
  }

  /**
   * 初始化插件
   */
  async initialize(config: PluginConfig): Promise<void> {
    // 执行初始化前钩子
    await this.hookManager.execute(PluginLifecycleStage.INITIALIZED, {
      plugin: this,
      config
    });

    // ... 初始化逻辑

    // 执行初始化后钩子
    await this.hookManager.execute(PluginLifecycleStage.INITIALIZED, {
      plugin: this,
      config
    });
  }

  /**
   * 启动插件
   */
  async start(): Promise<void> {
    // 执行启动前钩子
    await this.hookManager.execute(PluginLifecycleStage.RUNNING, {
      plugin: this
    });

    // ... 启动逻辑

    // 执行启动后钩子
    await this.hookManager.execute(PluginLifecycleStage.RUNNING, {
      plugin: this
    });
  }

  /**
   * 停止插件
   */
  async stop(): Promise<void> {
    // 执行停止前钩子
    await this.hookManager.execute(PluginLifecycleStage.STOPPED, {
      plugin: this
    });

    // ... 停止逻辑

    // 执行停止后钩子
    await this.hookManager.execute(PluginLifecycleStage.STOPPED, {
      plugin: this
    });
  }
}
```

```
```typescript

// src/plugin.ts
import { PluginHookManager, PluginLifecycleHook } from '@claude-code/plugin-sdk';

export class Plugin implements IPlugin {
  private hookManager: PluginHookManager = new PluginHookManager();

  /**
   * 注册生命周期钩子
   */
  registerLifecycleHook(hook: PluginLifecycleHook): void {
    this.hookManager.register(hook);
  }

  /**
   * 初始化插件
   */
  async initialize(config: PluginConfig): Promise<void> {
    // 执行初始化前钩子
    await this.hookManager.execute(PluginLifecycleStage.INITIALIZED, {
      plugin: this,
      config
    });

    // ... 初始化逻辑

    // 执行初始化后钩子
    await this.hookManager.execute(PluginLifecycleStage.INITIALIZED, {
      plugin: this,
      config
    });
  }

  /**
   * 启动插件
   */
  async start(): Promise<void> {
    // 执行启动前钩子
    await this.hookManager.execute(PluginLifecycleStage.RUNNING, {
      plugin: this
    });

    // ... 启动逻辑

    // 执行启动后钩子
    await this.hookManager.execute(PluginLifecycleStage.RUNNING, {
      plugin: this
    });
  }

  /**
   * 停止插件
   */
  async stop(): Promise<void> {
    // 执行停止前钩子
    await this.hookManager.execute(PluginLifecycleStage.STOPPED, {
      plugin: this
    });

    // ... 停止逻辑

    // 执行停止后钩子
    await this.hookManager.execute(PluginLifecycleStage.STOPPED, {
      plugin: this
    });
  }
}
```

---

## 3 插件开发 API

**URL**: https://claudecode.tangshuang.net/course/21.3%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%20API

#### 概述#

Claude Code 提供了一套强大的插件开发 API，允许开发者扩展和定制系统功能。本章节将详细介绍核心 API 接口、使用方法和最佳实践。

#### 核心 API 接口#

##### IPlugin 接口#

IPlugin 是所有插件必须实现的核心接口：

```
typescript复制/**
 * 插件接口
 */
export interface IPlugin {
  /**
   * 插件元数据
   */
  metadata: PluginMetadata;

  /**
   * 插件配置
   */
  config: PluginConfig;

  /**
   * 插件状态
   */
  status: PluginStatus;

  /**
   * 初始化插件
   * @param context 插件上下文
   */
  initialize(context: PluginContext): Promise<void>;

  /**
   * 启动插件
   */
  start(): Promise<void>;

  /**
   * 停止插件
   */
  stop(): Promise<void>;

  /**
   * 清理插件
   */
  cleanup(): Promise<void>;

  /**
   * 处理插件消息
   * @param message 消息内容
   */
  handleMessage(message: PluginMessage): Promise<PluginMessageResponse>;

  /**
   * 获取插件功能
   */
  getCapabilities(): PluginCapabilities;
}
```

```
/**
 * 插件接口
 */
export interface IPlugin {
  /**
   * 插件元数据
   */
  metadata: PluginMetadata;

  /**
   * 插件配置
   */
  config: PluginConfig;

  /**
   * 插件状态
   */
  status: PluginStatus;

  /**
   * 初始化插件
   * @param context 插件上下文
   */
  initialize(context: PluginContext): Promise<void>;

  /**
   * 启动插件
   */
  start(): Promise<void>;

  /**
   * 停止插件
   */
  stop(): Promise<void>;

  /**
   * 清理插件
   */
  cleanup(): Promise<void>;

  /**
   * 处理插件消息
   * @param message 消息内容
   */
  handleMessage(message: PluginMessage): Promise<PluginMessageResponse>;

  /**
   * 获取插件功能
   */
  getCapabilities(): PluginCapabilities;
}
```

##### PluginMetadata 接口#

插件元数据定义了插件的基本信息：

```
typescript复制/**
 * 插件元数据
 */
export interface PluginMetadata {
  /**
   * 插件唯一标识符
   */
  id: string;

  /**
   * 插件名称
   */
  name: string;

  /**
   * 插件版本
   */
  version: string;

  /**
   * 插件描述
   */
  description: string;

  /**
   * 插件作者
   */
  author?: string;

  /**
   * 插件许可证
   */
  license?: string;

  /**
   * 插件主页
   */
  homepage?: string;

  /**
   * 插件依赖
   */
  dependencies?: PluginDependency[];

  /**
   * 插件兼容性
   */
  compatibility?: PluginCompatibility;
}
```

```
/**
 * 插件元数据
 */
export interface PluginMetadata {
  /**
   * 插件唯一标识符
   */
  id: string;

  /**
   * 插件名称
   */
  name: string;

  /**
   * 插件版本
   */
  version: string;

  /**
   * 插件描述
   */
  description: string;

  /**
   * 插件作者
   */
  author?: string;

  /**
   * 插件许可证
   */
  license?: string;

  /**
   * 插件主页
   */
  homepage?: string;

  /**
   * 插件依赖
   */
  dependencies?: PluginDependency[];

  /**
   * 插件兼容性
   */
  compatibility?: PluginCompatibility;
}
```

##### PluginContext 接口#

插件上下文提供了插件与系统交互的能力：

```
typescript复制/**
 * 插件上下文
 */
export interface PluginContext {
  /**
   * 系统服务提供者
   */
  services: ServiceProvider;

  /**
   * 日志服务
   */
  logger: Logger;

  /**
   * 配置服务
   */
  configService: ConfigService;

  /**
   * 事件总线
   */
  eventBus: EventBus;

  /**
   * 插件管理器
   */
  pluginManager: PluginManager;

  /**
   * 资源管理器
   */
  resourceManager: ResourceManager;

  /**
   * 获取系统信息
   */
  getSystemInfo(): SystemInfo;

  /**
   * 发送系统通知
   */
  sendNotification(notification: Notification): Promise<void>;

  /**
   * 执行系统命令
   */
  executeCommand(command: Command): Promise<CommandResult>;
}
```

```
/**
 * 插件上下文
 */
export interface PluginContext {
  /**
   * 系统服务提供者
   */
  services: ServiceProvider;

  /**
   * 日志服务
   */
  logger: Logger;

  /**
   * 配置服务
   */
  configService: ConfigService;

  /**
   * 事件总线
   */
  eventBus: EventBus;

  /**
   * 插件管理器
   */
  pluginManager: PluginManager;

  /**
   * 资源管理器
   */
  resourceManager: ResourceManager;

  /**
   * 获取系统信息
   */
  getSystemInfo(): SystemInfo;

  /**
   * 发送系统通知
   */
  sendNotification(notification: Notification): Promise<void>;

  /**
   * 执行系统命令
   */
  executeCommand(command: Command): Promise<CommandResult>;
}
```

#### 工具 API#

##### ITool 接口#

ITool 接口用于创建可复用的工具：

```
typescript复制/**
 * 工具接口
 */
export interface ITool {
  /**
   * 工具元数据
   */
  metadata: ToolMetadata;

  /**
   * 工具配置
   */
  config: ToolConfig;

  /**
   * 执行工具
   * @param parameters 工具参数
   */
  execute(parameters: ToolParameters): Promise<ToolResult>;

  /**
   * 验证参数
   * @param parameters 工具参数
   */
  validate(parameters: ToolParameters): ToolValidationResult;

  /**
   * 获取工具帮助信息
   */
  getHelp(): ToolHelp;
}
```

```
/**
 * 工具接口
 */
export interface ITool {
  /**
   * 工具元数据
   */
  metadata: ToolMetadata;

  /**
   * 工具配置
   */
  config: ToolConfig;

  /**
   * 执行工具
   * @param parameters 工具参数
   */
  execute(parameters: ToolParameters): Promise<ToolResult>;

  /**
   * 验证参数
   * @param parameters 工具参数
   */
  validate(parameters: ToolParameters): ToolValidationResult;

  /**
   * 获取工具帮助信息
   */
  getHelp(): ToolHelp;
}
```

##### ToolMetadata 接口#

```
typescript复制/**
 * 工具元数据
 */
export interface ToolMetadata {
  /**
   * 工具唯一标识符
   */
  id: string;

  /**
   * 工具名称
   */
  name: string;

  /**
   * 工具描述
   */
  description: string;

  /**
   * 工具类型
   */
  type: ToolType;

  /**
   * 工具参数
   */
  parameters: ToolParameter[];

  /**
   * 工具返回结果
   */
  returns: ToolReturn;

  /**
   * 工具示例
   */
  examples: ToolExample[];
}
```

```
/**
 * 工具元数据
 */
export interface ToolMetadata {
  /**
   * 工具唯一标识符
   */
  id: string;

  /**
   * 工具名称
   */
  name: string;

  /**
   * 工具描述
   */
  description: string;

  /**
   * 工具类型
   */
  type: ToolType;

  /**
   * 工具参数
   */
  parameters: ToolParameter[];

  /**
   * 工具返回结果
   */
  returns: ToolReturn;

  /**
   * 工具示例
   */
  examples: ToolExample[];
}
```

#### 命令 API#

##### ICommand 接口#

ICommand 接口用于实现 CLI 命令：

```
typescript复制/**
 * 命令接口
 */
export interface ICommand {
  /**
   * 命令元数据
   */
  metadata: CommandMetadata;

  /**
   * 执行命令
   * @param args 命令参数
   * @param options 命令选项
   */
  execute(args: string[], options: CommandOptions): Promise<CommandResult>;

  /**
   * 验证命令参数
   * @param args 命令参数
   * @param options 命令选项
   */
  validate(args: string[], options: CommandOptions): CommandValidationResult;

  /**
   * 获取命令帮助信息
   */
  getHelp(): CommandHelp;
}
```

```
/**
 * 命令接口
 */
export interface ICommand {
  /**
   * 命令元数据
   */
  metadata: CommandMetadata;

  /**
   * 执行命令
   * @param args 命令参数
   * @param options 命令选项
   */
  execute(args: string[], options: CommandOptions): Promise<CommandResult>;

  /**
   * 验证命令参数
   * @param args 命令参数
   * @param options 命令选项
   */
  validate(args: string[], options: CommandOptions): CommandValidationResult;

  /**
   * 获取命令帮助信息
   */
  getHelp(): CommandHelp;
}
```

##### CommandMetadata 接口#

```
typescript复制/**
 * 命令元数据
 */
export interface CommandMetadata {
  /**
   * 命令名称
   */
  name: string;

  /**
   * 命令描述
   */
  description: string;

  /**
   * 命令别名
   */
  aliases?: string[];

  /**
   * 命令参数
   */
  arguments: CommandArgument[];

  /**
   * 命令选项
   */
  options: CommandOption[];

  /**
   * 命令示例
   */
  examples: CommandExample[];

  /**
   * 命令类别
   */
  category?: string;

  /**
   * 命令可见性
   */
  visible?: boolean;
}
```

```
/**
 * 命令元数据
 */
export interface CommandMetadata {
  /**
   * 命令名称
   */
  name: string;

  /**
   * 命令描述
   */
  description: string;

  /**
   * 命令别名
   */
  aliases?: string[];

  /**
   * 命令参数
   */
  arguments: CommandArgument[];

  /**
   * 命令选项
   */
  options: CommandOption[];

  /**
   * 命令示例
   */
  examples: CommandExample[];

  /**
   * 命令类别
   */
  category?: string;

  /**
   * 命令可见性
   */
  visible?: boolean;
}
```

#### 钩子 API#

##### IHook 接口#

IHook 接口用于实现事件驱动功能：

```
typescript复制/**
 * 钩子接口
 */
export interface IHook {
  /**
   * 钩子元数据
   */
  metadata: HookMetadata;

  /**
   * 执行钩子
   * @param context 钩子上下文
   */
  execute(context: HookContext): Promise<HookResult>;

  /**
   * 注册钩子
   */
  register(): void;

  /**
   * 注销钩子
   */
  unregister(): void;
}
```

```
/**
 * 钩子接口
 */
export interface IHook {
  /**
   * 钩子元数据
   */
  metadata: HookMetadata;

  /**
   * 执行钩子
   * @param context 钩子上下文
   */
  execute(context: HookContext): Promise<HookResult>;

  /**
   * 注册钩子
   */
  register(): void;

  /**
   * 注销钩子
   */
  unregister(): void;
}
```

##### HookMetadata 接口#

```
typescript复制/**
 * 钩子元数据
 */
export interface HookMetadata {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子描述
   */
  description: string;

  /**
   * 钩子类型
   */
  type: HookType;

  /**
   * 钩子触发点
   */
  triggerPoint: string;

  /**
   * 钩子优先级
   */
  priority: number;

  /**
   * 钩子参数
   */
  parameters: HookParameter[];

  /**
   * 钩子返回结果
   */
  returns: HookReturn;
}
```

```
/**
 * 钩子元数据
 */
export interface HookMetadata {
  /**
   * 钩子名称
   */
  name: string;

  /**
   * 钩子描述
   */
  description: string;

  /**
   * 钩子类型
   */
  type: HookType;

  /**
   * 钩子触发点
   */
  triggerPoint: string;

  /**
   * 钩子优先级
   */
  priority: number;

  /**
   * 钩子参数
   */
  parameters: HookParameter[];

  /**
   * 钩子返回结果
   */
  returns: HookReturn;
}
```

#### API 使用示例#

##### 创建简单插件#

```
typescript复制import { IPlugin, PluginMetadata, PluginContext } from '@claude-code/plugin-sdk';

export class HelloWorldPlugin implements IPlugin {
  metadata: PluginMetadata = {
    id: 'hello-world-plugin',
    name: 'Hello World Plugin',
    version: '1.0.0',
    description: 'A simple hello world plugin',
    author: 'Claude Code Team',
    license: 'MIT'
  };

  config: any = {};
  status: any = {};

  async initialize(context: PluginContext): Promise<void> {
    context.logger.info('Hello World Plugin initialized');
  }

  async start(): Promise<void> {
    console.log('Hello World Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Hello World Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Hello World Plugin cleaned up');
  }

  async handleMessage(message: any): Promise<any> {
    return { message: 'Hello from plugin' };
  }

  getCapabilities(): any {
    return { features: ['hello-world'] };
  }
}
```

```
import { IPlugin, PluginMetadata, PluginContext } from '@claude-code/plugin-sdk';

export class HelloWorldPlugin implements IPlugin {
  metadata: PluginMetadata = {
    id: 'hello-world-plugin',
    name: 'Hello World Plugin',
    version: '1.0.0',
    description: 'A simple hello world plugin',
    author: 'Claude Code Team',
    license: 'MIT'
  };

  config: any = {};
  status: any = {};

  async initialize(context: PluginContext): Promise<void> {
    context.logger.info('Hello World Plugin initialized');
  }

  async start(): Promise<void> {
    console.log('Hello World Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Hello World Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Hello World Plugin cleaned up');
  }

  async handleMessage(message: any): Promise<any> {
    return { message: 'Hello from plugin' };
  }

  getCapabilities(): any {
    return { features: ['hello-world'] };
  }
}
```

##### 创建工具#

```
typescript复制import { ITool, ToolMetadata, ToolParameters } from '@claude-code/plugin-sdk';

export class CalculatorTool implements ITool {
  metadata: ToolMetadata = {
    id: 'calculator-tool',
    name: 'Calculator Tool',
    description: 'A simple calculator tool',
    type: 'utility',
    parameters: [
      { name: 'operation', type: 'string', description: 'Operation to perform' },
      { name: 'a', type: 'number', description: 'First number' },
      { name: 'b', type: 'number', description: 'Second number' }
    ],
    returns: { type: 'number', description: 'Calculation result' },
    examples: [
      { input: { operation: 'add', a: 1, b: 2 }, output: 3 },
      { input: { operation: 'multiply', a: 3, b: 4 }, output: 12 }
    ]
  };

  config: any = {};

  async execute(parameters: ToolParameters): Promise<any> {
    const { operation, a, b } = parameters;
    
    switch (operation) {
      case 'add':
        return a + b;
      case 'subtract':
        return a - b;
      case 'multiply':
        return a * b;
      case 'divide':
        return a / b;
      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  }

  validate(parameters: ToolParameters): any {
    if (!parameters.operation) {
      return { valid: false, error: 'Operation is required' };
    }
    return { valid: true };
  }

  getHelp(): any {
    return { description: 'A simple calculator tool' };
  }
}
```

```
import { ITool, ToolMetadata, ToolParameters } from '@claude-code/plugin-sdk';

export class CalculatorTool implements ITool {
  metadata: ToolMetadata = {
    id: 'calculator-tool',
    name: 'Calculator Tool',
    description: 'A simple calculator tool',
    type: 'utility',
    parameters: [
      { name: 'operation', type: 'string', description: 'Operation to perform' },
      { name: 'a', type: 'number', description: 'First number' },
      { name: 'b', type: 'number', description: 'Second number' }
    ],
    returns: { type: 'number', description: 'Calculation result' },
    examples: [
      { input: { operation: 'add', a: 1, b: 2 }, output: 3 },
      { input: { operation: 'multiply', a: 3, b: 4 }, output: 12 }
    ]
  };

  config: any = {};

  async execute(parameters: ToolParameters): Promise<any> {
    const { operation, a, b } = parameters;
    
    switch (operation) {
      case 'add':
        return a + b;
      case 'subtract':
        return a - b;
      case 'multiply':
        return a * b;
      case 'divide':
        return a / b;
      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  }

  validate(parameters: ToolParameters): any {
    if (!parameters.operation) {
      return { valid: false, error: 'Operation is required' };
    }
    return { valid: true };
  }

  getHelp(): any {
    return { description: 'A simple calculator tool' };
  }
}
```

#### API 最佳实践#

##### 1. 接口设计原则#

- 单一职责：每个接口只负责一个功能
- 最小依赖：减少接口之间的耦合
- 明确契约：清晰定义输入输出
- 版本管理：使用语义化版本控制

##### 2. 错误处理#

```
typescript复制// 推荐的错误处理方式
try {
  // 执行操作
} catch (error) {
  context.logger.error('Operation failed', error);
  throw new PluginError('OPERATION_FAILED', 'Failed to perform operation', error);
}
```

```
// 推荐的错误处理方式
try {
  // 执行操作
} catch (error) {
  context.logger.error('Operation failed', error);
  throw new PluginError('OPERATION_FAILED', 'Failed to perform operation', error);
}
```

##### 3. 性能优化#

- 异步操作：使用 Promise 和 async/await
- 缓存策略：缓存频繁使用的数据
- 批量处理：减少系统调用次数
- 资源管理：及时释放资源

##### 4. 安全性#

- 输入验证：验证所有外部输入
- 权限控制：检查用户权限
- 数据加密：保护敏感数据
- 审计日志：记录重要操作

#### 常见问题#

##### Q: 如何处理 API 版本兼容性？#

A: 使用版本号管理 API，提供向后兼容的实现：

```
typescript复制// 版本兼容示例
if (context.getSystemInfo().version >= '2.0.0') {
  // 使用新 API
} else {
  // 使用兼容 API
}
```

```
// 版本兼容示例
if (context.getSystemInfo().version >= '2.0.0') {
  // 使用新 API
} else {
  // 使用兼容 API
}
```

##### Q: 如何扩展现有 API？#

A: 使用装饰器或适配器模式扩展 API：

```
typescript复制// 使用装饰器扩展 API
@decorate(ITool)
export class EnhancedTool extends BaseTool {
  // 扩展功能
}
```

```
// 使用装饰器扩展 API
@decorate(ITool)
export class EnhancedTool extends BaseTool {
  // 扩展功能
}
```

##### Q: 如何调试 API 调用？#

A: 使用日志和调试工具：

```
typescript复制// 调试日志
context.logger.debug('API call', { parameters, result });
```

```
// 调试日志
context.logger.debug('API call', { parameters, result });
```

#### 总结#

Claude Code 插件开发 API 提供了一套完整的扩展机制，允许开发者创建强大的插件和工具。通过遵循最佳实践和设计原则，可以创建出高质量、可维护的插件。

下一章将介绍高级插件开发技术，包括插件通信、数据持久化和性能优化。

---

## 4 基本插件示例

**URL**: https://claudecode.tangshuang.net/course/21.4%20%E5%9F%BA%E6%9C%AC%E6%8F%92%E4%BB%B6%E7%A4%BA%E4%BE%8B

#### 21.4.1 简单的 Hello World 插件#

##### 插件实现#

// src/plugin.ts
import { Plugin, PluginConfig, PluginContext } from '@claude-code/plugin-sdk';

export class HelloWorldPlugin extends Plugin {
constructor() {
super({
name: 'hello-world',
version: '1.0.0',

description: 'A simple Hello World plugin'
});
}

async initialize(config: PluginConfig): Promise<void> {
console.log('Hello World Plugin initialized');
}

async start(): Promise<void> {
console.log('Hello World Plugin started');
}

async stop(): Promise<void> {
console.log('Hello World Plugin stopped');
}

async cleanup(): Promise<void> {
console.log('Hello World Plugin cleaned up');
}
}

##### 插件清单#

```
bash复制yaml

# plugin.yaml
name: hello-world
version: 1.0.0
description: A simple Hello World plugin
author: Your Name
license: MIT
main: dist/plugin.js
types: dist/plugin.d.ts

### 使用示例

// 使用插件
import { HelloWorldPlugin } from './plugin';
const plugin = new HelloWorldPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 获取插件状态
const status = plugin.getStatus();
console.log(status);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

```
yaml

# plugin.yaml
name: hello-world
version: 1.0.0
description: A simple Hello World plugin
author: Your Name
license: MIT
main: dist/plugin.js
types: dist/plugin.d.ts

### 使用示例

// 使用插件
import { HelloWorldPlugin } from './plugin';
const plugin = new HelloWorldPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 获取插件状态
const status = plugin.getStatus();
console.log(status);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

#### 21.4.2 带工具的插件#

##### 插件实现#

```
bash复制typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Tool,
  ToolResult,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetingTool } from './tools/greeting';
import { TimeTool } from './tools/time';

export class ToolsPlugin extends Plugin {
  private toolManager: any;

  constructor() {
    super({
      name: 'tools-plugin',
      version: '1.0.0',
      description: 'A plugin with tools'
    });

    this.toolManager = {
      register: (tool: Tool) => {},
      execute: async (name: string, params: any, context: PluginContext) => {
        return { success: true, data: {} };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Tools Plugin initialized');

    // 注册工具
    this.toolManager.register(new GreetingTool());
    this.toolManager.register(new TimeTool());
  }

  async start(): Promise<void> {
    console.log('Tools Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Tools Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Tools Plugin cleaned up');
  }
}

### Greeting 工具

// src/tools/greeting.ts
import { Tool, ToolResult, PluginContext } from '@claude-code/plugin-sdk';
export class GreetingTool extends Tool {
constructor() {
super({
name: 'greeting',
description: 'Generate a greeting message',
parameters: [
{
name: 'name',
type: 'string',
description: 'The name to greet',
required: true
},
{
name: 'language',
type: 'string',
description: 'The language of the greeting',
required: false,
default: 'english'
}
]
});
}
async execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult> {
const name = params.name;
const language = params.language || 'english';
let greeting: string;
switch (language.toLowerCase()) {
case 'english':
greeting = `Hello, ${name}!`;
break;
case 'spanish':
greeting = `¡Hola, ${name}!`;
break;
case 'french':
greeting = `Bonjour, ${name}!`;
break;
case 'german':
greeting = `Hallo, ${name}!`;
break;
case 'chinese':
greeting = `你好，${name}！`;
break;
default:
greeting = `Hello, ${name}!`;
}
return {
success: true,
data: {
greeting,
language
}
};
}
}
```

```
typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Tool,
  ToolResult,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetingTool } from './tools/greeting';
import { TimeTool } from './tools/time';

export class ToolsPlugin extends Plugin {
  private toolManager: any;

  constructor() {
    super({
      name: 'tools-plugin',
      version: '1.0.0',
      description: 'A plugin with tools'
    });

    this.toolManager = {
      register: (tool: Tool) => {},
      execute: async (name: string, params: any, context: PluginContext) => {
        return { success: true, data: {} };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Tools Plugin initialized');

    // 注册工具
    this.toolManager.register(new GreetingTool());
    this.toolManager.register(new TimeTool());
  }

  async start(): Promise<void> {
    console.log('Tools Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Tools Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Tools Plugin cleaned up');
  }
}

### Greeting 工具

// src/tools/greeting.ts
import { Tool, ToolResult, PluginContext } from '@claude-code/plugin-sdk';
export class GreetingTool extends Tool {
constructor() {
super({
name: 'greeting',
description: 'Generate a greeting message',
parameters: [
{
name: 'name',
type: 'string',
description: 'The name to greet',
required: true
},
{
name: 'language',
type: 'string',
description: 'The language of the greeting',
required: false,
default: 'english'
}
]
});
}
async execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult> {
const name = params.name;
const language = params.language || 'english';
let greeting: string;
switch (language.toLowerCase()) {
case 'english':
greeting = `Hello, ${name}!`;
break;
case 'spanish':
greeting = `¡Hola, ${name}!`;
break;
case 'french':
greeting = `Bonjour, ${name}!`;
break;
case 'german':
greeting = `Hallo, ${name}!`;
break;
case 'chinese':
greeting = `你好，${name}！`;
break;
default:
greeting = `Hello, ${name}!`;
}
return {
success: true,
data: {
greeting,
language
}
};
}
}
```

##### Time 工具#

```
bash复制typescript

// src/tools/time.ts
import { Tool, ToolResult, PluginContext } from '@claude-code/plugin-sdk';

export class TimeTool extends Tool {
  constructor() {
    super({
      name: 'time',
      description: 'Get current time in various formats',
      parameters: [
        {
          name: 'format',
          type: 'string',
          description: 'The format of the time (iso, unix, readable)',
          required: false,
          default: 'iso'
        },
        {
          name: 'timezone',
          type: 'string',
          description: 'The timezone (e.g., UTC, America/New_York)',
          required: false
        }
      ]
    });
  }

  async execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult> {
    const format = params.format || 'iso';
    const timezone = params.timezone;

    let date: Date;
    if (timezone) {
      // 使用指定时区
      date = new Date();
    } else {
      date = new Date();
    }

    let time: string;

    switch (format.toLowerCase()) {
      case 'iso':
        time = date.toISOString();
        break;
      case 'unix':
        time = Math.floor(date.getTime() / 1000).toString();
        break;
      case 'readable':
        time = date.toLocaleString();
        break;
      default:
        time = date.toISOString();
    }

    return {
      success: true,
      data: {
        time,
        format,
        timezone: timezone || 'local'
      }
    };
  }
}

### 使用示例

// 使用插件
import { ToolsPlugin } from './plugin';
const plugin = new ToolsPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 执行工具
const greetingResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World', language: 'chinese' },
{}
);
console.log(greetingResult.data.greeting); // 你好，World！
const timeResult = await plugin.toolManager.execute(
'time',
{ format: 'readable' },
{}
);
console.log(timeResult.data.time); // 2024-01-15 10:30:00
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

```
typescript

// src/tools/time.ts
import { Tool, ToolResult, PluginContext } from '@claude-code/plugin-sdk';

export class TimeTool extends Tool {
  constructor() {
    super({
      name: 'time',
      description: 'Get current time in various formats',
      parameters: [
        {
          name: 'format',
          type: 'string',
          description: 'The format of the time (iso, unix, readable)',
          required: false,
          default: 'iso'
        },
        {
          name: 'timezone',
          type: 'string',
          description: 'The timezone (e.g., UTC, America/New_York)',
          required: false
        }
      ]
    });
  }

  async execute(params: Record<string, any>, context: PluginContext): Promise<ToolResult> {
    const format = params.format || 'iso';
    const timezone = params.timezone;

    let date: Date;
    if (timezone) {
      // 使用指定时区
      date = new Date();
    } else {
      date = new Date();
    }

    let time: string;

    switch (format.toLowerCase()) {
      case 'iso':
        time = date.toISOString();
        break;
      case 'unix':
        time = Math.floor(date.getTime() / 1000).toString();
        break;
      case 'readable':
        time = date.toLocaleString();
        break;
      default:
        time = date.toISOString();
    }

    return {
      success: true,
      data: {
        time,
        format,
        timezone: timezone || 'local'
      }
    };
  }
}

### 使用示例

// 使用插件
import { ToolsPlugin } from './plugin';
const plugin = new ToolsPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 执行工具
const greetingResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World', language: 'chinese' },
{}
);
console.log(greetingResult.data.greeting); // 你好，World！
const timeResult = await plugin.toolManager.execute(
'time',
{ format: 'readable' },
{}
);
console.log(timeResult.data.time); // 2024-01-15 10:30:00
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

#### 21.4.3 带命令的插件#

##### 插件实现#

```
bash复制typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Command,
  CommandResult,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetCommand } from './commands/greet';
import { CalcCommand } from './commands/calc';

export class CommandsPlugin extends Plugin {
  private commandManager: any;

  constructor() {
    super({
      name: 'commands-plugin',
      version: '1.0.0',
      description: 'A plugin with commands'
    });

    this.commandManager = {
      register: (command: Command) => {},
      execute: async (name: string, args: string[], context: PluginContext) => {
        return { success: true, output: '' };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Commands Plugin initialized');

    // 注册命令
    this.commandManager.register(new GreetCommand());
    this.commandManager.register(new CalcCommand());
  }

  async start(): Promise<void> {
    console.log('Commands Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Commands Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Commands Plugin cleaned up');
  }
}

### Greet 命令

// src/commands/greet.ts
import { Command, CommandResult, PluginContext } from '@claude-code/plugin-sdk';
export class GreetCommand extends Command {
constructor() {
super({
name: 'greet',
description: 'Greet someone',
parameters: [
{
name: 'name',
type: 'string',
description: 'The name to greet',
required: true,
short: 'n'
},
{
name: 'formal',
type: 'flag',
description: 'Use formal greeting',
required: false,
short: 'f'
}
]
});
}
async execute(args: string[], context: PluginContext): Promise<CommandResult> {
const parsed = this.parseArgs(args);
const name = parsed.name;
const formal = parsed.formal || false;
let greeting: string;
if (formal) {
greeting = `Good day, ${name}. It is a pleasure to meet you.`;
} else {
greeting = `Hey, ${name}! How's it going?`;
}
return {
success: true,
output: greeting
};
}
}
```

```
typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Command,
  CommandResult,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetCommand } from './commands/greet';
import { CalcCommand } from './commands/calc';

export class CommandsPlugin extends Plugin {
  private commandManager: any;

  constructor() {
    super({
      name: 'commands-plugin',
      version: '1.0.0',
      description: 'A plugin with commands'
    });

    this.commandManager = {
      register: (command: Command) => {},
      execute: async (name: string, args: string[], context: PluginContext) => {
        return { success: true, output: '' };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Commands Plugin initialized');

    // 注册命令
    this.commandManager.register(new GreetCommand());
    this.commandManager.register(new CalcCommand());
  }

  async start(): Promise<void> {
    console.log('Commands Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Commands Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Commands Plugin cleaned up');
  }
}

### Greet 命令

// src/commands/greet.ts
import { Command, CommandResult, PluginContext } from '@claude-code/plugin-sdk';
export class GreetCommand extends Command {
constructor() {
super({
name: 'greet',
description: 'Greet someone',
parameters: [
{
name: 'name',
type: 'string',
description: 'The name to greet',
required: true,
short: 'n'
},
{
name: 'formal',
type: 'flag',
description: 'Use formal greeting',
required: false,
short: 'f'
}
]
});
}
async execute(args: string[], context: PluginContext): Promise<CommandResult> {
const parsed = this.parseArgs(args);
const name = parsed.name;
const formal = parsed.formal || false;
let greeting: string;
if (formal) {
greeting = `Good day, ${name}. It is a pleasure to meet you.`;
} else {
greeting = `Hey, ${name}! How's it going?`;
}
return {
success: true,
output: greeting
};
}
}
```

##### Calc 命令#

```
bash复制typescript

// src/commands/calc.ts
import { Command, CommandResult, PluginContext } from '@claude-code/plugin-sdk';

export class CalcCommand extends Command {
  constructor() {
    super({
      name: 'calc',
      description: 'Perform mathematical calculations',
      parameters: [
        {
          name: 'expression',
          type: 'string',
          description: 'The mathematical expression to evaluate',
          required: true,
          short: 'e'
        },
        {
          name: 'precision',
          type: 'number',
          description: 'Number of decimal places',
          required: false,
          default: 2,
          short: 'p'
        }
      ]
    });
  }

  async execute(args: string[], context: PluginContext): Promise<CommandResult> {
    const parsed = this.parseArgs(args);

    const expression = parsed.expression;
    const precision = parsed.precision || 2;

    try {
      // 安全地评估表达式
      const result = this.evaluateExpression(expression);

      // 格式化结果
      const formatted = result.toFixed(precision);

      return {
        success: true,
        output: `${expression} = ${formatted}`
      };
    } catch (error) {
      return {
        success: false,
        output: '',
        error: error.message,
        exitCode: 1
      };
    }
  }

  private evaluateExpression(expression: string): number {
    // 只允许数字和基本运算符
    const sanitized = expression.replace(/[^0-9+\-*/().]/g, '');

    // 使用 Function 构造函数安全地评估
    return new Function(`return ${sanitized}`)();
  }
}

### 使用示例

// 使用插件
import { CommandsPlugin } from './plugin';
const plugin = new CommandsPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 执行命令
const greetResult = await plugin.commandManager.execute(
'greet',
['--name', 'World', '--formal'],
{}
);
console.log(greetResult.output); // Good day, World. It is a pleasure to meet you.
const calcResult = await plugin.commandManager.execute(
'calc',
['--expression', '2 + 2 * 3', '--precision', '0'],
{}
);
console.log(calcResult.output); // 2 + 2 * 3 = 8
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

```
typescript

// src/commands/calc.ts
import { Command, CommandResult, PluginContext } from '@claude-code/plugin-sdk';

export class CalcCommand extends Command {
  constructor() {
    super({
      name: 'calc',
      description: 'Perform mathematical calculations',
      parameters: [
        {
          name: 'expression',
          type: 'string',
          description: 'The mathematical expression to evaluate',
          required: true,
          short: 'e'
        },
        {
          name: 'precision',
          type: 'number',
          description: 'Number of decimal places',
          required: false,
          default: 2,
          short: 'p'
        }
      ]
    });
  }

  async execute(args: string[], context: PluginContext): Promise<CommandResult> {
    const parsed = this.parseArgs(args);

    const expression = parsed.expression;
    const precision = parsed.precision || 2;

    try {
      // 安全地评估表达式
      const result = this.evaluateExpression(expression);

      // 格式化结果
      const formatted = result.toFixed(precision);

      return {
        success: true,
        output: `${expression} = ${formatted}`
      };
    } catch (error) {
      return {
        success: false,
        output: '',
        error: error.message,
        exitCode: 1
      };
    }
  }

  private evaluateExpression(expression: string): number {
    // 只允许数字和基本运算符
    const sanitized = expression.replace(/[^0-9+\-*/().]/g, '');

    // 使用 Function 构造函数安全地评估
    return new Function(`return ${sanitized}`)();
  }
}

### 使用示例

// 使用插件
import { CommandsPlugin } from './plugin';
const plugin = new CommandsPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 执行命令
const greetResult = await plugin.commandManager.execute(
'greet',
['--name', 'World', '--formal'],
{}
);
console.log(greetResult.output); // Good day, World. It is a pleasure to meet you.
const calcResult = await plugin.commandManager.execute(
'calc',
['--expression', '2 + 2 * 3', '--precision', '0'],
{}
);
console.log(calcResult.output); // 2 + 2 * 3 = 8
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

#### 21.4.4 带钩子的插件#

##### 插件实现#

```
bash复制typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Hook,
  HookResult,
  HookEvent,
  PluginContext
} from '@claude-code/plugin-sdk';
import { LoggingHook } from './hooks/logging';
import { ErrorHandlingHook } from './hooks/error-handling';

export class HooksPlugin extends Plugin {
  private hookManager: any;

  constructor() {
    super({
      name: 'hooks-plugin',
      version: '1.0.0',
      description: 'A plugin with hooks'
    });

    this.hookManager = {
      register: (hook: Hook) => {},
      execute: async (type: string, event: HookEvent, context: PluginContext) => {
        return { success: true };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Hooks Plugin initialized');

    // 注册钩子
    this.hookManager.register(new LoggingHook());
    this.hookManager.register(new ErrorHandlingHook());
  }

  async start(): Promise<void> {
    console.log('Hooks Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Hooks Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Hooks Plugin cleaned up');
  }
}

### Logging 钩子

// src/hooks/logging.ts
import {
Hook,
HookResult,
HookEvent,
PluginContext,
HookType
} from '@claude-code/plugin-sdk';
export class LoggingHook extends Hook {
constructor() {
super({
name: 'logging',
type: 'before_command' as HookType,
description: 'Log all commands before execution',
priority: 10
});
}
async execute(event: HookEvent, context: PluginContext): Promise<HookResult> {
const command = event.data.command;
const args = event.data.args;
console.log(`[LoggingHook] Executing command: ${command} ${args.join(' ')}`);
return {
success: true
};
}
}
```

```
typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Hook,
  HookResult,
  HookEvent,
  PluginContext
} from '@claude-code/plugin-sdk';
import { LoggingHook } from './hooks/logging';
import { ErrorHandlingHook } from './hooks/error-handling';

export class HooksPlugin extends Plugin {
  private hookManager: any;

  constructor() {
    super({
      name: 'hooks-plugin',
      version: '1.0.0',
      description: 'A plugin with hooks'
    });

    this.hookManager = {
      register: (hook: Hook) => {},
      execute: async (type: string, event: HookEvent, context: PluginContext) => {
        return { success: true };
      }
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    console.log('Hooks Plugin initialized');

    // 注册钩子
    this.hookManager.register(new LoggingHook());
    this.hookManager.register(new ErrorHandlingHook());
  }

  async start(): Promise<void> {
    console.log('Hooks Plugin started');
  }

  async stop(): Promise<void> {
    console.log('Hooks Plugin stopped');
  }

  async cleanup(): Promise<void> {
    console.log('Hooks Plugin cleaned up');
  }
}

### Logging 钩子

// src/hooks/logging.ts
import {
Hook,
HookResult,
HookEvent,
PluginContext,
HookType
} from '@claude-code/plugin-sdk';
export class LoggingHook extends Hook {
constructor() {
super({
name: 'logging',
type: 'before_command' as HookType,
description: 'Log all commands before execution',
priority: 10
});
}
async execute(event: HookEvent, context: PluginContext): Promise<HookResult> {
const command = event.data.command;
const args = event.data.args;
console.log(`[LoggingHook] Executing command: ${command} ${args.join(' ')}`);
return {
success: true
};
}
}
```

##### Error Handling 钩子#

```
bash复制typescript

// src/hooks/error-handling.ts
import {
  Hook,
  HookResult,
  HookEvent,
  PluginContext,
  HookType
} from '@claude-code/plugin-sdk';

export class ErrorHandlingHook extends Hook {
  constructor() {
    super({
      name: 'error-handling',
      type: 'on_error' as HookType,
      description: 'Handle errors and provide helpful messages',
      priority: 100
    });
  }

  async execute(event: HookEvent, context: PluginContext): Promise<HookResult> {
    const error = event.data.error;

    console.error(`[ErrorHandlingHook] Error occurred: ${error.message}`);

    // 提供错误建议
    const suggestions = this.getErrorSuggestions(error);

    if (suggestions.length > 0) {
      console.log('[ErrorHandlingHook] Suggestions:');
      suggestions.forEach((suggestion, index) => {
        console.log(`  ${index + 1}. ${suggestion}`);
      });
    }

    return {
      success: true
    };
  }

  private getErrorSuggestions(error: Error): string[] {
    const suggestions: string[] = [];

    if (error.message.includes('permission')) {
      suggestions.push('Check if you have the necessary permissions');
      suggestions.push('Try running with elevated privileges');
    }

    if (error.message.includes('not found')) {
      suggestions.push('Verify the file or resource exists');
      suggestions.push('Check the spelling of the file name');
    }

    if (error.message.includes('network')) {
      suggestions.push('Check your internet connection');
      suggestions.push('Verify the server is running');
    }

    return suggestions;
  }
}

### 使用示例

// 使用插件
import { HooksPlugin } from './plugin';
const plugin = new HooksPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 触发 before_command 钩子
await plugin.hookManager.execute(
'before_command',
{
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
},
{}
);
// 触发 on_error 钩子
await plugin.hookManager.execute(
'on_error',
{
type: 'on_error',
data: {
error: new Error('Permission denied')
},
timestamp: new Date()
},
{}
);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

```
typescript

// src/hooks/error-handling.ts
import {
  Hook,
  HookResult,
  HookEvent,
  PluginContext,
  HookType
} from '@claude-code/plugin-sdk';

export class ErrorHandlingHook extends Hook {
  constructor() {
    super({
      name: 'error-handling',
      type: 'on_error' as HookType,
      description: 'Handle errors and provide helpful messages',
      priority: 100
    });
  }

  async execute(event: HookEvent, context: PluginContext): Promise<HookResult> {
    const error = event.data.error;

    console.error(`[ErrorHandlingHook] Error occurred: ${error.message}`);

    // 提供错误建议
    const suggestions = this.getErrorSuggestions(error);

    if (suggestions.length > 0) {
      console.log('[ErrorHandlingHook] Suggestions:');
      suggestions.forEach((suggestion, index) => {
        console.log(`  ${index + 1}. ${suggestion}`);
      });
    }

    return {
      success: true
    };
  }

  private getErrorSuggestions(error: Error): string[] {
    const suggestions: string[] = [];

    if (error.message.includes('permission')) {
      suggestions.push('Check if you have the necessary permissions');
      suggestions.push('Try running with elevated privileges');
    }

    if (error.message.includes('not found')) {
      suggestions.push('Verify the file or resource exists');
      suggestions.push('Check the spelling of the file name');
    }

    if (error.message.includes('network')) {
      suggestions.push('Check your internet connection');
      suggestions.push('Verify the server is running');
    }

    return suggestions;
  }
}

### 使用示例

// 使用插件
import { HooksPlugin } from './plugin';
const plugin = new HooksPlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 触发 before_command 钩子
await plugin.hookManager.execute(
'before_command',
{
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
},
{}
);
// 触发 on_error 钩子
await plugin.hookManager.execute(
'on_error',
{
type: 'on_error',
data: {
error: new Error('Permission denied')
},
timestamp: new Date()
},
{}
);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

#### 21.4.5 完整的插件示例#

##### 插件实现#

```
bash复制typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Tool,
  Command,
  Hook,
  ToolResult,
  CommandResult,
  HookResult,
  HookEvent,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetingTool } from './tools/greeting';
import { TimeTool } from './tools/time';
import { GreetCommand } from './commands/greet';
import { CalcCommand } from './commands/calc';
import { LoggingHook } from './hooks/logging';
import { ErrorHandlingHook } from './hooks/error-handling';

export class CompletePlugin extends Plugin {
  private toolManager: any;
  private commandManager: any;
  private hookManager: any;
  private logger: any;

  constructor() {
    super({
      name: 'complete-plugin',
      version: '1.0.0',
      description: 'A complete plugin with tools, commands, and hooks'
    });

    this.toolManager = {
      register: (tool: Tool) => {},
      execute: async (name: string, params: any, context: PluginContext) => {
        return { success: true, data: {} };
      }
    };

    this.commandManager = {
      register: (command: Command) => {},
      execute: async (name: string, args: string[], context: PluginContext) => {
        return { success: true, output: '' };
      }
    };

    this.hookManager = {
      register: (hook: Hook) => {},
      execute: async (type: string, event: HookEvent, context: PluginContext) => {
        return { success: true };
      }
    };

    this.logger = {
      info: (message: string) => console.log(`[INFO] ${message}`),
      error: (message: string) => console.error(`[ERROR] ${message}`)
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    this.logger.info('Complete Plugin initialized');

    // 注册工具
    this.toolManager.register(new GreetingTool());
    this.toolManager.register(new TimeTool());

    // 注册命令
    this.commandManager.register(new GreetCommand());
    this.commandManager.register(new CalcCommand());

    // 注册钩子
    this.hookManager.register(new LoggingHook());
    this.hookManager.register(new ErrorHandlingHook());
  }

  async start(): Promise<void> {
    this.logger.info('Complete Plugin started');
  }

  async stop(): Promise<void> {
    this.logger.info('Complete Plugin stopped');
  }

  async cleanup(): Promise<void> {
    this.logger.info('Complete Plugin cleaned up');
  }
}

### 使用示例

// 使用插件
import { CompletePlugin } from './plugin';
const plugin = new CompletePlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 使用工具
const greetingResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World', language: 'chinese' },
{}
);
console.log(greetingResult.data.greeting); // 你好，World！
// 使用命令
const greetResult = await plugin.commandManager.execute(
'greet',
['--name', 'World', '--formal'],
{}
);
console.log(greetResult.output); // Good day, World. It is a pleasure to meet you.
// 触发钩子
await plugin.hookManager.execute(
'before_command',
{
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
},
{}
);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

```
typescript

// src/plugin.ts
import {
  Plugin,
  PluginConfig,
  Tool,
  Command,
  Hook,
  ToolResult,
  CommandResult,
  HookResult,
  HookEvent,
  PluginContext
} from '@claude-code/plugin-sdk';
import { GreetingTool } from './tools/greeting';
import { TimeTool } from './tools/time';
import { GreetCommand } from './commands/greet';
import { CalcCommand } from './commands/calc';
import { LoggingHook } from './hooks/logging';
import { ErrorHandlingHook } from './hooks/error-handling';

export class CompletePlugin extends Plugin {
  private toolManager: any;
  private commandManager: any;
  private hookManager: any;
  private logger: any;

  constructor() {
    super({
      name: 'complete-plugin',
      version: '1.0.0',
      description: 'A complete plugin with tools, commands, and hooks'
    });

    this.toolManager = {
      register: (tool: Tool) => {},
      execute: async (name: string, params: any, context: PluginContext) => {
        return { success: true, data: {} };
      }
    };

    this.commandManager = {
      register: (command: Command) => {},
      execute: async (name: string, args: string[], context: PluginContext) => {
        return { success: true, output: '' };
      }
    };

    this.hookManager = {
      register: (hook: Hook) => {},
      execute: async (type: string, event: HookEvent, context: PluginContext) => {
        return { success: true };
      }
    };

    this.logger = {
      info: (message: string) => console.log(`[INFO] ${message}`),
      error: (message: string) => console.error(`[ERROR] ${message}`)
    };
  }

  async initialize(config: PluginConfig): Promise<void> {
    this.logger.info('Complete Plugin initialized');

    // 注册工具
    this.toolManager.register(new GreetingTool());
    this.toolManager.register(new TimeTool());

    // 注册命令
    this.commandManager.register(new GreetCommand());
    this.commandManager.register(new CalcCommand());

    // 注册钩子
    this.hookManager.register(new LoggingHook());
    this.hookManager.register(new ErrorHandlingHook());
  }

  async start(): Promise<void> {
    this.logger.info('Complete Plugin started');
  }

  async stop(): Promise<void> {
    this.logger.info('Complete Plugin stopped');
  }

  async cleanup(): Promise<void> {
    this.logger.info('Complete Plugin cleaned up');
  }
}

### 使用示例

// 使用插件
import { CompletePlugin } from './plugin';
const plugin = new CompletePlugin();
// 初始化插件
await plugin.initialize({});
// 启动插件
await plugin.start();
// 使用工具
const greetingResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World', language: 'chinese' },
{}
);
console.log(greetingResult.data.greeting); // 你好，World！
// 使用命令
const greetResult = await plugin.commandManager.execute(
'greet',
['--name', 'World', '--formal'],
{}
);
console.log(greetResult.output); // Good day, World. It is a pleasure to meet you.
// 触发钩子
await plugin.hookManager.execute(
'before_command',
{
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
},
{}
);
// 停止插件
await plugin.stop();
// 清理插件
await plugin.cleanup();
```

#### 21.4.6 插件测试示例#

##### 测试文件#

```
bash复制typescript

// __tests__/plugin.test.ts
import { CompletePlugin } from '../src/plugin';

describe('CompletePlugin', () => {
  let plugin: CompletePlugin;

  beforeEach(() => {
    plugin = new CompletePlugin();
  });

  afterEach(async () => {
    try {
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  test('should initialize successfully', async () => {
    await expect(plugin.initialize({})).resolves.not.toThrow();

    const status = plugin.getStatus();
    expect(status.name).toBe('complete-plugin');
    expect(status.version).toBe('1.0.0');
  });

  test('should start successfully', async () => {
    await plugin.initialize({});
    await expect(plugin.start()).resolves.not.toThrow();
  });

  test('should stop successfully', async () => {
    await plugin.initialize({});
    await plugin.start();
    await expect(plugin.stop()).resolves.not.toThrow();
  });

  test('should cleanup successfully', async () => {
    await plugin.initialize({});
    await plugin.start();
    await plugin.stop();
    await expect(plugin.cleanup()).resolves.not.toThrow();
  });
});

### 工具测试

// __tests__/tools/greeting.test.ts
import { GreetingTool } from '../../src/tools/greeting';
describe('GreetingTool', () => {
let tool: GreetingTool;
beforeEach(() => {
tool = new GreetingTool();
});
test('should generate English greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'english' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!');
});
test('should generate Chinese greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'chinese' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('你好，World！');
});
test('should validate parameters', () => {
const result = tool.validate({});
expect(result.valid).toBe(false);
expect(result.errors).toContain('Missing required parameter: name');
});
});
```

```
typescript

// __tests__/plugin.test.ts
import { CompletePlugin } from '../src/plugin';

describe('CompletePlugin', () => {
  let plugin: CompletePlugin;

  beforeEach(() => {
    plugin = new CompletePlugin();
  });

  afterEach(async () => {
    try {
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  test('should initialize successfully', async () => {
    await expect(plugin.initialize({})).resolves.not.toThrow();

    const status = plugin.getStatus();
    expect(status.name).toBe('complete-plugin');
    expect(status.version).toBe('1.0.0');
  });

  test('should start successfully', async () => {
    await plugin.initialize({});
    await expect(plugin.start()).resolves.not.toThrow();
  });

  test('should stop successfully', async () => {
    await plugin.initialize({});
    await plugin.start();
    await expect(plugin.stop()).resolves.not.toThrow();
  });

  test('should cleanup successfully', async () => {
    await plugin.initialize({});
    await plugin.start();
    await plugin.stop();
    await expect(plugin.cleanup()).resolves.not.toThrow();
  });
});

### 工具测试

// __tests__/tools/greeting.test.ts
import { GreetingTool } from '../../src/tools/greeting';
describe('GreetingTool', () => {
let tool: GreetingTool;
beforeEach(() => {
tool = new GreetingTool();
});
test('should generate English greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'english' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!');
});
test('should generate Chinese greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'chinese' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('你好，World！');
});
test('should validate parameters', () => {
const result = tool.validate({});
expect(result.valid).toBe(false);
expect(result.errors).toContain('Missing required parameter: name');
});
});
```

##### 命令测试#

```
bash复制typescript

// __tests__/commands/greet.test.ts
import { GreetCommand } from '../../src/commands/greet';

describe('GreetCommand', () => {
  let command: GreetCommand;

  beforeEach(() => {
    command = new GreetCommand();
  });

  test('should greet informally', async () => {
    const result = await command.execute(
      ['--name', 'World'],
      {}
    );

    expect(result.success).toBe(true);
    expect(result.output).toContain('Hey, World!');
  });

  test('should greet formally', async () => {
    const result = await command.execute(
      ['--name', 'World', '--formal'],
      {}
    );

    expect(result.success).toBe(true);
    expect(result.output).toContain('Good day, World.');
  });

  test('should parse arguments correctly', () => {
    const parsed = command.parseArgs(['--name', 'World', '--formal']);

    expect(parsed.name).toBe('World');
    expect(parsed.formal).toBe(true);
  });
});

### 运行测试

# 运行所有测试
npm test
# 运行特定测试文件
npm test -- plugin.test.ts
# 运行测试并生成覆盖率报告
npm test -- --coverage
# 监听模式
npm run test:watch
```

```
typescript

// __tests__/commands/greet.test.ts
import { GreetCommand } from '../../src/commands/greet';

describe('GreetCommand', () => {
  let command: GreetCommand;

  beforeEach(() => {
    command = new GreetCommand();
  });

  test('should greet informally', async () => {
    const result = await command.execute(
      ['--name', 'World'],
      {}
    );

    expect(result.success).toBe(true);
    expect(result.output).toContain('Hey, World!');
  });

  test('should greet formally', async () => {
    const result = await command.execute(
      ['--name', 'World', '--formal'],
      {}
    );

    expect(result.success).toBe(true);
    expect(result.output).toContain('Good day, World.');
  });

  test('should parse arguments correctly', () => {
    const parsed = command.parseArgs(['--name', 'World', '--formal']);

    expect(parsed.name).toBe('World');
    expect(parsed.formal).toBe(true);
  });
});

### 运行测试

# 运行所有测试
npm test
# 运行特定测试文件
npm test -- plugin.test.ts
# 运行测试并生成覆盖率报告
npm test -- --coverage
# 监听模式
npm run test:watch
```

---

## 5 插件测试与调试

**URL**: https://claudecode.tangshuang.net/course/21.5%20%E6%8F%92%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95

#### 21.5.1 单元测试#

##### 测试框架配置#

// jest.config.ts
export default {
preset: 'ts-jest',
testEnvironment: 'node',
roots: ['<rootDir>/src'],
testMatch: ['/tests//.ts', '**/?(.)+(spec|test).ts'],
collectCoverageFrom: [

'src//*.ts',
'!src//.d.ts',
'!src/**/.test.ts',
'!src/**/.spec.ts'
],
coverageThreshold: {
global: {
branches: 80,
functions: 80,
lines: 80,
statements: 80
}
},
moduleNameMapper: {
'^@/(.)$': '<rootDir>/src/$1'
}
};

##### 基本单元测试#

```
bash复制typescript

// __tests__/plugin.test.ts
import { MyPlugin } from '../src/plugin';

describe('MyPlugin', () => {
  let plugin: MyPlugin;

  beforeEach(() => {
    plugin = new MyPlugin();
  });

  afterEach(async () => {
    try {
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('initialization', () => {
    test('should initialize with correct configuration', async () => {
      await plugin.initialize({
        name: 'test-plugin',
        version: '1.0.0',
        description: 'Test plugin'
      });

      const info = plugin.getInfo();
      expect(info.name).toBe('test-plugin');
      expect(info.version).toBe('1.0.0');
    });

    test('should throw error if already initialized', async () => {
      await plugin.initialize({});

      await expect(plugin.initialize({})).rejects.toThrow();
    });
  });

  describe('lifecycle', () => {
    test('should start after initialization', async () => {
      await plugin.initialize({});
      await plugin.start();

      const status = plugin.getStatus();
      expect(status.enabled).toBe(true);
    });

    test('should stop after starting', async () => {
      await plugin.initialize({});
      await plugin.start();
      await plugin.stop();

      const status = plugin.getStatus();
      expect(status.enabled).toBe(false);
    });
  });
});

### 工具测试

// __tests__/tools/greeting.test.ts
import { GreetingTool } from '../../src/tools/greeting';
describe('GreetingTool', () => {
let tool: GreetingTool;
beforeEach(() => {
tool = new GreetingTool();
});
describe('execute', () => {
test('should generate English greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'english' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!');
expect(result.data.language).toBe('english');
});
test('should generate Chinese greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'chinese' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('你好，World！');
});
test('should handle invalid language gracefully', async () => {
const result = await tool.execute(
{ name: 'World', language: 'invalid' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!'); // 默认英语
});
});
describe('validate', () => {
test('should validate required parameters', () => {
const result = tool.validate({});
expect(result.valid).toBe(false);
expect(result.errors).toContain('Missing required parameter: name');
});
test('should validate parameter types', () => {
const result = tool.validate({ name: 123 });
expect(result.valid).toBe(false);
expect(result.errors).toContain('Parameter name must be a string');
});
test('should pass valid parameters', () => {
const result = tool.validate({ name: 'World' });
expect(result.valid).toBe(true);
expect(result.errors).toHaveLength(0);
});
});
});
```

```
typescript

// __tests__/plugin.test.ts
import { MyPlugin } from '../src/plugin';

describe('MyPlugin', () => {
  let plugin: MyPlugin;

  beforeEach(() => {
    plugin = new MyPlugin();
  });

  afterEach(async () => {
    try {
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('initialization', () => {
    test('should initialize with correct configuration', async () => {
      await plugin.initialize({
        name: 'test-plugin',
        version: '1.0.0',
        description: 'Test plugin'
      });

      const info = plugin.getInfo();
      expect(info.name).toBe('test-plugin');
      expect(info.version).toBe('1.0.0');
    });

    test('should throw error if already initialized', async () => {
      await plugin.initialize({});

      await expect(plugin.initialize({})).rejects.toThrow();
    });
  });

  describe('lifecycle', () => {
    test('should start after initialization', async () => {
      await plugin.initialize({});
      await plugin.start();

      const status = plugin.getStatus();
      expect(status.enabled).toBe(true);
    });

    test('should stop after starting', async () => {
      await plugin.initialize({});
      await plugin.start();
      await plugin.stop();

      const status = plugin.getStatus();
      expect(status.enabled).toBe(false);
    });
  });
});

### 工具测试

// __tests__/tools/greeting.test.ts
import { GreetingTool } from '../../src/tools/greeting';
describe('GreetingTool', () => {
let tool: GreetingTool;
beforeEach(() => {
tool = new GreetingTool();
});
describe('execute', () => {
test('should generate English greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'english' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!');
expect(result.data.language).toBe('english');
});
test('should generate Chinese greeting', async () => {
const result = await tool.execute(
{ name: 'World', language: 'chinese' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('你好，World！');
});
test('should handle invalid language gracefully', async () => {
const result = await tool.execute(
{ name: 'World', language: 'invalid' },
{}
);
expect(result.success).toBe(true);
expect(result.data.greeting).toBe('Hello, World!'); // 默认英语
});
});
describe('validate', () => {
test('should validate required parameters', () => {
const result = tool.validate({});
expect(result.valid).toBe(false);
expect(result.errors).toContain('Missing required parameter: name');
});
test('should validate parameter types', () => {
const result = tool.validate({ name: 123 });
expect(result.valid).toBe(false);
expect(result.errors).toContain('Parameter name must be a string');
});
test('should pass valid parameters', () => {
const result = tool.validate({ name: 'World' });
expect(result.valid).toBe(true);
expect(result.errors).toHaveLength(0);
});
});
});
```

##### 命令测试#

```
bash复制typescript

// __tests__/commands/greet.test.ts
import { GreetCommand } from '../../src/commands/greet';

describe('GreetCommand', () => {
  let command: GreetCommand;

  beforeEach(() => {
    command = new GreetCommand();
  });

  describe('execute', () => {
    test('should greet informally by default', async () => {
      const result = await command.execute(
        ['--name', 'World'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toContain('Hey, World!');
    });

    test('should greet formally with flag', async () => {
      const result = await command.execute(
        ['--name', 'World', '--formal'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toContain('Good day, World.');
    });

    test('should handle missing name parameter', async () => {
      const result = await command.execute([], {});

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('parseArgs', () => {
    test('should parse long arguments', () => {
      const parsed = command.parseArgs(['--name', 'World', '--formal']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(true);
    });

    test('should parse short arguments', () => {
      const parsed = command.parseArgs(['-n', 'World', '-f']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(true);
    });

    test('should use default values', () => {
      const parsed = command.parseArgs(['--name', 'World']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(false);
    });
  });

  describe('help', () => {
    test('should generate help text', () => {
      const help = command.help();

      expect(help).toContain('Command: greet');
      expect(help).toContain('Description:');
      expect(help).toContain('Usage:');
      expect(help).toContain('Options:');
    });
  });
});

### 钩子测试

// __tests__/hooks/logging.test.ts
import { LoggingHook } from '../../src/hooks/logging';
describe('LoggingHook', () => {
let hook: LoggingHook;
let consoleLogSpy: jest.SpyInstance;
beforeEach(() => {
hook = new LoggingHook();
consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
});
afterEach(() => {
consoleLogSpy.mockRestore();
});
describe('execute', () => {
test('should log command execution', async () => {
const event = {
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
};
const result = await hook.execute(event, {});
expect(result.success).toBe(true);
expect(consoleLogSpy).toHaveBeenCalledWith(
expect.stringContaining('Executing command: greet')
);
});
test('should not prevent default behavior', async () => {
const event = {
type: 'before_command',
data: {},
timestamp: new Date()
};
const result = await hook.execute(event, {});
expect(result.success).toBe(true);
expect(result.preventDefault).toBeUndefined();
});
});
});
```

```
typescript

// __tests__/commands/greet.test.ts
import { GreetCommand } from '../../src/commands/greet';

describe('GreetCommand', () => {
  let command: GreetCommand;

  beforeEach(() => {
    command = new GreetCommand();
  });

  describe('execute', () => {
    test('should greet informally by default', async () => {
      const result = await command.execute(
        ['--name', 'World'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toContain('Hey, World!');
    });

    test('should greet formally with flag', async () => {
      const result = await command.execute(
        ['--name', 'World', '--formal'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toContain('Good day, World.');
    });

    test('should handle missing name parameter', async () => {
      const result = await command.execute([], {});

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('parseArgs', () => {
    test('should parse long arguments', () => {
      const parsed = command.parseArgs(['--name', 'World', '--formal']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(true);
    });

    test('should parse short arguments', () => {
      const parsed = command.parseArgs(['-n', 'World', '-f']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(true);
    });

    test('should use default values', () => {
      const parsed = command.parseArgs(['--name', 'World']);

      expect(parsed.name).toBe('World');
      expect(parsed.formal).toBe(false);
    });
  });

  describe('help', () => {
    test('should generate help text', () => {
      const help = command.help();

      expect(help).toContain('Command: greet');
      expect(help).toContain('Description:');
      expect(help).toContain('Usage:');
      expect(help).toContain('Options:');
    });
  });
});

### 钩子测试

// __tests__/hooks/logging.test.ts
import { LoggingHook } from '../../src/hooks/logging';
describe('LoggingHook', () => {
let hook: LoggingHook;
let consoleLogSpy: jest.SpyInstance;
beforeEach(() => {
hook = new LoggingHook();
consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
});
afterEach(() => {
consoleLogSpy.mockRestore();
});
describe('execute', () => {
test('should log command execution', async () => {
const event = {
type: 'before_command',
data: {
command: 'greet',
args: ['--name', 'World']
},
timestamp: new Date()
};
const result = await hook.execute(event, {});
expect(result.success).toBe(true);
expect(consoleLogSpy).toHaveBeenCalledWith(
expect.stringContaining('Executing command: greet')
);
});
test('should not prevent default behavior', async () => {
const event = {
type: 'before_command',
data: {},
timestamp: new Date()
};
const result = await hook.execute(event, {});
expect(result.success).toBe(true);
expect(result.preventDefault).toBeUndefined();
});
});
});
```

#### 21.5.2 集成测试#

##### 插件集成测试#

```
bash复制typescript

// __tests__/integration/plugin.integration.test.ts
import { MyPlugin } from '../../src/plugin';

describe('MyPlugin Integration', () => {
  let plugin: MyPlugin;

  beforeEach(async () => {
    plugin = new MyPlugin();
    await plugin.initialize({});
  });

  afterEach(async () => {
    try {
      await plugin.stop();
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('full lifecycle', () => {
    test('should complete full lifecycle', async () => {
      // 启动插件
      await plugin.start();

      // 验证插件运行中
      let status = plugin.getStatus();
      expect(status.enabled).toBe(true);

      // 停止插件
      await plugin.stop();

      // 验证插件已停止
      status = plugin.getStatus();
      expect(status.enabled).toBe(false);

      // 清理插件
      await plugin.cleanup();
    });
  });

  describe('tool integration', () => {
    test('should execute tool through plugin', async () => {
      await plugin.start();

      const result = await plugin.toolManager.execute(
        'greeting',
        { name: 'World' },
        {}
      );

      expect(result.success).toBe(true);
      expect(result.data.greeting).toBeDefined();
    });
  });

  describe('command integration', () => {
    test('should execute command through plugin', async () => {
      await plugin.start();

      const result = await plugin.commandManager.execute(
        'greet',
        ['--name', 'World'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toBeDefined();
    });
  });

  describe('hook integration', () => {
    test('should execute hooks through plugin', async () => {
      await plugin.start();

      const event = {
        type: 'before_command',
        data: {
          command: 'greet',
          args: ['--name', 'World']
        },
        timestamp: new Date()
      };

      const result = await plugin.hookManager.execute(
        'before_command',
        event,
        {}
      );

      expect(result.success).toBe(true);
    });
  });
});

### 端到端测试

// __tests__/e2e/plugin.e2e.test.ts
import { MyPlugin } from '../../src/plugin';
describe('MyPlugin E2E', () => {
let plugin: MyPlugin;
beforeEach(async () => {
plugin = new MyPlugin();
await plugin.initialize({});
await plugin.start();
});
afterEach(async () => {
try {
await plugin.stop();
await plugin.cleanup();
} catch (error) {
// 忽略清理错误
}
});
test('should handle complete workflow', async () => {
// 1. 执行工具
const toolResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World' },
{}
);
expect(toolResult.success).toBe(true);
// 2. 执行命令
const commandResult = await plugin.commandManager.execute(
'greet',
['--name', 'World'],
{}
);
expect(commandResult.success).toBe(true);
// 3. 验证插件状态
const status = plugin.getStatus();
expect(status.enabled).toBe(true);
});
test('should handle errors gracefully', async () => {
// 执行无效工具
const result = await plugin.toolManager.execute(
'invalid-tool',
{},
{}
);
expect(result.success).toBe(false);
expect(result.error).toBeDefined();
// 验证插件仍然运行
const status = plugin.getStatus();
expect(status.enabled).toBe(true);
});
});
```

```
typescript

// __tests__/integration/plugin.integration.test.ts
import { MyPlugin } from '../../src/plugin';

describe('MyPlugin Integration', () => {
  let plugin: MyPlugin;

  beforeEach(async () => {
    plugin = new MyPlugin();
    await plugin.initialize({});
  });

  afterEach(async () => {
    try {
      await plugin.stop();
      await plugin.cleanup();
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('full lifecycle', () => {
    test('should complete full lifecycle', async () => {
      // 启动插件
      await plugin.start();

      // 验证插件运行中
      let status = plugin.getStatus();
      expect(status.enabled).toBe(true);

      // 停止插件
      await plugin.stop();

      // 验证插件已停止
      status = plugin.getStatus();
      expect(status.enabled).toBe(false);

      // 清理插件
      await plugin.cleanup();
    });
  });

  describe('tool integration', () => {
    test('should execute tool through plugin', async () => {
      await plugin.start();

      const result = await plugin.toolManager.execute(
        'greeting',
        { name: 'World' },
        {}
      );

      expect(result.success).toBe(true);
      expect(result.data.greeting).toBeDefined();
    });
  });

  describe('command integration', () => {
    test('should execute command through plugin', async () => {
      await plugin.start();

      const result = await plugin.commandManager.execute(
        'greet',
        ['--name', 'World'],
        {}
      );

      expect(result.success).toBe(true);
      expect(result.output).toBeDefined();
    });
  });

  describe('hook integration', () => {
    test('should execute hooks through plugin', async () => {
      await plugin.start();

      const event = {
        type: 'before_command',
        data: {
          command: 'greet',
          args: ['--name', 'World']
        },
        timestamp: new Date()
      };

      const result = await plugin.hookManager.execute(
        'before_command',
        event,
        {}
      );

      expect(result.success).toBe(true);
    });
  });
});

### 端到端测试

// __tests__/e2e/plugin.e2e.test.ts
import { MyPlugin } from '../../src/plugin';
describe('MyPlugin E2E', () => {
let plugin: MyPlugin;
beforeEach(async () => {
plugin = new MyPlugin();
await plugin.initialize({});
await plugin.start();
});
afterEach(async () => {
try {
await plugin.stop();
await plugin.cleanup();
} catch (error) {
// 忽略清理错误
}
});
test('should handle complete workflow', async () => {
// 1. 执行工具
const toolResult = await plugin.toolManager.execute(
'greeting',
{ name: 'World' },
{}
);
expect(toolResult.success).toBe(true);
// 2. 执行命令
const commandResult = await plugin.commandManager.execute(
'greet',
['--name', 'World'],
{}
);
expect(commandResult.success).toBe(true);
// 3. 验证插件状态
const status = plugin.getStatus();
expect(status.enabled).toBe(true);
});
test('should handle errors gracefully', async () => {
// 执行无效工具
const result = await plugin.toolManager.execute(
'invalid-tool',
{},
{}
);
expect(result.success).toBe(false);
expect(result.error).toBeDefined();
// 验证插件仍然运行
const status = plugin.getStatus();
expect(status.enabled).toBe(true);
});
});
```

#### 21.5.3 测试工具和辅助函数#

##### Mock 工具#

```
bash复制typescript

// __tests__/utils/mocks.ts
import { PluginContext } from '@claude-code/plugin-sdk';

/**
 * 创建 Mock 插件上下文
 */
export function createMockContext(): PluginContext {
  return {
    getService: jest.fn(),
    setService: jest.fn(),
    getData: jest.fn(),
    setData: jest.fn(),
    removeData: jest.fn(),
    clearData: jest.fn()
  };
}

/**
 * 创建 Mock 工具管理器
 */
export function createMockToolManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getTool: jest.fn(),
    getAllTools: jest.fn(),
    execute: jest.fn()
  };
}

/**
 * 创建 Mock 命令管理器
 */
export function createMockCommandManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getCommand: jest.fn(),
    getAllCommands: jest.fn(),
    execute: jest.fn()
  };
}

/**
 * 创建 Mock 钩子管理器
 */
export function createMockHookManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getHooks: jest.fn(),
    getAllHooks: jest.fn(),
    execute: jest.fn()
  };
}

### 测试辅助函数

// __tests__/utils/helpers.ts
import { MyPlugin } from '../../src/plugin';
/**
* 创建测试插件实例
*/
export async function createTestPlugin(): Promise<MyPlugin> {
const plugin = new MyPlugin();
await plugin.initialize({});
return plugin;
}
/**
* 创建并启动测试插件
*/
export async function createAndStartTestPlugin(): Promise<MyPlugin> {
const plugin = await createTestPlugin();
await plugin.start();
return plugin;
}
/**
* 清理测试插件
*/
export async function cleanupTestPlugin(plugin: MyPlugin): Promise<void> {
try {
await plugin.stop();
await plugin.cleanup();
} catch (error) {
// 忽略清理错误
}
}
/**
* 等待异步操作完成
*/
export function waitFor(ms: number): Promise<void> {
return new Promise(resolve => setTimeout(resolve, ms));
}
/**
* 重试函数
*/
export async function retry<T>(
fn: () => Promise<T>,
maxRetries: number = 3,
delay: number = 100
): Promise<T> {
let lastError: Error;
for (let i = 0; i < maxRetries; i++) {
try {
return await fn();
} catch (error) {
lastError = error;
if (i < maxRetries - 1) {
await waitFor(delay);
}
}
}
throw lastError;
}
```

```
typescript

// __tests__/utils/mocks.ts
import { PluginContext } from '@claude-code/plugin-sdk';

/**
 * 创建 Mock 插件上下文
 */
export function createMockContext(): PluginContext {
  return {
    getService: jest.fn(),
    setService: jest.fn(),
    getData: jest.fn(),
    setData: jest.fn(),
    removeData: jest.fn(),
    clearData: jest.fn()
  };
}

/**
 * 创建 Mock 工具管理器
 */
export function createMockToolManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getTool: jest.fn(),
    getAllTools: jest.fn(),
    execute: jest.fn()
  };
}

/**
 * 创建 Mock 命令管理器
 */
export function createMockCommandManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getCommand: jest.fn(),
    getAllCommands: jest.fn(),
    execute: jest.fn()
  };
}

/**
 * 创建 Mock 钩子管理器
 */
export function createMockHookManager() {
  return {
    register: jest.fn(),
    unregister: jest.fn(),
    getHooks: jest.fn(),
    getAllHooks: jest.fn(),
    execute: jest.fn()
  };
}

### 测试辅助函数

// __tests__/utils/helpers.ts
import { MyPlugin } from '../../src/plugin';
/**
* 创建测试插件实例
*/
export async function createTestPlugin(): Promise<MyPlugin> {
const plugin = new MyPlugin();
await plugin.initialize({});
return plugin;
}
/**
* 创建并启动测试插件
*/
export async function createAndStartTestPlugin(): Promise<MyPlugin> {
const plugin = await createTestPlugin();
await plugin.start();
return plugin;
}
/**
* 清理测试插件
*/
export async function cleanupTestPlugin(plugin: MyPlugin): Promise<void> {
try {
await plugin.stop();
await plugin.cleanup();
} catch (error) {
// 忽略清理错误
}
}
/**
* 等待异步操作完成
*/
export function waitFor(ms: number): Promise<void> {
return new Promise(resolve => setTimeout(resolve, ms));
}
/**
* 重试函数
*/
export async function retry<T>(
fn: () => Promise<T>,
maxRetries: number = 3,
delay: number = 100
): Promise<T> {
let lastError: Error;
for (let i = 0; i < maxRetries; i++) {
try {
return await fn();
} catch (error) {
lastError = error;
if (i < maxRetries - 1) {
await waitFor(delay);
}
}
}
throw lastError;
}
```

##### 测试断言#

```
bash复制typescript

// __tests__/utils/assertions.ts
import { ToolResult, CommandResult } from '@claude-code/plugin-sdk';

/**
 * 断言工具结果成功
 */
export function expectToolSuccess(result: ToolResult) {
  expect(result.success).toBe(true);
  expect(result.error).toBeUndefined();
}

/**
 * 断言工具结果失败
 */
export function expectToolFailure(result: ToolResult) {
  expect(result.success).toBe(false);
  expect(result.error).toBeDefined();
}

/**
 * 断言命令结果成功
 */
export function expectCommandSuccess(result: CommandResult) {
  expect(result.success).toBe(true);
  expect(result.error).toBeUndefined();
  expect(result.exitCode).toBe(0);
}

/**
 * 断言命令结果失败
 */
export function expectCommandFailure(result: CommandResult) {
  expect(result.success).toBe(false);
  expect(result.error).toBeDefined();
  expect(result.exitCode).not.toBe(0);
}

/**
 * 断言结果包含数据
 */
export function expectResultData(result: ToolResult | CommandResult) {
  expect(result.data).toBeDefined();
  expect(Object.keys(result.data).length).toBeGreaterThan(0);
}

## 21.5.4 调试技巧

### 使用 VS Code 调试

// .vscode/launch.json
{
"version": "0.2.0",
"configurations": [
{
"type": "node",
"request": "launch",
"name": "Debug Plugin",
"runtimeExecutable": "npm",
"runtimeArgs": ["run", "dev"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
},
{
"type": "node",
"request": "launch",
"name": "Debug Tests",
"runtimeExecutable": "npm",
"runtimeArgs": ["run", "test:watch"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
},
{
"type": "node",
"request": "launch",
"name": "Debug Current Test",
"runtimeExecutable": "npm",
"runtimeArgs": ["test", "--", "${fileBasenameNoExtension}"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
}
]
}
```

```
typescript

// __tests__/utils/assertions.ts
import { ToolResult, CommandResult } from '@claude-code/plugin-sdk';

/**
 * 断言工具结果成功
 */
export function expectToolSuccess(result: ToolResult) {
  expect(result.success).toBe(true);
  expect(result.error).toBeUndefined();
}

/**
 * 断言工具结果失败
 */
export function expectToolFailure(result: ToolResult) {
  expect(result.success).toBe(false);
  expect(result.error).toBeDefined();
}

/**
 * 断言命令结果成功
 */
export function expectCommandSuccess(result: CommandResult) {
  expect(result.success).toBe(true);
  expect(result.error).toBeUndefined();
  expect(result.exitCode).toBe(0);
}

/**
 * 断言命令结果失败
 */
export function expectCommandFailure(result: CommandResult) {
  expect(result.success).toBe(false);
  expect(result.error).toBeDefined();
  expect(result.exitCode).not.toBe(0);
}

/**
 * 断言结果包含数据
 */
export function expectResultData(result: ToolResult | CommandResult) {
  expect(result.data).toBeDefined();
  expect(Object.keys(result.data).length).toBeGreaterThan(0);
}

## 21.5.4 调试技巧

### 使用 VS Code 调试

// .vscode/launch.json
{
"version": "0.2.0",
"configurations": [
{
"type": "node",
"request": "launch",
"name": "Debug Plugin",
"runtimeExecutable": "npm",
"runtimeArgs": ["run", "dev"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
},
{
"type": "node",
"request": "launch",
"name": "Debug Tests",
"runtimeExecutable": "npm",
"runtimeArgs": ["run", "test:watch"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
},
{
"type": "node",
"request": "launch",
"name": "Debug Current Test",
"runtimeExecutable": "npm",
"runtimeArgs": ["test", "--", "${fileBasenameNoExtension}"],
"console": "integratedTerminal",
"internalConsoleOptions": "neverOpen"
}
]
}
```

##### 日志调试#

```
bash复制typescript

// src/utils/logger.ts
export class DebugLogger {
  private enabled: boolean;

  constructor(enabled: boolean = process.env.DEBUG === 'true') {
    this.enabled = enabled;
  }

  log(message: string, data?: any): void {
    if (!this.enabled) {
      return;
    }

    console.log(`[DEBUG] ${message}`, data || '');
  }

  error(message: string, error?: Error): void {
    console.error(`[ERROR] ${message}`, error || '');
  }

  trace(message: string, data?: any): void {
    if (!this.enabled) {
      return;
    }

    console.trace(`[TRACE] ${message}`, data || '');
  }
}

// 使用示例
const logger = new DebugLogger();

export class MyPlugin extends Plugin {
  async initialize(config: PluginConfig): Promise<void> {
    logger.log('Initializing plugin', { config });

    try {
      // 初始化逻辑
      logger.log('Plugin initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize plugin', error);
      throw error;
    }
  }
}

### 性能分析

// src/utils/profiler.ts
export class Profiler {
private measurements: Map<string, number[]> = new Map();
/**
* 测量函数执行时间
*/
async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {
const start = Date.now();
try {
return await fn();
} finally {
const duration = Date.now() - start;
if (!this.measurements.has(name)) {
this.measurements.set(name, []);
}
this.measurements.get(name)!.push(duration);
}
}
/**
* 获取测量结果
*/
getStats(name: string) {
const measurements = this.measurements.get(name);
if (!measurements || measurements.length === 0) {
return null;
}
const sum = measurements.reduce((a, b) => a + b, 0);
const avg = sum / measurements.length;
const min = Math.min(...measurements);
const max = Math.max(...measurements);
return {
count: measurements.length,
sum,
avg,
min,
max
};
}
/**
* 打印所有统计信息
*/
printStats(): void {
for (const [name, measurements] of this.measurements.entries()) {
const stats = this.getStats(name);
console.log(`[Profiler] ${name}:`, stats);
}
}
}
// 使用示例
const profiler = new Profiler();
export class MyPlugin extends Plugin {
async executeTool(name: string, params: any): Promise<ToolResult> {
return profiler.measure(`tool.${name}`, async () => {
return this.toolManager.execute(name, params, {});
});
}
}
```

```
typescript

// src/utils/logger.ts
export class DebugLogger {
  private enabled: boolean;

  constructor(enabled: boolean = process.env.DEBUG === 'true') {
    this.enabled = enabled;
  }

  log(message: string, data?: any): void {
    if (!this.enabled) {
      return;
    }

    console.log(`[DEBUG] ${message}`, data || '');
  }

  error(message: string, error?: Error): void {
    console.error(`[ERROR] ${message}`, error || '');
  }

  trace(message: string, data?: any): void {
    if (!this.enabled) {
      return;
    }

    console.trace(`[TRACE] ${message}`, data || '');
  }
}

// 使用示例
const logger = new DebugLogger();

export class MyPlugin extends Plugin {
  async initialize(config: PluginConfig): Promise<void> {
    logger.log('Initializing plugin', { config });

    try {
      // 初始化逻辑
      logger.log('Plugin initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize plugin', error);
      throw error;
    }
  }
}

### 性能分析

// src/utils/profiler.ts
export class Profiler {
private measurements: Map<string, number[]> = new Map();
/**
* 测量函数执行时间
*/
async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {
const start = Date.now();
try {
return await fn();
} finally {
const duration = Date.now() - start;
if (!this.measurements.has(name)) {
this.measurements.set(name, []);
}
this.measurements.get(name)!.push(duration);
}
}
/**
* 获取测量结果
*/
getStats(name: string) {
const measurements = this.measurements.get(name);
if (!measurements || measurements.length === 0) {
return null;
}
const sum = measurements.reduce((a, b) => a + b, 0);
const avg = sum / measurements.length;
const min = Math.min(...measurements);
const max = Math.max(...measurements);
return {
count: measurements.length,
sum,
avg,
min,
max
};
}
/**
* 打印所有统计信息
*/
printStats(): void {
for (const [name, measurements] of this.measurements.entries()) {
const stats = this.getStats(name);
console.log(`[Profiler] ${name}:`, stats);
}
}
}
// 使用示例
const profiler = new Profiler();
export class MyPlugin extends Plugin {
async executeTool(name: string, params: any): Promise<ToolResult> {
return profiler.measure(`tool.${name}`, async () => {
return this.toolManager.execute(name, params, {});
});
}
}
```

##### 错误追踪#

```
bash复制typescript

// src/utils/error-tracker.ts
export class ErrorTracker {
  private errors: Error[] = [];

  /**
   * 追踪错误
   */
  track(error: Error): void {
    this.errors.push(error);
    console.error('[ErrorTracker]', error);
  }

  /**
   * 获取所有错误
   */
  getErrors(): Error[] {
    return [...this.errors];
  }

  /**
   * 清除错误
   */
  clear(): void {
    this.errors = [];
  }

  /**
   * 获取错误统计
   */
  getStats() {
    const errorTypes = new Map<string, number>();

    for (const error of this.errors) {
      const type = error.constructor.name;
      errorTypes.set(type, (errorTypes.get(type) || 0) + 1);
    }

    return {
      total: this.errors.length,
      types: Object.fromEntries(errorTypes)
    };
  }
}

// 使用示例
const errorTracker = new ErrorTracker();

export class MyPlugin extends Plugin {
  async executeTool(name: string, params: any): Promise<ToolResult> {
    try {
      return await this.toolManager.execute(name, params, {});
    } catch (error) {
      errorTracker.track(error);
      throw error;
    }
  }
}

## 21.5.5 测试最佳实践

### 1. 测试命名

// 好的测试命名
describe('GreetingTool', () => {
describe('execute', () => {
test('should generate English greeting when language is English', async () => {
// 测试代码
});
test('should generate Chinese greeting when language is Chinese', async () => {
// 测试代码
});
});
});
// 不好的测试命名
describe('GreetingTool', () => {
test('test1', async () => {
// 测试代码
});
test('test2', async () => {
// 测试代码
});
});
```

```
typescript

// src/utils/error-tracker.ts
export class ErrorTracker {
  private errors: Error[] = [];

  /**
   * 追踪错误
   */
  track(error: Error): void {
    this.errors.push(error);
    console.error('[ErrorTracker]', error);
  }

  /**
   * 获取所有错误
   */
  getErrors(): Error[] {
    return [...this.errors];
  }

  /**
   * 清除错误
   */
  clear(): void {
    this.errors = [];
  }

  /**
   * 获取错误统计
   */
  getStats() {
    const errorTypes = new Map<string, number>();

    for (const error of this.errors) {
      const type = error.constructor.name;
      errorTypes.set(type, (errorTypes.get(type) || 0) + 1);
    }

    return {
      total: this.errors.length,
      types: Object.fromEntries(errorTypes)
    };
  }
}

// 使用示例
const errorTracker = new ErrorTracker();

export class MyPlugin extends Plugin {
  async executeTool(name: string, params: any): Promise<ToolResult> {
    try {
      return await this.toolManager.execute(name, params, {});
    } catch (error) {
      errorTracker.track(error);
      throw error;
    }
  }
}

## 21.5.5 测试最佳实践

### 1. 测试命名

// 好的测试命名
describe('GreetingTool', () => {
describe('execute', () => {
test('should generate English greeting when language is English', async () => {
// 测试代码
});
test('should generate Chinese greeting when language is Chinese', async () => {
// 测试代码
});
});
});
// 不好的测试命名
describe('GreetingTool', () => {
test('test1', async () => {
// 测试代码
});
test('test2', async () => {
// 测试代码
});
});
```

##### 2. 测试隔离#

```
bash复制typescript

// 每个测试都应该独立运行
describe('MyPlugin', () => {
  let plugin: MyPlugin;

  beforeEach(() => {
    // 每个测试前创建新实例
    plugin = new MyPlugin();
  });

  afterEach(async () => {
    // 每个测试后清理
    await plugin.cleanup();
  });

  test('test 1', async () => {
    // 不依赖其他测试
  });

  test('test 2', async () => {
    // 不依赖其他测试
  });
});

### 3. 测试覆盖率

// 确保测试覆盖所有代码路径
describe('GreetingTool', () => {
describe('execute', () => {
test('should handle English language', async () => {
// 覆盖 English 分支
});
test('should handle Chinese language', async () => {
// 覆盖 Chinese 分支
});
test('should handle Spanish language', async () => {
// 覆盖 Spanish 分支
});
test('should handle unknown language', async () => {
// 覆盖默认分支
});
});
});
```

```
typescript

// 每个测试都应该独立运行
describe('MyPlugin', () => {
  let plugin: MyPlugin;

  beforeEach(() => {
    // 每个测试前创建新实例
    plugin = new MyPlugin();
  });

  afterEach(async () => {
    // 每个测试后清理
    await plugin.cleanup();
  });

  test('test 1', async () => {
    // 不依赖其他测试
  });

  test('test 2', async () => {
    // 不依赖其他测试
  });
});

### 3. 测试覆盖率

// 确保测试覆盖所有代码路径
describe('GreetingTool', () => {
describe('execute', () => {
test('should handle English language', async () => {
// 覆盖 English 分支
});
test('should handle Chinese language', async () => {
// 覆盖 Chinese 分支
});
test('should handle Spanish language', async () => {
// 覆盖 Spanish 分支
});
test('should handle unknown language', async () => {
// 覆盖默认分支
});
});
});
```

##### 4. 测试速度#

```
bash复制typescript

// 使用 Mock 加速测试
describe('MyPlugin', () => {
  test('should execute tool quickly', async () => {
    // Mock 工具管理器
    const mockToolManager = createMockToolManager();
    mockToolManager.execute.mockResolvedValue({
      success: true,
      data: { result: 'mocked' }
    });

    plugin.toolManager = mockToolManager;

    // 快速执行测试
    const result = await plugin.executeTool('test', {});
    expect(result.success).toBe(true);
  });
});

### 5. 测试可维护性

// 使用辅助函数提高可维护性
describe('MyPlugin', () => {
test('should handle multiple tool executions', async () => {
const tools = ['tool1', 'tool2', 'tool3'];
for (const tool of tools) {
const result = await plugin.executeTool(tool, {});
expectToolSuccess(result);
}
});
});
```

```
typescript

// 使用 Mock 加速测试
describe('MyPlugin', () => {
  test('should execute tool quickly', async () => {
    // Mock 工具管理器
    const mockToolManager = createMockToolManager();
    mockToolManager.execute.mockResolvedValue({
      success: true,
      data: { result: 'mocked' }
    });

    plugin.toolManager = mockToolManager;

    // 快速执行测试
    const result = await plugin.executeTool('test', {});
    expect(result.success).toBe(true);
  });
});

### 5. 测试可维护性

// 使用辅助函数提高可维护性
describe('MyPlugin', () => {
test('should handle multiple tool executions', async () => {
const tools = ['tool1', 'tool2', 'tool3'];
for (const tool of tools) {
const result = await plugin.executeTool(tool, {});
expectToolSuccess(result);
}
});
});
```

#### 21.5.6 运行测试#

##### 运行所有测试#

```
bash复制bash

# 运行所有测试
npm test

# 运行测试并生成覆盖率报告
npm run test -- --coverage

# 监听模式
npm run test:watch

### 运行特定测试

# 运行特定测试文件
npm test -- plugin.test.ts
# 运行特定测试套件
npm test -- --testNamePattern="MyPlugin"
# 运行特定测试
npm test -- --testNamePattern="should initialize successfully"
```

```
bash

# 运行所有测试
npm test

# 运行测试并生成覆盖率报告
npm run test -- --coverage

# 监听模式
npm run test:watch

### 运行特定测试

# 运行特定测试文件
npm test -- plugin.test.ts
# 运行特定测试套件
npm test -- --testNamePattern="MyPlugin"
# 运行特定测试
npm test -- --testNamePattern="should initialize successfully"
```

##### 测试覆盖率#

```
bash复制bash

# 生成覆盖率报告
npm run test -- --coverage

# 查看覆盖率报告
open coverage/lcov-report/index.html

# 设置覆盖率阈值
npm run test -- --coverage --coverageThreshold='{"global":{"branches":80,"functions":80,"lines":80,"statements":80}}'

### CI/CD 集成

# .github/workflows/test.yml
name: Tests
on:
push:
branches: [ main, develop ]
pull_request:
branches: [ main, develop ]
jobs:
test:
runs-on: ubuntu-latest
strategy:
matrix:
node-version: [14.x, 16.x, 18.x]
steps:
- uses: actions/checkout@v2
- name: Use Node.js ${{ matrix.node-version }}
uses: actions/setup-node@v2
with:
node-version: ${{ matrix.node-version }}
- name: Install dependencies
run: npm ci
- name: Run tests
run: npm test
- name: Generate coverage
run: npm run test -- --coverage
- name: Upload coverage
uses: codecov/codecov-action@v2
with:
files: ./coverage/lcov.info
```

```
bash

# 生成覆盖率报告
npm run test -- --coverage

# 查看覆盖率报告
open coverage/lcov-report/index.html

# 设置覆盖率阈值
npm run test -- --coverage --coverageThreshold='{"global":{"branches":80,"functions":80,"lines":80,"statements":80}}'

### CI/CD 集成

# .github/workflows/test.yml
name: Tests
on:
push:
branches: [ main, develop ]
pull_request:
branches: [ main, develop ]
jobs:
test:
runs-on: ubuntu-latest
strategy:
matrix:
node-version: [14.x, 16.x, 18.x]
steps:
- uses: actions/checkout@v2
- name: Use Node.js ${{ matrix.node-version }}
uses: actions/setup-node@v2
with:
node-version: ${{ matrix.node-version }}
- name: Install dependencies
run: npm ci
- name: Run tests
run: npm test
- name: Generate coverage
run: npm run test -- --coverage
- name: Upload coverage
uses: codecov/codecov-action@v2
with:
files: ./coverage/lcov.info
```

---

# 第 22 章

## 1 复杂插件设计

**URL**: https://claudecode.tangshuang.net/course/22.1%20%E5%A4%8D%E6%9D%82%E6%8F%92%E4%BB%B6%E8%AE%BE%E8%AE%A1

#### 22.1.1 插件架构模式#

##### 1. 分层架构#

// src/plugin.ts
import { Plugin, PluginConfig, PluginContext } from '@claude-code/plugin-sdk';

- 分层架构插件
*/
export class LayeredPlugin extends Plugin {
private presentationLayer: PresentationLayer;
private businessLayer: BusinessLayer;
private dataLayer: DataLayer;

constructor() {
super({
name: 'layered-plugin',
version: '1.0.0',
description: 'A plugin with layered architecture'
});

// 初始化各层
this.dataLayer = new DataLayer();
this.businessLayer = new BusinessLayer(this.dataLayer);
this.presentationLayer = new PresentationLayer(this.businessLayer);
}

async initialize(config: PluginConfig): Promise<void> {
// 初始化数据层
await this.dataLayer.initialize(config.data);

// 初始化业务层
await this.businessLayer.initialize(config.business);

// 初始化表示层
await this.presentationLayer.initialize(config.presentation);
}

async start(): Promise<void> {
// 启动数据层
await this.dataLayer.start();

// 启动业务层
await this.businessLayer.start();

// 启动表示层
await this.presentationLayer.start();
}

async stop(): Promise<void> {
// 停止表示层
await this.presentationLayer.stop();

// 停止业务层

await this.businessLayer.stop();

// 停止数据层
await this.dataLayer.stop();
}

async cleanup(): Promise<void> {
// 清理表示层
await this.presentationLayer.cleanup();

// 清理业务层
await this.businessLayer.cleanup();

// 清理数据层
await this.dataLayer.cleanup();
}
}

- 表示层
*/
class PresentationLayer {
constructor(private businessLayer: BusinessLayer) {}

async initialize(config: any): Promise<void> {
// 初始化表示层
}

async start(): Promise<void> {
// 启动表示层
}

async stop(): Promise<void> {
// 停止表示层
}

async cleanup(): Promise<void> {
// 清理表示层
}

- 处理用户请求
*/
async handleRequest(request: any): Promise<any> {
// 转发到业务层
return this.businessLayer.processRequest(request);
}
}

- 业务层
*/
class BusinessLayer {
constructor(private dataLayer: DataLayer) {}

async initialize(config: any): Promise<void> {
// 初始化业务层
}

async start(): Promise<void> {
// 启动业务层
}

async stop(): Promise<void> {
// 停止业务层
}

async cleanup(): Promise<void> {
// 清理业务层
}

- 处理业务逻辑
*/
async processRequest(request: any): Promise<any> {
// 业务逻辑处理
const data = await this.dataLayer.fetchData(request);
return this.transformData(data);
}

private transformData(data: any): any {
// 数据转换
return data;
}
}

- 数据层
*/
class DataLayer {
async initialize(config: any): Promise<void> {
// 初始化数据层
}

async start(): Promise<void> {
// 启动数据层
}

async stop(): Promise<void> {
// 停止数据层
}

async cleanup(): Promise<void> {
// 清理数据层
}

- 获取数据
*/
async fetchData(request: any): Promise<any> {
// 数据获取逻辑
return {};
}
}

##### 2. 事件驱动架构#

```
bash复制typescript

// src/plugin.ts
import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';

/**
 * 事件驱动插件
 */
export class EventDrivenPlugin extends Plugin {
  private eventBus: EventBus;
  private eventHandlers: Map<string, EventHandler[]> = new Map();

  constructor() {
    super({
      name: 'event-driven-plugin',
      version: '1.0.0',
      description: 'An event-driven plugin'
    });

    this.eventBus = new EventBus();
  }

  async initialize(config: PluginConfig): Promise<void> {
    // 注册事件处理器
    this.registerEventHandlers();

    // 订阅事件
    this.subscribeToEvents();
  }

  async start(): Promise<void> {
    // 启动事件总线
    await this.eventBus.start();
  }

  async stop(): Promise<void> {
    // 停止事件总线
    await this.eventBus.stop();
  }

  async cleanup(): Promise<void> {
    // 清理事件处理器
    this.eventHandlers.clear();
  }

  /**
   * 注册事件处理器
   */
  private registerEventHandlers(): void {
    this.on('user.created', new UserCreatedHandler());
    this.on('user.updated', new UserUpdatedHandler());
    this.on('user.deleted', new UserDeletedHandler());
  }

  /**
   * 订阅事件
   */
  private subscribeToEvents(): void {
    this.eventBus.subscribe('user.created', async (event) => {
      await this.handleEvent('user.created', event);
    });

    this.eventBus.subscribe('user.updated', async (event) => {
      await this.handleEvent('user.updated', event);
    });

    this.eventBus.subscribe('user.deleted', async (event) => {
      await this.handleEvent('user.deleted', event);
    });
  }

  /**
   * 注册事件处理器
   */
  private on(eventType: string, handler: EventHandler): void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType)!.push(handler);
  }

  /**
   * 处理事件
   */
  private async handleEvent(eventType: string, event: Event): Promise<void> {
    const handlers = this.eventHandlers.get(eventType);
    if (!handlers) {
      return;
    }

    for (const handler of handlers) {
      try {
        await handler.handle(event);
      } catch (error) {
        console.error(`Error handling event ${eventType}:`, error);
      }
    }
  }
}

/**
 * 事件总线
 */
class EventBus {
  private subscribers: Map<string, EventSubscriber[]> = new Map();
  private running: boolean = false;

  async start(): Promise<void> {
    this.running = true;
  }

  async stop(): Promise<void> {
    this.running = false;
  }

  subscribe(eventType: string, subscriber: EventSubscriber): void {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType)!.push(subscriber);
  }

  unsubscribe(eventType: string, subscriber: EventSubscriber): void {
    const subscribers = this.subscribers.get(eventType);
    if (subscribers) {
      const index = subscribers.indexOf(subscriber);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    }
  }

  async publish(event: Event): Promise<void> {
    if (!this.running) {
      return;
    }

    const subscribers = this.subscribers.get(event.type);
    if (!subscribers) {
      return;
    }

    for (const subscriber of subscribers) {
      try {
        await subscriber(event);
      } catch (error) {
        console.error(`Error in subscriber for event ${event.type}:`, error);
      }
    }
  }
}

/**
 * 事件处理器接口
 */
interface EventHandler {
  handle(event: Event): Promise<void>;
}

/**
 * 用户创建处理器
 */
class UserCreatedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User created:', event.data);
    // 处理用户创建逻辑
  }
}

/**
 * 用户更新处理器
 */
class UserUpdatedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User updated:', event.data);
    // 处理用户更新逻辑
  }
}

/**
 * 用户删除处理器
 */
class UserDeletedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User deleted:', event.data);
    // 处理用户删除逻辑
  }
}

/**
 * 事件接口
 */
interface Event {
  type: string;
  data: any;
  timestamp: Date;
}

/**
 * 事件订阅者
 */
type EventSubscriber = (event: Event) => Promise<void>;

### 3. 微服务架构

// src/plugin.ts
import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';
/**
* 微服务架构插件
*/
export class MicroservicePlugin extends Plugin {
private services: Map<string, Microservice> = new Map();
private serviceRegistry: ServiceRegistry;
private apiGateway: ApiGateway;
constructor() {
super({
name: 'microservice-plugin',
version: '1.0.0',
description: 'A microservice architecture plugin'
});
this.serviceRegistry = new ServiceRegistry();
this.apiGateway = new ApiGateway(this.serviceRegistry);
}
async initialize(config: PluginConfig): Promise<void> {
// 创建微服务
this.createServices(config.services);
// 注册服务
this.registerServices();
// 配置 API 网关
this.configureApiGateway(config.gateway);
}
async start(): Promise<void> {
// 启动所有服务
for (const service of this.services.values()) {
await service.start();
}
// 启动 API 网关
await this.apiGateway.start();
}
async stop(): Promise<void> {
// 停止 API 网关
await this.apiGateway.stop();
// 停止所有服务
for (const service of this.services.values()) {
await service.stop();
}
}
async cleanup(): Promise<void> {
// 清理服务
this.services.clear();
}
/**
* 创建服务
*/
private createServices(servicesConfig: any[]): void {
for (const config of servicesConfig) {
const service = this.createService(config);
this.services.set(service.name, service);
}
}
/**
* 创建服务
*/
private createService(config: any): Microservice {
switch (config.type) {
case 'user':
return new UserService(config);
case 'order':
return new OrderService(config);
case 'product':
return new ProductService(config);
default:
throw new Error(`Unknown service type: ${config.type}`);
}
}
/**
* 注册服务
*/
private registerServices(): void {
for (const service of this.services.values()) {
this.serviceRegistry.register(service);
}
}
/**
* 配置 API 网关
*/
private configureApiGateway(config: any): void {
this.apiGateway.configure(config);
}
}
/**
* 微服务基类
*/
abstract class Microservice {
abstract name: string;
abstract type: string;
protected config: any;
protected running: boolean = false;
constructor(config: any) {
this.config = config;
}
abstract start(): Promise<void>;
abstract stop(): Promise<void>;
/**
* 健康检查
*/
async healthCheck(): Promise<boolean> {
return this.running;
}
/**
* 获取服务信息
*/
getInfo() {
return {
name: this.name,
type: this.type,
running: this.running
};
}
}
/**
* 用户服务
*/
class UserService extends Microservice {
name = 'user-service';
type = 'user';
async start(): Promise<void> {
this.running = true;
console.log('User service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('User service stopped');
}
/**
* 创建用户
*/
async createUser(userData: any): Promise<any> {
// 创建用户逻辑
return { id: 1, ...userData };
}
/**
* 获取用户
*/
async getUser(userId: number): Promise<any> {
// 获取用户逻辑
return { id: userId, name: 'John Doe' };
}
}
/**
* 订单服务
*/
class OrderService extends Microservice {
name = 'order-service';
type = 'order';
async start(): Promise<void> {
this.running = true;
console.log('Order service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('Order service stopped');
}
/**
* 创建订单
*/
async createOrder(orderData: any): Promise<any> {
// 创建订单逻辑
return { id: 1, ...orderData };
}
/**
* 获取订单
*/
async getOrder(orderId: number): Promise<any> {
// 获取订单逻辑
return { id: orderId, userId: 1, total: 100 };
}
}
/**
* 产品服务
*/
class ProductService extends Microservice {
name = 'product-service';
type = 'product';
async start(): Promise<void> {
this.running = true;
console.log('Product service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('Product service stopped');
}
/**
* 创建产品
*/
async createProduct(productData: any): Promise<any> {
// 创建产品逻辑
return { id: 1, ...productData };
}
/**
* 获取产品
*/
async getProduct(productId: number): Promise<any> {
// 获取产品逻辑
return { id: productId, name: 'Product 1', price: 10 };
}
}
/**
* 服务注册表
*/
class ServiceRegistry {
private services: Map<string, Microservice> = new Map();
register(service: Microservice): void {
this.services.set(service.name, service);
}
unregister(serviceName: string): void {
this.services.delete(serviceName);
}
getService(serviceName: string): Microservice | undefined {
return this.services.get(serviceName);
}
getAllServices(): Microservice[] {
return Array.from(this.services.values());
}
async healthCheckAll(): Promise<Map<string, boolean>> {
const results = new Map<string, boolean>();
for (const [name, service] of this.services.entries()) {
results.set(name, await service.healthCheck());
}
return results;
}
}
/**
* API 网关
*/
class ApiGateway {
private routes: Map<string, Route> = new Map();
private running: boolean = false;
constructor(private serviceRegistry: ServiceRegistry) {}
configure(config: any): void {
// 配置路由
for (const routeConfig of config.routes) {
const route = new Route(routeConfig);
this.routes.set(route.path, route);
}
}
async start(): Promise<void> {
this.running = true;
console.log('API Gateway started');
}
async stop(): Promise<void> {
this.running = false;
console.log('API Gateway stopped');
}
/**
* 处理请求
*/
async handleRequest(request: Request): Promise<Response> {
if (!this.running) {
return {
status: 503,
body: 'Service Unavailable'
};
}
const route = this.routes.get(request.path);
if (!route) {
return {
status: 404,
body: 'Not Found'
};
}
// 转发到对应的服务
const service = this.serviceRegistry.getService(route.service);
if (!service) {
return {
status: 503,
body: 'Service Unavailable'
};
}
// 调用服务方法
const result = await this.callService(service, route.method, request.body);
return {
status: 200,
body: result
};
}
private async callService(service: any, method: string, data: any): Promise<any> {
// 根据方法调用服务
switch (method) {
case 'createUser':
return await service.createUser(data);
case 'getUser':
return await service.getUser(data.id);
case 'createOrder':
return await service.createOrder(data);
case 'getOrder':
return await service.getOrder(data.id);
case 'createProduct':
return await service.createProduct(data);
case 'getProduct':
return await service.getProduct(data.id);
default:
throw new Error(`Unknown method: ${method}`);
}
}
}
/**
* 路由
*/
class Route {
path: string;
service: string;
method: string;
constructor(config: any) {
this.path = config.path;
this.service = config.service;
this.method = config.method;
}
}
/**
* 请求
*/
interface Request {
path: string;
method: string;
body: any;
}
/**
* 响应
*/
interface Response {
status: number;
body: any;
}
```

```
typescript

// src/plugin.ts
import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';

/**
 * 事件驱动插件
 */
export class EventDrivenPlugin extends Plugin {
  private eventBus: EventBus;
  private eventHandlers: Map<string, EventHandler[]> = new Map();

  constructor() {
    super({
      name: 'event-driven-plugin',
      version: '1.0.0',
      description: 'An event-driven plugin'
    });

    this.eventBus = new EventBus();
  }

  async initialize(config: PluginConfig): Promise<void> {
    // 注册事件处理器
    this.registerEventHandlers();

    // 订阅事件
    this.subscribeToEvents();
  }

  async start(): Promise<void> {
    // 启动事件总线
    await this.eventBus.start();
  }

  async stop(): Promise<void> {
    // 停止事件总线
    await this.eventBus.stop();
  }

  async cleanup(): Promise<void> {
    // 清理事件处理器
    this.eventHandlers.clear();
  }

  /**
   * 注册事件处理器
   */
  private registerEventHandlers(): void {
    this.on('user.created', new UserCreatedHandler());
    this.on('user.updated', new UserUpdatedHandler());
    this.on('user.deleted', new UserDeletedHandler());
  }

  /**
   * 订阅事件
   */
  private subscribeToEvents(): void {
    this.eventBus.subscribe('user.created', async (event) => {
      await this.handleEvent('user.created', event);
    });

    this.eventBus.subscribe('user.updated', async (event) => {
      await this.handleEvent('user.updated', event);
    });

    this.eventBus.subscribe('user.deleted', async (event) => {
      await this.handleEvent('user.deleted', event);
    });
  }

  /**
   * 注册事件处理器
   */
  private on(eventType: string, handler: EventHandler): void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType)!.push(handler);
  }

  /**
   * 处理事件
   */
  private async handleEvent(eventType: string, event: Event): Promise<void> {
    const handlers = this.eventHandlers.get(eventType);
    if (!handlers) {
      return;
    }

    for (const handler of handlers) {
      try {
        await handler.handle(event);
      } catch (error) {
        console.error(`Error handling event ${eventType}:`, error);
      }
    }
  }
}

/**
 * 事件总线
 */
class EventBus {
  private subscribers: Map<string, EventSubscriber[]> = new Map();
  private running: boolean = false;

  async start(): Promise<void> {
    this.running = true;
  }

  async stop(): Promise<void> {
    this.running = false;
  }

  subscribe(eventType: string, subscriber: EventSubscriber): void {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType)!.push(subscriber);
  }

  unsubscribe(eventType: string, subscriber: EventSubscriber): void {
    const subscribers = this.subscribers.get(eventType);
    if (subscribers) {
      const index = subscribers.indexOf(subscriber);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    }
  }

  async publish(event: Event): Promise<void> {
    if (!this.running) {
      return;
    }

    const subscribers = this.subscribers.get(event.type);
    if (!subscribers) {
      return;
    }

    for (const subscriber of subscribers) {
      try {
        await subscriber(event);
      } catch (error) {
        console.error(`Error in subscriber for event ${event.type}:`, error);
      }
    }
  }
}

/**
 * 事件处理器接口
 */
interface EventHandler {
  handle(event: Event): Promise<void>;
}

/**
 * 用户创建处理器
 */
class UserCreatedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User created:', event.data);
    // 处理用户创建逻辑
  }
}

/**
 * 用户更新处理器
 */
class UserUpdatedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User updated:', event.data);
    // 处理用户更新逻辑
  }
}

/**
 * 用户删除处理器
 */
class UserDeletedHandler implements EventHandler {
  async handle(event: Event): Promise<void> {
    console.log('User deleted:', event.data);
    // 处理用户删除逻辑
  }
}

/**
 * 事件接口
 */
interface Event {
  type: string;
  data: any;
  timestamp: Date;
}

/**
 * 事件订阅者
 */
type EventSubscriber = (event: Event) => Promise<void>;

### 3. 微服务架构

// src/plugin.ts
import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';
/**
* 微服务架构插件
*/
export class MicroservicePlugin extends Plugin {
private services: Map<string, Microservice> = new Map();
private serviceRegistry: ServiceRegistry;
private apiGateway: ApiGateway;
constructor() {
super({
name: 'microservice-plugin',
version: '1.0.0',
description: 'A microservice architecture plugin'
});
this.serviceRegistry = new ServiceRegistry();
this.apiGateway = new ApiGateway(this.serviceRegistry);
}
async initialize(config: PluginConfig): Promise<void> {
// 创建微服务
this.createServices(config.services);
// 注册服务
this.registerServices();
// 配置 API 网关
this.configureApiGateway(config.gateway);
}
async start(): Promise<void> {
// 启动所有服务
for (const service of this.services.values()) {
await service.start();
}
// 启动 API 网关
await this.apiGateway.start();
}
async stop(): Promise<void> {
// 停止 API 网关
await this.apiGateway.stop();
// 停止所有服务
for (const service of this.services.values()) {
await service.stop();
}
}
async cleanup(): Promise<void> {
// 清理服务
this.services.clear();
}
/**
* 创建服务
*/
private createServices(servicesConfig: any[]): void {
for (const config of servicesConfig) {
const service = this.createService(config);
this.services.set(service.name, service);
}
}
/**
* 创建服务
*/
private createService(config: any): Microservice {
switch (config.type) {
case 'user':
return new UserService(config);
case 'order':
return new OrderService(config);
case 'product':
return new ProductService(config);
default:
throw new Error(`Unknown service type: ${config.type}`);
}
}
/**
* 注册服务
*/
private registerServices(): void {
for (const service of this.services.values()) {
this.serviceRegistry.register(service);
}
}
/**
* 配置 API 网关
*/
private configureApiGateway(config: any): void {
this.apiGateway.configure(config);
}
}
/**
* 微服务基类
*/
abstract class Microservice {
abstract name: string;
abstract type: string;
protected config: any;
protected running: boolean = false;
constructor(config: any) {
this.config = config;
}
abstract start(): Promise<void>;
abstract stop(): Promise<void>;
/**
* 健康检查
*/
async healthCheck(): Promise<boolean> {
return this.running;
}
/**
* 获取服务信息
*/
getInfo() {
return {
name: this.name,
type: this.type,
running: this.running
};
}
}
/**
* 用户服务
*/
class UserService extends Microservice {
name = 'user-service';
type = 'user';
async start(): Promise<void> {
this.running = true;
console.log('User service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('User service stopped');
}
/**
* 创建用户
*/
async createUser(userData: any): Promise<any> {
// 创建用户逻辑
return { id: 1, ...userData };
}
/**
* 获取用户
*/
async getUser(userId: number): Promise<any> {
// 获取用户逻辑
return { id: userId, name: 'John Doe' };
}
}
/**
* 订单服务
*/
class OrderService extends Microservice {
name = 'order-service';
type = 'order';
async start(): Promise<void> {
this.running = true;
console.log('Order service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('Order service stopped');
}
/**
* 创建订单
*/
async createOrder(orderData: any): Promise<any> {
// 创建订单逻辑
return { id: 1, ...orderData };
}
/**
* 获取订单
*/
async getOrder(orderId: number): Promise<any> {
// 获取订单逻辑
return { id: orderId, userId: 1, total: 100 };
}
}
/**
* 产品服务
*/
class ProductService extends Microservice {
name = 'product-service';
type = 'product';
async start(): Promise<void> {
this.running = true;
console.log('Product service started');
}
async stop(): Promise<void> {
this.running = false;
console.log('Product service stopped');
}
/**
* 创建产品
*/
async createProduct(productData: any): Promise<any> {
// 创建产品逻辑
return { id: 1, ...productData };
}
/**
* 获取产品
*/
async getProduct(productId: number): Promise<any> {
// 获取产品逻辑
return { id: productId, name: 'Product 1', price: 10 };
}
}
/**
* 服务注册表
*/
class ServiceRegistry {
private services: Map<string, Microservice> = new Map();
register(service: Microservice): void {
this.services.set(service.name, service);
}
unregister(serviceName: string): void {
this.services.delete(serviceName);
}
getService(serviceName: string): Microservice | undefined {
return this.services.get(serviceName);
}
getAllServices(): Microservice[] {
return Array.from(this.services.values());
}
async healthCheckAll(): Promise<Map<string, boolean>> {
const results = new Map<string, boolean>();
for (const [name, service] of this.services.entries()) {
results.set(name, await service.healthCheck());
}
return results;
}
}
/**
* API 网关
*/
class ApiGateway {
private routes: Map<string, Route> = new Map();
private running: boolean = false;
constructor(private serviceRegistry: ServiceRegistry) {}
configure(config: any): void {
// 配置路由
for (const routeConfig of config.routes) {
const route = new Route(routeConfig);
this.routes.set(route.path, route);
}
}
async start(): Promise<void> {
this.running = true;
console.log('API Gateway started');
}
async stop(): Promise<void> {
this.running = false;
console.log('API Gateway stopped');
}
/**
* 处理请求
*/
async handleRequest(request: Request): Promise<Response> {
if (!this.running) {
return {
status: 503,
body: 'Service Unavailable'
};
}
const route = this.routes.get(request.path);
if (!route) {
return {
status: 404,
body: 'Not Found'
};
}
// 转发到对应的服务
const service = this.serviceRegistry.getService(route.service);
if (!service) {
return {
status: 503,
body: 'Service Unavailable'
};
}
// 调用服务方法
const result = await this.callService(service, route.method, request.body);
return {
status: 200,
body: result
};
}
private async callService(service: any, method: string, data: any): Promise<any> {
// 根据方法调用服务
switch (method) {
case 'createUser':
return await service.createUser(data);
case 'getUser':
return await service.getUser(data.id);
case 'createOrder':
return await service.createOrder(data);
case 'getOrder':
return await service.getOrder(data.id);
case 'createProduct':
return await service.createProduct(data);
case 'getProduct':
return await service.getProduct(data.id);
default:
throw new Error(`Unknown method: ${method}`);
}
}
}
/**
* 路由
*/
class Route {
path: string;
service: string;
method: string;
constructor(config: any) {
this.path = config.path;
this.service = config.service;
this.method = config.method;
}
}
/**
* 请求
*/
interface Request {
path: string;
method: string;
body: any;
}
/**
* 响应
*/
interface Response {
status: number;
body: any;
}
```

#### 22.1.2 设计模式应用#

##### 1. 工厂模式#

```
bash复制typescript

// src/patterns/factory.ts

/**
 * 工厂接口
 */
interface ToolFactory {
  createTool(type: string): Tool;
}

/**
 * 具体工厂
 */
class ConcreteToolFactory implements ToolFactory {
  createTool(type: string): Tool {
    switch (type) {
      case 'greeting':
        return new GreetingTool();
      case 'time':
        return new TimeTool();
      case 'calc':
        return new CalcTool();
      default:
        throw new Error(`Unknown tool type: ${type}`);
    }
  }
}

/**
 * 工具接口
 */
interface Tool {
  execute(params: any): Promise<any>;
}

/**
 * 具体工具
 */
class GreetingTool implements Tool {
  async execute(params: any): Promise<any> {
    return { greeting: `Hello, ${params.name}!` };
  }
}

class TimeTool implements Tool {
  async execute(params: any): Promise<any> {
    return { time: new Date().toISOString() };
  }
}

class CalcTool implements Tool {
  async execute(params: any): Promise<any> {
    const result = eval(params.expression);
    return { result };
  }
}

// 使用示例
const factory = new ConcreteToolFactory();
const greetingTool = factory.createTool('greeting');
const result = await greetingTool.execute({ name: 'World' });
console.log(result); // { greeting: 'Hello, World!' }

### 2. 策略模式

// src/patterns/strategy.ts
/**
* 策略接口
*/
interface DataProcessingStrategy {
process(data: any): Promise<any>;
}
/**
* 具体策略
*/
class JsonProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
return JSON.parse(data);
}
}
class XmlProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
// XML 处理逻辑
return { xml: data };
}
}
class CsvProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
// CSV 处理逻辑
return { csv: data };
}
}
/**
* 上下文
*/
class DataProcessor {
private strategy: DataProcessingStrategy;
constructor(strategy: DataProcessingStrategy) {
this.strategy = strategy;
}
setStrategy(strategy: DataProcessingStrategy): void {
this.strategy = strategy;
}
async processData(data: any): Promise<any> {
return this.strategy.process(data);
}
}
// 使用示例
const processor = new DataProcessor(new JsonProcessingStrategy());
const result1 = await processor.processData('{"name": "John"}');
console.log(result1); // { name: 'John' }
processor.setStrategy(new XmlProcessingStrategy());
const result2 = await processor.processData('<name>John</name>');
console.log(result2); // { xml: '<name>John</name>' }
```

```
typescript

// src/patterns/factory.ts

/**
 * 工厂接口
 */
interface ToolFactory {
  createTool(type: string): Tool;
}

/**
 * 具体工厂
 */
class ConcreteToolFactory implements ToolFactory {
  createTool(type: string): Tool {
    switch (type) {
      case 'greeting':
        return new GreetingTool();
      case 'time':
        return new TimeTool();
      case 'calc':
        return new CalcTool();
      default:
        throw new Error(`Unknown tool type: ${type}`);
    }
  }
}

/**
 * 工具接口
 */
interface Tool {
  execute(params: any): Promise<any>;
}

/**
 * 具体工具
 */
class GreetingTool implements Tool {
  async execute(params: any): Promise<any> {
    return { greeting: `Hello, ${params.name}!` };
  }
}

class TimeTool implements Tool {
  async execute(params: any): Promise<any> {
    return { time: new Date().toISOString() };
  }
}

class CalcTool implements Tool {
  async execute(params: any): Promise<any> {
    const result = eval(params.expression);
    return { result };
  }
}

// 使用示例
const factory = new ConcreteToolFactory();
const greetingTool = factory.createTool('greeting');
const result = await greetingTool.execute({ name: 'World' });
console.log(result); // { greeting: 'Hello, World!' }

### 2. 策略模式

// src/patterns/strategy.ts
/**
* 策略接口
*/
interface DataProcessingStrategy {
process(data: any): Promise<any>;
}
/**
* 具体策略
*/
class JsonProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
return JSON.parse(data);
}
}
class XmlProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
// XML 处理逻辑
return { xml: data };
}
}
class CsvProcessingStrategy implements DataProcessingStrategy {
async process(data: any): Promise<any> {
// CSV 处理逻辑
return { csv: data };
}
}
/**
* 上下文
*/
class DataProcessor {
private strategy: DataProcessingStrategy;
constructor(strategy: DataProcessingStrategy) {
this.strategy = strategy;
}
setStrategy(strategy: DataProcessingStrategy): void {
this.strategy = strategy;
}
async processData(data: any): Promise<any> {
return this.strategy.process(data);
}
}
// 使用示例
const processor = new DataProcessor(new JsonProcessingStrategy());
const result1 = await processor.processData('{"name": "John"}');
console.log(result1); // { name: 'John' }
processor.setStrategy(new XmlProcessingStrategy());
const result2 = await processor.processData('<name>John</name>');
console.log(result2); // { xml: '<name>John</name>' }
```

##### 3. 观察者模式#

```
bash复制typescript

// src/patterns/observer.ts

/**
 * 观察者接口
 */
interface Observer {
  update(event: Event): void;
}

/**
 * 被观察者接口
 */
interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(event: Event): void;
}

/**
 * 具体被观察者
 */
class EventSubject implements Subject {
  private observers: Observer[] = [];

  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(event: Event): void {
    for (const observer of this.observers) {
      observer.update(event);
    }
  }
}

/**
 * 具体观察者
 */
class LoggingObserver implements Observer {
  update(event: Event): void {
    console.log(`[Logging] Event: ${event.type}`, event.data);
  }
}

class MetricsObserver implements Observer {
  update(event: Event): void {
    // 记录指标
    console.log(`[Metrics] Event: ${event.type}`);
  }
}

class AlertObserver implements Observer {
  update(event: Event): void {
    if (event.type === 'error') {
      console.error(`[Alert] Error occurred: ${event.data.message}`);
    }
  }
}

// 使用示例
const subject = new EventSubject();
subject.attach(new LoggingObserver());
subject.attach(new MetricsObserver());
subject.attach(new AlertObserver());

subject.notify({
  type: 'user.created',
  data: { userId: 1 },
  timestamp: new Date()
});

subject.notify({
  type: 'error',
  data: { message: 'Something went wrong' },
  timestamp: new Date()
});

### 4. 装饰器模式

// src/patterns/decorator.ts
/**
* 组件接口
*/
interface Tool {
execute(params: any): Promise<any>;
}
/**
* 具体组件
*/
class BaseTool implements Tool {
async execute(params: any): Promise<any> {
return { result: 'base result' };
}
}
/**
* 装饰器基类
*/
abstract class ToolDecorator implements Tool {
protected tool: Tool;
constructor(tool: Tool) {
this.tool = tool;
}
async execute(params: any): Promise<any> {
return this.tool.execute(params);
}
}
/**
* 具体装饰器
*/
class LoggingDecorator extends ToolDecorator {
async execute(params: any): Promise<any> {
console.log(`[Logging] Executing tool with params:`, params);
const result = await this.tool.execute(params);
console.log(`[Logging] Result:`, result);
return result;
}
}
class CachingDecorator extends ToolDecorator {
private cache: Map<string, any> = new Map();
async execute(params: any): Promise<any> {
const cacheKey = JSON.stringify(params);
if (this.cache.has(cacheKey)) {
console.log(`[Cache] Cache hit for key: ${cacheKey}`);
return this.cache.get(cacheKey);
}
const result = await this.tool.execute(params);
this.cache.set(cacheKey, result);
console.log(`[Cache] Cached result for key: ${cacheKey}`);
return result;
}
}
class RetryDecorator extends ToolDecorator {
private maxRetries: number;
constructor(tool: Tool, maxRetries: number = 3) {
super(tool);
this.maxRetries = maxRetries;
}
async execute(params: any): Promise<any> {
let lastError: Error;
for (let i = 0; i < this.maxRetries; i++) {
try {
return await this.tool.execute(params);
} catch (error) {
lastError = error;
console.log(`[Retry] Attempt ${i + 1} failed:`, error.message);
if (i < this.maxRetries - 1) {
await this.delay(1000 * (i + 1));
}
}
}
throw lastError;
}
private delay(ms: number): Promise<void> {
return new Promise(resolve => setTimeout(resolve, ms));
}
}
// 使用示例
let tool: Tool = new BaseTool();
tool = new LoggingDecorator(tool);
tool = new CachingDecorator(tool);
tool = new RetryDecorator(tool, 3);
const result = await tool.execute({ param: 'value' });
console.log(result);
```

```
typescript

// src/patterns/observer.ts

/**
 * 观察者接口
 */
interface Observer {
  update(event: Event): void;
}

/**
 * 被观察者接口
 */
interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(event: Event): void;
}

/**
 * 具体被观察者
 */
class EventSubject implements Subject {
  private observers: Observer[] = [];

  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(event: Event): void {
    for (const observer of this.observers) {
      observer.update(event);
    }
  }
}

/**
 * 具体观察者
 */
class LoggingObserver implements Observer {
  update(event: Event): void {
    console.log(`[Logging] Event: ${event.type}`, event.data);
  }
}

class MetricsObserver implements Observer {
  update(event: Event): void {
    // 记录指标
    console.log(`[Metrics] Event: ${event.type}`);
  }
}

class AlertObserver implements Observer {
  update(event: Event): void {
    if (event.type === 'error') {
      console.error(`[Alert] Error occurred: ${event.data.message}`);
    }
  }
}

// 使用示例
const subject = new EventSubject();
subject.attach(new LoggingObserver());
subject.attach(new MetricsObserver());
subject.attach(new AlertObserver());

subject.notify({
  type: 'user.created',
  data: { userId: 1 },
  timestamp: new Date()
});

subject.notify({
  type: 'error',
  data: { message: 'Something went wrong' },
  timestamp: new Date()
});

### 4. 装饰器模式

// src/patterns/decorator.ts
/**
* 组件接口
*/
interface Tool {
execute(params: any): Promise<any>;
}
/**
* 具体组件
*/
class BaseTool implements Tool {
async execute(params: any): Promise<any> {
return { result: 'base result' };
}
}
/**
* 装饰器基类
*/
abstract class ToolDecorator implements Tool {
protected tool: Tool;
constructor(tool: Tool) {
this.tool = tool;
}
async execute(params: any): Promise<any> {
return this.tool.execute(params);
}
}
/**
* 具体装饰器
*/
class LoggingDecorator extends ToolDecorator {
async execute(params: any): Promise<any> {
console.log(`[Logging] Executing tool with params:`, params);
const result = await this.tool.execute(params);
console.log(`[Logging] Result:`, result);
return result;
}
}
class CachingDecorator extends ToolDecorator {
private cache: Map<string, any> = new Map();
async execute(params: any): Promise<any> {
const cacheKey = JSON.stringify(params);
if (this.cache.has(cacheKey)) {
console.log(`[Cache] Cache hit for key: ${cacheKey}`);
return this.cache.get(cacheKey);
}
const result = await this.tool.execute(params);
this.cache.set(cacheKey, result);
console.log(`[Cache] Cached result for key: ${cacheKey}`);
return result;
}
}
class RetryDecorator extends ToolDecorator {
private maxRetries: number;
constructor(tool: Tool, maxRetries: number = 3) {
super(tool);
this.maxRetries = maxRetries;
}
async execute(params: any): Promise<any> {
let lastError: Error;
for (let i = 0; i < this.maxRetries; i++) {
try {
return await this.tool.execute(params);
} catch (error) {
lastError = error;
console.log(`[Retry] Attempt ${i + 1} failed:`, error.message);
if (i < this.maxRetries - 1) {
await this.delay(1000 * (i + 1));
}
}
}
throw lastError;
}
private delay(ms: number): Promise<void> {
return new Promise(resolve => setTimeout(resolve, ms));
}
}
// 使用示例
let tool: Tool = new BaseTool();
tool = new LoggingDecorator(tool);
tool = new CachingDecorator(tool);
tool = new RetryDecorator(tool, 3);
const result = await tool.execute({ param: 'value' });
console.log(result);
```

##### 5. 适配器模式#

```
bash复制typescript

// src/patterns/adapter.ts

/**
 * 目标接口
 */
interface ClaudeTool {
  execute(params: any): Promise<any>;
}

/**
 * 被适配者
 */
class ExternalService {
  async callApi(endpoint: string, data: any): Promise<any> {
    // 外部服务调用
    return { endpoint, data, result: 'success' };
  }
}

/**
 * 适配器
 */
class ExternalServiceAdapter implements ClaudeTool {
  constructor(private service: ExternalService) {}

  async execute(params: any): Promise<any> {
    // 将 Claude 工具参数转换为外部服务参数
    const endpoint = this.mapToEndpoint(params.action);
    const data = this.mapToData(params);

    // 调用外部服务
    const result = await this.service.callApi(endpoint, data);

    // 将外部服务结果转换为 Claude 工具结果
    return this.mapToResult(result);
  }

  private mapToEndpoint(action: string): string {
    const mapping: Record<string, string> = {
      'create': '/api/create',
      'update': '/api/update',
      'delete': '/api/delete'
    };

    return mapping[action] || '/api/default';
  }

  private mapToData(params: any): any {
    return {
      id: params.id,
      data: params.data
    };
  }

  private mapToResult(result: any): any {
    return {
      success: true,
      data: result.result
    };
  }
}

// 使用示例
const service = new ExternalService();
const adapter = new ExternalServiceAdapter(service);

const result = await adapter.execute({
  action: 'create',
  id: 1,
  data: { name: 'John' }
});

console.log(result); // { success: true, data: 'success' }
```

```
typescript

// src/patterns/adapter.ts

/**
 * 目标接口
 */
interface ClaudeTool {
  execute(params: any): Promise<any>;
}

/**
 * 被适配者
 */
class ExternalService {
  async callApi(endpoint: string, data: any): Promise<any> {
    // 外部服务调用
    return { endpoint, data, result: 'success' };
  }
}

/**
 * 适配器
 */
class ExternalServiceAdapter implements ClaudeTool {
  constructor(private service: ExternalService) {}

  async execute(params: any): Promise<any> {
    // 将 Claude 工具参数转换为外部服务参数
    const endpoint = this.mapToEndpoint(params.action);
    const data = this.mapToData(params);

    // 调用外部服务
    const result = await this.service.callApi(endpoint, data);

    // 将外部服务结果转换为 Claude 工具结果
    return this.mapToResult(result);
  }

  private mapToEndpoint(action: string): string {
    const mapping: Record<string, string> = {
      'create': '/api/create',
      'update': '/api/update',
      'delete': '/api/delete'
    };

    return mapping[action] || '/api/default';
  }

  private mapToData(params: any): any {
    return {
      id: params.id,
      data: params.data
    };
  }

  private mapToResult(result: any): any {
    return {
      success: true,
      data: result.result
    };
  }
}

// 使用示例
const service = new ExternalService();
const adapter = new ExternalServiceAdapter(service);

const result = await adapter.execute({
  action: 'create',
  id: 1,
  data: { name: 'John' }
});

console.log(result); // { success: true, data: 'success' }
```

---

## 3 多插件协作

**URL**: https://claudecode.tangshuang.net/course/22.3%20%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%8D%8F%E4%BD%9C

#### 22.3.1 插件间通信机制#

##### 事件总线通信#

// src/communication/event-bus.ts

- 插件事件总线
*/
export class PluginEventBus {
private listeners: Map<string, EventListener[]> = new Map();
private history: Event[] = [];
private maxHistorySize: number = 100;

constructor(maxHistorySize: number = 100) {
this.maxHistorySize = maxHistorySize;
}

- 订阅事件
*/
subscribe(eventType: string, listener: EventListener): void {
if (!this.listeners.has(eventType)) {
this.listeners.set(eventType, []);
}

this.listeners.get(eventType)!.push(listener);
}

- 取消订阅
*/
unsubscribe(eventType: string, listener: EventListener): void {
const listeners = this.listeners.get(eventType);

if (listeners) {
const index = listeners.indexOf(listener);
if (index > -1) {
listeners.splice(index, 1);
}
}
}

- 发布事件
*/
async publish(event: PluginEvent): Promise<void> {
// 记录历史
this.addToHistory(event);

// 获取监听器
const listeners = this.listeners.get(event.type);

if (!listeners || listeners.length === 0) {
return;
}

// 通知所有监听器
const promises = listeners.map(listener =>
this.safeNotify(listener, event)
);

await Promise.all(promises);
}

- 安全通知
*/
private async safeNotify(listener: EventListener, event: PluginEvent): Promise<void> {
try {
await listener(event);
} catch (error) {
console.error(Error in event listener for ${event.type}:, error);
}
}

```
Error in event listener for ${event.type}:
```

- 添加到历史
*/
private addToHistory(event: PluginEvent): void {
this.history.push(event);

// 限制历史大小
if (this.history.length > this.maxHistorySize) {
this.history.shift();
}
}

- 获取历史事件
*/
getHistory(eventType?: string): PluginEvent[] {
if (eventType) {
return this.history.filter(event => event.type === eventType);
}

return [...this.history];
}

- 清除历史
*/
clearHistory(): void {
this.history = [];
}
}

- 事件监听器
*/
type EventListener = (event: PluginEvent) => Promise<void> | void;

- 插件事件
*/
interface PluginEvent {
type: string;
source: string;
target?: string;
data: any;
timestamp: Date;
}

// 使用示例
const eventBus = new PluginEventBus();

// 插件 A 订阅事件
eventBus.subscribe('user.created', async (event) => {
console.log(Plugin A received user.created:, event.data);
});

```
Plugin A received user.created:
```

// 插件 B 订阅事件
eventBus.subscribe('user.created', async (event) => {
console.log(Plugin B received user.created:, event.data);
});

```
Plugin B received user.created:
```

// 插件 C 发布事件
await eventBus.publish({
type: 'user.created',
source: 'plugin-c',
data: { userId: 1, name: 'John' },
timestamp: new Date()
});

// 查看历史
const history = eventBus.getHistory('user.created');
console.log('History:', history);

##### 消息队列通信#

```
bash复制typescript

// src/communication/message-queue.ts

/**
 * 插件消息队列
 */
export class PluginMessageQueue {
  private queues: Map<string, Message[]> = new Map();
  private consumers: Map<string, MessageConsumer[]> = new Map();
  private processing: boolean = false;

  /**
   * 发送消息
   */
  send(queueName: string, message: Message): void {
    if (!this.queues.has(queueName)) {
      this.queues.set(queueName, []);
    }

    this.queues.get(queueName)!.push(message);

    // 触发处理
    this.processQueue(queueName);
  }

  /**
   * 接收消息
   */
  receive(queueName: string, consumer: MessageConsumer): void {
    if (!this.consumers.has(queueName)) {
      this.consumers.set(queueName, []);
    }

    this.consumers.get(queueName)!.push(consumer);
  }

  /**
   * 处理队列
   */
  private async processQueue(queueName: string): Promise<void> {
    if (this.processing) {
      return;
    }

    this.processing = true;

    try {
      const queue = this.queues.get(queueName);
      const consumers = this.consumers.get(queueName);

      if (!queue || queue.length === 0 || !consumers || consumers.length === 0) {
        return;
      }

      // 取出消息
      const message = queue.shift()!;

      // 分发给消费者
      const promises = consumers.map(consumer =>
        this.safeConsume(consumer, message)
      );

      await Promise.all(promises);

      // 继续处理下一条消息
      if (queue.length > 0) {
        await this.processQueue(queueName);
      }
    } finally {
      this.processing = false;
    }
  }

  /**
   * 安全消费
   */
  private async safeConsume(consumer: MessageConsumer, message: Message): Promise<void> {
    try {
      await consumer(message);
    } catch (error) {
      console.error(`Error in message consumer:`, error);
    }
  }

  /**
   * 获取队列大小
   */
  getQueueSize(queueName: string): number {
    const queue = this.queues.get(queueName);
    return queue ? queue.length : 0;
  }

  /**
   * 清空队列
   */
  clearQueue(queueName: string): void {
    this.queues.set(queueName, []);
  }
}

/**
 * 消息接口
 */
interface Message {
  id: string;
  source: string;
  target?: string;
  data: any;
  timestamp: Date;
}

/**
 * 消息消费者
 */
type MessageConsumer = (message: Message) => Promise<void> | void;

// 使用示例
const messageQueue = new PluginMessageQueue();

// 插件 A 注册消费者
messageQueue.receive('user-queue', async (message) => {
  console.log(`Plugin A received message:`, message.data);
});

// 插件 B 注册消费者
messageQueue.receive('user-queue', async (message) => {
  console.log(`Plugin B received message:`, message.data);
});

// 插件 C 发送消息
messageQueue.send('user-queue', {
  id: 'msg-1',
  source: 'plugin-c',
  data: { userId: 1, name: 'John' },
  timestamp: new Date()
});

// 查看队列大小
const size = messageQueue.getQueueSize('user-queue');
console.log('Queue size:', size);

### RPC 通信

// src/communication/rpc.ts
/**
* 插件 RPC 服务
*/
export class PluginRPCService {
private services: Map<string, RPCHandler> = new Map();
private clients: Map<string, RPCClient> = new Map();
/**
* 注册服务
*/
registerService(serviceName: string, handler: RPCHandler): void {
this.services.set(serviceName, handler);
}
/**
* 注销服务
*/
unregisterService(serviceName: string): void {
this.services.delete(serviceName);
}
/**
* 调用服务
*/
async call(serviceName: string, method: string, params: any): Promise<any> {
const handler = this.services.get(serviceName);
if (!handler) {
throw new Error(`Service not found: ${serviceName}`);
}
return handler(method, params);
}
/**
* 创建客户端
*/
createClient(serviceName: string): RPCClient {
const client = new RPCClient(this, serviceName);
this.clients.set(serviceName, client);
return client;
}
/**
* 获取客户端
*/
getClient(serviceName: string): RPCClient | undefined {
return this.clients.get(serviceName);
}
}
/**
* RPC 处理器
*/
type RPCHandler = (method: string, params: any) => Promise<any>;
/**
* RPC 客户端
*/
export class RPCClient {
constructor(
private rpcService: PluginRPCService,
private serviceName: string
) {}
/**
* 调用方法
*/
async call(method: string, params?: any): Promise<any> {
return this.rpcService.call(this.serviceName, method, params || {});
}
}
// 使用示例
const rpcService = new PluginRPCService();
// 插件 A 注册服务
rpcService.registerService('user-service', async (method, params) => {
switch (method) {
case 'getUser':
return { id: params.id, name: 'John Doe' };
case 'createUser':
return { id: Date.now(), ...params };
default:
throw new Error(`Unknown method: ${method}`);
}
});
// 插件 B 注册服务
rpcService.registerService('order-service', async (method, params) => {
switch (method) {
case 'getOrder':
return { id: params.id, userId: 1, total: 100 };
case 'createOrder':
return { id: Date.now(), ...params };
default:
throw new Error(`Unknown method: ${method}`);
}
});
// 插件 C 创建客户端并调用服务
const userClient = rpcService.createClient('user-service');
const orderClient = rpcService.createClient('order-service');
const user = await userClient.call('getUser', { id: 1 });
console.log('User:', user);
const order = await orderClient.call('getOrder', { id: 1 });
console.log('Order:', order);
```

```
typescript

// src/communication/message-queue.ts

/**
 * 插件消息队列
 */
export class PluginMessageQueue {
  private queues: Map<string, Message[]> = new Map();
  private consumers: Map<string, MessageConsumer[]> = new Map();
  private processing: boolean = false;

  /**
   * 发送消息
   */
  send(queueName: string, message: Message): void {
    if (!this.queues.has(queueName)) {
      this.queues.set(queueName, []);
    }

    this.queues.get(queueName)!.push(message);

    // 触发处理
    this.processQueue(queueName);
  }

  /**
   * 接收消息
   */
  receive(queueName: string, consumer: MessageConsumer): void {
    if (!this.consumers.has(queueName)) {
      this.consumers.set(queueName, []);
    }

    this.consumers.get(queueName)!.push(consumer);
  }

  /**
   * 处理队列
   */
  private async processQueue(queueName: string): Promise<void> {
    if (this.processing) {
      return;
    }

    this.processing = true;

    try {
      const queue = this.queues.get(queueName);
      const consumers = this.consumers.get(queueName);

      if (!queue || queue.length === 0 || !consumers || consumers.length === 0) {
        return;
      }

      // 取出消息
      const message = queue.shift()!;

      // 分发给消费者
      const promises = consumers.map(consumer =>
        this.safeConsume(consumer, message)
      );

      await Promise.all(promises);

      // 继续处理下一条消息
      if (queue.length > 0) {
        await this.processQueue(queueName);
      }
    } finally {
      this.processing = false;
    }
  }

  /**
   * 安全消费
   */
  private async safeConsume(consumer: MessageConsumer, message: Message): Promise<void> {
    try {
      await consumer(message);
    } catch (error) {
      console.error(`Error in message consumer:`, error);
    }
  }

  /**
   * 获取队列大小
   */
  getQueueSize(queueName: string): number {
    const queue = this.queues.get(queueName);
    return queue ? queue.length : 0;
  }

  /**
   * 清空队列
   */
  clearQueue(queueName: string): void {
    this.queues.set(queueName, []);
  }
}

/**
 * 消息接口
 */
interface Message {
  id: string;
  source: string;
  target?: string;
  data: any;
  timestamp: Date;
}

/**
 * 消息消费者
 */
type MessageConsumer = (message: Message) => Promise<void> | void;

// 使用示例
const messageQueue = new PluginMessageQueue();

// 插件 A 注册消费者
messageQueue.receive('user-queue', async (message) => {
  console.log(`Plugin A received message:`, message.data);
});

// 插件 B 注册消费者
messageQueue.receive('user-queue', async (message) => {
  console.log(`Plugin B received message:`, message.data);
});

// 插件 C 发送消息
messageQueue.send('user-queue', {
  id: 'msg-1',
  source: 'plugin-c',
  data: { userId: 1, name: 'John' },
  timestamp: new Date()
});

// 查看队列大小
const size = messageQueue.getQueueSize('user-queue');
console.log('Queue size:', size);

### RPC 通信

// src/communication/rpc.ts
/**
* 插件 RPC 服务
*/
export class PluginRPCService {
private services: Map<string, RPCHandler> = new Map();
private clients: Map<string, RPCClient> = new Map();
/**
* 注册服务
*/
registerService(serviceName: string, handler: RPCHandler): void {
this.services.set(serviceName, handler);
}
/**
* 注销服务
*/
unregisterService(serviceName: string): void {
this.services.delete(serviceName);
}
/**
* 调用服务
*/
async call(serviceName: string, method: string, params: any): Promise<any> {
const handler = this.services.get(serviceName);
if (!handler) {
throw new Error(`Service not found: ${serviceName}`);
}
return handler(method, params);
}
/**
* 创建客户端
*/
createClient(serviceName: string): RPCClient {
const client = new RPCClient(this, serviceName);
this.clients.set(serviceName, client);
return client;
}
/**
* 获取客户端
*/
getClient(serviceName: string): RPCClient | undefined {
return this.clients.get(serviceName);
}
}
/**
* RPC 处理器
*/
type RPCHandler = (method: string, params: any) => Promise<any>;
/**
* RPC 客户端
*/
export class RPCClient {
constructor(
private rpcService: PluginRPCService,
private serviceName: string
) {}
/**
* 调用方法
*/
async call(method: string, params?: any): Promise<any> {
return this.rpcService.call(this.serviceName, method, params || {});
}
}
// 使用示例
const rpcService = new PluginRPCService();
// 插件 A 注册服务
rpcService.registerService('user-service', async (method, params) => {
switch (method) {
case 'getUser':
return { id: params.id, name: 'John Doe' };
case 'createUser':
return { id: Date.now(), ...params };
default:
throw new Error(`Unknown method: ${method}`);
}
});
// 插件 B 注册服务
rpcService.registerService('order-service', async (method, params) => {
switch (method) {
case 'getOrder':
return { id: params.id, userId: 1, total: 100 };
case 'createOrder':
return { id: Date.now(), ...params };
default:
throw new Error(`Unknown method: ${method}`);
}
});
// 插件 C 创建客户端并调用服务
const userClient = rpcService.createClient('user-service');
const orderClient = rpcService.createClient('order-service');
const user = await userClient.call('getUser', { id: 1 });
console.log('User:', user);
const order = await orderClient.call('getOrder', { id: 1 });
console.log('Order:', order);
```

#### 22.3.2 插件依赖管理#

##### 依赖解析#

```
bash复制typescript

// src/dependencies/dependency-resolver.ts

/**
 * 插件依赖解析器
 */
export class PluginDependencyResolver {
  private plugins: Map<string, PluginInfo> = new Map();

  /**
   * 添加插件
   */
  addPlugin(pluginInfo: PluginInfo): void {
    this.plugins.set(pluginInfo.name, pluginInfo);
  }

  /**
   * 移除插件
   */
  removePlugin(pluginName: string): void {
    this.plugins.delete(pluginName);
  }

  /**
   * 解析依赖顺序
   */
  resolve(): string[] {
    const visited: Set<string> = new Set();
    const visiting: Set<string> = new Set();
    const order: string[] = [];

    for (const pluginName of this.plugins.keys()) {
      if (!visited.has(pluginName)) {
        this.visit(pluginName, visited, visiting, order);
      }
    }

    return order;
  }

  /**
   * 访问插件
   */
  private visit(
    pluginName: string,
    visited: Set<string>,
    visiting: Set<string>,
    order: string[]
  ): void {
    if (visiting.has(pluginName)) {
      throw new Error(`Circular dependency detected: ${pluginName}`);
    }

    if (visited.has(pluginName)) {
      return;
    }

    visiting.add(pluginName);

    const plugin = this.plugins.get(pluginName);
    if (plugin) {
      for (const dep of plugin.dependencies || []) {
        this.visit(dep, visited, visiting, order);
      }
    }

    visiting.delete(pluginName);
    visited.add(pluginName);
    order.push(pluginName);
  }

  /**
   * 检查依赖
   */
  checkDependencies(): DependencyCheckResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    for (const [name, plugin] of this.plugins.entries()) {
      for (const dep of plugin.dependencies || []) {
        if (!this.plugins.has(dep)) {
          errors.push(`Plugin ${name} depends on missing plugin: ${dep}`);
        }
      }
    }

    return { errors, warnings };
  }
}

/**
 * 插件信息
 */
interface PluginInfo {
  name: string;
  version: string;
  dependencies?: string[];
}

/**
 * 依赖检查结果
 */
interface DependencyCheckResult {
  errors: string[];
  warnings: string[];
}

// 使用示例
const resolver = new PluginDependencyResolver();

// 添加插件
resolver.addPlugin({
  name: 'plugin-a',
  version: '1.0.0',
  dependencies: []
});

resolver.addPlugin({
  name: 'plugin-b',
  version: '1.0.0',
  dependencies: ['plugin-a']
});

resolver.addPlugin({
  name: 'plugin-c',
  version: '1.0.0',
  dependencies: ['plugin-a', 'plugin-b']
});

// 检查依赖
const checkResult = resolver.checkDependencies();
console.log('Dependency check:', checkResult);

// 解析依赖顺序
const order = resolver.resolve();
console.log('Load order:', order);
// ['plugin-a', 'plugin-b', 'plugin-c']

### 依赖注入

// src/dependencies/dependency-injection.ts
/**
* 插件依赖注入容器
*/
export class PluginDIContainer {
private services: Map<string, ServiceDefinition> = new Map();
private instances: Map<string, any> = new Map();
/**
* 注册服务
*/
registerService(name: string, definition: ServiceDefinition): void {
this.services.set(name, definition);
}
/**
* 解析服务
*/
resolve(name: string): any {
// 检查是否已实例化
if (this.instances.has(name)) {
return this.instances.get(name);
}
// 获取服务定义
const definition = this.services.get(name);
if (!definition) {
throw new Error(`Service not found: ${name}`);
}
// 解析依赖
const dependencies = (definition.dependencies || []).map(dep =>
this.resolve(dep)
);
// 创建实例
const instance = definition.factory(...dependencies);
// 如果是单例，缓存实例
if (definition.singleton) {
this.instances.set(name, instance);
}
return instance;
}
/**
* 清除实例
*/
clear(): void {
this.instances.clear();
}
}
/**
* 服务定义
*/
interface ServiceDefinition {
factory: (...args: any[]) => any;
dependencies?: string[];
singleton?: boolean;
}
// 使用示例
const container = new PluginDIContainer();
// 注册服务
container.registerService('logger', {
factory: () => ({
log: (message: string) => console.log(`[LOG] ${message}`)
}),
singleton: true
});
container.registerService('database', {
factory: (logger: any) => ({
query: (sql: string) => {
logger.log(`Executing query: ${sql}`);
return [];
}
}),
dependencies: ['logger'],
singleton: true
});
container.registerService('userService', {
factory: (database: any, logger: any) => ({
getUser: (id: number) => {
logger.log(`Getting user ${id}`);
return database.query(`SELECT * FROM users WHERE id = ${id}`);
}
}),
dependencies: ['database', 'logger'],
singleton: false
});
// 解析服务
const userService = container.resolve('userService');
const user = userService.getUser(1);
console.log('User:', user);
```

```
typescript

// src/dependencies/dependency-resolver.ts

/**
 * 插件依赖解析器
 */
export class PluginDependencyResolver {
  private plugins: Map<string, PluginInfo> = new Map();

  /**
   * 添加插件
   */
  addPlugin(pluginInfo: PluginInfo): void {
    this.plugins.set(pluginInfo.name, pluginInfo);
  }

  /**
   * 移除插件
   */
  removePlugin(pluginName: string): void {
    this.plugins.delete(pluginName);
  }

  /**
   * 解析依赖顺序
   */
  resolve(): string[] {
    const visited: Set<string> = new Set();
    const visiting: Set<string> = new Set();
    const order: string[] = [];

    for (const pluginName of this.plugins.keys()) {
      if (!visited.has(pluginName)) {
        this.visit(pluginName, visited, visiting, order);
      }
    }

    return order;
  }

  /**
   * 访问插件
   */
  private visit(
    pluginName: string,
    visited: Set<string>,
    visiting: Set<string>,
    order: string[]
  ): void {
    if (visiting.has(pluginName)) {
      throw new Error(`Circular dependency detected: ${pluginName}`);
    }

    if (visited.has(pluginName)) {
      return;
    }

    visiting.add(pluginName);

    const plugin = this.plugins.get(pluginName);
    if (plugin) {
      for (const dep of plugin.dependencies || []) {
        this.visit(dep, visited, visiting, order);
      }
    }

    visiting.delete(pluginName);
    visited.add(pluginName);
    order.push(pluginName);
  }

  /**
   * 检查依赖
   */
  checkDependencies(): DependencyCheckResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    for (const [name, plugin] of this.plugins.entries()) {
      for (const dep of plugin.dependencies || []) {
        if (!this.plugins.has(dep)) {
          errors.push(`Plugin ${name} depends on missing plugin: ${dep}`);
        }
      }
    }

    return { errors, warnings };
  }
}

/**
 * 插件信息
 */
interface PluginInfo {
  name: string;
  version: string;
  dependencies?: string[];
}

/**
 * 依赖检查结果
 */
interface DependencyCheckResult {
  errors: string[];
  warnings: string[];
}

// 使用示例
const resolver = new PluginDependencyResolver();

// 添加插件
resolver.addPlugin({
  name: 'plugin-a',
  version: '1.0.0',
  dependencies: []
});

resolver.addPlugin({
  name: 'plugin-b',
  version: '1.0.0',
  dependencies: ['plugin-a']
});

resolver.addPlugin({
  name: 'plugin-c',
  version: '1.0.0',
  dependencies: ['plugin-a', 'plugin-b']
});

// 检查依赖
const checkResult = resolver.checkDependencies();
console.log('Dependency check:', checkResult);

// 解析依赖顺序
const order = resolver.resolve();
console.log('Load order:', order);
// ['plugin-a', 'plugin-b', 'plugin-c']

### 依赖注入

// src/dependencies/dependency-injection.ts
/**
* 插件依赖注入容器
*/
export class PluginDIContainer {
private services: Map<string, ServiceDefinition> = new Map();
private instances: Map<string, any> = new Map();
/**
* 注册服务
*/
registerService(name: string, definition: ServiceDefinition): void {
this.services.set(name, definition);
}
/**
* 解析服务
*/
resolve(name: string): any {
// 检查是否已实例化
if (this.instances.has(name)) {
return this.instances.get(name);
}
// 获取服务定义
const definition = this.services.get(name);
if (!definition) {
throw new Error(`Service not found: ${name}`);
}
// 解析依赖
const dependencies = (definition.dependencies || []).map(dep =>
this.resolve(dep)
);
// 创建实例
const instance = definition.factory(...dependencies);
// 如果是单例，缓存实例
if (definition.singleton) {
this.instances.set(name, instance);
}
return instance;
}
/**
* 清除实例
*/
clear(): void {
this.instances.clear();
}
}
/**
* 服务定义
*/
interface ServiceDefinition {
factory: (...args: any[]) => any;
dependencies?: string[];
singleton?: boolean;
}
// 使用示例
const container = new PluginDIContainer();
// 注册服务
container.registerService('logger', {
factory: () => ({
log: (message: string) => console.log(`[LOG] ${message}`)
}),
singleton: true
});
container.registerService('database', {
factory: (logger: any) => ({
query: (sql: string) => {
logger.log(`Executing query: ${sql}`);
return [];
}
}),
dependencies: ['logger'],
singleton: true
});
container.registerService('userService', {
factory: (database: any, logger: any) => ({
getUser: (id: number) => {
logger.log(`Getting user ${id}`);
return database.query(`SELECT * FROM users WHERE id = ${id}`);
}
}),
dependencies: ['database', 'logger'],
singleton: false
});
// 解析服务
const userService = container.resolve('userService');
const user = userService.getUser(1);
console.log('User:', user);
```

#### 22.3.3 插件生命周期协调#

##### 生命周期管理器#

```
bash复制typescript

// src/lifecycle/lifecycle-manager.ts

/**
 * 插件生命周期管理器
 */
export class PluginLifecycleManager {
  private plugins: Map<string, ManagedPlugin> = new Map();
  private state: LifecycleState = LifecycleState.IDLE;

  /**
   * 添加插件
   */
  addPlugin(plugin: ManagedPlugin): void {
    this.plugins.set(plugin.name, plugin);
  }

  /**
   * 移除插件
   */
  removePlugin(pluginName: string): void {
    this.plugins.delete(pluginName);
  }

  /**
   * 初始化所有插件
   */
  async initializeAll(): Promise<void> {
    this.state = LifecycleState.INITIALIZING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序
    const order = resolver.resolve();

    // 按顺序初始化
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.initialize();
      }
    }

    this.state = LifecycleState.INITIALIZED;
  }

  /**
   * 启动所有插件
   */
  async startAll(): Promise<void> {
    this.state = LifecycleState.STARTING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序
    const order = resolver.resolve();

    // 按顺序启动
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.start();
      }
    }

    this.state = LifecycleState.RUNNING;
  }

  /**
   * 停止所有插件
   */
  async stopAll(): Promise<void> {
    this.state = LifecycleState.STOPPING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序（反向）
    const order = resolver.resolve().reverse();

    // 按反向顺序停止
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.stop();
      }
    }

    this.state = LifecycleState.STOPPED;
  }

  /**
   * 清理所有插件
   */
  async cleanupAll(): Promise<void> {
    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序（反向）
    const order = resolver.resolve().reverse();

    // 按反向顺序清理
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.cleanup();
      }
    }

    this.state = LifecycleState.IDLE;
  }

  /**
   * 获取状态
   */
  getState(): LifecycleState {
    return this.state;
  }
}

/**
 * 管理的插件
 */
interface ManagedPlugin {
  name: string;
  version: string;
  dependencies?: string[];
  initialize: () => Promise<void>;
  start: () => Promise<void>;
  stop: () => Promise<void>;
  cleanup: () => Promise<void>;
}

/**
 * 生命周期状态
 */
enum LifecycleState {
  IDLE = 'IDLE',
  INITIALIZING = 'INITIALIZING',
  INITIALIZED = 'INITIALIZED',
  STARTING = 'STARTING',
  RUNNING = 'RUNNING',
  STOPPING = 'STOPPING',
  STOPPED = 'STOPPED'
}

// 使用示例
const manager = new PluginLifecycleManager();

// 添加插件
manager.addPlugin({
  name: 'plugin-a',
  version: '1.0.0',
  dependencies: [],
  initialize: async () => console.log('Plugin A initialized'),
  start: async () => console.log('Plugin A started'),
  stop: async () => console.log('Plugin A stopped'),
  cleanup: async () => console.log('Plugin A cleaned up')
});

manager.addPlugin({
  name: 'plugin-b',
  version: '1.0.0',
  dependencies: ['plugin-a'],
  initialize: async () => console.log('Plugin B initialized'),
  start: async () => console.log('Plugin B started'),
  stop: async () => console.log('Plugin B stopped'),
  cleanup: async () => console.log('Plugin B cleaned up')
});

manager.addPlugin({
  name: 'plugin-c',
  version: '1.0.0',
  dependencies: ['plugin-a', 'plugin-b'],
  initialize: async () => console.log('Plugin C initialized'),
  start: async () => console.log('Plugin C started'),
  stop: async () => console.log('Plugin C stopped'),
  cleanup: async () => console.log('Plugin C cleaned up')
});

// 初始化
await manager.initializeAll();

// 启动
await manager.startAll();

// 停止
await manager.stopAll();

// 清理
await manager.cleanupAll();

### 生命周期事件

// src/lifecycle/lifecycle-events.ts
/**
* 插件生命周期事件
*/
export class PluginLifecycleEvents {
private listeners: Map<string, LifecycleEventListener[]> = new Map();
/**
* 订阅事件
*/
subscribe(eventType: LifecycleEventType, listener: LifecycleEventListener): void {
if (!this.listeners.has(eventType)) {
this.listeners.set(eventType, []);
}
this.listeners.get(eventType)!.push(listener);
}
/**
* 取消订阅
*/
unsubscribe(eventType: LifecycleEventType, listener: LifecycleEventListener): void {
const listeners = this.listeners.get(eventType);
if (listeners) {
const index = listeners.indexOf(listener);
if (index > -1) {
listeners.splice(index, 1);
}
}
}
/**
* 触发事件
*/
async emit(event: LifecycleEvent): Promise<void> {
const listeners = this.listeners.get(event.type);
if (!listeners || listeners.length === 0) {
return;
}
const promises = listeners.map(listener =>
this.safeNotify(listener, event)
);
await Promise.all(promises);
}
/**
* 安全通知
*/
private async safeNotify(listener: LifecycleEventListener, event: LifecycleEvent): Promise<void> {
try {
await listener(event);
} catch (error) {
console.error(`Error in lifecycle event listener:`, error);
}
}
}
/**
* 生命周期事件类型
*/
enum LifecycleEventType {
BEFORE_INITIALIZE = 'BEFORE_INITIALIZE',
AFTER_INITIALIZE = 'AFTER_INITIALIZE',
BEFORE_START = 'BEFORE_START',
AFTER_START = 'AFTER_START',
BEFORE_STOP = 'BEFORE_STOP',
AFTER_STOP = 'AFTER_STOP',
BEFORE_CLEANUP = 'BEFORE_CLEANUP',
AFTER_CLEANUP = 'AFTER_CLEANUP'
}
/**
* 生命周期事件
*/
interface LifecycleEvent {
type: LifecycleEventType;
pluginName: string;
timestamp: Date;
}
/**
* 生命周期事件监听器
*/
type LifecycleEventListener = (event: LifecycleEvent) => Promise<void> | void;
// 使用示例
const events = new PluginLifecycleEvents();
// 订阅事件
events.subscribe(LifecycleEventType.BEFORE_START, async (event) => {
console.log(`Before starting plugin: ${event.pluginName}`);
});
events.subscribe(LifecycleEventType.AFTER_START, async (event) => {
console.log(`After starting plugin: ${event.pluginName}`);
});
// 触发事件
await events.emit({
type: LifecycleEventType.BEFORE_START,
pluginName: 'plugin-a',
timestamp: new Date()
});
await events.emit({
type: LifecycleEventType.AFTER_START,
pluginName: 'plugin-a',
timestamp: new Date()
});
```

```
typescript

// src/lifecycle/lifecycle-manager.ts

/**
 * 插件生命周期管理器
 */
export class PluginLifecycleManager {
  private plugins: Map<string, ManagedPlugin> = new Map();
  private state: LifecycleState = LifecycleState.IDLE;

  /**
   * 添加插件
   */
  addPlugin(plugin: ManagedPlugin): void {
    this.plugins.set(plugin.name, plugin);
  }

  /**
   * 移除插件
   */
  removePlugin(pluginName: string): void {
    this.plugins.delete(pluginName);
  }

  /**
   * 初始化所有插件
   */
  async initializeAll(): Promise<void> {
    this.state = LifecycleState.INITIALIZING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序
    const order = resolver.resolve();

    // 按顺序初始化
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.initialize();
      }
    }

    this.state = LifecycleState.INITIALIZED;
  }

  /**
   * 启动所有插件
   */
  async startAll(): Promise<void> {
    this.state = LifecycleState.STARTING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序
    const order = resolver.resolve();

    // 按顺序启动
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.start();
      }
    }

    this.state = LifecycleState.RUNNING;
  }

  /**
   * 停止所有插件
   */
  async stopAll(): Promise<void> {
    this.state = LifecycleState.STOPPING;

    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序（反向）
    const order = resolver.resolve().reverse();

    // 按反向顺序停止
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.stop();
      }
    }

    this.state = LifecycleState.STOPPED;
  }

  /**
   * 清理所有插件
   */
  async cleanupAll(): Promise<void> {
    const resolver = new PluginDependencyResolver();

    // 添加插件到解析器
    for (const plugin of this.plugins.values()) {
      resolver.addPlugin({
        name: plugin.name,
        version: plugin.version,
        dependencies: plugin.dependencies
      });
    }

    // 解析依赖顺序（反向）
    const order = resolver.resolve().reverse();

    // 按反向顺序清理
    for (const pluginName of order) {
      const plugin = this.plugins.get(pluginName);
      if (plugin) {
        await plugin.cleanup();
      }
    }

    this.state = LifecycleState.IDLE;
  }

  /**
   * 获取状态
   */
  getState(): LifecycleState {
    return this.state;
  }
}

/**
 * 管理的插件
 */
interface ManagedPlugin {
  name: string;
  version: string;
  dependencies?: string[];
  initialize: () => Promise<void>;
  start: () => Promise<void>;
  stop: () => Promise<void>;
  cleanup: () => Promise<void>;
}

/**
 * 生命周期状态
 */
enum LifecycleState {
  IDLE = 'IDLE',
  INITIALIZING = 'INITIALIZING',
  INITIALIZED = 'INITIALIZED',
  STARTING = 'STARTING',
  RUNNING = 'RUNNING',
  STOPPING = 'STOPPING',
  STOPPED = 'STOPPED'
}

// 使用示例
const manager = new PluginLifecycleManager();

// 添加插件
manager.addPlugin({
  name: 'plugin-a',
  version: '1.0.0',
  dependencies: [],
  initialize: async () => console.log('Plugin A initialized'),
  start: async () => console.log('Plugin A started'),
  stop: async () => console.log('Plugin A stopped'),
  cleanup: async () => console.log('Plugin A cleaned up')
});

manager.addPlugin({
  name: 'plugin-b',
  version: '1.0.0',
  dependencies: ['plugin-a'],
  initialize: async () => console.log('Plugin B initialized'),
  start: async () => console.log('Plugin B started'),
  stop: async () => console.log('Plugin B stopped'),
  cleanup: async () => console.log('Plugin B cleaned up')
});

manager.addPlugin({
  name: 'plugin-c',
  version: '1.0.0',
  dependencies: ['plugin-a', 'plugin-b'],
  initialize: async () => console.log('Plugin C initialized'),
  start: async () => console.log('Plugin C started'),
  stop: async () => console.log('Plugin C stopped'),
  cleanup: async () => console.log('Plugin C cleaned up')
});

// 初始化
await manager.initializeAll();

// 启动
await manager.startAll();

// 停止
await manager.stopAll();

// 清理
await manager.cleanupAll();

### 生命周期事件

// src/lifecycle/lifecycle-events.ts
/**
* 插件生命周期事件
*/
export class PluginLifecycleEvents {
private listeners: Map<string, LifecycleEventListener[]> = new Map();
/**
* 订阅事件
*/
subscribe(eventType: LifecycleEventType, listener: LifecycleEventListener): void {
if (!this.listeners.has(eventType)) {
this.listeners.set(eventType, []);
}
this.listeners.get(eventType)!.push(listener);
}
/**
* 取消订阅
*/
unsubscribe(eventType: LifecycleEventType, listener: LifecycleEventListener): void {
const listeners = this.listeners.get(eventType);
if (listeners) {
const index = listeners.indexOf(listener);
if (index > -1) {
listeners.splice(index, 1);
}
}
}
/**
* 触发事件
*/
async emit(event: LifecycleEvent): Promise<void> {
const listeners = this.listeners.get(event.type);
if (!listeners || listeners.length === 0) {
return;
}
const promises = listeners.map(listener =>
this.safeNotify(listener, event)
);
await Promise.all(promises);
}
/**
* 安全通知
*/
private async safeNotify(listener: LifecycleEventListener, event: LifecycleEvent): Promise<void> {
try {
await listener(event);
} catch (error) {
console.error(`Error in lifecycle event listener:`, error);
}
}
}
/**
* 生命周期事件类型
*/
enum LifecycleEventType {
BEFORE_INITIALIZE = 'BEFORE_INITIALIZE',
AFTER_INITIALIZE = 'AFTER_INITIALIZE',
BEFORE_START = 'BEFORE_START',
AFTER_START = 'AFTER_START',
BEFORE_STOP = 'BEFORE_STOP',
AFTER_STOP = 'AFTER_STOP',
BEFORE_CLEANUP = 'BEFORE_CLEANUP',
AFTER_CLEANUP = 'AFTER_CLEANUP'
}
/**
* 生命周期事件
*/
interface LifecycleEvent {
type: LifecycleEventType;
pluginName: string;
timestamp: Date;
}
/**
* 生命周期事件监听器
*/
type LifecycleEventListener = (event: LifecycleEvent) => Promise<void> | void;
// 使用示例
const events = new PluginLifecycleEvents();
// 订阅事件
events.subscribe(LifecycleEventType.BEFORE_START, async (event) => {
console.log(`Before starting plugin: ${event.pluginName}`);
});
events.subscribe(LifecycleEventType.AFTER_START, async (event) => {
console.log(`After starting plugin: ${event.pluginName}`);
});
// 触发事件
await events.emit({
type: LifecycleEventType.BEFORE_START,
pluginName: 'plugin-a',
timestamp: new Date()
});
await events.emit({
type: LifecycleEventType.AFTER_START,
pluginName: 'plugin-a',
timestamp: new Date()
});
```

---

## 5 插件发布与维护

**URL**: https://claudecode.tangshuang.net/course/22.5%20%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8E%E7%BB%B4%E6%8A%A4

#### 22.5.1 插件打包#

##### 基本打包配置#

// package.json
{
"name": "my-claude-plugin",
"version": "1.0.0",
"description": "My Claude Code Plugin",
"main": "dist/index.js",
"types": "dist/index.d.ts",
"files": [
"dist",
"plugin.yaml"
],
"scripts": {
"build": "tsc",
"prepack": "npm run build",
"pack": "npm pack",
"publish": "npm publish"
},
"keywords": [
"claude-code",
"plugin"
],
"author": "Your Name",
"license": "MIT",
"devDependencies": {
"@claude-code/plugin-sdk": "^1.0.0",
"typescript": "^4.9.0"
}
}

##### TypeScript 配置#

```
bash复制json

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}

### 插件清单

# plugin.yaml
name: my-claude-plugin
version: 1.0.0
description: My Claude Code Plugin
author: Your Name
license: MIT
homepage: https://github.com/yourname/my-claude-plugin
repository: https://github.com/yourname/my-claude-plugin
# 插件入口
main: dist/index.js
types: dist/index.d.ts
# 插件权限
permissions:
file:
- read: "/"
network:
- https: ["api.example.com"]
# 插件依赖
dependencies:
claude-code: ">=1.0.0"
# 插件元数据
metadata:
category: development
tags:
- code-generation
- productivity
keywords:
- plugin
- claude-code
```

```
json

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}

### 插件清单

# plugin.yaml
name: my-claude-plugin
version: 1.0.0
description: My Claude Code Plugin
author: Your Name
license: MIT
homepage: https://github.com/yourname/my-claude-plugin
repository: https://github.com/yourname/my-claude-plugin
# 插件入口
main: dist/index.js
types: dist/index.d.ts
# 插件权限
permissions:
file:
- read: "/"
network:
- https: ["api.example.com"]
# 插件依赖
dependencies:
claude-code: ">=1.0.0"
# 插件元数据
metadata:
category: development
tags:
- code-generation
- productivity
keywords:
- plugin
- claude-code
```

##### 打包脚本#

```
bash复制bash

#!/bin/bash
# scripts/build.sh

echo "Building plugin..."

# 清理构建目录
rm -rf dist

# 编译 TypeScript
npm run build

# 复制插件清单
cp plugin.yaml dist/

# 复制 README
cp README.md dist/

# 复制 LICENSE
cp LICENSE dist/ 2>/dev/null || true

echo "Build complete!"

#!/bin/bash
# scripts/pack.sh
echo "Packing plugin..."
# 构建
./scripts/build.sh
# 打包
cd dist
```

```
bash

#!/bin/bash
# scripts/build.sh

echo "Building plugin..."

# 清理构建目录
rm -rf dist

# 编译 TypeScript
npm run build

# 复制插件清单
cp plugin.yaml dist/

# 复制 README
cp README.md dist/

# 复制 LICENSE
cp LICENSE dist/ 2>/dev/null || true

echo "Build complete!"

#!/bin/bash
# scripts/pack.sh
echo "Packing plugin..."
# 构建
./scripts/build.sh
# 打包
cd dist
```

npm pack

### 移动包到项目根目录

mv *.tgz ../
echo "Pack complete!"

```
bash复制## 22.5.2 版本管理
### 语义化版本
```

```
## 22.5.2 版本管理
### 语义化版本
```

typescript

// src/version.ts

- 语义化版本
*/
export class SemanticVersion {
major: number;
minor: number;
patch: number;
prerelease?: string;
build?: string;

constructor(version: string) {
const parsed = this.parse(version);
this.major = parsed.major;
this.minor = parsed.minor;
this.patch = parsed.patch;
this.prerelease = parsed.prerelease;
this.build = parsed.build;
}

- 解析版本字符串
*/
private parse(version: string): {
major: number;
minor: number;
patch: number;
prerelease?: string;
build?: string;
} {
const regex = /^(\d+).(\d+).(\d+)(?:-([0-9A-Za-z-]+))?(?:+([0-9A-Za-z-]+))?$/;
const match = version.match(regex);

```
bash复制if (!match) {
```

```
if (!match) {
```

```
bash复制  throw new Error(`Invalid version: ${version}`);
}

return {
  major: parseInt(match[1]),
  minor: parseInt(match[2]),
  patch: parseInt(match[3]),
  prerelease: match[4],
  build: match[5]
};
```

```
throw new Error(`Invalid version: ${version}`);
}

return {
  major: parseInt(match[1]),
  minor: parseInt(match[2]),
  patch: parseInt(match[3]),
  prerelease: match[4],
  build: match[5]
};
```

- 转换为字符串
*/
toString(): string {
let version = ${this.major}.${this.minor}.${this.patch};

```
${this.major}.${this.minor}.${this.patch}
```

```
bash复制if (this.prerelease) {
```

```
if (this.prerelease) {
```

```
bash复制  version += `-${this.prerelease}`;
}

if (this.build) {
  version += `+${this.build}`;
}

return version;
```

```
version += `-${this.prerelease}`;
}

if (this.build) {
  version += `+${this.build}`;
}

return version;
```

- 主版本升级
*/
bumpMajor(): SemanticVersion {
return new SemanticVersion(
${this.major + 1}.0.0
);
}

```
${this.major + 1}.0.0
```

- 次版本升级
*/
bumpMinor(): SemanticVersion {
return new SemanticVersion(
${this.major}.${this.minor + 1}.0
);
}

```
${this.major}.${this.minor + 1}.0
```

- 补丁版本升级
*/
bumpPatch(): SemanticVersion {
return new SemanticVersion(
${this.major}.${this.minor}.${this.patch + 1}
);
}

```
${this.major}.${this.minor}.${this.patch + 1}
```

- 比较版本
*/
compare(other: SemanticVersion): number {
if (this.major !== other.major) {
return this.major - other.major;
}

```
bash复制if (this.minor !== other.minor) {
```

```
if (this.minor !== other.minor) {
```

```
bash复制  return this.minor - other.minor;
}

if (this.patch !== other.patch) {
  return this.patch - other.patch;
}

return 0;
```

```
return this.minor - other.minor;
}

if (this.patch !== other.patch) {
  return this.patch - other.patch;
}

return 0;
```

- 检查是否大于
*/
greaterThan(other: SemanticVersion): boolean {
return this.compare(other) > 0;
}

- 检查是否小于
*/
lessThan(other: SemanticVersion): boolean {
return this.compare(other) < 0;
}

- 检查是否等于
*/
equals(other: SemanticVersion): boolean {
return this.compare(other) === 0;
}
}

// 使用示例
const version = new SemanticVersion('1.2.3');
console.log(version.toString()); // 1.2.3

const nextMajor = version.bumpMajor();
console.log(nextMajor.toString()); // 2.0.0

const nextMinor = version.bumpMinor();
console.log(nextMinor.toString()); // 1.3.0

const nextPatch = version.bumpPatch();
console.log(nextPatch.toString()); // 1.2.4

const v1 = new SemanticVersion('1.2.3');
const v2 = new SemanticVersion('1.2.4');

console.log(v1.lessThan(v2)); // true
console.log(v2.greaterThan(v1)); // true

##### 版本发布脚本#

#!/bin/bash

### scripts/release.sh

VERSION=$1
if [ -z "$VERSION" ]; then
echo "Usage: ./scripts/release.sh <version>"
exit 1
fi
echo "Releasing version $VERSION..."

### 更新 package.json

npm version $VERSION --no-git-tag-version

### 更新 plugin.yaml

sed -i.bak "s/^version: .*/version: $VERSION/" plugin.yaml
rm plugin.yaml.bak

### 构建和打包

./scripts/pack.sh

### 提交更改

git add package.json plugin.yaml
git commit -m "Release version $VERSION"

### 创建标签

git tag -a "v$VERSION" -m "Release version $VERSION"

### 推送到远程

git push origin main
git push origin "v$VERSION"

### 发布到 npm

npm publish
echo "Release $VERSION complete!"

```
bash复制## 22.5.3 文档生成
### API 文档生成
```

```
## 22.5.3 文档生成
### API 文档生成
```

typescript

// scripts/generate-docs.ts

import { Project, TSConfigReader, TypeDocReader } from 'typedoc';
import { MarkdownRenderer } from 'typedoc-plugin-markdown';

- 生成 API 文档
/
async function generateDocs() {
const project = new Project({
tsconfig: 'tsconfig.json',
entryPoints: ['src/index.ts'],
readme: 'README.md',
out: 'docs/api',
plugin: [TypeDocReader, MarkdownRenderer],
exclude: ['**/.test.ts', '/node_modules/'],
theme: 'markdown',
gitRevision: 'main'
});

await project.generate();
}

generateDocs().catch(console.error);

##### README 模板#

### My Claude Code Plugin

My Claude Code Plugin is a powerful plugin for Claude Code that provides [brief description].

#### Features#

- Feature 1
- Feature 2
- Feature 3

#### Installation#

```
bash复制`bash

claude plugin install my-claude-plugin

```> Or install from npm:

```
bash

npm install -g my-claude-plugin

## Usage

### Basic Usage

````typescript
````typescript

import { MyPlugin } from 'my-claude-plugin';

const plugin = new MyPlugin();
await plugin.initialize({});
await plugin.start();

```### Advanced Usage

```
typescript

const plugin = new MyPlugin({
  option1: 'value1',
  option2: 'value2'
});

await plugin.initialize(config);
await plugin.start();

## Configuration

The plugin can be configured with the following options:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| option1 | string | 'default' | Description of option1 |
| option2 | number | 100 | Description of option2 |

## API

### Methods

#### `initialize(config: PluginConfig): Promise<void>`

Initializes the plugin with the given configuration.

#### `start(): Promise<void>`

Starts the plugin.

#### `stop(): Promise<void>`

Stops the plugin.

## Development

### Prerequisites

> - Node.js >= 14
> - npm >= 6

### Setup

````bash
````bash

# Clone the repository
git clone https://github.com/yourname/my-claude-plugin.git
cd my-claude-plugin

# Install dependencies
npm install

# Build the project
npm run build

```### Testing

```
bash

# Run tests
npm test

# Run tests with coverage
npm run test:coverage

### Building

````bash
````bash

# Build the project
npm run build

# Pack the project
npm run pack

```## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT © [Your Name]

## Support

For support, please open an issue on GitHub or contact [your-email@example.com].

```
## 22.5.4 持续集成

### GitHub Actions 配置

# .github/workflows/ci.yml
name: CI
on:
push:
branches: [ main, develop ]
pull_request:
branches: [ main, develop ]
jobs:
test:
runs-on: ubuntu-latest
strategy:
matrix:
node-version: [14.x, 16.x, 18.x]
steps:
- uses: actions/checkout@v2
- name: Use Node.js ${{ matrix.node-version }}
uses: actions/setup-node@v2
with:
node-version: ${{ matrix.node-version }}
cache: 'npm'
- name: Install dependencies
run: npm ci
- name: Run linter
run: npm run lint
- name: Run tests
run: npm test
- name: Generate coverage
run: npm run test:coverage
- name: Upload coverage
uses: codecov/codecov-action@v2
with:
files: ./coverage/lcov.info
build:
needs: test
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: Use Node.js
uses: actions/setup-node@v2
with:
node-version: '18.x'
cache: 'npm'
- name: Install dependencies
run: npm ci
- name: Build
run: npm run build
- name: Pack
run: npm run pack
- name: Upload artifact
uses: actions/upload-artifact@v2
with:
name: package
path: '*.tgz'

```
### 发布工作流
```
yaml

# .github/workflows/release.yml

name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Use Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '18.x'
        cache: 'npm'
        registry-url: 'https://registry.npmjs.org'

    - name: Install dependencies
      run: npm ci

    - name: Build
      run: npm run build

    - name: Run tests
      run: npm test

    - name: Publish to npm
      run: npm publish
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

## 22.5.5 错误监控

### 错误追踪集成

// src/monitoring/error-tracker.ts
/**
* 错误追踪器
*/
export class ErrorTracker {
private errors: ErrorReport[] = [];
private maxErrors: number = 100;
/**
* 追踪错误
*/
track(error: Error, context?: ErrorContext): void {
const report: ErrorReport = {
id: this.generateId(),
message: error.message,
stack: error.stack,
timestamp: new Date(),
context: context || {}
};
this.errors.push(report);
// 限制错误数量
if (this.errors.length > this.maxErrors) {
this.errors.shift();
}
// 发送到错误监控服务
this.sendToMonitoringService(report);
}
/**
* 生成 ID
*/
private generateId(): string {
return `error-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
/**
* 发送到监控服务
*/
private sendToMonitoringService(report: ErrorReport): void {
// 集成到 Sentry、Bugsnag 等
console.log('Sending error to monitoring service:', report.id);
}
/**
* 获取错误报告
*/
getReports(limit?: number): ErrorReport[] {
if (limit) {
return this.errors.slice(-limit);
}
return [...this.errors];
}
/**
* 清除错误报告
*/
clearReports(): void {
this.errors = [];
}
/**
* 获取错误统计
*/
getStats(): ErrorStats {
const stats: ErrorStats = {
total: this.errors.length,
byType: {},
byHour: {}
};
for (const error of this.errors) {
// 按类型统计
const type = error.context.type || 'unknown';
stats.byType[type] = (stats.byType[type] || 0) + 1;
// 按小时统计
const hour = error.timestamp.getHours();
stats.byHour[hour] = (stats.byHour[hour] || 0) + 1;
}
return stats;
}
}
/**
* 错误报告
*/
interface ErrorReport {
id: string;
message: string;
stack?: string;
timestamp: Date;
context: ErrorContext;
}
/**
* 错误上下文
*/
interface ErrorContext {
type?: string;
plugin?: string;
user?: string;
[key: string]: any;
}
/**
* 错误统计
*/
interface ErrorStats {
total: number;
byType: Record<string, number>;
byHour: Record<number, number>;
}
// 使用示例
const tracker = new ErrorTracker();
try {
// 可能出错的代码
throw new Error('Something went wrong');
} catch (error) {
tracker.track(error, {
type: 'runtime',
plugin: 'my-plugin',
user: 'user123'
});
}
// 获取错误报告
const reports = tracker.getReports(10);
console.log('Recent errors:', reports);
// 获取错误统计
const stats = tracker.getStats();
console.log('Error stats:', stats);

```
### 性能监控
```
typescript

// src/monitoring/performance-monitor.ts

/**
 * 性能监控器
 */
export class PerformanceMonitor {
  private metrics: Map<string, Metric[]> = new Map();
  private maxMetrics: number = 1000;

  /**
   * 记录指标
   */
  record(name: string, value: number, tags?: Record<string, string>): void {
    const metric: Metric = {
      name,
      value,
      timestamp: new Date(),
      tags: tags || {}
    };

    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push(metric);

    // 限制指标数量
    if (metrics.length > this.maxMetrics) {
      metrics.shift();
    }
  }

  /**
   * 测量函数执行时间
   */
  async measure<T>(name: string, fn: () => Promise<T>, tags?: Record<string, string>): Promise<T> {
    const start = Date.now();

    try {
      const result = await fn();
      const duration = Date.now() - start;

      this.record(name, duration, tags);

      return result;
    } catch (error) {
      const duration = Date.now() - start;

      this.record(`${name}.error`, duration, {
        ...tags,
        error: error.message
      });

      throw error;
    }
  }

  /**
   * 获取指标
   */
  getMetrics(name: string, limit?: number): Metric[] {
    const metrics = this.metrics.get(name);

    if (!metrics) {
      return [];
    }

    if (limit) {
      return metrics.slice(-limit);
    }

    return [...metrics];
  }

  /**
   * 获取指标统计
   */
  getStats(name: string): MetricStats | null {
    const metrics = this.metrics.get(name);

    if (!metrics || metrics.length === 0) {
      return null;
    }

    const values = metrics.map(m => m.value);
    const sum = values.reduce((a, b) => a + b, 0);
    const avg = sum / values.length;
    const min = Math.min(...values);
    const max = Math.max(...values);

    // 计算百分位数
    const sorted = [...values].sort((a, b) => a - b);
    const p50 = sorted[Math.floor(sorted.length * 0.5)];
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const p99 = sorted[Math.floor(sorted.length * 0.99)];

    return {
      count: metrics.length,
      sum,
      avg,
      min,
      max,
      p50,
      p95,
      p99
    };
  }

  /**
   * 清除指标
   */
  clearMetrics(name?: string): void {
    if (name) {
      this.metrics.delete(name);
    } else {
      this.metrics.clear();
    }
  }
}

/**
 * 指标
 */
interface Metric {
  name: string;
  value: number;
  timestamp: Date;
  tags: Record<string, string>;
}

/**
 * 指标统计
 */
interface MetricStats {
  count: number;
  sum: number;
  avg: number;
  min: number;
  max: number;
  p50: number;
  p95: number;
  p99: number;
}

// 使用示例
const monitor = new PerformanceMonitor();

// 记录指标
monitor.record('request.duration', 123, {
  method: 'GET',
  endpoint: '/api/users'
});

// 测量函数执行时间
const result = await monitor.measure('database.query', async () => {
  // 数据库查询
  return { id: 1, name: 'John' };
});

// 获取指标统计
const stats = monitor.getStats('request.duration');
console.log('Stats:', stats);

## 22.5.6 用户反馈

### 反馈收集

// src/feedback/feedback-collector.ts
/**
* 反馈收集器
*/
export class FeedbackCollector {
private feedbacks: Feedback[] = [];
/**
* 收集反馈
*/
collect(feedback: Omit<Feedback, 'id' | 'timestamp'>): string {
const newFeedback: Feedback = {
id: this.generateId(),
timestamp: new Date(),
...feedback
};
this.feedbacks.push(newFeedback);
// 发送到反馈服务
this.sendToFeedbackService(newFeedback);
return newFeedback.id;
}
/**
* 生成 ID
*/
private generateId(): string {
return `feedback-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
/**
* 发送到反馈服务
*/
private sendToFeedbackService(feedback: Feedback): void {
// 发送到反馈服务
console.log('Sending feedback:', feedback.id);
}
/**
* 获取反馈
*/
getFeedbacks(limit?: number): Feedback[] {
if (limit) {
return this.feedbacks.slice(-limit);
}
return [...this.feedbacks];
}
/**
* 获取反馈统计
*/
getStats(): FeedbackStats {
const stats: FeedbackStats = {
total: this.feedbacks.length,
byType: {},
byRating: {},
averageRating: 0
};
let totalRating = 0;
let ratingCount = 0;
for (const feedback of this.feedbacks) {
// 按类型统计
stats.byType[feedback.type] = (stats.byType[feedback.type] || 0) + 1;
// 按评分统计
if (feedback.rating) {
stats.byRating[feedback.rating] = (stats.byRating[feedback.rating] || 0) + 1;
totalRating += feedback.rating;
ratingCount++;
}
}
// 计算平均评分
if (ratingCount > 0) {
stats.averageRating = totalRating / ratingCount;
}
return stats;
}
}
/**
* 反馈
*/
interface Feedback {
id: string;
type: 'bug' | 'feature' | 'improvement' | 'other';
rating?: number;
title: string;
description: string;
user?: string;
timestamp: Date;
}
/**
* 反馈统计
*/
interface FeedbackStats {
total: number;
byType: Record<string, number>;
byRating: Record<number, number>;
averageRating: number;
}
// 使用示例
const collector = new FeedbackCollector();
// 收集反馈
const feedbackId = collector.collect({
type: 'feature',
rating: 5,
title: 'Add new feature',
description: 'Please add this feature',
user: 'user123'
});
console.log('Feedback ID:', feedbackId);
// 获取反馈统计
const stats = collector.getStats();
console.log('Feedback stats:', stats);

```
### 用户调查
```
typescript

// src/feedback/survey.ts

/**
 * 用户调查
 */
export class UserSurvey {
  private questions: SurveyQuestion[] = [];
  private responses: SurveyResponse[] = [];

  /**
   * 添加问题
   */
  addQuestion(question: SurveyQuestion): void {
    this.questions.push(question);
  }

  /**
   * 提交响应
   */
  submitResponse(response: Omit<SurveyResponse, 'id' | 'timestamp'>): string {
    const newResponse: SurveyResponse = {
      id: this.generateId(),
      timestamp: new Date(),
      ...response
    };

    this.responses.push(newResponse);

    // 发送到调查服务
    this.sendToSurveyService(newResponse);

    return newResponse.id;
  }

  /**
   * 生成 ID
   */
  private generateId(): string {
    return `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 发送到调查服务
   */
  private sendToSurveyService(response: SurveyResponse): void {
    // 发送到调查服务
    console.log('Sending survey response:', response.id);
  }

  /**
   * 获取响应
   */
  getResponses(limit?: number): SurveyResponse[] {
    if (limit) {
      return this.responses.slice(-limit);
    }
    return [...this.responses];
  }

  /**
   * 分析响应
   */
  analyzeResponses(): SurveyAnalysis {
    const analysis: SurveyAnalysis = {
      totalResponses: this.responses.length,
      averageRating: 0,
      byQuestion: {}
    };

    let totalRating = 0;
    let ratingCount = 0;

    for (const question of this.questions) {
      const questionResponses = this.responses.filter(
        r => r.answers[question.id] !== undefined
      );

      if (question.type === 'rating') {
        const ratings = questionResponses.map(
          r => r.answers[question.id] as number
        );

        const sum = ratings.reduce((a, b) => a + b, 0);
        const avg = ratings.length > 0 ? sum / ratings.length : 0;

        analysis.byQuestion[question.id] = {
          count: ratings.length,
          average: avg,
          min: Math.min(...ratings),
          max: Math.max(...ratings)
        };

        totalRating += sum;
        ratingCount += ratings.length;
      }
    }

    // 计算平均评分
    if (ratingCount > 0) {
      analysis.averageRating = totalRating / ratingCount;
    }

    return analysis;
  }
}

/**
 * 调查问题
 */
interface SurveyQuestion {
  id: string;
  type: 'text' | 'rating' | 'choice' | 'multiple';
  question: string;
  options?: string[];
  required: boolean;
}

/**
 * 调查响应
 */
interface SurveyResponse {
  id: string;
  userId?: string;
  answers: Record<string, any>;
  timestamp: Date;
}

/**
 * 调查分析
 */
interface SurveyAnalysis {
  totalResponses: number;
  averageRating: number;
  byQuestion: Record<string, any>;
}

// 使用示例
const survey = new UserSurvey();

// 添加问题
survey.addQuestion({
  id: 'q1',
  type: 'rating',
  question: 'How satisfied are you with the plugin?',
  required: true
});

survey.addQuestion({
  id: 'q2',
  type: 'text',
  question: 'What do you like most about the plugin?',
  required: false
});

survey.addQuestion({
  id: 'q3',
  type: 'choice',
  question: 'How often do you use the plugin?',
  options: ['Daily', 'Weekly', 'Monthly', 'Rarely'],
  required: true
});

// 提交响应
const responseId = survey.submitResponse({
  userId: 'user123',
  answers: {
    q1: 5,
    q2: 'Easy to use and powerful',
    q3: 'Daily'
  }
});

console.log('Response ID:', responseId);

// 分析响应
const analysis = survey.analyzeResponses();
console.log('Survey analysis:', analysis);

```
```
```

```
`bash

claude plugin install my-claude-plugin

```> Or install from npm:

```
bash

npm install -g my-claude-plugin

## Usage

### Basic Usage

````typescript
````typescript

import { MyPlugin } from 'my-claude-plugin';

const plugin = new MyPlugin();
await plugin.initialize({});
await plugin.start();

```### Advanced Usage

```
typescript

const plugin = new MyPlugin({
  option1: 'value1',
  option2: 'value2'
});

await plugin.initialize(config);
await plugin.start();

## Configuration

The plugin can be configured with the following options:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| option1 | string | 'default' | Description of option1 |
| option2 | number | 100 | Description of option2 |

## API

### Methods

#### `initialize(config: PluginConfig): Promise<void>`

Initializes the plugin with the given configuration.

#### `start(): Promise<void>`

Starts the plugin.

#### `stop(): Promise<void>`

Stops the plugin.

## Development

### Prerequisites

> - Node.js >= 14
> - npm >= 6

### Setup

````bash
````bash

# Clone the repository
git clone https://github.com/yourname/my-claude-plugin.git
cd my-claude-plugin

# Install dependencies
npm install

# Build the project
npm run build

```### Testing

```
bash

# Run tests
npm test

# Run tests with coverage
npm run test:coverage

### Building

````bash
````bash

# Build the project
npm run build

# Pack the project
npm run pack

```## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT © [Your Name]

## Support

For support, please open an issue on GitHub or contact [your-email@example.com].

```
## 22.5.4 持续集成

### GitHub Actions 配置

# .github/workflows/ci.yml
name: CI
on:
push:
branches: [ main, develop ]
pull_request:
branches: [ main, develop ]
jobs:
test:
runs-on: ubuntu-latest
strategy:
matrix:
node-version: [14.x, 16.x, 18.x]
steps:
- uses: actions/checkout@v2
- name: Use Node.js ${{ matrix.node-version }}
uses: actions/setup-node@v2
with:
node-version: ${{ matrix.node-version }}
cache: 'npm'
- name: Install dependencies
run: npm ci
- name: Run linter
run: npm run lint
- name: Run tests
run: npm test
- name: Generate coverage
run: npm run test:coverage
- name: Upload coverage
uses: codecov/codecov-action@v2
with:
files: ./coverage/lcov.info
build:
needs: test
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: Use Node.js
uses: actions/setup-node@v2
with:
node-version: '18.x'
cache: 'npm'
- name: Install dependencies
run: npm ci
- name: Build
run: npm run build
- name: Pack
run: npm run pack
- name: Upload artifact
uses: actions/upload-artifact@v2
with:
name: package
path: '*.tgz'

```
### 发布工作流
```
yaml

# .github/workflows/release.yml

name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Use Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '18.x'
        cache: 'npm'
        registry-url: 'https://registry.npmjs.org'

    - name: Install dependencies
      run: npm ci

    - name: Build
      run: npm run build

    - name: Run tests
      run: npm test

    - name: Publish to npm
      run: npm publish
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

## 22.5.5 错误监控

### 错误追踪集成

// src/monitoring/error-tracker.ts
/**
* 错误追踪器
*/
export class ErrorTracker {
private errors: ErrorReport[] = [];
private maxErrors: number = 100;
/**
* 追踪错误
*/
track(error: Error, context?: ErrorContext): void {
const report: ErrorReport = {
id: this.generateId(),
message: error.message,
stack: error.stack,
timestamp: new Date(),
context: context || {}
};
this.errors.push(report);
// 限制错误数量
if (this.errors.length > this.maxErrors) {
this.errors.shift();
}
// 发送到错误监控服务
this.sendToMonitoringService(report);
}
/**
* 生成 ID
*/
private generateId(): string {
return `error-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
/**
* 发送到监控服务
*/
private sendToMonitoringService(report: ErrorReport): void {
// 集成到 Sentry、Bugsnag 等
console.log('Sending error to monitoring service:', report.id);
}
/**
* 获取错误报告
*/
getReports(limit?: number): ErrorReport[] {
if (limit) {
return this.errors.slice(-limit);
}
return [...this.errors];
}
/**
* 清除错误报告
*/
clearReports(): void {
this.errors = [];
}
/**
* 获取错误统计
*/
getStats(): ErrorStats {
const stats: ErrorStats = {
total: this.errors.length,
byType: {},
byHour: {}
};
for (const error of this.errors) {
// 按类型统计
const type = error.context.type || 'unknown';
stats.byType[type] = (stats.byType[type] || 0) + 1;
// 按小时统计
const hour = error.timestamp.getHours();
stats.byHour[hour] = (stats.byHour[hour] || 0) + 1;
}
return stats;
}
}
/**
* 错误报告
*/
interface ErrorReport {
id: string;
message: string;
stack?: string;
timestamp: Date;
context: ErrorContext;
}
/**
* 错误上下文
*/
interface ErrorContext {
type?: string;
plugin?: string;
user?: string;
[key: string]: any;
}
/**
* 错误统计
*/
interface ErrorStats {
total: number;
byType: Record<string, number>;
byHour: Record<number, number>;
}
// 使用示例
const tracker = new ErrorTracker();
try {
// 可能出错的代码
throw new Error('Something went wrong');
} catch (error) {
tracker.track(error, {
type: 'runtime',
plugin: 'my-plugin',
user: 'user123'
});
}
// 获取错误报告
const reports = tracker.getReports(10);
console.log('Recent errors:', reports);
// 获取错误统计
const stats = tracker.getStats();
console.log('Error stats:', stats);

```
### 性能监控
```
typescript

// src/monitoring/performance-monitor.ts

/**
 * 性能监控器
 */
export class PerformanceMonitor {
  private metrics: Map<string, Metric[]> = new Map();
  private maxMetrics: number = 1000;

  /**
   * 记录指标
   */
  record(name: string, value: number, tags?: Record<string, string>): void {
    const metric: Metric = {
      name,
      value,
      timestamp: new Date(),
      tags: tags || {}
    };

    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push(metric);

    // 限制指标数量
    if (metrics.length > this.maxMetrics) {
      metrics.shift();
    }
  }

  /**
   * 测量函数执行时间
   */
  async measure<T>(name: string, fn: () => Promise<T>, tags?: Record<string, string>): Promise<T> {
    const start = Date.now();

    try {
      const result = await fn();
      const duration = Date.now() - start;

      this.record(name, duration, tags);

      return result;
    } catch (error) {
      const duration = Date.now() - start;

      this.record(`${name}.error`, duration, {
        ...tags,
        error: error.message
      });

      throw error;
    }
  }

  /**
   * 获取指标
   */
  getMetrics(name: string, limit?: number): Metric[] {
    const metrics = this.metrics.get(name);

    if (!metrics) {
      return [];
    }

    if (limit) {
      return metrics.slice(-limit);
    }

    return [...metrics];
  }

  /**
   * 获取指标统计
   */
  getStats(name: string): MetricStats | null {
    const metrics = this.metrics.get(name);

    if (!metrics || metrics.length === 0) {
      return null;
    }

    const values = metrics.map(m => m.value);
    const sum = values.reduce((a, b) => a + b, 0);
    const avg = sum / values.length;
    const min = Math.min(...values);
    const max = Math.max(...values);

    // 计算百分位数
    const sorted = [...values].sort((a, b) => a - b);
    const p50 = sorted[Math.floor(sorted.length * 0.5)];
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const p99 = sorted[Math.floor(sorted.length * 0.99)];

    return {
      count: metrics.length,
      sum,
      avg,
      min,
      max,
      p50,
      p95,
      p99
    };
  }

  /**
   * 清除指标
   */
  clearMetrics(name?: string): void {
    if (name) {
      this.metrics.delete(name);
    } else {
      this.metrics.clear();
    }
  }
}

/**
 * 指标
 */
interface Metric {
  name: string;
  value: number;
  timestamp: Date;
  tags: Record<string, string>;
}

/**
 * 指标统计
 */
interface MetricStats {
  count: number;
  sum: number;
  avg: number;
  min: number;
  max: number;
  p50: number;
  p95: number;
  p99: number;
}

// 使用示例
const monitor = new PerformanceMonitor();

// 记录指标
monitor.record('request.duration', 123, {
  method: 'GET',
  endpoint: '/api/users'
});

// 测量函数执行时间
const result = await monitor.measure('database.query', async () => {
  // 数据库查询
  return { id: 1, name: 'John' };
});

// 获取指标统计
const stats = monitor.getStats('request.duration');
console.log('Stats:', stats);

## 22.5.6 用户反馈

### 反馈收集

// src/feedback/feedback-collector.ts
/**
* 反馈收集器
*/
export class FeedbackCollector {
private feedbacks: Feedback[] = [];
/**
* 收集反馈
*/
collect(feedback: Omit<Feedback, 'id' | 'timestamp'>): string {
const newFeedback: Feedback = {
id: this.generateId(),
timestamp: new Date(),
...feedback
};
this.feedbacks.push(newFeedback);
// 发送到反馈服务
this.sendToFeedbackService(newFeedback);
return newFeedback.id;
}
/**
* 生成 ID
*/
private generateId(): string {
return `feedback-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
/**
* 发送到反馈服务
*/
private sendToFeedbackService(feedback: Feedback): void {
// 发送到反馈服务
console.log('Sending feedback:', feedback.id);
}
/**
* 获取反馈
*/
getFeedbacks(limit?: number): Feedback[] {
if (limit) {
return this.feedbacks.slice(-limit);
}
return [...this.feedbacks];
}
/**
* 获取反馈统计
*/
getStats(): FeedbackStats {
const stats: FeedbackStats = {
total: this.feedbacks.length,
byType: {},
byRating: {},
averageRating: 0
};
let totalRating = 0;
let ratingCount = 0;
for (const feedback of this.feedbacks) {
// 按类型统计
stats.byType[feedback.type] = (stats.byType[feedback.type] || 0) + 1;
// 按评分统计
if (feedback.rating) {
stats.byRating[feedback.rating] = (stats.byRating[feedback.rating] || 0) + 1;
totalRating += feedback.rating;
ratingCount++;
}
}
// 计算平均评分
if (ratingCount > 0) {
stats.averageRating = totalRating / ratingCount;
}
return stats;
}
}
/**
* 反馈
*/
interface Feedback {
id: string;
type: 'bug' | 'feature' | 'improvement' | 'other';
rating?: number;
title: string;
description: string;
user?: string;
timestamp: Date;
}
/**
* 反馈统计
*/
interface FeedbackStats {
total: number;
byType: Record<string, number>;
byRating: Record<number, number>;
averageRating: number;
}
// 使用示例
const collector = new FeedbackCollector();
// 收集反馈
const feedbackId = collector.collect({
type: 'feature',
rating: 5,
title: 'Add new feature',
description: 'Please add this feature',
user: 'user123'
});
console.log('Feedback ID:', feedbackId);
// 获取反馈统计
const stats = collector.getStats();
console.log('Feedback stats:', stats);

```
### 用户调查
```
typescript

// src/feedback/survey.ts

/**
 * 用户调查
 */
export class UserSurvey {
  private questions: SurveyQuestion[] = [];
  private responses: SurveyResponse[] = [];

  /**
   * 添加问题
   */
  addQuestion(question: SurveyQuestion): void {
    this.questions.push(question);
  }

  /**
   * 提交响应
   */
  submitResponse(response: Omit<SurveyResponse, 'id' | 'timestamp'>): string {
    const newResponse: SurveyResponse = {
      id: this.generateId(),
      timestamp: new Date(),
      ...response
    };

    this.responses.push(newResponse);

    // 发送到调查服务
    this.sendToSurveyService(newResponse);

    return newResponse.id;
  }

  /**
   * 生成 ID
   */
  private generateId(): string {
    return `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 发送到调查服务
   */
  private sendToSurveyService(response: SurveyResponse): void {
    // 发送到调查服务
    console.log('Sending survey response:', response.id);
  }

  /**
   * 获取响应
   */
  getResponses(limit?: number): SurveyResponse[] {
    if (limit) {
      return this.responses.slice(-limit);
    }
    return [...this.responses];
  }

  /**
   * 分析响应
   */
  analyzeResponses(): SurveyAnalysis {
    const analysis: SurveyAnalysis = {
      totalResponses: this.responses.length,
      averageRating: 0,
      byQuestion: {}
    };

    let totalRating = 0;
    let ratingCount = 0;

    for (const question of this.questions) {
      const questionResponses = this.responses.filter(
        r => r.answers[question.id] !== undefined
      );

      if (question.type === 'rating') {
        const ratings = questionResponses.map(
          r => r.answers[question.id] as number
        );

        const sum = ratings.reduce((a, b) => a + b, 0);
        const avg = ratings.length > 0 ? sum / ratings.length : 0;

        analysis.byQuestion[question.id] = {
          count: ratings.length,
          average: avg,
          min: Math.min(...ratings),
          max: Math.max(...ratings)
        };

        totalRating += sum;
        ratingCount += ratings.length;
      }
    }

    // 计算平均评分
    if (ratingCount > 0) {
      analysis.averageRating = totalRating / ratingCount;
    }

    return analysis;
  }
}

/**
 * 调查问题
 */
interface SurveyQuestion {
  id: string;
  type: 'text' | 'rating' | 'choice' | 'multiple';
  question: string;
  options?: string[];
  required: boolean;
}

/**
 * 调查响应
 */
interface SurveyResponse {
  id: string;
  userId?: string;
  answers: Record<string, any>;
  timestamp: Date;
}

/**
 * 调查分析
 */
interface SurveyAnalysis {
  totalResponses: number;
  averageRating: number;
  byQuestion: Record<string, any>;
}

// 使用示例
const survey = new UserSurvey();

// 添加问题
survey.addQuestion({
  id: 'q1',
  type: 'rating',
  question: 'How satisfied are you with the plugin?',
  required: true
});

survey.addQuestion({
  id: 'q2',
  type: 'text',
  question: 'What do you like most about the plugin?',
  required: false
});

survey.addQuestion({
  id: 'q3',
  type: 'choice',
  question: 'How often do you use the plugin?',
  options: ['Daily', 'Weekly', 'Monthly', 'Rarely'],
  required: true
});

// 提交响应
const responseId = survey.submitResponse({
  userId: 'user123',
  answers: {
    q1: 5,
    q2: 'Easy to use and powerful',
    q3: 'Daily'
  }
});

console.log('Response ID:', responseId);

// 分析响应
const analysis = survey.analyzeResponses();
console.log('Survey analysis:', analysis);

```
```
```

---

## 6 插件通信与协作

**URL**: https://claudecode.tangshuang.net/course/22.6%20%E6%8F%92%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%8D%8F%E4%BD%9C

#### 概述#

在复杂的插件系统中，插件之间的通信与协作是实现高级功能的关键。本章节将详细介绍 Claude Code 插件系统中的各种通信机制、协作模式和最佳实践。

#### 插件通信机制#

##### 1. 事件总线 (Event Bus)#

事件总线是插件间通信的核心机制，基于发布-订阅模式：

```
typescript复制/**
 * 事件总线接口
 */
export interface IEventBus {
  /**
   * 发布事件
   * @param event 事件名称
   * @param data 事件数据
   */
  publish(event: string, data?: any): Promise<void>;

  /**
   * 订阅事件
   * @param event 事件名称
   * @param handler 事件处理函数
   */
  subscribe(event: string, handler: EventHandler): Subscription;

  /**
   * 取消订阅
   * @param subscription 订阅对象
   */
  unsubscribe(subscription: Subscription): void;

  /**
```

```
/**
 * 事件总线接口
 */
export interface IEventBus {
  /**
   * 发布事件
   * @param event 事件名称
   * @param data 事件数据
   */
  publish(event: string, data?: any): Promise<void>;

  /**
   * 订阅事件
   * @param event 事件名称
   * @param handler 事件处理函数
   */
  subscribe(event: string, handler: EventHandler): Subscription;

  /**
   * 取消订阅
   * @param subscription 订阅对象
   */
  unsubscribe(subscription: Subscription): void;

  /**
```

- 订阅一次性事件
- @param event 事件名称
- @param handler 事件处理函数
*/
once(event: string, handler: EventHandler): Subscription;
}

```
bash复制
### 使用示例

```typescript
// 插件A发布事件
context.eventBus.publish('user.created', { id: '123', name: 'John' });

// 插件B订阅事件
const subscription = context.eventBus.subscribe('user.created', (data) => {
  console.log('User created:', data);
});

// 取消订阅
subscription.unsubscribe();
```

```
### 使用示例

```typescript
// 插件A发布事件
context.eventBus.publish('user.created', { id: '123', name: 'John' });

// 插件B订阅事件
const subscription = context.eventBus.subscribe('user.created', (data) => {
  console.log('User created:', data);
});

// 取消订阅
subscription.unsubscribe();
```

##### 2. 消息队列 (Message Queue)#

消息队列用于异步通信和任务调度：

```
typescript复制/**
 * 消息队列接口
 */
export interface IMessageQueue {
  /**
   * 发送消息
   * @param queue 队列名称
   * @param message 消息内容
   */
  send(queue: string, message: Message): Promise<MessageId>;

  /**
   * 接收消息
   * @param queue 队列名称
   * @param handler 消息处理函数
   */
  receive(queue: string, handler: MessageHandler): void;

  /**
   * 发送延迟消息
   * @param queue 队列名称
   * @param message 消息内容
   * @param delay 延迟时间（毫秒）
   */
  sendDelayed(queue: string, message: Message, delay: number): Promise<MessageId>;

  /**
   * 发送重试消息
   * @param queue 队列名称
   * @param message 消息内容
   * @param retryOptions 重试选项
   */
  sendWithRetry(queue: string, message: Message, retryOptions: RetryOptions): Promise<MessageId>;
}
```

```
/**
 * 消息队列接口
 */
export interface IMessageQueue {
  /**
   * 发送消息
   * @param queue 队列名称
   * @param message 消息内容
   */
  send(queue: string, message: Message): Promise<MessageId>;

  /**
   * 接收消息
   * @param queue 队列名称
   * @param handler 消息处理函数
   */
  receive(queue: string, handler: MessageHandler): void;

  /**
   * 发送延迟消息
   * @param queue 队列名称
   * @param message 消息内容
   * @param delay 延迟时间（毫秒）
   */
  sendDelayed(queue: string, message: Message, delay: number): Promise<MessageId>;

  /**
   * 发送重试消息
   * @param queue 队列名称
   * @param message 消息内容
   * @param retryOptions 重试选项
   */
  sendWithRetry(queue: string, message: Message, retryOptions: RetryOptions): Promise<MessageId>;
}
```

##### 使用示例#

```
typescript复制// 发送任务到队列
const messageId = await context.messageQueue.send('email.tasks', {
  to: 'user@example.com',
  subject: 'Welcome',
  body: 'Hello from Claude Code'
});

// 处理队列消息
context.messageQueue.receive('email.tasks', async (message) => {
  try {
    await sendEmail(message.data);
    return MessageStatus.SUCCESS;
  } catch (error) {
    return MessageStatus.FAILED;
  }
});
```

```
// 发送任务到队列
const messageId = await context.messageQueue.send('email.tasks', {
  to: 'user@example.com',
  subject: 'Welcome',
  body: 'Hello from Claude Code'
});

// 处理队列消息
context.messageQueue.receive('email.tasks', async (message) => {
  try {
    await sendEmail(message.data);
    return MessageStatus.SUCCESS;
  } catch (error) {
    return MessageStatus.FAILED;
  }
});
```

##### 3. RPC 调用 (Remote Procedure Call)#

RPC 允许插件直接调用其他插件的方法：

```
typescript复制/**
 * RPC 客户端接口
 */
export interface IRPCClient {
  /**
   * 调用远程方法
   * @param service 服务名称
   * @param method 方法名称
   * @param parameters 方法参数
   */
  call(service: string, method: string, parameters?: any[]): Promise<any>;

  /**
   * 调用远程方法（带超时）
   * @param service 服务名称
   * @param method 方法名称
   * @param parameters 方法参数
   * @param timeout 超时时间（毫秒）
   */
  callWithTimeout(service: string, method: string, parameters?: any[], timeout?: number): Promise<any>;

  /**
   * 订阅服务
   * @param service 服务名称
   * @param callback 服务状态变化回调
   */
  subscribeService(service: string, callback: ServiceStatusCallback): void;
}
```

```
/**
 * RPC 客户端接口
 */
export interface IRPCClient {
  /**
   * 调用远程方法
   * @param service 服务名称
   * @param method 方法名称
   * @param parameters 方法参数
   */
  call(service: string, method: string, parameters?: any[]): Promise<any>;

  /**
   * 调用远程方法（带超时）
   * @param service 服务名称
   * @param method 方法名称
   * @param parameters 方法参数
   * @param timeout 超时时间（毫秒）
   */
  callWithTimeout(service: string, method: string, parameters?: any[], timeout?: number): Promise<any>;

  /**
   * 订阅服务
   * @param service 服务名称
   * @param callback 服务状态变化回调
   */
  subscribeService(service: string, callback: ServiceStatusCallback): void;
}
```

##### 使用示例#

```
typescript复制// 插件A提供服务
context.rpcServer.register('calculator', {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b
});

// 插件B调用服务
const result = await context.rpcClient.call('calculator', 'add', [2, 3]);
console.log('Result:', result); // 输出: 5
```

```
// 插件A提供服务
context.rpcServer.register('calculator', {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b
});

// 插件B调用服务
const result = await context.rpcClient.call('calculator', 'add', [2, 3]);
console.log('Result:', result); // 输出: 5
```

#### 插件协作模式#

##### 1. 插件依赖管理#

插件可以声明对其他插件的依赖：

```
typescript复制// package.json
{
  "name": "my-plugin",
  "version": "1.0.0",
  "dependencies": {
    "auth-plugin": "^1.0.0",
    "storage-plugin": "^2.0.0"
  }
}
```

```
// package.json
{
  "name": "my-plugin",
  "version": "1.0.0",
  "dependencies": {
    "auth-plugin": "^1.0.0",
    "storage-plugin": "^2.0.0"
  }
}
```

##### 2. 服务发现与注册#

插件可以注册服务供其他插件发现和使用：

```
typescript复制// 注册服务
context.serviceRegistry.register('payment-service', {
  name: 'Stripe Payment',
  version: '1.0.0',
  endpoint: 'stripe-payment',
  metadata: { supportedCurrencies: ['USD', 'EUR', 'CNY'] }
});

// 发现服务
const services = await context.serviceRegistry.discover('payment-service');
const stripeService = services.find(s => s.metadata.supportedCurrencies.includes('USD'));
```

```
// 注册服务
context.serviceRegistry.register('payment-service', {
  name: 'Stripe Payment',
  version: '1.0.0',
  endpoint: 'stripe-payment',
  metadata: { supportedCurrencies: ['USD', 'EUR', 'CNY'] }
});

// 发现服务
const services = await context.serviceRegistry.discover('payment-service');
const stripeService = services.find(s => s.metadata.supportedCurrencies.includes('USD'));
```

##### 3. 插件链 (Plugin Chain)#

插件可以形成链式处理流程：

```
typescript复制// 插件A处理请求
context.eventBus.subscribe('request.received', async (data, next) => {
  data.userId = '123';
  await next(); // 传递给下一个插件
});

// 插件B处理请求
context.eventBus.subscribe('request.received', async (data, next) => {
  data.timestamp = Date.now();
  await next(); // 传递给下一个插件
});

// 执行插件链
const result = await context.pluginChain.execute('request.received', { url: '/api/users' });
```

```
// 插件A处理请求
context.eventBus.subscribe('request.received', async (data, next) => {
  data.userId = '123';
  await next(); // 传递给下一个插件
});

// 插件B处理请求
context.eventBus.subscribe('request.received', async (data, next) => {
  data.timestamp = Date.now();
  await next(); // 传递给下一个插件
});

// 执行插件链
const result = await context.pluginChain.execute('request.received', { url: '/api/users' });
```

#### 数据共享与同步#

##### 1. 分布式缓存#

插件可以使用分布式缓存共享数据：

```
typescript复制// 设置缓存
await context.cache.set('user:123', { id: '123', name: 'John' }, { ttl: 3600 });

// 获取缓存
const user = await context.cache.get('user:123');

// 删除缓存
await context.cache.delete('user:123');

// 批量操作
await context.cache.multi()
  .set('user:123', user1)
  .set('user:456', user2)
  .expire('user:123', 3600)
  .exec();
```

```
// 设置缓存
await context.cache.set('user:123', { id: '123', name: 'John' }, { ttl: 3600 });

// 获取缓存
const user = await context.cache.get('user:123');

// 删除缓存
await context.cache.delete('user:123');

// 批量操作
await context.cache.multi()
  .set('user:123', user1)
  .set('user:456', user2)
  .expire('user:123', 3600)
  .exec();
```

##### 2. 分布式锁#

插件可以使用分布式锁确保数据一致性：

```
typescript复制// 获取锁
const lock = await context.lock.acquire('resource:lock', { ttl: 30000 });

try {
  // 执行临界区操作
  await updateResource();
} finally {
  // 释放锁
  await lock.release();
}
```

```
// 获取锁
const lock = await context.lock.acquire('resource:lock', { ttl: 30000 });

try {
  // 执行临界区操作
  await updateResource();
} finally {
  // 释放锁
  await lock.release();
}
```

##### 3. 数据同步#

插件可以使用数据同步机制保持数据一致性：

```
typescript复制// 监听数据变化
context.dataSync.watch('users', async (change) => {
  if (change.type === 'create') {
    await sendWelcomeEmail(change.data);
  } else if (change.type === 'update') {
    await updateUserCache(change.data);
  }
});

// 同步数据
await context.dataSync.sync('users', {
  from: '2024-01-01',
  to: '2024-01-31'
});
```

```
// 监听数据变化
context.dataSync.watch('users', async (change) => {
  if (change.type === 'create') {
    await sendWelcomeEmail(change.data);
  } else if (change.type === 'update') {
    await updateUserCache(change.data);
  }
});

// 同步数据
await context.dataSync.sync('users', {
  from: '2024-01-01',
  to: '2024-01-31'
});
```

#### 事务处理#

##### 1. 分布式事务#

插件可以参与分布式事务：

```
typescript复制// 开始事务
const transaction = await context.transactionManager.begin();

try {
  // 执行多个操作
  await pluginA.createUser(transaction, userData);
  await pluginB.createOrder(transaction, orderData);
  await pluginC.sendNotification(transaction, notificationData);

  // 提交事务
  await transaction.commit();
} catch (error) {
  // 回滚事务
  await transaction.rollback();
  throw error;
}
```

```
// 开始事务
const transaction = await context.transactionManager.begin();

try {
  // 执行多个操作
  await pluginA.createUser(transaction, userData);
  await pluginB.createOrder(transaction, orderData);
  await pluginC.sendNotification(transaction, notificationData);

  // 提交事务
  await transaction.commit();
} catch (error) {
  // 回滚事务
  await transaction.rollback();
  throw error;
}
```

##### 2. 两阶段提交#

插件可以实现两阶段提交协议：

```
typescript复制// 第一阶段：准备
const participants = [pluginA, pluginB, pluginC];
const prepareResults = await Promise.all(
  participants.map(p => p.prepare(transaction))
);

// 检查准备结果
if (prepareResults.every(r => r.status === 'prepared')) {
  // 第二阶段：提交
  await Promise.all(participants.map(p => p.commit(transaction)));
} else {
  // 第二阶段：回滚
  await Promise.all(participants.map(p => p.rollback(transaction)));
}
```

```
// 第一阶段：准备
const participants = [pluginA, pluginB, pluginC];
const prepareResults = await Promise.all(
  participants.map(p => p.prepare(transaction))
);

// 检查准备结果
if (prepareResults.every(r => r.status === 'prepared')) {
  // 第二阶段：提交
  await Promise.all(participants.map(p => p.commit(transaction)));
} else {
  // 第二阶段：回滚
  await Promise.all(participants.map(p => p.rollback(transaction)));
}
```

#### 错误处理与恢复#

##### 1. 错误传播#

插件可以通过事件总线传播错误：

```
typescript复制// 插件A抛出错误
try {
  await riskyOperation();
} catch (error) {
  context.eventBus.publish('plugin.error', {
    pluginId: 'plugin-a',
    error: error.message,
    stack: error.stack
  });
  throw error;
}

// 插件B监听错误
context.eventBus.subscribe('plugin.error', (errorData) => {
  context.logger.error('Plugin error:', errorData);
  // 执行错误恢复逻辑
});
```

```
// 插件A抛出错误
try {
  await riskyOperation();
} catch (error) {
  context.eventBus.publish('plugin.error', {
    pluginId: 'plugin-a',
    error: error.message,
    stack: error.stack
  });
  throw error;
}

// 插件B监听错误
context.eventBus.subscribe('plugin.error', (errorData) => {
  context.logger.error('Plugin error:', errorData);
  // 执行错误恢复逻辑
});
```

##### 2. 熔断机制#

插件可以使用熔断机制防止级联失败：

```
typescript复制// 创建熔断器
const circuitBreaker = context.circuitBreakerFactory.create('external-service', {
  failureThreshold: 50,
  successThreshold: 10,
  timeout: 5000
});

// 使用熔断器
try {
  const result = await circuitBreaker.execute(() => callExternalService());
  return result;
} catch (error) {
  if (error.type === 'CircuitOpenError') {
    // 熔断器打开，返回降级结果
    return fallbackResult();
  }
  throw error;
}
```

```
// 创建熔断器
const circuitBreaker = context.circuitBreakerFactory.create('external-service', {
  failureThreshold: 50,
  successThreshold: 10,
  timeout: 5000
});

// 使用熔断器
try {
  const result = await circuitBreaker.execute(() => callExternalService());
  return result;
} catch (error) {
  if (error.type === 'CircuitOpenError') {
    // 熔断器打开，返回降级结果
    return fallbackResult();
  }
  throw error;
}
```

##### 3. 降级策略#

插件可以实现降级策略：

```
typescript复制// 降级策略示例
async function getUsers() {
  try {
    return await database.query('SELECT * FROM users');
  } catch (error) {
    // 数据库失败，返回缓存数据
    context.logger.warn('Database failed, falling back to cache');
    return cache.get('users:all');
  }
}
```

```
// 降级策略示例
async function getUsers() {
  try {
    return await database.query('SELECT * FROM users');
  } catch (error) {
    // 数据库失败，返回缓存数据
    context.logger.warn('Database failed, falling back to cache');
    return cache.get('users:all');
  }
}
```

#### 性能优化#

##### 1. 批量处理#

插件可以批量处理请求提高性能：

```
typescript复制// 批量处理事件
const batchProcessor = context.batchProcessor.create('user-events', {
  batchSize: 100,
  batchTimeout: 1000
});

// 发送事件
batchProcessor.add({ type: 'created', userId: '123' });
batchProcessor.add({ type: 'updated', userId: '456' });

// 处理批量
batchProcessor.on('batch', async (events) => {
  await database.batchInsert('user_events', events);
});
```

```
// 批量处理事件
const batchProcessor = context.batchProcessor.create('user-events', {
  batchSize: 100,
  batchTimeout: 1000
});

// 发送事件
batchProcessor.add({ type: 'created', userId: '123' });
batchProcessor.add({ type: 'updated', userId: '456' });

// 处理批量
batchProcessor.on('batch', async (events) => {
  await database.batchInsert('user_events', events);
});
```

##### 2. 异步处理#

插件可以使用异步处理提高响应性：

```
typescript复制// 异步处理请求
app.post('/api/users', async (req, res) => {
  // 立即返回响应
  res.status(202).json({ status: 'accepted' });

  // 异步处理任务
  setTimeout(async () => {
    await createUser(req.body);
    await sendWelcomeEmail(req.body.email);
  }, 0);
});
```

```
// 异步处理请求
app.post('/api/users', async (req, res) => {
  // 立即返回响应
  res.status(202).json({ status: 'accepted' });

  // 异步处理任务
  setTimeout(async () => {
    await createUser(req.body);
    await sendWelcomeEmail(req.body.email);
  }, 0);
});
```

##### 3. 缓存策略#

插件可以使用多级缓存提高性能：

```
typescript复制// 多级缓存
async function getUser(userId) {
  // 先查本地缓存
  let user = localCache.get(`user:${userId}`);
  if (user) return user;

  // 再查分布式缓存
  user = await distributedCache.get(`user:${userId}`);
  if (user) {
    localCache.set(`user:${userId}`, user, { ttl: 60 });
    return user;
  }

  // 最后查数据库
  user = await database.query('SELECT * FROM users WHERE id = ?', [userId]);
  distributedCache.set(`user:${userId}`, user, { ttl: 3600 });
  localCache.set(`user:${userId}`, user, { ttl: 60 });
  return user;
}
```

```
// 多级缓存
async function getUser(userId) {
  // 先查本地缓存
  let user = localCache.get(`user:${userId}`);
  if (user) return user;

  // 再查分布式缓存
  user = await distributedCache.get(`user:${userId}`);
  if (user) {
    localCache.set(`user:${userId}`, user, { ttl: 60 });
    return user;
  }

  // 最后查数据库
  user = await database.query('SELECT * FROM users WHERE id = ?', [userId]);
  distributedCache.set(`user:${userId}`, user, { ttl: 3600 });
  localCache.set(`user:${userId}`, user, { ttl: 60 });
  return user;
}
```

#### 安全考虑#

##### 1. 权限控制#

插件可以实现细粒度的权限控制：

```
typescript复制// 权限检查
async function deleteUser(userId, requester) {
  const permission = await context.permissionService.check(
    requester.id,
    'user:delete',
    { userId }
  );

  if (!permission.granted) {
    throw new Error('Permission denied');
  }

  await database.query('DELETE FROM users WHERE id = ?', [userId]);
}
```

```
// 权限检查
async function deleteUser(userId, requester) {
  const permission = await context.permissionService.check(
    requester.id,
    'user:delete',
    { userId }
  );

  if (!permission.granted) {
    throw new Error('Permission denied');
  }

  await database.query('DELETE FROM users WHERE id = ?', [userId]);
}
```

##### 2. 数据加密#

插件可以加密敏感数据：

```
typescript复制// 加密数据
const encryptedData = await context.encryptionService.encrypt(
  sensitiveData,
  'AES-256-GCM',
  { keyId: 'data-encryption-key' }
);

// 解密数据
const decryptedData = await context.encryptionService.decrypt(
  encryptedData,
  'AES-256-GCM',
  { keyId: 'data-encryption-key' }
);
```

```
// 加密数据
const encryptedData = await context.encryptionService.encrypt(
  sensitiveData,
  'AES-256-GCM',
  { keyId: 'data-encryption-key' }
);

// 解密数据
const decryptedData = await context.encryptionService.decrypt(
  encryptedData,
  'AES-256-GCM',
  { keyId: 'data-encryption-key' }
);
```

##### 3. 审计日志#

插件可以记录审计日志：

```
typescript复制// 记录审计日志
context.auditLogger.log({
  action: 'user.created',
  actor: 'system',
  target: userId,
  metadata: { ipAddress: '192.168.1.1', userAgent: 'Claude Code' },
  timestamp: new Date()
});
```

```
// 记录审计日志
context.auditLogger.log({
  action: 'user.created',
  actor: 'system',
  target: userId,
  metadata: { ipAddress: '192.168.1.1', userAgent: 'Claude Code' },
  timestamp: new Date()
});
```

#### 最佳实践#

##### 1. 通信协议设计#

- 使用标准化的事件名称和消息格式
- 定义清晰的版本控制策略
- 提供详细的文档和示例

##### 2. 错误处理#

- 始终处理异步操作的错误
- 提供有意义的错误信息
- 实现适当的重试和降级策略

##### 3. 性能优化#

- 批量处理减少系统调用
- 使用缓存减少重复计算
- 异步处理提高响应性

##### 4. 安全性#

- 验证所有外部输入
- 实施最小权限原则
- 加密敏感数据

##### 5. 可观测性#

- 记录关键操作和事件
- 监控插件性能和健康状况
- 提供详细的错误信息

#### 总结#

插件通信与协作是构建复杂插件系统的关键。通过选择合适的通信机制、遵循协作模式和最佳实践，可以构建出高效、可靠和安全的插件系统。

下一章将介绍插件测试与调试技术，帮助开发者确保插件质量和稳定性。

---

## 7 插件测试与调试

**URL**: https://claudecode.tangshuang.net/course/22.7%20%E6%8F%92%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95

#### 概述#

测试与调试是插件开发过程中的重要环节，确保插件质量和稳定性。本章节将详细介绍 Claude Code 插件的测试策略、调试技术和最佳实践。

#### 测试策略#

##### 1. 测试金字塔#

插件测试应遵循测试金字塔原则：

```
bash复制          UI 测试
        /
      集成测试
    /
  单元测试
```

```
UI 测试
        /
      集成测试
    /
  单元测试
```

- 单元测试：测试最小的功能单元（函数、方法）
- 集成测试：测试插件内部组件之间的交互
- UI 测试：测试插件与用户界面的交互

##### 2. 测试类型#

###### 单元测试

单元测试关注插件的最小功能单元：

```
typescript复制// 单元测试示例
```

```
// 单元测试示例
```

import { CalculatorTool } from './calculator-tool';

describe('CalculatorTool', () => {
let tool: CalculatorTool;

beforeEach(() => {
tool = new CalculatorTool();
});

describe('add', () => {
it('should add two numbers', async () => {
const result = await tool.execute({ operation: 'add', a: 2, b: 3 });
expect(result).toBe(5);
});

```
bash复制it('should handle negative numbers', async () => {
  const result = await tool.execute({ operation: 'add', a: -2, b: 3 });
  expect(result).toBe(1);
});
```

```
it('should handle negative numbers', async () => {
  const result = await tool.execute({ operation: 'add', a: -2, b: 3 });
  expect(result).toBe(1);
});
```

describe('validate', () => {
it('should validate required parameters', () => {
const result = tool.validate({});
expect(result.valid).toBe(false);
expect(result.error).toBe('Operation is required');
});
});
});

```
bash复制
#### 集成测试

集成测试关注插件内部组件之间的交互：

```typescript
// 集成测试示例
import { UserPlugin } from './user-plugin';
import { DatabaseService } from './database-service';

describe('UserPlugin', () => {
  let plugin: UserPlugin;
  let databaseService: DatabaseService;

  beforeEach(() => {
    databaseService = new DatabaseService();
    plugin = new UserPlugin({ databaseService });
  });

  it('should create user and store in database', async () => {
    const user = await plugin.createUser({ name: 'John', email: 'john@example.com' });

    const storedUser = await databaseService.getUser(user.id);
    expect(storedUser).toBeDefined();
    expect(storedUser.name).toBe('John');
  });
});
```

```
#### 集成测试

集成测试关注插件内部组件之间的交互：

```typescript
// 集成测试示例
import { UserPlugin } from './user-plugin';
import { DatabaseService } from './database-service';

describe('UserPlugin', () => {
  let plugin: UserPlugin;
  let databaseService: DatabaseService;

  beforeEach(() => {
    databaseService = new DatabaseService();
    plugin = new UserPlugin({ databaseService });
  });

  it('should create user and store in database', async () => {
    const user = await plugin.createUser({ name: 'John', email: 'john@example.com' });

    const storedUser = await databaseService.getUser(user.id);
    expect(storedUser).toBeDefined();
    expect(storedUser.name).toBe('John');
  });
});
```

###### 端到端测试

端到端测试关注插件与系统的交互：

```
typescript复制// 端到端测试示例
import { PluginManager } from '@claude-code/plugin-sdk';

describe('UserPlugin E2E', () => {
  let pluginManager: PluginManager;

  beforeAll(async () => {
    pluginManager = new PluginManager();
    await pluginManager.loadPlugin('user-plugin');
  });

  afterAll(async () => {
    await pluginManager.unloadPlugin('user-plugin');
  });

  it('should create user through plugin API', async () => {
    const result = await pluginManager.executeCommand('user:create', {
      name: 'John',
      email: 'john@example.com'
    });

    expect(result.success).toBe(true);
    expect(result.data.user.id).toBeDefined();
  });
});
```

```
// 端到端测试示例
import { PluginManager } from '@claude-code/plugin-sdk';

describe('UserPlugin E2E', () => {
  let pluginManager: PluginManager;

  beforeAll(async () => {
    pluginManager = new PluginManager();
    await pluginManager.loadPlugin('user-plugin');
  });

  afterAll(async () => {
    await pluginManager.unloadPlugin('user-plugin');
  });

  it('should create user through plugin API', async () => {
    const result = await pluginManager.executeCommand('user:create', {
      name: 'John',
      email: 'john@example.com'
    });

    expect(result.success).toBe(true);
    expect(result.data.user.id).toBeDefined();
  });
});
```

#### 测试框架与工具#

##### 1. Jest#

Jest 是一个流行的 JavaScript 测试框架：

```
json复制// package.json
{
  "devDependencies": {
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

```
// package.json
{
  "devDependencies": {
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

##### 2. Mocha#

Mocha 是一个灵活的 JavaScript 测试框架：

```
json复制// package.json
{
  "devDependencies": {
    "mocha": "^10.0.0",
    "chai": "^4.0.0",
    "sinon": "^15.0.0"
  },
  "scripts": {
    "test": "mocha",
    "test:watch": "mocha --watch"
  }
}
```

```
// package.json
{
  "devDependencies": {
    "mocha": "^10.0.0",
    "chai": "^4.0.0",
    "sinon": "^15.0.0"
  },
  "scripts": {
    "test": "mocha",
    "test:watch": "mocha --watch"
  }
}
```

##### 3. Vitest#

Vitest 是一个快速的 Vite-native 测试框架：

```
json复制// package.json
{
  "devDependencies": {
    "vitest": "^0.30.0"
  },
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui"
  }
}
```

```
// package.json
{
  "devDependencies": {
    "vitest": "^0.30.0"
  },
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui"
  }
}
```

#### 调试技术#

##### 1. 日志调试#

使用日志记录插件运行时信息：

```
typescript复制// 日志调试示例
class UserPlugin {
  async createUser(userData) {
    this.logger.debug('Creating user', { userData });

    try {
      const user = await this.database.create(userData);
      this.logger.info('User created', { userId: user.id });
      return user;
    } catch (error) {
      this.logger.error('Failed to create user', { error: error.message });
      throw error;
    }
  }
}
```

```
// 日志调试示例
class UserPlugin {
  async createUser(userData) {
    this.logger.debug('Creating user', { userData });

    try {
      const user = await this.database.create(userData);
      this.logger.info('User created', { userId: user.id });
      return user;
    } catch (error) {
      this.logger.error('Failed to create user', { error: error.message });
      throw error;
    }
  }
}
```

##### 2. 断点调试#

使用 VS Code 进行断点调试：

```
json复制// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Plugin",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/src/plugin.ts",
      "args": ["--debug"],
      "outFiles": ["${workspaceFolder}/dist/**/*.js"]
    }
  ]
}
```

```
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Plugin",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/src/plugin.ts",
      "args": ["--debug"],
      "outFiles": ["${workspaceFolder}/dist/**/*.js"]
    }
  ]
}
```

##### 3. 远程调试#

插件支持远程调试：

```
typescript复制// 启用远程调试
if (process.env.NODE_ENV === 'development') {
  require('inspector').open(9229, '0.0.0.0', true);
}
```

```
// 启用远程调试
if (process.env.NODE_ENV === 'development') {
  require('inspector').open(9229, '0.0.0.0', true);
}
```

#### 测试环境搭建#

##### 1. 测试数据库#

使用测试数据库进行集成测试：

```
typescript复制// 测试数据库配置
const testConfig = {
  database: {
    type: 'sqlite',
    database: ':memory:',
    synchronize: true,
    logging: false
  }
};
```

```
// 测试数据库配置
const testConfig = {
  database: {
    type: 'sqlite',
    database: ':memory:',
    synchronize: true,
    logging: false
  }
};
```

##### 2. 测试替身#

使用测试替身模拟外部依赖：

```
typescript复制// 使用 Sinon 模拟依赖
import sinon from 'sinon';

describe('UserPlugin', () => {
  it('should send welcome email', async () => {
    const emailService = { send: sinon.stub().resolves(true) };
    const plugin = new UserPlugin({ emailService });

    await plugin.createUser({ name: 'John', email: 'john@example.com' });

    expect(emailService.send.calledOnce).toBe(true);
    expect(emailService.send.calledWith('john@example.com', 'Welcome')).toBe(true);
  });
});
```

```
// 使用 Sinon 模拟依赖
import sinon from 'sinon';

describe('UserPlugin', () => {
  it('should send welcome email', async () => {
    const emailService = { send: sinon.stub().resolves(true) };
    const plugin = new UserPlugin({ emailService });

    await plugin.createUser({ name: 'John', email: 'john@example.com' });

    expect(emailService.send.calledOnce).toBe(true);
    expect(emailService.send.calledWith('john@example.com', 'Welcome')).toBe(true);
  });
});
```

##### 3. 测试数据#

使用测试数据进行测试：

```
typescript复制// 测试数据生成
function generateTestUser() {
  return {
    name: `Test User ${Math.random().toString(36).substring(2, 10)}`,
    email: `test-${Math.random().toString(36).substring(2, 10)}@example.com`,
    password: 'password123'
  };
}

// 批量生成测试数据
function generateTestUsers(count: number) {
  return Array.from({ length: count }, () => generateTestUser());
}
```

```
// 测试数据生成
function generateTestUser() {
  return {
    name: `Test User ${Math.random().toString(36).substring(2, 10)}`,
    email: `test-${Math.random().toString(36).substring(2, 10)}@example.com`,
    password: 'password123'
  };
}

// 批量生成测试数据
function generateTestUsers(count: number) {
  return Array.from({ length: count }, () => generateTestUser());
}
```

#### 持续集成#

##### 1. GitHub Actions#

使用 GitHub Actions 进行持续集成：

```
yaml复制# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm install
      - run: npm test
      - run: npm run lint
```

```
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm install
      - run: npm test
      - run: npm run lint
```

##### 2. GitLab CI#

使用 GitLab CI 进行持续集成：

```
yaml复制# .gitlab-ci.yml
stages:
  - test

unit_test:
  stage: test
  image: node:18
  script:
    - npm install
    - npm test
```

```
# .gitlab-ci.yml
stages:
  - test

unit_test:
  stage: test
  image: node:18
  script:
    - npm install
    - npm test
```

#### 性能测试#

##### 1. 基准测试#

使用基准测试评估插件性能：

```
typescript复制// 基准测试示例
import { suite } from 'benchmark';
import { CalculatorTool } from './calculator-tool';

const tool = new CalculatorTool();

const bench = new suite('CalculatorTool');

bench
  .add('add', async (deferred) => {
    await tool.execute({ operation: 'add', a: 2, b: 3 });
    deferred.resolve();
  }, { defer: true })
  .add('multiply', async (deferred) => {
    await tool.execute({ operation: 'multiply', a: 2, b: 3 });
    deferred.resolve();
  }, { defer: true })
  .on('cycle', (event) => {
    console.log(String(event.target));
  })
  .run();
```

```
// 基准测试示例
import { suite } from 'benchmark';
import { CalculatorTool } from './calculator-tool';

const tool = new CalculatorTool();

const bench = new suite('CalculatorTool');

bench
  .add('add', async (deferred) => {
    await tool.execute({ operation: 'add', a: 2, b: 3 });
    deferred.resolve();
  }, { defer: true })
  .add('multiply', async (deferred) => {
    await tool.execute({ operation: 'multiply', a: 2, b: 3 });
    deferred.resolve();
  }, { defer: true })
  .on('cycle', (event) => {
    console.log(String(event.target));
  })
  .run();
```

##### 2. 负载测试#

使用负载测试评估插件在高并发下的性能：

```
typescript复制// 负载测试示例
import http from 'k6/http';
import { sleep } from 'k6';

export const options = {
  vus: 100,
  duration: '30s'
};

export default function () {
  http.post('http://localhost:3000/api/users', JSON.stringify({
    name: 'Test User',
    email: 'test@example.com'
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
  sleep(1);
}
```

```
// 负载测试示例
import http from 'k6/http';
import { sleep } from 'k6';

export const options = {
  vus: 100,
  duration: '30s'
};

export default function () {
  http.post('http://localhost:3000/api/users', JSON.stringify({
    name: 'Test User',
    email: 'test@example.com'
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
  sleep(1);
}
```

#### 测试覆盖率#

##### 1. 覆盖率报告#

使用 Jest 生成覆盖率报告：

```
json复制// package.json
{
  "scripts": {
    "test:coverage": "jest --coverage"
  }
}
```

```
// package.json
{
  "scripts": {
    "test:coverage": "jest --coverage"
  }
}
```

##### 2. 覆盖率阈值#

设置覆盖率阈值确保测试质量：

```
json复制// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

```
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

#### 调试技巧#

##### 1. 日志级别#

使用不同的日志级别调试：

```
typescript复制// 日志级别配置
const logger = createLogger({
  level: process.env.NODE_ENV === 'development' ? 'debug' : 'info'
});
```

```
// 日志级别配置
const logger = createLogger({
  level: process.env.NODE_ENV === 'development' ? 'debug' : 'info'
});
```

##### 2. 调试工具#

使用 Chrome DevTools 调试：

```
bash复制# 启动调试模式
node --inspect-brk plugin.js
```

```
# 启动调试模式
node --inspect-brk plugin.js
```

##### 3. 错误追踪#

使用 Sentry 进行错误追踪：

```
typescript复制// Sentry 配置
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: 'your-sentry-dsn',
  environment: process.env.NODE_ENV
});
```

```
// Sentry 配置
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: 'your-sentry-dsn',
  environment: process.env.NODE_ENV
});
```

#### 最佳实践#

##### 1. 测试驱动开发#

采用测试驱动开发（TDD）：

True. 编写失败的测试
True. 编写足够的代码使测试通过
True. 重构代码
True. 重复

##### 2. 测试隔离#

确保测试之间相互隔离：

```
typescript复制// 测试隔离示例
beforeEach(() => {
  // 重置状态
  database.clear();
  cache.clear();
});
```

```
// 测试隔离示例
beforeEach(() => {
  // 重置状态
  database.clear();
  cache.clear();
});
```

##### 3. 测试命名#

使用清晰的测试命名规范：

```
typescript复制// 测试命名示例
describe('UserPlugin', () => {
  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // ...
    });

    it('should throw error with invalid data', async () => {
      // ...
    });
  });
});
```

```
// 测试命名示例
describe('UserPlugin', () => {
  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // ...
    });

    it('should throw error with invalid data', async () => {
      // ...
    });
  });
});
```

##### 4. 测试文档#

为测试编写文档：

```
typescript复制// 测试文档示例
/**
 * 测试用户创建功能
 * 1. 验证必填字段
 * 2. 验证数据存储
 * 3. 验证错误处理
 */
describe('UserPlugin.createUser', () => {
  // ...
});
```

```
// 测试文档示例
/**
 * 测试用户创建功能
 * 1. 验证必填字段
 * 2. 验证数据存储
 * 3. 验证错误处理
 */
describe('UserPlugin.createUser', () => {
  // ...
});
```

#### 常见问题#

##### Q: 如何测试异步代码？#

A: 使用 async/await 测试异步代码：

```
typescript复制it('should handle async operation', async () => {
  const result = await asyncFunction();
  expect(result).toBe(true);
});
```

```
it('should handle async operation', async () => {
  const result = await asyncFunction();
  expect(result).toBe(true);
});
```

##### Q: 如何测试错误情况？#

A: 使用 expect.toThrow 测试错误情况：

```
typescript复制it('should throw error with invalid data', async () => {
  await expect(plugin.createUser({})).rejects.toThrow('Invalid data');
});
```

```
it('should throw error with invalid data', async () => {
  await expect(plugin.createUser({})).rejects.toThrow('Invalid data');
});
```

##### Q: 如何测试定时器？#

A: 使用 Jest 的定时器模拟：

```
typescript复制it('should execute after delay', async () => {
  jest.useFakeTimers();

  const callback = jest.fn();
  setTimeout(callback, 1000);

  jest.runAllTimers();
  expect(callback).toHaveBeenCalled();
});
```

```
it('should execute after delay', async () => {
  jest.useFakeTimers();

  const callback = jest.fn();
  setTimeout(callback, 1000);

  jest.runAllTimers();
  expect(callback).toHaveBeenCalled();
});
```

#### 总结#

测试与调试是插件开发过程中的重要环节。通过采用合适的测试策略、使用测试框架和工具、遵循最佳实践，可以确保插件的质量和稳定性。

下一章将介绍插件性能优化技术，帮助开发者提高插件性能和响应性。

---

## 8 插件性能优化

**URL**: https://claudecode.tangshuang.net/course/22.8%20%E6%8F%92%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96

#### 概述#

性能优化是插件开发中的重要环节，直接影响用户体验和系统稳定性。本章节将详细介绍插件性能优化的各个方面，包括性能分析、优化技术和最佳实践。

#### 性能分析#

##### 1. 性能指标#

常见的性能指标包括：

- 响应时间：处理请求所需的时间
- 吞吐量：单位时间内处理的请求数
- 并发数：同时处理的请求数
- 资源利用率：CPU、内存、磁盘等资源的使用情况

##### 2. 性能分析工具#

###### Chrome DevTools

Chrome DevTools 是强大的性能分析工具：

```
bash复制# 启动 Chrome DevTools
chrome://devtools/
```

```
# 启动 Chrome DevTools
chrome://devtools/
```

###### Node.js 内置工具

Node.js 提供了内置的性能分析工具：

```
bash复制# 生成 CPU 分析报告
node --prof app.js

# 分析 CPU 分析报告
```

```
# 生成 CPU 分析报告
node --prof app.js

# 分析 CPU 分析报告
```

node --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt

### 生成堆快照

node --heapsnapshot-signal=SIGUSR2 app.js

```
bash复制
#### 第三方工具

常用的第三方性能分析工具：

- **Clinic.js**：Node.js 性能分析套件
- **0x**：CPU 分析工具
- **Artillery**：负载测试工具

### 3. 性能分析流程

性能分析的一般流程：

1. **确定性能目标**：定义可接受的性能指标
2. **收集性能数据**：使用性能分析工具收集数据
3. **分析性能瓶颈**：识别性能瓶颈和问题
4. **实施优化措施**：针对瓶颈进行优化
5. **验证优化效果**：测试优化后的性能

## 代码优化

### 1. 算法优化

选择合适的算法和数据结构：

```typescript
// 优化前：O(n^2) 时间复杂度
function findDuplicates(arr) {
  const duplicates = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        duplicates.push(arr[i]);
      }
    }
  }
  return duplicates;
}

// 优化后：O(n) 时间复杂度
function findDuplicates(arr) {
  const seen = new Set();
  const duplicates = new Set();
  for (const item of arr) {
    if (seen.has(item)) {
      duplicates.add(item);
    }
    seen.add(item);
  }
  return Array.from(duplicates);
}
```

```
#### 第三方工具

常用的第三方性能分析工具：

- **Clinic.js**：Node.js 性能分析套件
- **0x**：CPU 分析工具
- **Artillery**：负载测试工具

### 3. 性能分析流程

性能分析的一般流程：

1. **确定性能目标**：定义可接受的性能指标
2. **收集性能数据**：使用性能分析工具收集数据
3. **分析性能瓶颈**：识别性能瓶颈和问题
4. **实施优化措施**：针对瓶颈进行优化
5. **验证优化效果**：测试优化后的性能

## 代码优化

### 1. 算法优化

选择合适的算法和数据结构：

```typescript
// 优化前：O(n^2) 时间复杂度
function findDuplicates(arr) {
  const duplicates = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        duplicates.push(arr[i]);
      }
    }
  }
  return duplicates;
}

// 优化后：O(n) 时间复杂度
function findDuplicates(arr) {
  const seen = new Set();
  const duplicates = new Set();
  for (const item of arr) {
    if (seen.has(item)) {
      duplicates.add(item);
    }
    seen.add(item);
  }
  return Array.from(duplicates);
}
```

##### 2. 内存优化#

减少内存占用和垃圾回收：

```
typescript复制// 优化前：频繁创建对象
function processData(data) {
  const result = [];
  for (const item of data) {
    result.push({
      id: item.id,
      value: item.value * 2
    });
  }
  return result;
}

// 优化后：重用对象
function processData(data) {
  const result = [];
  const temp = {};
  for (const item of data) {
    temp.id = item.id;
    temp.value = item.value * 2;
    result.push(Object.assign({}, temp));
  }
  return result;
}
```

```
// 优化前：频繁创建对象
function processData(data) {
  const result = [];
  for (const item of data) {
    result.push({
      id: item.id,
      value: item.value * 2
    });
  }
  return result;
}

// 优化后：重用对象
function processData(data) {
  const result = [];
  const temp = {};
  for (const item of data) {
    temp.id = item.id;
    temp.value = item.value * 2;
    result.push(Object.assign({}, temp));
  }
  return result;
}
```

##### 3. 异步优化#

使用异步操作提高响应性：

```
typescript复制// 优化前：同步操作
function processFiles(files) {
  const results = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    results.push(processContent(content));
  }
  return results;
}

// 优化后：异步操作
async function processFiles(files) {
  const promises = files.map(async (file) => {
    const content = await fs.readFile(file, 'utf8');
    return processContent(content);
  });
  return Promise.all(promises);
}
```

```
// 优化前：同步操作
function processFiles(files) {
  const results = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    results.push(processContent(content));
  }
  return results;
}

// 优化后：异步操作
async function processFiles(files) {
  const promises = files.map(async (file) => {
    const content = await fs.readFile(file, 'utf8');
    return processContent(content);
  });
  return Promise.all(promises);
}
```

#### 缓存优化#

##### 1. 缓存策略#

常见的缓存策略：

- LRU (Least Recently Used)：最近最少使用
- LFU (Least Frequently Used)：最不经常使用
- FIFO (First In First Out)：先进先出

##### 2. 缓存实现#

使用缓存提高性能：

```
typescript复制// LRU 缓存实现
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return undefined;
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(key, value);
  }
}
```

```
// LRU 缓存实现
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return undefined;
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(key, value);
  }
}
```

##### 3. 多级缓存#

使用多级缓存提高性能：

```
typescript复制// 多级缓存示例
async function getData(key) {
  // 先查本地缓存
  let data = localCache.get(key);
  if (data) return data;

  // 再查分布式缓存
  data = await redis.get(key);
  if (data) {
    localCache.set(key, data, { ttl: 60 });
    return data;
  }

  // 最后查数据库
  data = await database.query('SELECT * FROM data WHERE key = ?', [key]);
  redis.set(key, data, { ex: 3600 });
  localCache.set(key, data, { ttl: 60 });
  return data;
}
```

```
// 多级缓存示例
async function getData(key) {
  // 先查本地缓存
  let data = localCache.get(key);
  if (data) return data;

  // 再查分布式缓存
  data = await redis.get(key);
  if (data) {
    localCache.set(key, data, { ttl: 60 });
    return data;
  }

  // 最后查数据库
  data = await database.query('SELECT * FROM data WHERE key = ?', [key]);
  redis.set(key, data, { ex: 3600 });
  localCache.set(key, data, { ttl: 60 });
  return data;
}
```

#### 数据库优化#

##### 1. 查询优化#

优化数据库查询：

```
typescript复制// 优化前：N+1 查询问题
async function getUsersWithPosts() {
  const users = await database.query('SELECT * FROM users');
  for (const user of users) {
    user.posts = await database.query('SELECT * FROM posts WHERE user_id = ?', [user.id]);
  }
  return users;
}

// 优化后：批量查询
async function getUsersWithPosts() {
  const users = await database.query('SELECT * FROM users');
  const userIds = users.map(u => u.id);
  const posts = await database.query('SELECT * FROM posts WHERE user_id IN (?)', [userIds]);

  const postsByUser = new Map();
  for (const post of posts) {
    if (!postsByUser.has(post.user_id)) {
      postsByUser.set(post.user_id, []);
    }
    postsByUser.get(post.user_id).push(post);
  }

  return users.map(user => ({
    ...user,
    posts: postsByUser.get(user.id) || []
  }));
}
```

```
// 优化前：N+1 查询问题
async function getUsersWithPosts() {
  const users = await database.query('SELECT * FROM users');
  for (const user of users) {
    user.posts = await database.query('SELECT * FROM posts WHERE user_id = ?', [user.id]);
  }
  return users;
}

// 优化后：批量查询
async function getUsersWithPosts() {
  const users = await database.query('SELECT * FROM users');
  const userIds = users.map(u => u.id);
  const posts = await database.query('SELECT * FROM posts WHERE user_id IN (?)', [userIds]);

  const postsByUser = new Map();
  for (const post of posts) {
    if (!postsByUser.has(post.user_id)) {
      postsByUser.set(post.user_id, []);
    }
    postsByUser.get(post.user_id).push(post);
  }

  return users.map(user => ({
    ...user,
    posts: postsByUser.get(user.id) || []
  }));
}
```

##### 2. 索引优化#

使用索引提高查询性能：

```
sql复制-- 创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_posts_user_id ON posts(user_id);

-- 复合索引
CREATE INDEX idx_posts_user_id_created_at ON posts(user_id, created_at DESC);
```

```
-- 创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_posts_user_id ON posts(user_id);

-- 复合索引
CREATE INDEX idx_posts_user_id_created_at ON posts(user_id, created_at DESC);
```

##### 3. 批量操作#

使用批量操作减少数据库调用：

```
typescript复制// 优化前：单条插入
async function createUsers(users) {
  for (const user of users) {
    await database.query('INSERT INTO users (name, email) VALUES (?, ?)', [user.name, user.email]);
  }
}

// 优化后：批量插入
async function createUsers(users) {
  const values = users.map(u => `('${u.name}', '${u.email}')`).join(', ');
  await database.query(`INSERT INTO users (name, email) VALUES ${values}`);
}
```

```
// 优化前：单条插入
async function createUsers(users) {
  for (const user of users) {
    await database.query('INSERT INTO users (name, email) VALUES (?, ?)', [user.name, user.email]);
  }
}

// 优化后：批量插入
async function createUsers(users) {
  const values = users.map(u => `('${u.name}', '${u.email}')`).join(', ');
  await database.query(`INSERT INTO users (name, email) VALUES ${values}`);
}
```

#### 网络优化#

##### 1. 数据压缩#

使用数据压缩减少网络传输量：

```
typescript复制// 使用 gzip 压缩
import zlib from 'zlib';

aasync function compressData(data) {
  return new Promise((resolve, reject) => {
    zlib.gzip(JSON.stringify(data), (err, compressed) => {
      if (err) reject(err);
      else resolve(compressed);
    });
  });
}
```

```
// 使用 gzip 压缩
import zlib from 'zlib';

aasync function compressData(data) {
  return new Promise((resolve, reject) => {
    zlib.gzip(JSON.stringify(data), (err, compressed) => {
      if (err) reject(err);
      else resolve(compressed);
    });
  });
}
```

##### 2. 批量请求#

使用批量请求减少网络调用：

```
typescript复制// 优化前：多次请求
async function fetchUserData(userIds) {
  const users = [];
  for (const userId of userIds) {
    const user = await fetch(`/api/users/${userId}`);
    users.push(await user.json());
  }
  return users;
}

// 优化后：批量请求
async function fetchUserData(userIds) {
  const response = await fetch('/api/users/batch', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userIds })
  });
  return response.json();
}
```

```
// 优化前：多次请求
async function fetchUserData(userIds) {
  const users = [];
  for (const userId of userIds) {
    const user = await fetch(`/api/users/${userId}`);
    users.push(await user.json());
  }
  return users;
}

// 优化后：批量请求
async function fetchUserData(userIds) {
  const response = await fetch('/api/users/batch', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userIds })
  });
  return response.json();
}
```

##### 3. 缓存策略#

使用 HTTP 缓存减少重复请求：

```
typescript复制// 设置缓存头
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=3600');
  res.json(data);
});
```

```
// 设置缓存头
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=3600');
  res.json(data);
});
```

#### 并发优化#

##### 1. 异步并发#

使用异步并发提高吞吐量：

```
typescript复制// 优化前：串行处理
async function processTasks(tasks) {
  const results = [];
  for (const task of tasks) {
    const result = await processTask(task);
    results.push(result);
  }
  return results;
}

// 优化后：并行处理
async function processTasks(tasks) {
  const promises = tasks.map(task => processTask(task));
  return Promise.all(promises);
}
```

```
// 优化前：串行处理
async function processTasks(tasks) {
  const results = [];
  for (const task of tasks) {
    const result = await processTask(task);
    results.push(result);
  }
  return results;
}

// 优化后：并行处理
async function processTasks(tasks) {
  const promises = tasks.map(task => processTask(task));
  return Promise.all(promises);
}
```

##### 2. 线程池#

使用线程池处理 CPU 密集型任务：

```
typescript复制// 使用 worker_threads
import { Worker } from 'worker_threads';

function processLargeData(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./data-processor.js', { workerData: data });
    worker.on('message', resolve);
    worker.on('error', reject);
    worker.on('exit', (code) => {
      if (code !== 0) reject(new Error(`Worker exited with code ${code}`));
    });
  });
}
```

```
// 使用 worker_threads
import { Worker } from 'worker_threads';

function processLargeData(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./data-processor.js', { workerData: data });
    worker.on('message', resolve);
    worker.on('error', reject);
    worker.on('exit', (code) => {
      if (code !== 0) reject(new Error(`Worker exited with code ${code}`));
    });
  });
}
```

##### 3. 限流#

使用限流保护系统：

```
typescript复制// 限流实现
class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = new Map();
  }

  allow(key) {
    const now = Date.now();
    const windowStart = now - this.windowMs;

    if (!this.requests.has(key)) {
      this.requests.set(key, []);
    }

    const timestamps = this.requests.get(key);
    timestamps.filter(t => t > windowStart);

    if (timestamps.length < this.maxRequests) {
      timestamps.push(now);
      return true;
    }

    return false;
  }
}
```

```
// 限流实现
class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = new Map();
  }

  allow(key) {
    const now = Date.now();
    const windowStart = now - this.windowMs;

    if (!this.requests.has(key)) {
      this.requests.set(key, []);
    }

    const timestamps = this.requests.get(key);
    timestamps.filter(t => t > windowStart);

    if (timestamps.length < this.maxRequests) {
      timestamps.push(now);
      return true;
    }

    return false;
  }
}
```

#### 资源优化#

##### 1. 内存管理#

优化内存使用：

```
typescript复制// 及时释放资源
async function processFile(filePath) {
  let fileHandle;
  try {
    fileHandle = await fs.promises.open(filePath, 'r');
    const content = await fileHandle.readFile('utf8');
    return processContent(content);
  } finally {
    if (fileHandle) {
      await fileHandle.close();
    }
  }
}
```

```
// 及时释放资源
async function processFile(filePath) {
  let fileHandle;
  try {
    fileHandle = await fs.promises.open(filePath, 'r');
    const content = await fileHandle.readFile('utf8');
    return processContent(content);
  } finally {
    if (fileHandle) {
      await fileHandle.close();
    }
  }
}
```

##### 2. 文件系统优化#

优化文件系统操作：

```
typescript复制// 使用流处理大文件
async function processLargeFile(filePath) {
  const stream = fs.createReadStream(filePath, { highWaterMark: 64 * 1024 });

  return new Promise((resolve, reject) => {
    let content = '';
    stream.on('data', (chunk) => {
      content += chunk;
    });
    stream.on('end', () => {
      resolve(processContent(content));
    });
    stream.on('error', reject);
  });
}
```

```
// 使用流处理大文件
async function processLargeFile(filePath) {
  const stream = fs.createReadStream(filePath, { highWaterMark: 64 * 1024 });

  return new Promise((resolve, reject) => {
    let content = '';
    stream.on('data', (chunk) => {
      content += chunk;
    });
    stream.on('end', () => {
      resolve(processContent(content));
    });
    stream.on('error', reject);
  });
}
```

##### 3. 资源池#

使用资源池管理连接：

```
typescript复制// 数据库连接池
class ConnectionPool {
  constructor(size) {
    this.size = size;
    this.pool = [];
    this.available = [];
  }

  async getConnection() {
    if (this.available.length > 0) {
      return this.available.pop();
    }

    if (this.pool.length < this.size) {
      const connection = await createConnection();
      this.pool.push(connection);
      return connection;
    }

    return new Promise((resolve) => {
      const interval = setInterval(() => {
        if (this.available.length > 0) {
          clearInterval(interval);
          resolve(this.available.pop());
        }
      }, 100);
    });
  }

  releaseConnection(connection) {
    this.available.push(connection);
  }
}
```

```
// 数据库连接池
class ConnectionPool {
  constructor(size) {
    this.size = size;
    this.pool = [];
    this.available = [];
  }

  async getConnection() {
    if (this.available.length > 0) {
      return this.available.pop();
    }

    if (this.pool.length < this.size) {
      const connection = await createConnection();
      this.pool.push(connection);
      return connection;
    }

    return new Promise((resolve) => {
      const interval = setInterval(() => {
        if (this.available.length > 0) {
          clearInterval(interval);
          resolve(this.available.pop());
        }
      }, 100);
    });
  }

  releaseConnection(connection) {
    this.available.push(connection);
  }
}
```

#### 性能监控#

##### 1. 监控指标#

监控关键性能指标：

```
typescript复制// 性能监控
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
  }

  recordMetric(name, value) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name).push({ timestamp: Date.now(), value });
  }

  getMetrics(name) {
    return this.metrics.get(name) || [];
  }
}
```

```
// 性能监控
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
  }

  recordMetric(name, value) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name).push({ timestamp: Date.now(), value });
  }

  getMetrics(name) {
    return this.metrics.get(name) || [];
  }
}
```

##### 2. 告警系统#

设置性能告警：

```
typescript复制// 告警系统
class AlertSystem {
  constructor() {
    this.rules = [];
  }

  addRule(name, threshold, callback) {
    this.rules.push({ name, threshold, callback });
  }

  checkMetrics(metrics) {
    for (const rule of this.rules) {
      const metric = metrics.get(rule.name);
      if (metric && metric.value > rule.threshold) {
        rule.callback(metric);
      }
    }
  }
}
```

```
// 告警系统
class AlertSystem {
  constructor() {
    this.rules = [];
  }

  addRule(name, threshold, callback) {
    this.rules.push({ name, threshold, callback });
  }

  checkMetrics(metrics) {
    for (const rule of this.rules) {
      const metric = metrics.get(rule.name);
      if (metric && metric.value > rule.threshold) {
        rule.callback(metric);
      }
    }
  }
}
```

##### 3. 可视化#

使用可视化工具展示性能数据：

```
typescript复制// 生成性能报告
function generatePerformanceReport(metrics) {
  const report = {
    timestamp: new Date().toISOString(),
    metrics: {}
  };

  for (const [name, values] of metrics) {
    report.metrics[name] = {
      average: values.reduce((sum, v) => sum + v.value, 0) / values.length,
      max: Math.max(...values.map(v => v.value)),
      min: Math.min(...values.map(v => v.value))
    };
  }

  return report;
}
```

```
// 生成性能报告
function generatePerformanceReport(metrics) {
  const report = {
    timestamp: new Date().toISOString(),
    metrics: {}
  };

  for (const [name, values] of metrics) {
    report.metrics[name] = {
      average: values.reduce((sum, v) => sum + v.value, 0) / values.length,
      max: Math.max(...values.map(v => v.value)),
      min: Math.min(...values.map(v => v.value))
    };
  }

  return report;
}
```

#### 最佳实践#

##### 1. 性能预算#

设置性能预算确保性能目标：

```
json复制// performance-budget.json
{
  "loadTime": 2000,
  "apiResponseTime": 500,
  "memoryUsage": 512
}
```

```
// performance-budget.json
{
  "loadTime": 2000,
  "apiResponseTime": 500,
  "memoryUsage": 512
}
```

##### 2. 渐进式优化#

采用渐进式优化策略：

True. 识别瓶颈：使用性能分析工具识别瓶颈
True. 优先优化：优先优化影响最大的瓶颈
True. 持续监控：监控优化效果

##### 3. 性能测试#

定期进行性能测试：

```
bash复制# 负载测试
artillery run load-test.yml

# 基准测试
node benchmark.js
```

```
# 负载测试
artillery run load-test.yml

# 基准测试
node benchmark.js
```

##### 4. 代码审查#

在代码审查中关注性能：

- 检查算法复杂度
- 检查内存使用
- 检查异步操作

#### 常见问题#

##### Q: 如何处理内存泄漏？#

A: 使用内存分析工具识别内存泄漏：

```
bash复制# 生成堆快照
node --heapsnapshot-signal=SIGUSR2 app.js
```

```
# 生成堆快照
node --heapsnapshot-signal=SIGUSR2 app.js
```

##### Q: 如何优化 CPU 密集型任务？#

A: 使用 worker_threads 或 cluster 模块：

```
typescript复制// 使用 cluster 模块
import cluster from 'cluster';
import os from 'os';

if (cluster.isPrimary) {
  const numCPUs = os.cpus().length;
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
} else {
  // 工作进程代码
}
```

```
// 使用 cluster 模块
import cluster from 'cluster';
import os from 'os';

if (cluster.isPrimary) {
  const numCPUs = os.cpus().length;
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
} else {
  // 工作进程代码
}
```

##### Q: 如何优化 I/O 密集型任务？#

A: 使用异步操作和批量处理：

```
typescript复制// 使用异步 I/O
async function processFiles(files) {
  const promises = files.map(file => fs.promises.readFile(file, 'utf8'));
  const contents = await Promise.all(promises);
  return contents.map(content => processContent(content));
}
```

```
// 使用异步 I/O
async function processFiles(files) {
  const promises = files.map(file => fs.promises.readFile(file, 'utf8'));
  const contents = await Promise.all(promises);
  return contents.map(content => processContent(content));
}
```

#### 总结#

性能优化是一个持续的过程，需要结合性能分析、代码优化、缓存优化、数据库优化等多种技术。通过遵循最佳实践和持续监控，可以确保插件的性能和稳定性。

下一章将介绍插件安全与防护技术，帮助开发者保护插件和系统的安全。

---

# 第 23 章

## 1 代码生成基础

**URL**: https://claudecode.tangshuang.net/course/23.1%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%9F%BA%E7%A1%80

#### 概述#

代码生成是 Claude Code 的核心功能之一，能够根据自然语言描述生成高质量的代码。本章节将详细介绍代码生成的基本原理、使用方法和最佳实践。

#### 代码生成原理#

##### 1. 大语言模型#

Claude Code 基于 Anthropic 的 Claude 大语言模型，具有强大的代码理解和生成能力：

```
bash复制输入: 自然语言描述
→ 模型处理: 理解需求、分析上下文、生成代码
```

```
输入: 自然语言描述
→ 模型处理: 理解需求、分析上下文、生成代码
```

→ 输出: 高质量代码

```
bash复制
### 2. 代码生成流程

代码生成的一般流程：

1. **需求分析**：理解用户的代码需求
2. **上下文理解**：分析代码上下文和环境
3. **代码生成**：生成符合要求的代码
4. **代码优化**：优化代码质量和性能
5. **代码验证**：验证代码正确性

### 3. 代码生成技术

- **Few-shot learning**：通过少量示例学习代码模式
- **Chain-of-thought**：逐步思考生成代码
- **Self-correction**：自我修正代码错误

## 基本使用方法

### 1. 简单代码生成

```typescript
// 生成简单函数
function add(a: number, b: number): number {
  return a + b;
}
```

```
### 2. 代码生成流程

代码生成的一般流程：

1. **需求分析**：理解用户的代码需求
2. **上下文理解**：分析代码上下文和环境
3. **代码生成**：生成符合要求的代码
4. **代码优化**：优化代码质量和性能
5. **代码验证**：验证代码正确性

### 3. 代码生成技术

- **Few-shot learning**：通过少量示例学习代码模式
- **Chain-of-thought**：逐步思考生成代码
- **Self-correction**：自我修正代码错误

## 基本使用方法

### 1. 简单代码生成

```typescript
// 生成简单函数
function add(a: number, b: number): number {
  return a + b;
}
```

##### 2. 类生成#

```
typescript复制// 生成类
class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }

  subtract(a: number, b: number): number {
    return a - b;
  }

  multiply(a: number, b: number): number {
    return a * b;
  }

  divide(a: number, b: number): number {
    if (b === 0) {
      throw new Error('Cannot divide by zero');
    }
    return a / b;
  }
}
```

```
// 生成类
class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }

  subtract(a: number, b: number): number {
    return a - b;
  }

  multiply(a: number, b: number): number {
    return a * b;
  }

  divide(a: number, b: number): number {
    if (b === 0) {
      throw new Error('Cannot divide by zero');
    }
    return a / b;
  }
}
```

##### 3. 接口生成#

```
typescript复制// 生成接口
interface User {
  id: string;
  name: string;
  email: string;
  age?: number;
  createdAt: Date;
}
```

```
// 生成接口
interface User {
  id: string;
  name: string;
  email: string;
  age?: number;
  createdAt: Date;
}
```

#### 代码生成技巧#

##### 1. 明确需求#

提供清晰的需求描述：

```
bash复制// 好的需求
"生成一个 TypeScript 函数，用于验证电子邮件地址格式"

// 更好的需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试"
```

```
// 好的需求
"生成一个 TypeScript 函数，用于验证电子邮件地址格式"

// 更好的需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试"
```

##### 2. 提供上下文#

提供代码上下文信息：

```
bash复制// 提供上下文
"我有一个 User 接口：
interface User {
  id: string;
  name: string;
  email: string;
}

生成一个函数，将 User 对象转换为 JSON 字符串"
```

```
// 提供上下文
"我有一个 User 接口：
interface User {
  id: string;
  name: string;
  email: string;
}

生成一个函数，将 User 对象转换为 JSON 字符串"
```

##### 3. 指定技术栈#

明确指定技术栈和版本：

```
bash复制// 指定技术栈
"使用 React 18 和 TypeScript 生成一个 TodoList 组件，包含添加、删除、切换完成状态功能"
```

```
// 指定技术栈
"使用 React 18 和 TypeScript 生成一个 TodoList 组件，包含添加、删除、切换完成状态功能"
```

##### 4. 要求测试#

要求生成测试代码：

```
bash复制// 要求测试
"生成一个 TypeScript 函数，用于计算斐波那契数列，包含单元测试"
```

```
// 要求测试
"生成一个 TypeScript 函数，用于计算斐波那契数列，包含单元测试"
```

#### 代码生成示例#

##### 1. 算法生成#

```
typescript复制// 生成快速排序算法
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);

  return [...quickSort(left), ...middle, ...quickSort(right)];
}
```

```
// 生成快速排序算法
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);

  return [...quickSort(left), ...middle, ...quickSort(right)];
}
```

##### 2. 数据结构生成#

```
typescript复制// 生成链表数据结构
class ListNode {
  val: number;
  next: ListNode | null;

  constructor(val: number = 0, next: ListNode | null = null) {
    this.val = val;
    this.next = next;
  }
}

class LinkedList {
  head: ListNode | null;

  constructor() {
    this.head = null;
  }

  add(val: number): void {
    const newNode = new ListNode(val);
    if (!this.head) {
      this.head = newNode;
      return;
    }

    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  remove(val: number): void {
    if (!this.head) return;

    if (this.head.val === val) {
      this.head = this.head.next;
      return;
    }

    let current = this.head;
    while (current.next && current.next.val !== val) {
      current = current.next;
    }

    if (current.next) {
      current.next = current.next.next;
    }
  }
}
```

```
// 生成链表数据结构
class ListNode {
  val: number;
  next: ListNode | null;

  constructor(val: number = 0, next: ListNode | null = null) {
    this.val = val;
    this.next = next;
  }
}

class LinkedList {
  head: ListNode | null;

  constructor() {
    this.head = null;
  }

  add(val: number): void {
    const newNode = new ListNode(val);
    if (!this.head) {
      this.head = newNode;
      return;
    }

    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  remove(val: number): void {
    if (!this.head) return;

    if (this.head.val === val) {
      this.head = this.head.next;
      return;
    }

    let current = this.head;
    while (current.next && current.next.val !== val) {
      current = current.next;
    }

    if (current.next) {
      current.next = current.next.next;
    }
  }
}
```

##### 3. API 客户端生成#

```
typescript复制// 生成 GitHub API 客户端
class GitHubAPI {
  private token: string;

  constructor(token: string) {
    this.token = token;
  }

  async getUser(username: string): Promise<any> {
    const response = await fetch(`https://api.github.com/users/${username}`, {
      headers: {
        Authorization: `token ${this.token}`
      }
    });
    return response.json();
  }

  async getRepos(username: string): Promise<any[]> {
    const response = await fetch(`https://api.github.com/users/${username}/repos`, {
      headers: {
        Authorization: `token ${this.token}`
      }
    });
    return response.json();
  }

  async createRepo(name: string, description?: string): Promise<any> {
    const response = await fetch('https://api.github.com/user/repos', {
      method: 'POST',
      headers: {
        Authorization: `token ${this.token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name,
        description
      })
    });
    return response.json();
  }
}
```

```
// 生成 GitHub API 客户端
class GitHubAPI {
  private token: string;

  constructor(token: string) {
    this.token = token;
  }

  async getUser(username: string): Promise<any> {
    const response = await fetch(`https://api.github.com/users/${username}`, {
      headers: {
        Authorization: `token ${this.token}`
      }
    });
    return response.json();
  }

  async getRepos(username: string): Promise<any[]> {
    const response = await fetch(`https://api.github.com/users/${username}/repos`, {
      headers: {
        Authorization: `token ${this.token}`
      }
    });
    return response.json();
  }

  async createRepo(name: string, description?: string): Promise<any> {
    const response = await fetch('https://api.github.com/user/repos', {
      method: 'POST',
      headers: {
        Authorization: `token ${this.token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name,
        description
      })
    });
    return response.json();
  }
}
```

#### 代码质量控制#

##### 1. 代码审查#

生成代码后进行审查：

```
typescript复制// 生成的代码
function calculateTotal(prices: number[]): number {
  let total = 0;
  for (const price of prices) {
    total += price;
  }
  return total;
}

// 审查后优化
function calculateTotal(prices: number[]): number {
  return prices.reduce((total, price) => total + price, 0);
}
```

```
// 生成的代码
function calculateTotal(prices: number[]): number {
  let total = 0;
  for (const price of prices) {
    total += price;
  }
  return total;
}

// 审查后优化
function calculateTotal(prices: number[]): number {
  return prices.reduce((total, price) => total + price, 0);
}
```

##### 2. 代码格式化#

使用代码格式化工具：

```
bash复制# 使用 Prettier 格式化
npx prettier --write code.ts
```

```
# 使用 Prettier 格式化
npx prettier --write code.ts
```

##### 3. 类型检查#

使用 TypeScript 进行类型检查：

```
bash复制# 类型检查
npx tsc --noEmit code.ts
```

```
# 类型检查
npx tsc --noEmit code.ts
```

#### 常见问题#

##### Q: 如何生成符合特定风格的代码？#

A: 指定代码风格要求：

```
bash复制"生成一个 TypeScript 函数，使用箭头函数风格，符合 Airbnb 编码规范"
```

```
"生成一个 TypeScript 函数，使用箭头函数风格，符合 Airbnb 编码规范"
```

##### Q: 如何生成可维护的代码？#

A: 要求生成注释和文档：

```
bash复制"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

```
"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

##### Q: 如何生成性能优化的代码？#

A: 指定性能要求：

```
bash复制"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

```
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

#### 最佳实践#

##### 1. 分步骤生成#

分步骤生成复杂代码：

```
bash复制1. 生成数据模型
2. 生成业务逻辑
3. 生成 API 接口
4. 生成测试代码
```

```
1. 生成数据模型
2. 生成业务逻辑
3. 生成 API 接口
4. 生成测试代码
```

##### 2. 迭代优化#

迭代优化生成的代码：

```
bash复制// 初始需求
"生成一个 TypeScript 函数，用于验证密码强度"

// 迭代优化
"优化密码强度验证函数，增加对特殊字符的要求"
```

```
// 初始需求
"生成一个 TypeScript 函数，用于验证密码强度"

// 迭代优化
"优化密码强度验证函数，增加对特殊字符的要求"
```

##### 3. 结合工具#

结合其他开发工具使用：

```
bash复制// 结合 ESLint
npx eslint --fix code.ts

// 结合 Jest
npx jest code.test.ts
```

```
// 结合 ESLint
npx eslint --fix code.ts

// 结合 Jest
npx jest code.test.ts
```

#### 总结#

代码生成是 Claude Code 的核心功能之一，能够显著提高开发效率。通过明确需求、提供上下文、指定技术栈等技巧，可以生成高质量的代码。同时，需要注意代码质量控制和最佳实践，确保生成的代码可维护、可扩展。

下一章将介绍代码补全功能，帮助开发者在编码过程中快速补全代码。

---

## 2 智能代码补全

**URL**: https://claudecode.tangshuang.net/course/23.2%20%E6%99%BA%E8%83%BD%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8

#### 概述#

智能代码补全是 Claude Code 的重要功能之一，能够在编码过程中实时提供代码建议，显著提高开发效率。本章节将详细介绍智能代码补全的原理、使用方法和最佳实践。

#### 智能代码补全原理#

##### 1. 上下文理解#

Claude Code 能够理解代码上下文：

```
typescript复制// 上下文理解示例
function getUser(userId: string) {
  // 当输入 "db." 时，Claude Code 会理解需要数据库操作
  return db.query('SELECT * FROM users WHERE id = ?', [userId]);
}
```

```
// 上下文理解示例
function getUser(userId: string) {
  // 当输入 "db." 时，Claude Code 会理解需要数据库操作
  return db.query('SELECT * FROM users WHERE id = ?', [userId]);
}
```

##### 2. 模式识别#

通过模式识别提供代码建议：

```
typescript复制// 模式识别示例
const users = [
  { id: '1', name: 'John' },
  { id: '2', name: 'Jane' }
];

// 当输入 "users.map(" 时，Claude Code 会提供常见的映射模式
const userNames = users.map(user => user.name);
```

```
// 模式识别示例
const users = [
  { id: '1', name: 'John' },
  { id: '2', name: 'Jane' }
];

// 当输入 "users.map(" 时，Claude Code 会提供常见的映射模式
const userNames = users.map(user => user.name);
```

##### 3. 机器学习#

基于机器学习模型提供智能建议：

```
bash复制输入: "const express = require('express');"
→ 建议: "const app = express();"
→ 建议: "app.get('/', (req, res) => { res.send('Hello World'); });"
→ 建议: "app.listen(3000, () => { console.log('Server running on port 3000'); });"
```

```
输入: "const express = require('express');"
→ 建议: "const app = express();"
→ 建议: "app.get('/', (req, res) => { res.send('Hello World'); });"
→ 建议: "app.listen(3000, () => { console.log('Server running on port 3000'); });"
```

#### 代码补全类型#

##### 1. 基本补全#

提供基本的代码补全：

```
typescript复制// 变量补全
const userName = "John";
console.log(userN); // 补全为 userName

// 函数补全
function calculateTotal(prices: number[]) {
  return prices.reduce((total, price) => total + price, 0);
}

calculateT(); // 补全为 calculateTotal
```

```
// 变量补全
const userName = "John";
console.log(userN); // 补全为 userName

// 函数补全
function calculateTotal(prices: number[]) {
  return prices.reduce((total, price) => total + price, 0);
}

calculateT(); // 补全为 calculateTotal
```

##### 2. 方法补全#

提供对象方法的补全：

```
typescript复制// 数组方法补全
const numbers = [1, 2, 3];
numbers.map(n => n * 2); // 补全 map 方法

// 字符串方法补全
const message = "Hello";
message.toUpperCase(); // 补全 toUpperCase 方法
```

```
// 数组方法补全
const numbers = [1, 2, 3];
numbers.map(n => n * 2); // 补全 map 方法

// 字符串方法补全
const message = "Hello";
message.toUpperCase(); // 补全 toUpperCase 方法
```

##### 3. 参数补全#

提供函数参数的补全：

```
typescript复制// 参数补全
function createUser(name: string, email: string, age?: number) {
  return { name, email, age };
}

createUser("John", "john@example.com", 30); // 补全参数提示
```

```
// 参数补全
function createUser(name: string, email: string, age?: number) {
  return { name, email, age };
}

createUser("John", "john@example.com", 30); // 补全参数提示
```

##### 4. 模板补全#

提供代码模板的补全：

```
typescript复制// 循环模板补全
for (const user of users) {
  // 补全循环体
}

// 条件模板补全
if (user.isActive) {
  // 补全条件体
}
```

```
// 循环模板补全
for (const user of users) {
  // 补全循环体
}

// 条件模板补全
if (user.isActive) {
  // 补全条件体
}
```

##### 5. 导入补全#

提供导入语句的补全：

```
typescript复制// 导入补全
import { useState } from 'react'; // 补全 useState
```

```
// 导入补全
import { useState } from 'react'; // 补全 useState
```

#### 代码补全使用技巧#

##### 1. 触发补全#

手动触发代码补全：

```
bash复制# VS Code 快捷键
Ctrl+Space # Windows/Linux
Cmd+Space # macOS
```

```
# VS Code 快捷键
Ctrl+Space # Windows/Linux
Cmd+Space # macOS
```

##### 2. 接受补全#

接受代码补全：

```
bash复制# 接受补全
Tab # 接受当前补全
Enter # 接受当前补全并换行
```

```
# 接受补全
Tab # 接受当前补全
Enter # 接受当前补全并换行
```

##### 3. 选择补全#

在多个补全选项中选择：

```
bash复制# 选择补全选项
↑/↓ # 上下选择
Ctrl+↑/↓ # 上下选择（VS Code）
```

```
# 选择补全选项
↑/↓ # 上下选择
Ctrl+↑/↓ # 上下选择（VS Code）
```

##### 4. 拒绝补全#

拒绝代码补全：

```
bash复制# 拒绝补全
Esc # 取消补全
```

```
# 拒绝补全
Esc # 取消补全
```

#### 高级补全功能#

##### 1. 智能感知#

基于上下文的智能感知：

```
typescript复制// 智能感知示例
interface User {
  id: string;
  name: string;
  email: string;
}

function getUser(): User {
  return { id: '1', name: 'John', email: 'john@example.com' };
}

const user = getUser();
user. // 智能感知 user 的属性
```

```
// 智能感知示例
interface User {
  id: string;
  name: string;
  email: string;
}

function getUser(): User {
  return { id: '1', name: 'John', email: 'john@example.com' };
}

const user = getUser();
user. // 智能感知 user 的属性
```

##### 2. 类型推断#

基于类型推断的补全：

```
typescript复制// 类型推断示例
const numbers = [1, 2, 3];
numbers.map(n => n. // 推断 n 为 number 类型，提供 number 方法
```

```
// 类型推断示例
const numbers = [1, 2, 3];
numbers.map(n => n. // 推断 n 为 number 类型，提供 number 方法
```

##### 3. 代码片段#

使用代码片段补全：

```
typescript复制// 代码片段补全
for (const item of items) {
  // 补全 for-of 循环
}

// 自定义代码片段
"use strict";
```

```
// 代码片段补全
for (const item of items) {
  // 补全 for-of 循环
}

// 自定义代码片段
"use strict";
```

##### 4. 重构建议#

提供代码重构建议：

```
typescript复制// 重构建议示例
function calculateTotal(prices) {
  let total = 0;
  for (let i = 0; i < prices.length; i++) {
    total += prices[i];
  }
  return total;
}

// 建议重构为
function calculateTotal(prices) {
  return prices.reduce((total, price) => total + price, 0);
}
```

```
// 重构建议示例
function calculateTotal(prices) {
  let total = 0;
  for (let i = 0; i < prices.length; i++) {
    total += prices[i];
  }
  return total;
}

// 建议重构为
function calculateTotal(prices) {
  return prices.reduce((total, price) => total + price, 0);
}
```

#### 代码补全配置#

##### 1. VS Code 配置#

配置 VS Code 的代码补全：

```
json复制// settings.json
{
  "editor.quickSuggestions": {
    "other": true,
    "comments": false,
    "strings": true
  },
  "editor.suggestOnTriggerCharacters": true,
  "editor.acceptSuggestionOnEnter": "on",
  "editor.snippetSuggestions": "top"
}
```

```
// settings.json
{
  "editor.quickSuggestions": {
    "other": true,
    "comments": false,
    "strings": true
  },
  "editor.suggestOnTriggerCharacters": true,
  "editor.acceptSuggestionOnEnter": "on",
  "editor.snippetSuggestions": "top"
}
```

##### 2. 语言特定配置#

配置特定语言的代码补全：

```
json复制// settings.json
{
  "typescript.suggest.completeFunctionCalls": true,
  "javascript.suggest.completeFunctionCalls": true,
  "python.analysis.completeFunctionParens": true
}
```

```
// settings.json
{
  "typescript.suggest.completeFunctionCalls": true,
  "javascript.suggest.completeFunctionCalls": true,
  "python.analysis.completeFunctionParens": true
}
```

##### 3. 自定义补全#

自定义代码补全：

```
json复制// snippets/typescript.json
{
  "For Loop": {
    "prefix": "for",
    "body": [
      "for (const ${1:item} of ${2:items}) {
        ${0}
      }"
    ],
    "description": "For loop"
  }
}
```

```
// snippets/typescript.json
{
  "For Loop": {
    "prefix": "for",
    "body": [
      "for (const ${1:item} of ${2:items}) {
        ${0}
      }"
    ],
    "description": "For loop"
  }
}
```

#### 代码补全最佳实践#

##### 1. 保持代码简洁#

编写简洁的代码有助于更好的补全：

```
typescript复制// 好的代码
const user = getUser();
console.log(user.name); // 补全 user.name

// 不好的代码
console.log(getUser().name); // 难以补全
```

```
// 好的代码
const user = getUser();
console.log(user.name); // 补全 user.name

// 不好的代码
console.log(getUser().name); // 难以补全
```

##### 2. 使用类型注解#

使用类型注解提高补全质量：

```
typescript复制// 好的代码
const user: User = getUser();
user. // 准确补全 User 的属性

// 不好的代码
const user = getUser();
user. // 可能补全不准确
```

```
// 好的代码
const user: User = getUser();
user. // 准确补全 User 的属性

// 不好的代码
const user = getUser();
user. // 可能补全不准确
```

##### 3. 合理命名#

使用有意义的命名：

```
typescript复制// 好的命名
const users = getUsers();
users.map(user => user.name); // 补全 user.name

// 不好的命名
const u = getUsers();
u.map(x => x.n); // 难以理解
```

```
// 好的命名
const users = getUsers();
users.map(user => user.name); // 补全 user.name

// 不好的命名
const u = getUsers();
u.map(x => x.n); // 难以理解
```

##### 4. 保持代码一致性#

保持代码风格一致：

```
typescript复制// 一致的风格
const users = getUsers();
for (const user of users) {
  console.log(user.name);
}

// 不一致的风格
const users = getUsers();
for (let i = 0; i < users.length; i++) {
  console.log(users[i].name);
}
```

```
// 一致的风格
const users = getUsers();
for (const user of users) {
  console.log(user.name);
}

// 不一致的风格
const users = getUsers();
for (let i = 0; i < users.length; i++) {
  console.log(users[i].name);
}
```

#### 常见问题#

##### Q: 代码补全不工作怎么办？#

A: 检查以下设置：

```
json复制// 确保启用了代码补全
{
  "editor.quickSuggestions": {
    "other": true
  }
}
```

```
// 确保启用了代码补全
{
  "editor.quickSuggestions": {
    "other": true
  }
}
```

##### Q: 如何提高代码补全质量？#

A: 提高代码补全质量的方法：

True. 使用类型注解
True. 保持代码简洁
True. 使用有意义的命名
True. 保持代码一致性

##### Q: 如何自定义代码补全？#

A: 创建自定义代码片段：

```
json复制// snippets/typescript.json
{
  "React Component": {
    "prefix": "rc",
    "body": [
      "import React from 'react';",
      "",
      "interface ${1:ComponentName}Props {",
      "  ${2}",
      "}",
      "",
      "export const ${1:ComponentName} = (props: ${1:ComponentName}Props) => {",
      "  return (",
      "    <div>",
      "      ${0}",
      "    </div>",
      "  );",
      "}"
    ],
    "description": "React Component"
  }
}
```

```
// snippets/typescript.json
{
  "React Component": {
    "prefix": "rc",
    "body": [
      "import React from 'react';",
      "",
      "interface ${1:ComponentName}Props {",
      "  ${2}",
      "}",
      "",
      "export const ${1:ComponentName} = (props: ${1:ComponentName}Props) => {",
      "  return (",
      "    <div>",
      "      ${0}",
      "    </div>",
      "  );",
      "}"
    ],
    "description": "React Component"
  }
}
```

#### 代码补全与 AI#

##### 1. AI 辅助补全#

AI 辅助代码补全的优势：

- 理解上下文
- 提供智能建议
- 生成复杂代码
- 支持多种语言

##### 2. 未来发展#

代码补全的未来发展方向：

- 更智能的上下文理解
- 更准确的代码建议
- 支持更多编程语言
- 集成更多开发工具

#### 总结#

智能代码补全是提高开发效率的重要工具，能够显著减少编码时间和错误。通过理解代码补全的原理、使用方法和最佳实践，可以充分发挥 Claude Code 的代码补全功能，提高开发效率和代码质量。

下一章将介绍代码理解与重构功能，帮助开发者更好地理解和改进现有代码。

---

## 3 代码生成最佳实践

**URL**: https://claudecode.tangshuang.net/course/23.3%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5

#### 概述#

代码生成是 Claude Code 的核心功能之一，能够显著提高开发效率。本章节将详细介绍代码生成的最佳实践，帮助开发者生成高质量、可维护的代码。

#### 需求描述最佳实践#

##### 1. 明确需求#

提供清晰、明确的需求描述：

```
bash复制// 好的需求
"生成一个 TypeScript 函数，用于验证电子邮件地址格式"

// 更好的需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试"

// 最佳需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试，符合 Airbnb 编码规范"
```

```
// 好的需求
"生成一个 TypeScript 函数，用于验证电子邮件地址格式"

// 更好的需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试"

// 最佳需求
"生成一个 TypeScript 函数，使用正则表达式验证电子邮件地址格式，返回布尔值，包含单元测试，符合 Airbnb 编码规范"
```

##### 2. 提供上下文#

提供代码上下文信息：

```
bash复制// 提供上下文
"我有一个 User 接口：
interface User {
```

```
// 提供上下文
"我有一个 User 接口：
interface User {
```

id: string;
name: string;
email: string;
}

生成一个函数，将 User 对象转换为 JSON 字符串"

```
bash复制
### 3. 指定技术栈

明确指定技术栈和版本：
```

```
### 3. 指定技术栈

明确指定技术栈和版本：
```

// 指定技术栈
"使用 React 18 和 TypeScript 生成一个 TodoList 组件，包含添加、删除、切换完成状态功能"

```
bash复制
### 4. 要求测试

要求生成测试代码：
```

```
### 4. 要求测试

要求生成测试代码：
```

// 要求测试
"生成一个 TypeScript 函数，用于计算斐波那契数列，包含单元测试"

```
bash复制
### 5. 定义输出格式

定义代码的输出格式：
```

```
### 5. 定义输出格式

定义代码的输出格式：
```

// 定义输出格式
"生成一个 TypeScript 函数，用于验证密码强度，返回包含验证结果和错误信息的对象，使用 JSDoc 注释"

```
bash复制
## 代码质量最佳实践

### 1. 代码审查

生成代码后进行审查：

```typescript
// 生成的代码
function calculateTotal(prices: number[]): number {
  let total = 0;
  for (const price of prices) {
    total += price;
  }
  return total;
}

// 审查后优化
function calculateTotal(prices: number[]): number {
  return prices.reduce((total, price) => total + price, 0);
}
```

```
## 代码质量最佳实践

### 1. 代码审查

生成代码后进行审查：

```typescript
// 生成的代码
function calculateTotal(prices: number[]): number {
  let total = 0;
  for (const price of prices) {
    total += price;
  }
  return total;
}

// 审查后优化
function calculateTotal(prices: number[]): number {
  return prices.reduce((total, price) => total + price, 0);
}
```

##### 2. 代码格式化#

使用代码格式化工具：

```
bash复制# 使用 Prettier 格式化
npx prettier --write code.ts
```

```
# 使用 Prettier 格式化
npx prettier --write code.ts
```

##### 3. 类型检查#

使用 TypeScript 进行类型检查：

```
bash复制# 类型检查
npx tsc --noEmit code.ts
```

```
# 类型检查
npx tsc --noEmit code.ts
```

##### 4. 代码分析#

使用代码分析工具：

```
bash复制# 使用 ESLint 分析
npx eslint code.ts
```

```
# 使用 ESLint 分析
npx eslint code.ts
```

#### 代码生成策略#

##### 1. 分步骤生成#

分步骤生成复杂代码：

```
bash复制1. 生成数据模型
2. 生成业务逻辑
3. 生成 API 接口
4. 生成测试代码
```

```
1. 生成数据模型
2. 生成业务逻辑
3. 生成 API 接口
4. 生成测试代码
```

##### 2. 迭代优化#

迭代优化生成的代码：

```
bash复制// 初始需求
"生成一个 TypeScript 函数，用于验证密码强度"

// 迭代优化
"优化密码强度验证函数，增加对特殊字符的要求"
```

```
// 初始需求
"生成一个 TypeScript 函数，用于验证密码强度"

// 迭代优化
"优化密码强度验证函数，增加对特殊字符的要求"
```

##### 3. 模块化生成#

模块化生成代码：

```
bash复制// 模块化生成
"生成一个用户管理模块，包含用户列表、用户详情、用户创建、用户编辑、用户删除功能"
```

```
// 模块化生成
"生成一个用户管理模块，包含用户列表、用户详情、用户创建、用户编辑、用户删除功能"
```

##### 4. 复用生成#

复用生成的代码：

```
bash复制// 复用生成
"使用之前生成的 User 接口，生成一个用户管理 API 客户端"
```

```
// 复用生成
"使用之前生成的 User 接口，生成一个用户管理 API 客户端"
```

#### 代码生成技巧#

##### 1. 使用示例代码#

提供示例代码作为参考：

```
bash复制// 提供示例代码
"参考以下代码风格：
function add(a: number, b: number): number {
  return a + b;
}

生成一个减法函数"
```

```
// 提供示例代码
"参考以下代码风格：
function add(a: number, b: number): number {
  return a + b;
}

生成一个减法函数"
```

##### 2. 指定编码规范#

指定编码规范：

```
bash复制// 指定编码规范
"生成一个 TypeScript 函数，符合 Airbnb 编码规范，使用箭头函数风格"
```

```
// 指定编码规范
"生成一个 TypeScript 函数，符合 Airbnb 编码规范，使用箭头函数风格"
```

##### 3. 要求性能优化#

要求性能优化：

```
bash复制// 要求性能优化
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

```
// 要求性能优化
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

##### 4. 要求安全性#

要求安全性：

```
bash复制// 要求安全性
"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

```
// 要求安全性
"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

#### 代码生成工具链#

##### 1. 集成开发环境#

使用集成开发环境：

- VS Code：支持 Claude Code 插件
- JetBrains IDEs：支持 Claude Code 插件
- Sublime Text：支持 Claude Code 插件

##### 2. 代码生成工具#

使用代码生成工具：

```
bash复制# 使用 OpenAPI Generator
npx @openapitools/openapi-generator-cli generate \
  -i openapi.yaml \
  -g typescript-axios \
  -o src/api
```

```
# 使用 OpenAPI Generator
npx @openapitools/openapi-generator-cli generate \
  -i openapi.yaml \
  -g typescript-axios \
  -o src/api
```

##### 3. 自动化脚本#

使用自动化脚本：

```
bash复制# 使用 Shell 脚本
#!/bin/bash

# 生成数据模型
node generate-model.js

# 生成 API 接口
node generate-api.js

# 生成测试代码
node generate-test.js
```

```
# 使用 Shell 脚本
#!/bin/bash

# 生成数据模型
node generate-model.js

# 生成 API 接口
node generate-api.js

# 生成测试代码
node generate-test.js
```

#### 代码生成可维护性#

##### 1. 代码注释#

要求生成注释：

```
bash复制// 要求注释
"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

```
// 要求注释
"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

##### 2. 文档生成#

要求生成文档：

```
bash复制// 要求文档
"生成一个 TypeScript 函数，包含 API 文档和使用示例"
```

```
// 要求文档
"生成一个 TypeScript 函数，包含 API 文档和使用示例"
```

##### 3. 版本控制#

使用版本控制：

```
bash复制# 提交生成的代码
git add .
git commit -m "Add generated code"
```

```
# 提交生成的代码
git add .
git commit -m "Add generated code"
```

##### 4. 代码审查#

进行代码审查：

```
bash复制# 使用 GitHub Pull Request
git pull request create
```

```
# 使用 GitHub Pull Request
git pull request create
```

#### 代码生成安全性#

##### 1. 输入验证#

要求输入验证：

```
bash复制// 要求输入验证
"生成一个 TypeScript 函数，用于处理用户输入，包含输入验证和错误处理"
```

```
// 要求输入验证
"生成一个 TypeScript 函数，用于处理用户输入，包含输入验证和错误处理"
```

##### 2. 防止攻击#

要求防止攻击：

```
bash复制// 要求防止攻击
"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

```
// 要求防止攻击
"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

##### 3. 权限控制#

要求权限控制：

```
bash复制// 要求权限控制
"生成一个 TypeScript 函数，用于处理用户请求，包含权限控制和身份验证"
```

```
// 要求权限控制
"生成一个 TypeScript 函数，用于处理用户请求，包含权限控制和身份验证"
```

#### 代码生成性能#

##### 1. 性能优化#

要求性能优化：

```
bash复制// 要求性能优化
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

```
// 要求性能优化
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

##### 2. 内存优化#

要求内存优化：

```
bash复制// 要求内存优化
"生成一个 TypeScript 函数，用于处理大型数据集，内存占用不超过 100MB"
```

```
// 要求内存优化
"生成一个 TypeScript 函数，用于处理大型数据集，内存占用不超过 100MB"
```

##### 3. 并发处理#

要求并发处理：

```
bash复制// 要求并发处理
"生成一个 TypeScript 函数，用于处理并发请求，支持异步操作"
```

```
// 要求并发处理
"生成一个 TypeScript 函数，用于处理并发请求，支持异步操作"
```

#### 代码生成测试#

##### 1. 单元测试#

要求单元测试：

```
bash复制// 要求单元测试
"生成一个 TypeScript 函数，包含单元测试"
```

```
// 要求单元测试
"生成一个 TypeScript 函数，包含单元测试"
```

##### 2. 集成测试#

要求集成测试：

```
bash复制// 要求集成测试
"生成一个 TypeScript 函数，包含集成测试"
```

```
// 要求集成测试
"生成一个 TypeScript 函数，包含集成测试"
```

##### 3. 端到端测试#

要求端到端测试：

```
bash复制// 要求端到端测试
"生成一个 TypeScript 函数，包含端到端测试"
```

```
// 要求端到端测试
"生成一个 TypeScript 函数，包含端到端测试"
```

##### 4. 性能测试#

要求性能测试：

```
bash复制// 要求性能测试
"生成一个 TypeScript 函数，包含性能测试"
```

```
// 要求性能测试
"生成一个 TypeScript 函数，包含性能测试"
```

#### 常见问题#

##### Q: 如何生成符合特定风格的代码？#

A: 指定代码风格要求：

```
bash复制"生成一个 TypeScript 函数，使用箭头函数风格，符合 Airbnb 编码规范"
```

```
"生成一个 TypeScript 函数，使用箭头函数风格，符合 Airbnb 编码规范"
```

##### Q: 如何生成可维护的代码？#

A: 要求生成注释和文档：

```
bash复制"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

```
"生成一个 TypeScript 函数，包含 JSDoc 注释和使用示例"
```

##### Q: 如何生成性能优化的代码？#

A: 指定性能要求：

```
bash复制"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

```
"生成一个 TypeScript 函数，用于处理大型数组，时间复杂度不超过 O(n log n)"
```

##### Q: 如何生成安全的代码？#

A: 要求安全性：

```
bash复制"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

```
"生成一个 TypeScript 函数，用于处理用户输入，防止 SQL 注入和 XSS 攻击"
```

#### 最佳实践总结#

##### 1. 需求描述#

- 提供清晰、明确的需求描述
- 提供代码上下文信息
- 指定技术栈和版本
- 要求测试代码
- 定义输出格式

##### 2. 代码质量#

- 生成代码后进行审查
- 使用代码格式化工具
- 使用类型检查工具
- 使用代码分析工具

##### 3. 生成策略#

- 分步骤生成复杂代码
- 迭代优化生成的代码
- 模块化生成代码
- 复用生成的代码

##### 4. 可维护性#

- 要求生成注释
- 要求生成文档
- 使用版本控制
- 进行代码审查

##### 5. 安全性#

- 要求输入验证
- 要求防止攻击
- 要求权限控制

##### 6. 性能#

- 要求性能优化
- 要求内存优化
- 要求并发处理

##### 7. 测试#

- 要求单元测试
- 要求集成测试
- 要求端到端测试
- 要求性能测试

#### 总结#

代码生成是 Claude Code 的核心功能之一，能够显著提高开发效率。通过遵循最佳实践，可以生成高质量、可维护、安全、性能优化的代码。同时，需要注意代码的可维护性、安全性、性能和测试，确保生成的代码符合项目要求。

下一章将介绍代码理解与重构功能，帮助开发者更好地理解和改进现有代码。

---

# 第 24 章

## 1 高级代码生成技巧

**URL**: https://claudecode.tangshuang.net/course/27.1%20%E9%AB%98%E7%BA%A7%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E5%B7%A7

#### 高级代码生成概述#

Claude Code 不仅能生成简单的代码片段，还能处理复杂的代码生成任务。通过掌握高级代码生成技巧，开发者可以更高效地利用 Claude Code 完成复杂的编程任务。

#### 上下文感知生成#

##### 1. 项目上下文利用#

### 示例：利用项目上下文生成代码

用户请求：
"为我们的 Flask 应用添加一个用户认证系统，使用 JWT token"

Claude Code 会：

True. 分析项目结构
True. 识别现有的用户模型
True. 检查已安装的依赖
True. 生成符合项目风格的代码

生成的代码：

```
python复制````python

# app/auth.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token, jwt_required
from app.models import User
from app.utils import validate_password

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
"""用户登录"""
data = request.get_json()

 # 验证用户
user = User.query.filter_by(email=data.get('email')).first()
if not user or not validate_password(user, data.get('password')):
return jsonify({'error': 'Invalid credentials'}), 401

 # 生成 token
access_token = create_access_token(identity=user.id)

return jsonify({
'access_token': access_token,
'user': user.to_dict()
})

@auth_bp.route('/protected', methods=['GET'])
@jwt_required()
def protected():
"""受保护的路由"""
return jsonify({'message': 'Access granted'})

```> > ```

### 2. 代码风格一致性

# 示例：保持代码风格一致
用户请求：
"添加一个用户注册端点"
Claude Code 会：

生成的代码：
````python
`python

@auth_bp.route('/register', methods=['POST'])
def register():
"""用户注册"""
data = request.get_json()

 # 验证输入
if not data.get('email') or not data.get('password'):
return jsonify({'error': 'Missing required fields'}), 400

 # 检查用户是否已存在
if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'User already exists'}), 409

 # 创建新用户
user = User(
email=data['email'],
password_hash=hash_password(data['password'])
)
db.session.add(user)
db.session.commit()

 # 生成 token
access_token = create_access_token(identity=user.id)

return jsonify({
'access_token': access_token,
'user': user.to_dict()
}), 201

```> >

```
## 模式驱动生成

### 1. 设计模式应用

# 示例：应用设计模式
用户请求：
"使用单例模式实现一个配置管理器"
生成的代码：
````python
`python

# app/config_manager.py
```

```
````python

# app/auth.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token, jwt_required
from app.models import User
from app.utils import validate_password

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
"""用户登录"""
data = request.get_json()

 # 验证用户
user = User.query.filter_by(email=data.get('email')).first()
if not user or not validate_password(user, data.get('password')):
return jsonify({'error': 'Invalid credentials'}), 401

 # 生成 token
access_token = create_access_token(identity=user.id)

return jsonify({
'access_token': access_token,
'user': user.to_dict()
})

@auth_bp.route('/protected', methods=['GET'])
@jwt_required()
def protected():
"""受保护的路由"""
return jsonify({'message': 'Access granted'})

```> > ```

### 2. 代码风格一致性

# 示例：保持代码风格一致
用户请求：
"添加一个用户注册端点"
Claude Code 会：

生成的代码：
````python
`python

@auth_bp.route('/register', methods=['POST'])
def register():
"""用户注册"""
data = request.get_json()

 # 验证输入
if not data.get('email') or not data.get('password'):
return jsonify({'error': 'Missing required fields'}), 400

 # 检查用户是否已存在
if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'User already exists'}), 409

 # 创建新用户
user = User(
email=data['email'],
password_hash=hash_password(data['password'])
)
db.session.add(user)
db.session.commit()

 # 生成 token
access_token = create_access_token(identity=user.id)

return jsonify({
'access_token': access_token,
'user': user.to_dict()
}), 201

```> >

```
## 模式驱动生成

### 1. 设计模式应用

# 示例：应用设计模式
用户请求：
"使用单例模式实现一个配置管理器"
生成的代码：
````python
`python

# app/config_manager.py
```

from typing import Dict, Any
import threading

class ConfigManager:
"""配置管理器（单例模式）"""

_instance = None
_lock = threading.Lock()

def new(cls):
"""确保只有一个实例"""
if cls._instance is None:
with cls._lock:
if cls._instance is None:
cls._instance = super().new(cls)
cls._instance._config = {}
return cls._instance

def get(self, key: str, default: Any = None) -> Any:
"""获取配置"""
return self._config.get(key, default)

def set(self, key: str, value: Any):
"""设置配置"""
self._config[key] = value

def load_from_dict(self, config_dict: Dict[str, Any]):
"""从字典加载配置"""
self._config.update(config_dict)

def load_from_file(self, file_path: str):
"""从文件加载配置"""
import yaml
with open(file_path, 'r') as f:
config = yaml.safe_load(f)
self.load_from_dict(config)

def to_dict(self) -> Dict[str, Any]:
"""转换为字典"""
return self._config.copy()

### 使用示例

config = ConfigManager()
config.set('debug', True)
config.set('database_url', 'postgresql://localhost/mydb')

```
> >
```

##### 2. 架构模式实现#

### 示例：实现 MVC 架构

用户请求：
"为我们的应用实现 MVC 架构"
生成的代码结构：

```
bash复制``> > app/
├── models/          # Model 层
│   ├── __init__.py
│   ├── user.py
│   └── product.py
├── views/           # View 层
│   ├── __init__.py
│   ├── user_views.py
│   └── product_views.py
├── controllers/      # Controller 层
│   ├── __init__.py
│   ├── user_controller.py
│   └── product_controller.py
└── templates/        # 模板
├── user/
└── product/
```

```
``> > app/
├── models/          # Model 层
│   ├── __init__.py
│   ├── user.py
│   └── product.py
├── views/           # View 层
│   ├── __init__.py
│   ├── user_views.py
│   └── product_views.py
├── controllers/      # Controller 层
│   ├── __init__.py
│   ├── user_controller.py
│   └── product_controller.py
└── templates/        # 模板
├── user/
└── product/
```

生成的代码：

```
python复制python

# app/models/user.py
from app import db
from datetime import datetime

class User(db.Model):
    """用户模型"""
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        """转换为字典"""
        return {
            'id': self.id,
            'email': self.email,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

# app/controllers/user_controller.py
from app.models import User
from app.utils import hash_password, validate_password

class UserController:
    """用户控制器"""

    @staticmethod
    def create_user(email: str, password: str) -> User:
        """创建用户"""
        user = User(
            email=email,
            password_hash=hash_password(password)
        )
        db.session.add(user)
        db.session.commit()
        return user

    @staticmethod
    def get_user(user_id: int) -> User:
        """获取用户"""
        return User.query.get(user_id)

    @staticmethod
    def authenticate_user(email: str, password: str) -> User:
        """验证用户"""
        user = User.query.filter_by(email=email).first()
        if user and validate_password(user, password):
            return user
        return None

# app/views/user_views.py
from flask import Blueprint, request, jsonify
from app.controllers.user_controller import UserController

user_bp = Blueprint('users', __name__)

@user_bp.route('/users', methods=['POST'])
def create_user():
    """创建用户"""
    data = request.get_json()
    user = UserController.create_user(
        email=data['email'],
        password=data['password']
    )
    return jsonify(user.to_dict()), 201

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户"""
    user = UserController.get_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

## 增量代码生成
### 1. 基于现有代码扩展
```python
python

# 示例：扩展现有功能

用户请求：
"为现有的 Product 模型添加库存管理功能"

现有代码：
```python
```python

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)

生成的扩展代码：

```python

# app/models/product.py
class Product(db.Model):
id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(100), nullable=False)
price = db.Column(db.Float, nullable=False)

 # 新增库存字段
stock_quantity = db.Column(db.Integer, default=0)
reorder_level = db.Column(db.Integer, default=10)
last_restocked_at = db.Column(db.DateTime)

def is_low_stock(self) -> bool:
"""检查库存是否过低"""
return self.stock_quantity <= self.reorder_level

def restock(self, quantity: int):
"""补货"""
self.stock_quantity += quantity
self.last_restocked_at = datetime.utcnow()
db.session.commit()

def reduce_stock(self, quantity: int) -> bool:
"""减少库存"""
if self.stock_quantity >= quantity:
self.stock_quantity -= quantity
db.session.commit()
return True
return False

# app/controllers/product_controller.py
class ProductController:
@staticmethod
def get_low_stock_products():
"""获取库存过低的产品"""
return Product.query.filter(
Product.stock_quantity <= Product.reorder_level
).all()

@staticmethod
def restock_product(product_id: int, quantity: int):
"""补货产品"""
product = Product.query.get(product_id)
if product:
product.restock(quantity)
return product
return None

### 2. 功能迭代生成

# 示例：迭代式功能开发
用户请求：
"第一步：创建一个基本的 API 端点来获取产品列表"
生成的代码：
````python
`python

@product_bp.route('/products', methods=['GET'])
def get_products():
"""获取产品列表"""
products = Product.query.all()
return jsonify([p.to_dict() for p in products])

用户请求：
"第二步：添加分页功能"

生成的更新代码：
```python
python

@product_bp.route('/products', methods=['GET'])
def get_products():
    """获取产品列表（带分页）"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    pagination = Product.query.paginate(
        page=page,
        per_page=per_page,
        error_out=False
    )

    return jsonify({
        'products': [p.to_dict() for p in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page
    })

用户请求：
"第三步：添加搜索和过滤功能"

生成的更新代码：

```python

@product_bp.route('/products', methods=['GET'])
def get_products():
"""获取产品列表（带分页、搜索和过滤）"""
page = request.args.get('page', 1, type=int)
per_page = request.args.get('per_page', 10, type=int)
search = request.args.get('search', '')
min_price = request.args.get('min_price', type=float)
max_price = request.args.get('max_price', type=float)

query = Product.query

 # 搜索
if search:
query = query.filter(Product.name.ilike(f'%{search}%'))

 # 价格过滤
if min_price:
query = query.filter(Product.price >= min_price)
if max_price:
query = query.filter(Product.price <= max_price)

 # 分页
pagination = query.paginate(
page=page,
per_page=per_page,
error_out=False
)

return jsonify({
'products': [p.to_dict() for p in pagination.items],
'total': pagination.total,
'pages': pagination.pages,
'current_page': page
})

## 代码重构生成

### 1. 代码简化

# 示例：简化复杂代码
用户请求：
"简化这个函数，使其更易读和维护"
原始代码：
````python
`python

def process_order(order_data):
result = {}
if 'items' in order_data:
items = order_data['items']
total = 0
for item in items:
if 'price' in item and 'quantity' in item:
total = total + item['price'] * item['quantity']
result['total'] = total
if 'customer' in order_data:
result['customer'] = order_data['customer']
if 'shipping' in order_data:
result['shipping'] = order_data['shipping']
return result

生成的简化代码：
```python
python

def calculate_item_total(items: list) -> float:
    """计算商品总价"""
    return sum(
        item['price'] * item['quantity']
        for item in items
        if 'price' in item and 'quantity' in item
    )

def process_order(order_data: dict) -> dict:
    """处理订单"""
    result = {}

    if 'items' in order_data:
        result['total'] = calculate_item_total(order_data['items'])

    if 'customer' in order_data:
        result['customer'] = order_data['customer']

    if 'shipping' in order_data:
        result['shipping'] = order_data['shipping']

    return result

### 2. 设计模式应用
```python
python

# 示例：应用策略模式

用户请求：
"使用策略模式重构支付处理逻辑"

原始代码：
```python
```python

def process_payment(payment_type, amount, details):
    if payment_type == 'credit_card':
        # 处理信用卡支付
        pass
    elif payment_type == 'paypal':
        # 处理 PayPal 支付
        pass
    elif payment_type == 'bank_transfer':
        # 处理银行转账
        pass

生成的重构代码：

```python

from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
"""支付策略基类"""

@abstractmethod
def process(self, amount: float, details: dict) -> dict:
"""处理支付"""
pass

class CreditCardPayment(PaymentStrategy):
"""信用卡支付策略"""

def process(self, amount: float, details: dict) -> dict:
card_number = details.get('card_number')
expiry = details.get('expiry')
cvv = details.get('cvv')

 # 处理信用卡支付逻辑
return {
'status': 'success',
'payment_method': 'credit_card',
'amount': amount
}

class PayPalPayment(PaymentStrategy):
"""PayPal 支付策略"""

def process(self, amount: float, details: dict) -> dict:
email = details.get('email')
password = details.get('password')

 # 处理 PayPal 支付逻辑
return {
'status': 'success',
'payment_method': 'paypal',
'amount': amount
}

class BankTransferPayment(PaymentStrategy):
"""银行转账策略"""

def process(self, amount: float, details: dict) -> dict:
account_number = details.get('account_number')
routing_number = details.get('routing_number')

 # 处理银行转账逻辑
return {
'status': 'success',
'payment_method': 'bank_transfer',
'amount': amount
}

class PaymentProcessor:
"""支付处理器"""

def __init__(self):
self.strategies = {
'credit_card': CreditCardPayment(),
'paypal': PayPalPayment(),
'bank_transfer': BankTransferPayment()
}

def process_payment(self, payment_type: str, amount: float, details: dict) -> dict:
"""处理支付"""
strategy = self.strategies.get(payment_type)
if not strategy:
raise ValueError(f"Unsupported payment type: {payment_type}")

return strategy.process(amount, details)

# 使用示例
processor = PaymentProcessor()
result = processor.process_payment('credit_card', 100.0, {
'card_number': '4111111111111111',
'expiry': '12/25',
'cvv': '123'
})

## 总结

高级代码生成技巧包括：

1. **上下文感知生成**：利用项目上下文和代码风格
2. **模式驱动生成**：应用设计模式和架构模式
3. **增量代码生成**：基于现有代码扩展和迭代
4. **代码重构生成**：简化代码和应用设计模式

通过掌握这些技巧，开发者可以更高效地利用 Claude Code 完成复杂的编程任务。

在下一节中，我们将探讨复杂系统的设计与实现。
```

```
python

# app/models/user.py
from app import db
from datetime import datetime

class User(db.Model):
    """用户模型"""
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        """转换为字典"""
        return {
            'id': self.id,
            'email': self.email,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

# app/controllers/user_controller.py
from app.models import User
from app.utils import hash_password, validate_password

class UserController:
    """用户控制器"""

    @staticmethod
    def create_user(email: str, password: str) -> User:
        """创建用户"""
        user = User(
            email=email,
            password_hash=hash_password(password)
        )
        db.session.add(user)
        db.session.commit()
        return user

    @staticmethod
    def get_user(user_id: int) -> User:
        """获取用户"""
        return User.query.get(user_id)

    @staticmethod
    def authenticate_user(email: str, password: str) -> User:
        """验证用户"""
        user = User.query.filter_by(email=email).first()
        if user and validate_password(user, password):
            return user
        return None

# app/views/user_views.py
from flask import Blueprint, request, jsonify
from app.controllers.user_controller import UserController

user_bp = Blueprint('users', __name__)

@user_bp.route('/users', methods=['POST'])
def create_user():
    """创建用户"""
    data = request.get_json()
    user = UserController.create_user(
        email=data['email'],
        password=data['password']
    )
    return jsonify(user.to_dict()), 201

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户"""
    user = UserController.get_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

## 增量代码生成
### 1. 基于现有代码扩展
```python
python

# 示例：扩展现有功能

用户请求：
"为现有的 Product 模型添加库存管理功能"

现有代码：
```python
```python

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)

生成的扩展代码：

```python

# app/models/product.py
class Product(db.Model):
id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(100), nullable=False)
price = db.Column(db.Float, nullable=False)

 # 新增库存字段
stock_quantity = db.Column(db.Integer, default=0)
reorder_level = db.Column(db.Integer, default=10)
last_restocked_at = db.Column(db.DateTime)

def is_low_stock(self) -> bool:
"""检查库存是否过低"""
return self.stock_quantity <= self.reorder_level

def restock(self, quantity: int):
"""补货"""
self.stock_quantity += quantity
self.last_restocked_at = datetime.utcnow()
db.session.commit()

def reduce_stock(self, quantity: int) -> bool:
"""减少库存"""
if self.stock_quantity >= quantity:
self.stock_quantity -= quantity
db.session.commit()
return True
return False

# app/controllers/product_controller.py
class ProductController:
@staticmethod
def get_low_stock_products():
"""获取库存过低的产品"""
return Product.query.filter(
Product.stock_quantity <= Product.reorder_level
).all()

@staticmethod
def restock_product(product_id: int, quantity: int):
"""补货产品"""
product = Product.query.get(product_id)
if product:
product.restock(quantity)
return product
return None

### 2. 功能迭代生成

# 示例：迭代式功能开发
用户请求：
"第一步：创建一个基本的 API 端点来获取产品列表"
生成的代码：
````python
`python

@product_bp.route('/products', methods=['GET'])
def get_products():
"""获取产品列表"""
products = Product.query.all()
return jsonify([p.to_dict() for p in products])

用户请求：
"第二步：添加分页功能"

生成的更新代码：
```python
python

@product_bp.route('/products', methods=['GET'])
def get_products():
    """获取产品列表（带分页）"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    pagination = Product.query.paginate(
        page=page,
        per_page=per_page,
        error_out=False
    )

    return jsonify({
        'products': [p.to_dict() for p in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page
    })

用户请求：
"第三步：添加搜索和过滤功能"

生成的更新代码：

```python

@product_bp.route('/products', methods=['GET'])
def get_products():
"""获取产品列表（带分页、搜索和过滤）"""
page = request.args.get('page', 1, type=int)
per_page = request.args.get('per_page', 10, type=int)
search = request.args.get('search', '')
min_price = request.args.get('min_price', type=float)
max_price = request.args.get('max_price', type=float)

query = Product.query

 # 搜索
if search:
query = query.filter(Product.name.ilike(f'%{search}%'))

 # 价格过滤
if min_price:
query = query.filter(Product.price >= min_price)
if max_price:
query = query.filter(Product.price <= max_price)

 # 分页
pagination = query.paginate(
page=page,
per_page=per_page,
error_out=False
)

return jsonify({
'products': [p.to_dict() for p in pagination.items],
'total': pagination.total,
'pages': pagination.pages,
'current_page': page
})

## 代码重构生成

### 1. 代码简化

# 示例：简化复杂代码
用户请求：
"简化这个函数，使其更易读和维护"
原始代码：
````python
`python

def process_order(order_data):
result = {}
if 'items' in order_data:
items = order_data['items']
total = 0
for item in items:
if 'price' in item and 'quantity' in item:
total = total + item['price'] * item['quantity']
result['total'] = total
if 'customer' in order_data:
result['customer'] = order_data['customer']
if 'shipping' in order_data:
result['shipping'] = order_data['shipping']
return result

生成的简化代码：
```python
python

def calculate_item_total(items: list) -> float:
    """计算商品总价"""
    return sum(
        item['price'] * item['quantity']
        for item in items
        if 'price' in item and 'quantity' in item
    )

def process_order(order_data: dict) -> dict:
    """处理订单"""
    result = {}

    if 'items' in order_data:
        result['total'] = calculate_item_total(order_data['items'])

    if 'customer' in order_data:
        result['customer'] = order_data['customer']

    if 'shipping' in order_data:
        result['shipping'] = order_data['shipping']

    return result

### 2. 设计模式应用
```python
python

# 示例：应用策略模式

用户请求：
"使用策略模式重构支付处理逻辑"

原始代码：
```python
```python

def process_payment(payment_type, amount, details):
    if payment_type == 'credit_card':
        # 处理信用卡支付
        pass
    elif payment_type == 'paypal':
        # 处理 PayPal 支付
        pass
    elif payment_type == 'bank_transfer':
        # 处理银行转账
        pass

生成的重构代码：

```python

from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
"""支付策略基类"""

@abstractmethod
def process(self, amount: float, details: dict) -> dict:
"""处理支付"""
pass

class CreditCardPayment(PaymentStrategy):
"""信用卡支付策略"""

def process(self, amount: float, details: dict) -> dict:
card_number = details.get('card_number')
expiry = details.get('expiry')
cvv = details.get('cvv')

 # 处理信用卡支付逻辑
return {
'status': 'success',
'payment_method': 'credit_card',
'amount': amount
}

class PayPalPayment(PaymentStrategy):
"""PayPal 支付策略"""

def process(self, amount: float, details: dict) -> dict:
email = details.get('email')
password = details.get('password')

 # 处理 PayPal 支付逻辑
return {
'status': 'success',
'payment_method': 'paypal',
'amount': amount
}

class BankTransferPayment(PaymentStrategy):
"""银行转账策略"""

def process(self, amount: float, details: dict) -> dict:
account_number = details.get('account_number')
routing_number = details.get('routing_number')

 # 处理银行转账逻辑
return {
'status': 'success',
'payment_method': 'bank_transfer',
'amount': amount
}

class PaymentProcessor:
"""支付处理器"""

def __init__(self):
self.strategies = {
'credit_card': CreditCardPayment(),
'paypal': PayPalPayment(),
'bank_transfer': BankTransferPayment()
}

def process_payment(self, payment_type: str, amount: float, details: dict) -> dict:
"""处理支付"""
strategy = self.strategies.get(payment_type)
if not strategy:
raise ValueError(f"Unsupported payment type: {payment_type}")

return strategy.process(amount, details)

# 使用示例
processor = PaymentProcessor()
result = processor.process_payment('credit_card', 100.0, {
'card_number': '4111111111111111',
'expiry': '12/25',
'cvv': '123'
})

## 总结

高级代码生成技巧包括：

1. **上下文感知生成**：利用项目上下文和代码风格
2. **模式驱动生成**：应用设计模式和架构模式
3. **增量代码生成**：基于现有代码扩展和迭代
4. **代码重构生成**：简化代码和应用设计模式

通过掌握这些技巧，开发者可以更高效地利用 Claude Code 完成复杂的编程任务。

在下一节中，我们将探讨复杂系统的设计与实现。
```

---

## 2 复杂系统设计与实现

**URL**: https://claudecode.tangshuang.net/course/27.2%20%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0

#### 复杂系统设计概述#

Claude Code 可以帮助开发者设计和实现复杂的软件系统。通过系统化的设计方法和分阶段的实现策略，开发者可以利用 Claude Code 构建可扩展、可维护的复杂系统。

#### 系统架构设计#

##### 1. 微服务架构#

### 示例：设计微服务架构

用户请求：
"设计一个电商系统的微服务架构"

Claude Code 生成的架构设计：

#### 系统架构#

```
bash复制│                        API Gateway                          │
│  (负载均衡、认证、路由、限流、监控)                           │
└─────────────────────────────────────────────────────────────┘
│
┌─────────────────────┼─────────────────────┐
│                     │                     │
┌───────▼────────┐  ┌────────▼────────┐  ┌────────▼────────┐
│  User Service  │  │ Product Service │  │ Order Service   │
│  - 用户管理     │  │  - 商品管理      │  │  - 订单管理      │
│  - 认证授权     │  │  - 库存管理      │  │  - 支付处理      │
│  - 个人资料     │  │  - 分类管理      │  │  - 物流跟踪      │
└────────────────┘  └─────────────────┘  └─────────────────┘
│                     │                     │
└─────────────────────┼─────────────────────┘
│
┌─────────────────────┼─────────────────────┐
│                     │                     │
┌───────▼────────┐  ┌────────▼────────┐  ┌────────▼────────┐
│ Payment Service│  │ Inventory      │  │ Notification    │
│  - 支付处理     │  │ Service        │  │ Service         │
│  - 退款处理     │  │  - 库存同步     │  │  - 邮件通知      │
│  - 交易记录     │  │  - 预警管理     │  │  - 短信通知      │
└────────────────┘  └─────────────────┘  └─────────────────┘
│
┌─────────▼─────────┐
│   Message Broker  │
│  (Kafka/RabbitMQ) │
└───────────────────┘
```
## 服务定义

### User Service (用户服务)
```python
python

# services/user_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token
import bcrypt

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/users_db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'

db = SQLAlchemy(app)
jwt = JWTManager(app)

class User(db.Model):
    """用户模型"""
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20))
    created_at = db.Column(db.DateTime, server_default=db.func.now())

    def set_password(self, password):
        """设置密码"""
        self.password_hash = bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

    def check_password(self, password):
        """验证密码"""
        return bcrypt.checkpw(
            password.encode('utf-8'),
            self.password_hash.encode('utf-8')
        )

@app.route('/register', methods=['POST'])
def register():
    """用户注册"""
    data = request.get_json()

    user = User(
        email=data['email'],
        name=data['name'],
        phone=data.get('phone')
    )
    user.set_password(data['password'])

    db.session.add(user)
    db.session.commit()

    return jsonify({'user_id': user.id}), 201

@app.route('/login', methods=['POST'])
def login():
    """用户登录"""
    data = request.get_json()

    user = User.query.filter_by(email=data['email']).first()

    if not user or not user.check_password(data['password']):
        return jsonify({'error': 'Invalid credentials'}), 401

    access_token = create_access_token(identity=user.id)

    return jsonify({
        'access_token': access_token,
        'user': {
            'id': user.id,
            'email': user.email,
            'name': user.name
        }
    })

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户信息"""
    user = User.query.get_or_404(user_id)
    return jsonify({
        'id': user.id,
        'email': user.email,
        'name': user.name,
        'phone': user.phone
    })

### Product Service (商品服务)

```python

# services/product_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/products_db'

db = SQLAlchemy(app)
migrate = Migrate(app, db)

class Product(db.Model):
"""商品模型"""
__tablename__ = 'products'

id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(200), nullable=False)
description = db.Column(db.Text)
price = db.Column(db.Float, nullable=False)
stock = db.Column(db.Integer, default=0)
category_id = db.Column(db.Integer, db.ForeignKey('categories.id'))
created_at = db.Column(db.DateTime, server_default=db.func.now())
```

```
│                        API Gateway                          │
│  (负载均衡、认证、路由、限流、监控)                           │
└─────────────────────────────────────────────────────────────┘
│
┌─────────────────────┼─────────────────────┐
│                     │                     │
┌───────▼────────┐  ┌────────▼────────┐  ┌────────▼────────┐
│  User Service  │  │ Product Service │  │ Order Service   │
│  - 用户管理     │  │  - 商品管理      │  │  - 订单管理      │
│  - 认证授权     │  │  - 库存管理      │  │  - 支付处理      │
│  - 个人资料     │  │  - 分类管理      │  │  - 物流跟踪      │
└────────────────┘  └─────────────────┘  └─────────────────┘
│                     │                     │
└─────────────────────┼─────────────────────┘
│
┌─────────────────────┼─────────────────────┐
│                     │                     │
┌───────▼────────┐  ┌────────▼────────┐  ┌────────▼────────┐
│ Payment Service│  │ Inventory      │  │ Notification    │
│  - 支付处理     │  │ Service        │  │ Service         │
│  - 退款处理     │  │  - 库存同步     │  │  - 邮件通知      │
│  - 交易记录     │  │  - 预警管理     │  │  - 短信通知      │
└────────────────┘  └─────────────────┘  └─────────────────┘
│
┌─────────▼─────────┐
│   Message Broker  │
│  (Kafka/RabbitMQ) │
└───────────────────┘
```
## 服务定义

### User Service (用户服务)
```python
python

# services/user_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token
import bcrypt

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/users_db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'

db = SQLAlchemy(app)
jwt = JWTManager(app)

class User(db.Model):
    """用户模型"""
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20))
    created_at = db.Column(db.DateTime, server_default=db.func.now())

    def set_password(self, password):
        """设置密码"""
        self.password_hash = bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

    def check_password(self, password):
        """验证密码"""
        return bcrypt.checkpw(
            password.encode('utf-8'),
            self.password_hash.encode('utf-8')
        )

@app.route('/register', methods=['POST'])
def register():
    """用户注册"""
    data = request.get_json()

    user = User(
        email=data['email'],
        name=data['name'],
        phone=data.get('phone')
    )
    user.set_password(data['password'])

    db.session.add(user)
    db.session.commit()

    return jsonify({'user_id': user.id}), 201

@app.route('/login', methods=['POST'])
def login():
    """用户登录"""
    data = request.get_json()

    user = User.query.filter_by(email=data['email']).first()

    if not user or not user.check_password(data['password']):
        return jsonify({'error': 'Invalid credentials'}), 401

    access_token = create_access_token(identity=user.id)

    return jsonify({
        'access_token': access_token,
        'user': {
            'id': user.id,
            'email': user.email,
            'name': user.name
        }
    })

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户信息"""
    user = User.query.get_or_404(user_id)
    return jsonify({
        'id': user.id,
        'email': user.email,
        'name': user.name,
        'phone': user.phone
    })

### Product Service (商品服务)

```python

# services/product_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/products_db'

db = SQLAlchemy(app)
migrate = Migrate(app, db)

class Product(db.Model):
"""商品模型"""
__tablename__ = 'products'

id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(200), nullable=False)
description = db.Column(db.Text)
price = db.Column(db.Float, nullable=False)
stock = db.Column(db.Integer, default=0)
category_id = db.Column(db.Integer, db.ForeignKey('categories.id'))
created_at = db.Column(db.DateTime, server_default=db.func.now())
```

updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())

category = db.relationship('Category', backref='products')

class Category(db.Model):
"""分类模型"""
tablename = 'categories'

id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(100), nullable=False)
parent_id = db.Column(db.Integer, db.ForeignKey('categories.id'))

parent = db.relationship('Category', remote_side=[id], backref='children')

@app.route('/products', methods=['POST'])
def create_product():
"""创建商品"""
data = request.get_json()

product = Product(
name=data['name'],
description=data.get('description'),
price=data['price'],
stock=data.get('stock', 0),
category_id=data.get('category_id')
)

db.session.add(product)
db.session.commit()

return jsonify({'product_id': product.id}), 201

@app.route('/products/int:product_id', methods=['GET'])
def get_product(product_id):
"""获取商品详情"""
product = Product.query.get_or_404(product_id)
return jsonify({
'id': product.id,
'name': product.name,
'description': product.description,
'price': product.price,
'stock': product.stock,
'category': product.category.name if product.category else None
})

@app.route('/products/int:product_id/stock', methods=['PUT'])
def update_stock(product_id):
"""更新库存"""
data = request.get_json()

product = Product.query.get_or_404(product_id)
product.stock = data['stock']

db.session.commit()

return jsonify({'stock': product.stock})

##### Order Service (订单服务)#

```
python复制python

# services/order_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import requests

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/orders_db'

db = SQLAlchemy(app)

class Order(db.Model):
    """订单模型"""
    __tablename__ = 'orders'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, server_default=db.func.now())
    updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())

class OrderItem(db.Model):
    """订单项模型"""
    __tablename__ = 'order_items'

    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    product_id = db.Column(db.Integer, nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price = db.Column(db.Float, nullable=False)

    order = db.relationship('Order', backref='items')

@app.route('/orders', methods=['POST'])
def create_order():
    """创建订单"""
    data = request.get_json()

    # 验证商品库存
    for item in data['items']:
        response = requests.get(
            f"http://product-service:5001/products/{item['product_id']}"
        )
        product = response.json()

        if product['stock'] < item['quantity']:
            return jsonify({
                'error': f'Insufficient stock for product {item["product_id"]}'
            }), 400

    # 创建订单
    order = Order(
        user_id=data['user_id'],
        total_amount=0
    )
    db.session.add(order)
    db.session.flush()

    # 创建订单项
    total_amount = 0
    for item in data['items']:
        order_item = OrderItem(
            order_id=order.id,
            product_id=item['product_id'],
            quantity=item['quantity'],
            price=item['price']
        )
        db.session.add(order_item)
        total_amount += item['price'] * item['quantity']

    order.total_amount = total_amount
    db.session.commit()

    # 扣减库存
    for item in data['items']:
        response = requests.get(
            f"http://product-service:5001/products/{item['product_id']}"
        )
        product = response.json()
        new_stock = product['stock'] - item['quantity']

        requests.put(
            f"http://product-service:5001/products/{item['product_id']}/stock",
            json={'stock': new_stock}
        )

    return jsonify({'order_id': order.id}), 201

@app.route('/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    """获取订单详情"""
    order = Order.query.get_or_404(order_id)

    return jsonify({
        'id': order.id,
        'user_id': order.user_id,
        'total_amount': order.total_amount,
        'status': order.status,
        'items': [
            {
                'product_id': item.product_id,
                'quantity': item.quantity,
                'price': item.price
            }
            for item in order.items
        ]
    })

## API Gateway 实现
```python
python

# api_gateway/app.py
from flask import Flask, request, jsonify
import requests
import jwt
from functools import wraps

app = Flask(__name__)

SERVICES = {
    'user': 'http://user-service:5000',
    'product': 'http://product-service:5001',
    'order': 'http://order-service:5002'
}

def authenticate(f):
    """认证装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')

        if not token:
            return jsonify({'error': 'Missing token'}), 401

        try:
            payload = jwt.decode(token.split()[1], 'your-secret-key', algorithms=['HS256'])
            request.user_id = payload['user_id']
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        return f(*args, **kwargs)

    return decorated_function

@app.route('/<service>/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
def proxy(service, path):
    """代理请求到对应的服务"""
    if service not in SERVICES:
        return jsonify({'error': 'Service not found'}), 404

    service_url = SERVICES[service]
    url = f"{service_url}/{path}"

    headers = {key: value for key, value in request.headers if key != 'Host'}

    response = requests.request(
        method=request.method,
        url=url,
        headers=headers,
        json=request.get_json(),
        params=request.args
    )

    return jsonify(response.json()), response.status_code

@app.route('/health')
def health():
    """健康检查"""
    return jsonify({'status': 'healthy'})

```> >
### 2. 事件驱动架构
````python
`python

# 示例：设计事件驱动架构

用户请求：
"设计一个基于事件驱动的订单处理系统"

Claude Code 生成的架构设计：

## 系统架构

```> ┌──────────────┐
│   订单服务    │
│  (Order      │
│   Service)   │
└──────┬───────┘
│ 发布事件
▼
┌─────────────────────────────────────────────────────────────┐
│                    Message Broker                           │
│                    (Kafka/RabbitMQ)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 订单创建  │  │ 订单支付  │  │ 订单发货  │  │ 订单完成  │  │
│  │ 事件     │  │ 事件     │  │ 事件     │  │ 事件     │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
│              │              │              │
▼              ▼              ▼              ▼
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│ 库存服务  │   │ 支付服务  │   │ 物流服务  │   │ 通知服务  │
│ Inventory│   │ Payment  │   │ Shipping │   │ Notify   │
│ Service  │   │ Service  │   │ Service  │   │ Service  │
└──────────┘   └──────────┘   └──────────┘   └──────────┘
```

```
python

# services/order_service/app.py
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import requests

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/orders_db'

db = SQLAlchemy(app)

class Order(db.Model):
    """订单模型"""
    __tablename__ = 'orders'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, server_default=db.func.now())
    updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())

class OrderItem(db.Model):
    """订单项模型"""
    __tablename__ = 'order_items'

    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    product_id = db.Column(db.Integer, nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price = db.Column(db.Float, nullable=False)

    order = db.relationship('Order', backref='items')

@app.route('/orders', methods=['POST'])
def create_order():
    """创建订单"""
    data = request.get_json()

    # 验证商品库存
    for item in data['items']:
        response = requests.get(
            f"http://product-service:5001/products/{item['product_id']}"
        )
        product = response.json()

        if product['stock'] < item['quantity']:
            return jsonify({
                'error': f'Insufficient stock for product {item["product_id"]}'
            }), 400

    # 创建订单
    order = Order(
        user_id=data['user_id'],
        total_amount=0
    )
    db.session.add(order)
    db.session.flush()

    # 创建订单项
    total_amount = 0
    for item in data['items']:
        order_item = OrderItem(
            order_id=order.id,
            product_id=item['product_id'],
            quantity=item['quantity'],
            price=item['price']
        )
        db.session.add(order_item)
        total_amount += item['price'] * item['quantity']

    order.total_amount = total_amount
    db.session.commit()

    # 扣减库存
    for item in data['items']:
        response = requests.get(
            f"http://product-service:5001/products/{item['product_id']}"
        )
        product = response.json()
        new_stock = product['stock'] - item['quantity']

        requests.put(
            f"http://product-service:5001/products/{item['product_id']}/stock",
            json={'stock': new_stock}
        )

    return jsonify({'order_id': order.id}), 201

@app.route('/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    """获取订单详情"""
    order = Order.query.get_or_404(order_id)

    return jsonify({
        'id': order.id,
        'user_id': order.user_id,
        'total_amount': order.total_amount,
        'status': order.status,
        'items': [
            {
                'product_id': item.product_id,
                'quantity': item.quantity,
                'price': item.price
            }
            for item in order.items
        ]
    })

## API Gateway 实现
```python
python

# api_gateway/app.py
from flask import Flask, request, jsonify
import requests
import jwt
from functools import wraps

app = Flask(__name__)

SERVICES = {
    'user': 'http://user-service:5000',
    'product': 'http://product-service:5001',
    'order': 'http://order-service:5002'
}

def authenticate(f):
    """认证装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')

        if not token:
            return jsonify({'error': 'Missing token'}), 401

        try:
            payload = jwt.decode(token.split()[1], 'your-secret-key', algorithms=['HS256'])
            request.user_id = payload['user_id']
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        return f(*args, **kwargs)

    return decorated_function

@app.route('/<service>/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
def proxy(service, path):
    """代理请求到对应的服务"""
    if service not in SERVICES:
        return jsonify({'error': 'Service not found'}), 404

    service_url = SERVICES[service]
    url = f"{service_url}/{path}"

    headers = {key: value for key, value in request.headers if key != 'Host'}

    response = requests.request(
        method=request.method,
        url=url,
        headers=headers,
        json=request.get_json(),
        params=request.args
    )

    return jsonify(response.json()), response.status_code

@app.route('/health')
def health():
    """健康检查"""
    return jsonify({'status': 'healthy'})

```> >
### 2. 事件驱动架构
````python
`python

# 示例：设计事件驱动架构

用户请求：
"设计一个基于事件驱动的订单处理系统"

Claude Code 生成的架构设计：

## 系统架构

```> ┌──────────────┐
│   订单服务    │
│  (Order      │
│   Service)   │
└──────┬───────┘
│ 发布事件
▼
┌─────────────────────────────────────────────────────────────┐
│                    Message Broker                           │
│                    (Kafka/RabbitMQ)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 订单创建  │  │ 订单支付  │  │ 订单发货  │  │ 订单完成  │  │
│  │ 事件     │  │ 事件     │  │ 事件     │  │ 事件     │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
│              │              │              │
▼              ▼              ▼              ▼
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│ 库存服务  │   │ 支付服务  │   │ 物流服务  │   │ 通知服务  │
│ Inventory│   │ Payment  │   │ Shipping │   │ Notify   │
│ Service  │   │ Service  │   │ Service  │   │ Service  │
└──────────┘   └──────────┘   └──────────┘   └──────────┘
```

#### 事件定义#

### events/order_events.py

from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any
import json
@dataclass
class OrderEvent:
"""订单事件基类"""
event_type: str
order_id: int
timestamp: datetime
data: Dict[str, Any]
def to_dict(self) -> dict:
"""转换为字典"""
return {
'event_type': self.event_type,
'order_id': self.order_id,
'timestamp': self.timestamp.isoformat(),
'data': self.data
}
def to_json(self) -> str:
"""转换为 JSON"""
return json.dumps(self.to_dict())
@dataclass
class OrderCreatedEvent(OrderEvent):
"""订单创建事件"""
def init(self, order_id: int, user_id: int, total_amount: float, items: list):
super().init(
event_type='order.created',
order_id=order_id,
timestamp=datetime.utcnow(),
data={
'user_id': user_id,
'total_amount': total_amount,
'items': items
}
)
@dataclass
class OrderPaidEvent(OrderEvent):
"""订单支付事件"""
def init(self, order_id: int, payment_method: str, transaction_id: str):
super().init(
event_type='order.paid',
order_id=order_id,
timestamp=datetime.utcnow(),
data={
'payment_method': payment_method,
'transaction_id': transaction_id
}
)
@dataclass
class OrderShippedEvent(OrderEvent):
"""订单发货事件"""
def init(self, order_id: int, tracking_number: str, shipping_address: dict):
super().init(
event_type='order.shipped',
order_id=order_id,
timestamp=datetime.utcnow(),
data={
'tracking_number': tracking_number,
'shipping_address': shipping_address
}
)
@dataclass
class OrderCompletedEvent(OrderEvent):
"""订单完成事件"""
def init(self, order_id: int, delivery_time: datetime):
super().init(
event_type='order.completed',
order_id=order_id,
timestamp=datetime.utcnow(),
data={
'delivery_time': delivery_time.isoformat()
}
)

```
bash复制## 事件发布者
```

```
## 事件发布者
```

python

### services/order_service/event_publisher.py

import pika
import json
from events.order_events import OrderEvent

class EventPublisher:
"""事件发布者"""

```
bash复制def __init__(self, rabbitmq_url: str = 'amqp://localhost'):
    self.connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
    self.channel = self.connection.channel()

    # 声明交换机
    self.channel.exchange_declare(
        exchange='order_events',
        exchange_type='topic'
    )

def publish(self, event: OrderEvent, routing_key: str):
    """发布事件"""
    self.channel.basic_publish(
        exchange='order_events',
        routing_key=routing_key,
        body=event.to_json(),
        properties=pika.BasicProperties(
            delivery_mode=2,  # 持久化
        )
    )

def close(self):
    """关闭连接"""
    self.connection.close()
```

```
def __init__(self, rabbitmq_url: str = 'amqp://localhost'):
    self.connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
    self.channel = self.connection.channel()

    # 声明交换机
    self.channel.exchange_declare(
        exchange='order_events',
        exchange_type='topic'
    )

def publish(self, event: OrderEvent, routing_key: str):
    """发布事件"""
    self.channel.basic_publish(
        exchange='order_events',
        routing_key=routing_key,
        body=event.to_json(),
        properties=pika.BasicProperties(
            delivery_mode=2,  # 持久化
        )
    )

def close(self):
    """关闭连接"""
    self.connection.close()
```

#### 事件消费者#

### services/inventory_service/event_consumer.py

import pika
import json
import requests
class InventoryEventConsumer:
"""库存事件消费者"""
def init(self, rabbitmq_url: str = 'amqp://localhost'):
self.connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
self.channel = self.connection.channel()

### 声明交换机和队列

self.channel.exchange_declare(
exchange='order_events',
exchange_type='topic'
)
self.channel.queue_declare(queue='inventory_queue', durable=True)
self.channel.queue_bind(
exchange='order_events',
queue='inventory_queue',
routing_key='order.created'
)
def handle_order_created(self, ch, method, properties, body):
"""处理订单创建事件"""
event = json.loads(body)
print(f"Received order.created event: {event}")

### 扣减库存

for item in event['data']['items']:
response = requests.get(
f"http://product-service:5001/products/{item['product_id']}"
)
product = response.json()
new_stock = product['stock'] - item['quantity']
requests.put(
f"http://product-service:5001/products/{item['product_id']}/stock",
json={'stock': new_stock}
)

### 确认消息

ch.basic_ack(delivery_tag=method.delivery_tag)
def start_consuming(self):
"""开始消费消息"""
self.channel.basic_qos(prefetch_count=1)
self.channel.basic_consume(
queue='inventory_queue',
on_message_callback=self.handle_order_created
)
print('Inventory service started consuming messages...')
self.channel.start_consuming()
def close(self):
"""关闭连接"""
self.connection.close()

```
bash复制## 事件驱动订单服务
```

```
## 事件驱动订单服务
```

python

### services/order_service/app.py

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from event_publisher import EventPublisher
from events.order_events import OrderCreatedEvent

app = Flask(name)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/orders_db'

db = SQLAlchemy(app)
event_publisher = EventPublisher()

class Order(db.Model):
"""订单模型"""
tablename = 'orders'

```
bash复制id = db.Column(db.Integer, primary_key=True)
user_id = db.Column(db.Integer, nullable=False)
total_amount = db.Column(db.Float, nullable=False)
status = db.Column(db.String(20), default='pending')
created_at = db.Column(db.DateTime, server_default=db.func.now())
updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())
```

```
id = db.Column(db.Integer, primary_key=True)
user_id = db.Column(db.Integer, nullable=False)
total_amount = db.Column(db.Float, nullable=False)
status = db.Column(db.String(20), default='pending')
created_at = db.Column(db.DateTime, server_default=db.func.now())
updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())
```

class OrderItem(db.Model):
"""订单项模型"""
tablename = 'order_items'

```
bash复制id = db.Column(db.Integer, primary_key=True)
order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
product_id = db.Column(db.Integer, nullable=False)
quantity = db.Column(db.Integer, nullable=False)
price = db.Column(db.Float, nullable=False)

order = db.relationship('Order', backref='items')
```

```
id = db.Column(db.Integer, primary_key=True)
order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
product_id = db.Column(db.Integer, nullable=False)
quantity = db.Column(db.Integer, nullable=False)
price = db.Column(db.Float, nullable=False)

order = db.relationship('Order', backref='items')
```

@app.route('/orders', methods=['POST'])
def create_order():
"""创建订单"""
data = request.get_json()

```
bash复制# 创建订单
order = Order(
    user_id=data['user_id'],
    total_amount=0
)
db.session.add(order)
db.session.flush()

# 创建订单项
total_amount = 0
items = []
for item in data['items']:
    order_item = OrderItem(
        order_id=order.id,
        product_id=item['product_id'],
        quantity=item['quantity'],
        price=item['price']
    )
    db.session.add(order_item)
    total_amount += item['price'] * item['quantity']
    items.append({
        'product_id': item['product_id'],
        'quantity': item['quantity'],
        'price': item['price']
    })

order.total_amount = total_amount
db.session.commit()

# 发布订单创建事件
event = OrderCreatedEvent(
    order_id=order.id,
    user_id=data['user_id'],
    total_amount=total_amount,
    items=items
)
event_publisher.publish(event, 'order.created')

return jsonify({'order_id': order.id}), 201
```

```
# 创建订单
order = Order(
    user_id=data['user_id'],
    total_amount=0
)
db.session.add(order)
db.session.flush()

# 创建订单项
total_amount = 0
items = []
for item in data['items']:
    order_item = OrderItem(
        order_id=order.id,
        product_id=item['product_id'],
        quantity=item['quantity'],
        price=item['price']
    )
    db.session.add(order_item)
    total_amount += item['price'] * item['quantity']
    items.append({
        'product_id': item['product_id'],
        'quantity': item['quantity'],
        'price': item['price']
    })

order.total_amount = total_amount
db.session.commit()

# 发布订单创建事件
event = OrderCreatedEvent(
    order_id=order.id,
    user_id=data['user_id'],
    total_amount=total_amount,
    items=items
)
event_publisher.publish(event, 'order.created')

return jsonify({'order_id': order.id}), 201
```

if name == 'main':
app.run(host='0.0.0.0', port=5002)

---

## 3 代码理解与分析进阶

**URL**: https://claudecode.tangshuang.net/course/27.3%20%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3%E4%B8%8E%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6

#### 代码理解与分析概述#

Claude Code 不仅能生成代码，还能深入理解和分析代码。通过高级的代码理解与分析能力，开发者可以更好地理解代码结构、识别潜在问题、优化代码性能。

#### 代码结构分析#

##### 1. 依赖关系分析#

### 示例：分析代码依赖关系

用户请求：
"分析这个项目的依赖关系"

Claude Code 会分析项目结构并生成依赖图：

#### 依赖关系分析#

```
bash复制├── __init__.py
├── models/
│   ├── __init__.py
│   ├── user.py          # 依赖: db, bcrypt
│   ├── product.py       # 依赖: db, Category
│   └── order.py         # 依赖: db, User, Product
├── services/
│   ├── __init__.py
│   ├── auth_service.py  # 依赖: User, jwt
│   ├── order_service.py # 依赖: Order, OrderItem, Product
│   └── payment_service.py # 依赖: Order, stripe
├── controllers/
│   ├── __init__.py
│   ├── user_controller.py    # 依赖: UserService
│   ├── product_controller.py # 依赖: ProductService
│   └── order_controller.py   # 依赖: OrderService
└── views/
├── __init__.py
├── user_views.py    # 依赖: UserController
├── product_views.py # 依赖: ProductController
└── order_views.py   # 依赖: OrderController
依赖层次：
Level 0: db, bcrypt, jwt, stripe
Level 1: User, Product, Category, Order, OrderItem
Level 2: UserService, ProductService, OrderService, PaymentService
Level 3: UserController, ProductController, OrderController
Level 4: UserViews, ProductViews, OrderViews
循环依赖检测：
✓ 无循环依赖
```
### 2. 模块关系图

```python
python

# 示例：生成模块关系图

用户请求：
"生成模块关系图"

Claude Code 生成的模块关系图：

## 模块关系图

graph TD
A[app/__init__.py] --> B[models/]
A --> C[services/]
A --> D[controllers/]
A --> E[views/]

B --> B1[user.py]
B --> B2[product.py]
B --> B3[order.py]

C --> C1[auth_service.py]
C --> C2[order_service.py]
C --> C3[payment_service.py]

D --> D1[user_controller.py]
D --> D2[product_controller.py]
D --> D3[order_controller.py]

E --> E1[user_views.py]
E --> E2[product_views.py]
E --> E3[order_views.py]

B1 --> C1
B3 --> C2
B3 --> C3

C1 --> D1
C2 --> D3
C3 --> D3

D1 --> E1
D2 --> E2
D3 --> E3

B2 --> B3

## 依赖说明
```

```
├── __init__.py
├── models/
│   ├── __init__.py
│   ├── user.py          # 依赖: db, bcrypt
│   ├── product.py       # 依赖: db, Category
│   └── order.py         # 依赖: db, User, Product
├── services/
│   ├── __init__.py
│   ├── auth_service.py  # 依赖: User, jwt
│   ├── order_service.py # 依赖: Order, OrderItem, Product
│   └── payment_service.py # 依赖: Order, stripe
├── controllers/
│   ├── __init__.py
│   ├── user_controller.py    # 依赖: UserService
│   ├── product_controller.py # 依赖: ProductService
│   └── order_controller.py   # 依赖: OrderService
└── views/
├── __init__.py
├── user_views.py    # 依赖: UserController
├── product_views.py # 依赖: ProductController
└── order_views.py   # 依赖: OrderController
依赖层次：
Level 0: db, bcrypt, jwt, stripe
Level 1: User, Product, Category, Order, OrderItem
Level 2: UserService, ProductService, OrderService, PaymentService
Level 3: UserController, ProductController, OrderController
Level 4: UserViews, ProductViews, OrderViews
循环依赖检测：
✓ 无循环依赖
```
### 2. 模块关系图

```python
python

# 示例：生成模块关系图

用户请求：
"生成模块关系图"

Claude Code 生成的模块关系图：

## 模块关系图

graph TD
A[app/__init__.py] --> B[models/]
A --> C[services/]
A --> D[controllers/]
A --> E[views/]

B --> B1[user.py]
B --> B2[product.py]
B --> B3[order.py]

C --> C1[auth_service.py]
C --> C2[order_service.py]
C --> C3[payment_service.py]

D --> D1[user_controller.py]
D --> D2[product_controller.py]
D --> D3[order_controller.py]

E --> E1[user_views.py]
E --> E2[product_views.py]
E --> E3[order_views.py]

B1 --> C1
B3 --> C2
B3 --> C3

C1 --> D1
C2 --> D3
C3 --> D3

D1 --> E1
D2 --> E2
D3 --> E3

B2 --> B3

## 依赖说明
```

- models/: 数据模型层，定义数据库表结构
- services/: 业务逻辑层，处理核心业务逻辑
- controllers/: 控制器层，协调服务和模型
- views/: 视图层，处理 HTTP 请求和响应

#### 数据流向#

```
bash复制## 代码质量分析

### 1. 代码复杂度分析

```python
python

# 示例：分析代码复杂度

用户请求：
"分析这个函数的复杂度"

Claude Code 生成的分析报告：

## 代码复杂度分析

### 函数: process_order

def process_order(order_data):
"""处理订单"""
result = {}

 # 验证订单数据
if 'items' in order_data:
items = order_data['items']
if len(items) > 0:
total = 0
for item in items:
if 'price' in item and 'quantity' in item:
if item['price'] > 0 and item['quantity'] > 0:
total += item['price'] * item['quantity']
else:
raise ValueError('Invalid price or quantity')
else:
raise ValueError('Missing price or quantity')

result['total'] = total

if 'discount' in order_data:
discount = order_data['discount']
if discount > 0 and discount <= 1:
result['total'] *= (1 - discount)
else:
raise ValueError('Invalid discount')

if 'tax' in order_data:
tax = order_data['tax']
if tax >= 0:
result['total'] *= (1 + tax)
else:
raise ValueError('Invalid tax')

if 'shipping' in order_data:
shipping = order_data['shipping']
if shipping >= 0:
result['total'] += shipping
else:
raise ValueError('Invalid shipping')
else:
raise ValueError('No items in order')
else:
raise ValueError('Missing items')

if 'customer' in order_data:
result['customer'] = order_data['customer']

if 'address' in order_data:
result['address'] = order_data['address']

return result

### 复杂度指标
| 指标 | 值 | 等级 |
|------|-----|------|
| 圈复杂度 (Cyclomatic Complexity) | 12 | 高 |
| 认知复杂度 (Cognitive Complexity) | 15 | 高 |
| 嵌套深度 (Nesting Depth) | 5 | 高 |
| 函数长度 (Function Length) | 45 行 | 中 |
### 问题分析
1. **圈复杂度过高**: 12 个独立路径，建议降低到 10 以下
2. **认知复杂度过高**: 嵌套过深，难以理解和维护
3. **代码重复**: 多次验证输入，可以提取为独立函数
### 优化建议
```

```
## 代码质量分析

### 1. 代码复杂度分析

```python
python

# 示例：分析代码复杂度

用户请求：
"分析这个函数的复杂度"

Claude Code 生成的分析报告：

## 代码复杂度分析

### 函数: process_order

def process_order(order_data):
"""处理订单"""
result = {}

 # 验证订单数据
if 'items' in order_data:
items = order_data['items']
if len(items) > 0:
total = 0
for item in items:
if 'price' in item and 'quantity' in item:
if item['price'] > 0 and item['quantity'] > 0:
total += item['price'] * item['quantity']
else:
raise ValueError('Invalid price or quantity')
else:
raise ValueError('Missing price or quantity')

result['total'] = total

if 'discount' in order_data:
discount = order_data['discount']
if discount > 0 and discount <= 1:
result['total'] *= (1 - discount)
else:
raise ValueError('Invalid discount')

if 'tax' in order_data:
tax = order_data['tax']
if tax >= 0:
result['total'] *= (1 + tax)
else:
raise ValueError('Invalid tax')

if 'shipping' in order_data:
shipping = order_data['shipping']
if shipping >= 0:
result['total'] += shipping
else:
raise ValueError('Invalid shipping')
else:
raise ValueError('No items in order')
else:
raise ValueError('Missing items')

if 'customer' in order_data:
result['customer'] = order_data['customer']

if 'address' in order_data:
result['address'] = order_data['address']

return result

### 复杂度指标
| 指标 | 值 | 等级 |
|------|-----|------|
| 圈复杂度 (Cyclomatic Complexity) | 12 | 高 |
| 认知复杂度 (Cognitive Complexity) | 15 | 高 |
| 嵌套深度 (Nesting Depth) | 5 | 高 |
| 函数长度 (Function Length) | 45 行 | 中 |
### 问题分析
1. **圈复杂度过高**: 12 个独立路径，建议降低到 10 以下
2. **认知复杂度过高**: 嵌套过深，难以理解和维护
3. **代码重复**: 多次验证输入，可以提取为独立函数
### 优化建议
```

python

def validate_item(item):
"""验证商品项"""
if 'price' not in item or 'quantity' not in item:
raise ValueError('Missing price or quantity')

```
bash复制if item['price'] <= 0 or item['quantity'] <= 0:
    raise ValueError('Invalid price or quantity')
```

```
if item['price'] <= 0 or item['quantity'] <= 0:
    raise ValueError('Invalid price or quantity')
```

def calculate_item_total(items):
"""计算商品总价"""
return sum(item['price'] * item['quantity'] for item in items)

def apply_discount(total, discount):
"""应用折扣"""
if discount <= 0 or discount > 1:
raise ValueError('Invalid discount')
return total * (1 - discount)

def apply_tax(total, tax):
"""应用税费"""
if tax < 0:
raise ValueError('Invalid tax')
return total * (1 + tax)

def apply_shipping(total, shipping):
"""应用运费"""
if shipping < 0:
raise ValueError('Invalid shipping')
return total + shipping

def process_order(order_data):
"""处理订单（优化后）"""
result = {}

```
bash复制# 验证并计算商品总价
if 'items' not in order_data or len(order_data['items']) == 0:
    raise ValueError('No items in order')

for item in order_data['items']:
    validate_item(item)

total = calculate_item_total(order_data['items'])

# 应用折扣
if 'discount' in order_data:
    total = apply_discount(total, order_data['discount'])

# 应用税费
if 'tax' in order_data:
    total = apply_tax(total, order_data['tax'])

# 应用运费
if 'shipping' in order_data:
    total = apply_shipping(total, order_data['shipping'])

result['total'] = total

# 添加客户信息
if 'customer' in order_data:
    result['customer'] = order_data['customer']

if 'address' in order_data:
    result['address'] = order_data['address']

return result
```

```
# 验证并计算商品总价
if 'items' not in order_data or len(order_data['items']) == 0:
    raise ValueError('No items in order')

for item in order_data['items']:
    validate_item(item)

total = calculate_item_total(order_data['items'])

# 应用折扣
if 'discount' in order_data:
    total = apply_discount(total, order_data['discount'])

# 应用税费
if 'tax' in order_data:
    total = apply_tax(total, order_data['tax'])

# 应用运费
if 'shipping' in order_data:
    total = apply_shipping(total, order_data['shipping'])

result['total'] = total

# 添加客户信息
if 'customer' in order_data:
    result['customer'] = order_data['customer']

if 'address' in order_data:
    result['address'] = order_data['address']

return result
```

##### 优化后指标#

##### 2. 代码重复分析#

```
bash复制``python
`````python

# 示例：分析代码重复

用户请求：
"分析代码重复"

Claude Code 生成的分析报告：

## 代码重复分析

### 重复代码块 1

```python
```python

# user_controller.py
def get_user(user_id):
    user = User.query.get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

# product_controller.py
def get_product(product_id):
    product = Product.query.get(product_id)
    if not product:
        return jsonify({'error': 'Product not found'}), 404
    return jsonify(product.to_dict())

# order_controller.py
def get_order(order_id):
    order = Order.query.get(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    return jsonify(order.to_dict())

**重复率**: 85%
> **重复行数**: 6 行
> **影响**: 3 个文件

### 优化建议

# utils/helpers.py
def get_or_404(model, model_id, error_message=None):
"""通用获取或返回 404 的函数"""
instance = model.query.get(model_id)
if not instance:
error_message = error_message or f"{model.__name__} not found"
return jsonify({'error': error_message}), 404
return jsonify(instance.to_dict())
# user_controller.py
def get_user(user_id):
return get_or_404(User, user_id)
# product_controller.py
def get_product(product_id):
return get_or_404(Product, product_id)
# order_controller.py
def get_order(order_id):
return get_or_404(Order, order_id)
```

```
``python
`````python

# 示例：分析代码重复

用户请求：
"分析代码重复"

Claude Code 生成的分析报告：

## 代码重复分析

### 重复代码块 1

```python
```python

# user_controller.py
def get_user(user_id):
    user = User.query.get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

# product_controller.py
def get_product(product_id):
    product = Product.query.get(product_id)
    if not product:
        return jsonify({'error': 'Product not found'}), 404
    return jsonify(product.to_dict())

# order_controller.py
def get_order(order_id):
    order = Order.query.get(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    return jsonify(order.to_dict())

**重复率**: 85%
> **重复行数**: 6 行
> **影响**: 3 个文件

### 优化建议

# utils/helpers.py
def get_or_404(model, model_id, error_message=None):
"""通用获取或返回 404 的函数"""
instance = model.query.get(model_id)
if not instance:
error_message = error_message or f"{model.__name__} not found"
return jsonify({'error': error_message}), 404
return jsonify(instance.to_dict())
# user_controller.py
def get_user(user_id):
return get_or_404(User, user_id)
# product_controller.py
def get_product(product_id):
return get_or_404(Product, product_id)
# order_controller.py
def get_order(order_id):
return get_or_404(Order, order_id)
```

##### 重复代码块 2#

```
bash复制python

# user_views.py
@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = UserController.get_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

# product_views.py
@app.route('/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    product = ProductController.get_product(product_id)
    if not product:
        return jsonify({'error': 'Product not found'}), 404
    return jsonify(product.to_dict())

# order_views.py
@app.route('/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    order = OrderController.get_order(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    return jsonify(order.to_dict())

**重复率**: 90%
> **重复行数**: 8 行
> **影响**: 3 个文件

### 优化建议

# utils/decorators.py
def route_with_controller(route, controller_method, model_name):
"""通用路由装饰器"""
def decorator(f):
@wraps(f)
def wrapper(*args, **kwargs):
result = controller_method(*args, **kwargs)
if not result:
return jsonify({'error': f'{model_name} not found'}), 404
return jsonify(result.to_dict())
return wrapper
return decorator
# user_views.py
@app.route('/users/<int:user_id>', methods=['GET'])
@route_with_controller('/users/<int:user_id>', UserController.get_user, 'User')
def get_user(user_id):
pass
# product_views.py
@app.route('/products/<int:product_id>', methods=['GET'])
@route_with_controller('/products/<int:product_id>', ProductController.get_product, 'Product')
def get_product(product_id):
pass
# order_views.py
@app.route('/orders/<int:order_id>', methods=['GET'])
@route_with_controller('/orders/<int:order_id>', OrderController.get_order, 'Order')
def get_order(order_id):
pass
```

```
python

# user_views.py
@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = UserController.get_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user.to_dict())

# product_views.py
@app.route('/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    product = ProductController.get_product(product_id)
    if not product:
        return jsonify({'error': 'Product not found'}), 404
    return jsonify(product.to_dict())

# order_views.py
@app.route('/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    order = OrderController.get_order(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    return jsonify(order.to_dict())

**重复率**: 90%
> **重复行数**: 8 行
> **影响**: 3 个文件

### 优化建议

# utils/decorators.py
def route_with_controller(route, controller_method, model_name):
"""通用路由装饰器"""
def decorator(f):
@wraps(f)
def wrapper(*args, **kwargs):
result = controller_method(*args, **kwargs)
if not result:
return jsonify({'error': f'{model_name} not found'}), 404
return jsonify(result.to_dict())
return wrapper
return decorator
# user_views.py
@app.route('/users/<int:user_id>', methods=['GET'])
@route_with_controller('/users/<int:user_id>', UserController.get_user, 'User')
def get_user(user_id):
pass
# product_views.py
@app.route('/products/<int:product_id>', methods=['GET'])
@route_with_controller('/products/<int:product_id>', ProductController.get_product, 'Product')
def get_product(product_id):
pass
# order_views.py
@app.route('/orders/<int:order_id>', methods=['GET'])
@route_with_controller('/orders/<int:order_id>', OrderController.get_order, 'Order')
def get_order(order_id):
pass
```

#### 代码性能分析#

##### 1. 性能瓶颈识别#

```
bash复制python

# 示例：识别性能瓶颈

用户请求：
"分析这个函数的性能瓶颈"

Claude Code 生成的分析报告：

## 性能瓶颈分析

### 函数: get_user_orders

```python
```python

def get_user_orders(user_id):
    """获取用户的所有订单"""
    user = User.query.get(user_id)

    if not user:
        return []

    orders = []
    for order in user.orders:
        order_data = {
            'id': order.id,
            'total_amount': order.total_amount,
            'status': order.status,
            'created_at': order.created_at,
            'items': []
        }

        for item in order.items:
            product = Product.query.get(item.product_id)
            order_data['items'].append({
                'product_id': item.product_id,
                'product_name': product.name,
                'quantity': item.quantity,
                'price': item.price
            })

        orders.append(order_data)

    return orders

### 性能问题

1. **N+1 查询问题**:
 - 查询用户: 1 次
 - 查询订单: N 次
 - 查询商品: M × N 次
 - 总查询次数: 1 + N + M × N

2. **循环嵌套**:
 - 外层循环遍历订单
 - 内层循环遍历订单项
 - 时间复杂度: O(N × M)

3. **重复查询**:
 - 同一个商品可能被多次查询
 - 没有使用缓存

### 优化建议

````python
````python

def get_user_orders(user_id):
"""获取用户的所有订单（优化后）"""
 # 使用 join 一次性加载所有数据
orders = db.session.query(Order).join(OrderItem).join(Product).filter(
Order.user_id == user_id
).all()

 # 构建商品缓存
product_cache = {}
for order in orders:
for item in order.items:
if item.product_id not in product_cache:
product_cache[item.product_id] = item.product

 # 构建结果
result = []
for order in orders:
order_data = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

for item in order.items:
product = product_cache[item.product_id]
order_data['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

result.append(order_data)

return result

```### 性能对比

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 查询次数 | 1 + N + M × N | 1 | 99% ↓ |
| 执行时间 | 500ms | 50ms | 90% ↓ |
| 内存使用 | 10MB | 5MB | 50% ↓ |
```

```
python

# 示例：识别性能瓶颈

用户请求：
"分析这个函数的性能瓶颈"

Claude Code 生成的分析报告：

## 性能瓶颈分析

### 函数: get_user_orders

```python
```python

def get_user_orders(user_id):
    """获取用户的所有订单"""
    user = User.query.get(user_id)

    if not user:
        return []

    orders = []
    for order in user.orders:
        order_data = {
            'id': order.id,
            'total_amount': order.total_amount,
            'status': order.status,
            'created_at': order.created_at,
            'items': []
        }

        for item in order.items:
            product = Product.query.get(item.product_id)
            order_data['items'].append({
                'product_id': item.product_id,
                'product_name': product.name,
                'quantity': item.quantity,
                'price': item.price
            })

        orders.append(order_data)

    return orders

### 性能问题

1. **N+1 查询问题**:
 - 查询用户: 1 次
 - 查询订单: N 次
 - 查询商品: M × N 次
 - 总查询次数: 1 + N + M × N

2. **循环嵌套**:
 - 外层循环遍历订单
 - 内层循环遍历订单项
 - 时间复杂度: O(N × M)

3. **重复查询**:
 - 同一个商品可能被多次查询
 - 没有使用缓存

### 优化建议

````python
````python

def get_user_orders(user_id):
"""获取用户的所有订单（优化后）"""
 # 使用 join 一次性加载所有数据
orders = db.session.query(Order).join(OrderItem).join(Product).filter(
Order.user_id == user_id
).all()

 # 构建商品缓存
product_cache = {}
for order in orders:
for item in order.items:
if item.product_id not in product_cache:
product_cache[item.product_id] = item.product

 # 构建结果
result = []
for order in orders:
order_data = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

for item in order.items:
product = product_cache[item.product_id]
order_data['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

result.append(order_data)

return result

```### 性能对比

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 查询次数 | 1 + N + M × N | 1 | 99% ↓ |
| 执行时间 | 500ms | 50ms | 90% ↓ |
| 内存使用 | 10MB | 5MB | 50% ↓ |
```

##### 2. 内存使用分析#

### 示例：分析内存使用

用户请求：
"分析这个函数的内存使用"
Claude Code 生成的分析报告：

#### 内存使用分析#

##### 函数: process_large_file#

```
python复制`python

def process_large_file(file_path):
"""处理大文件"""
with open(file_path, 'r') as f:
lines = f.readlines()

results = []
for line in lines:
data = json.loads(line)
processed_data = {
'id': data['id'],
'name': data['name'],
'value': data['value'] * 2
}
results.append(processed_data)

return results

```### 内存问题

 - 文件大小: 1GB
 - 内存占用: ~1GB
 - 风险: 可能导致内存溢出

 - 原始数据: lines
 - 处理后数据: results
 - 内存占用: ~2GB

### 优化建议

```
python

def process_large_file(file_path):
    """处理大文件（优化后）"""
    results = []

    with open(file_path, 'r') as f:
        for line in f:
            data = json.loads(line)
            processed_data = {
                'id': data['id'],
                'name': data['name'],
                'value': data['value'] * 2
            }
            results.append(processed_data)

    return results

### 进一步优化（流式处理）

````python
````python

def process_large_file_streaming(file_path, output_path):
"""流式处理大文件"""
with open(file_path, 'r') as input_file, \
open(output_path, 'w') as output_file:

for line in input_file:
data = json.loads(line)
processed_data = {
'id': data['id'],
'name': data['name'],
'value': data['value'] * 2
}
output_file.write(json.dumps(processed_data) + '\n')

```
```

```
`python

def process_large_file(file_path):
"""处理大文件"""
with open(file_path, 'r') as f:
lines = f.readlines()

results = []
for line in lines:
data = json.loads(line)
processed_data = {
'id': data['id'],
'name': data['name'],
'value': data['value'] * 2
}
results.append(processed_data)

return results

```### 内存问题

 - 文件大小: 1GB
 - 内存占用: ~1GB
 - 风险: 可能导致内存溢出

 - 原始数据: lines
 - 处理后数据: results
 - 内存占用: ~2GB

### 优化建议

```
python

def process_large_file(file_path):
    """处理大文件（优化后）"""
    results = []

    with open(file_path, 'r') as f:
        for line in f:
            data = json.loads(line)
            processed_data = {
                'id': data['id'],
                'name': data['name'],
                'value': data['value'] * 2
            }
            results.append(processed_data)

    return results

### 进一步优化（流式处理）

````python
````python

def process_large_file_streaming(file_path, output_path):
"""流式处理大文件"""
with open(file_path, 'r') as input_file, \
open(output_path, 'w') as output_file:

for line in input_file:
data = json.loads(line)
processed_data = {
'id': data['id'],
'name': data['name'],
'value': data['value'] * 2
}
output_file.write(json.dumps(processed_data) + '\n')

```
```

---

## 4 代码质量评估与提升

**URL**: https://claudecode.tangshuang.net/course/27.4%20%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%8F%90%E5%8D%87

#### 代码质量评估概述#

Claude Code 可以帮助开发者全面评估代码质量，并提供具体的改进建议。通过系统化的质量评估和持续的代码改进，开发者可以构建更健壮、可维护的代码库。

#### 代码质量指标#

##### 1. 可读性评估#

### 示例：评估代码可读性

用户请求：
"评估这段代码的可读性"

Claude Code 生成的评估报告：

#### 代码可读性评估#

##### 待评估代码#

```
python复制````python

def f(x,y,z):
r=[]
for i in x:
if i['a']>y:
r.append({'id':i['id'],'v':i['b']*z})
return r

```### 可读性评分

| 指标 | 得分 | 满分 | 等级 |
|------|------|------|------|
| 命名规范 | 2/10 | 10 | 差 |
| 函数长度 | 8/10 | 10 | 良好 |
| 注释覆盖 | 0/10 | 10 | 差 |
| 代码格式 | 5/10 | 10 | 中等 |
| 复杂度 | 9/10 | 10 | 优秀 |
| **总分** | **24/50** | **50** | **差** |

### 问题分析

1. **命名不规范**:
 - 函数名 `f` 不具有描述性
 - 参数名 `x`, `y`, `z` 不清晰
 - 变量名 `r` 不明确

2. **缺少注释**:
 - 没有函数文档字符串
 - 没有行内注释说明逻辑

3. **格式不规范**:
 - 缺少空格分隔
 - 缩进不一致

### 改进建议

```
python

def filter_and_transform_items(items, threshold, multiplier):
    """
    过滤并转换商品项

    参数:
        items: 商品列表
        threshold: 过滤阈值
        multiplier: 转换乘数

    返回:
        过滤并转换后的商品列表
    """
    result = []

    for item in items:
        if item['amount'] > threshold:
            transformed_item = {
                'id': item['id'],
                'value': item['base_value'] * multiplier
            }
            result.append(transformed_item)

    return result

### 改进后评分

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 命名规范 | 2/10 | 10/10 | +400% |
| 函数长度 | 8/10 | 10/10 | +25% |
| 注释覆盖 | 0/10 | 10/10 | +1000% |
| 代码格式 | 5/10 | 10/10 | +100% |
| 复杂度 | 9/10 | 10/10 | +11% |
| **总分** | **24/50** | **50/50** | **+108%** |

### 2. 可维护性评估

```
python

# 示例：评估代码可维护性

用户请求：
"评估这段代码的可维护性"

Claude Code 生成的评估报告：

## 代码可维护性评估
```

```
````python

def f(x,y,z):
r=[]
for i in x:
if i['a']>y:
r.append({'id':i['id'],'v':i['b']*z})
return r

```### 可读性评分

| 指标 | 得分 | 满分 | 等级 |
|------|------|------|------|
| 命名规范 | 2/10 | 10 | 差 |
| 函数长度 | 8/10 | 10 | 良好 |
| 注释覆盖 | 0/10 | 10 | 差 |
| 代码格式 | 5/10 | 10 | 中等 |
| 复杂度 | 9/10 | 10 | 优秀 |
| **总分** | **24/50** | **50** | **差** |

### 问题分析

1. **命名不规范**:
 - 函数名 `f` 不具有描述性
 - 参数名 `x`, `y`, `z` 不清晰
 - 变量名 `r` 不明确

2. **缺少注释**:
 - 没有函数文档字符串
 - 没有行内注释说明逻辑

3. **格式不规范**:
 - 缺少空格分隔
 - 缩进不一致

### 改进建议

```
python

def filter_and_transform_items(items, threshold, multiplier):
    """
    过滤并转换商品项

    参数:
        items: 商品列表
        threshold: 过滤阈值
        multiplier: 转换乘数

    返回:
        过滤并转换后的商品列表
    """
    result = []

    for item in items:
        if item['amount'] > threshold:
            transformed_item = {
                'id': item['id'],
                'value': item['base_value'] * multiplier
            }
            result.append(transformed_item)

    return result

### 改进后评分

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 命名规范 | 2/10 | 10/10 | +400% |
| 函数长度 | 8/10 | 10/10 | +25% |
| 注释覆盖 | 0/10 | 10/10 | +1000% |
| 代码格式 | 5/10 | 10/10 | +100% |
| 复杂度 | 9/10 | 10/10 | +11% |
| **总分** | **24/50** | **50/50** | **+108%** |

### 2. 可维护性评估

```
python

# 示例：评估代码可维护性

用户请求：
"评估这段代码的可维护性"

Claude Code 生成的评估报告：

## 代码可维护性评估
```

##### 待评估代码#

```
python复制```python

class OrderProcessor:
    def process(self, data):
        if data['type'] == 'new':
            if data['payment'] == 'credit_card':
                if data['card']['type'] == 'visa':
                    self.process_visa(data)
                elif data['card']['type'] == 'mastercard':
                    self.process_mastercard(data)
                elif data['card']['type'] == 'amex':
                    self.process_amex(data)
            elif data['payment'] == 'paypal':
                self.process_paypal(data)
            elif data['payment'] == 'bank_transfer':
                self.process_bank_transfer(data)
        elif data['type'] == 'update':
            self.process_update(data)
        elif data['type'] == 'cancel':
            self.process_cancel(data)

### 可维护性评分

| 指标 | 得分 | 满分 | 等级 |
|------|------|------|------|
| 模块化 | 3/10 | 10 | 差 |
| 扩展性 | 2/10 | 10 | 差 |
| 耦合度 | 4/10 | 10 | 差 |
| 内聚性 | 6/10 | 10 | 中等 |
| 测试性 | 3/10 | 10 | 差 |
| **总分** | **18/50** | **50** | **差** |

### 问题分析

1. **模块化程度低**:
 - 所有逻辑集中在一个方法中
 - 缺少清晰的职责划分

2. **扩展性差**:
 - 添加新的订单类型需要修改现有代码
 - 添加新的支付方式需要修改现有代码

3. **高耦合**:
 - 订单处理与支付处理紧密耦合
 - 难以独立测试各个部分

4. **测试困难**:
 - 需要模拟大量场景
 - 难以隔离测试各个分支

### 改进建议

````python
````python

from abc import ABC, abstractmethod

class OrderType(ABC):
"""订单类型基类"""

@abstractmethod
def process(self, data):
"""处理订单"""
pass

class NewOrder(OrderType):
"""新订单"""

def __init__(self, payment_processor):
self.payment_processor = payment_processor

def process(self, data):
"""处理新订单"""
return self.payment_processor.process(data['payment'], data)

class UpdateOrder(OrderType):
"""更新订单"""

def process(self, data):
"""处理订单更新"""
return self.process_update(data)

def process_update(self, data):
"""更新订单逻辑"""
pass

class CancelOrder(OrderType):
"""取消订单"""

def process(self, data):
"""处理订单取消"""
return self.process_cancel(data)

def process_cancel(self, data):
"""取消订单逻辑"""
pass

class PaymentProcessor(ABC):
"""支付处理器基类"""

@abstractmethod
def process(self, payment_type, data):
"""处理支付"""
pass

class CreditCardPayment(PaymentProcessor):
"""信用卡支付"""

def __init__(self):
self.card_processors = {
'visa': self.process_visa,
'mastercard': self.process_mastercard,
'amex': self.process_amex
}

def process(self, payment_type, data):
"""处理信用卡支付"""
card_type = data['card']['type']
processor = self.card_processors.get(card_type)

if not processor:
raise ValueError(f"Unsupported card type: {card_type}")

return processor(data)

def process_visa(self, data):
"""处理 Visa 卡"""
pass

def process_mastercard(self, data):
"""处理万事达卡"""
pass

def process_amex(self, data):
"""处理美国运通卡"""
pass

class PayPalPayment(PaymentProcessor):
"""PayPal 支付"""

def process(self, payment_type, data):
"""处理 PayPal 支付"""
return self.process_paypal(data)

def process_paypal(self, data):
"""PayPal 支付逻辑"""
pass

class BankTransferPayment(PaymentProcessor):
"""银行转账"""

def process(self, payment_type, data):
"""处理银行转账"""
return self.process_bank_transfer(data)

def process_bank_transfer(self, data):
"""银行转账逻辑"""
pass

class OrderProcessor:
"""订单处理器"""

def __init__(self):
self.order_types = {
'new': NewOrder(self._create_payment_processor()),
'update': UpdateOrder(),
'cancel': CancelOrder()
}

def _create_payment_processor(self):
"""创建支付处理器"""
payment_processors = {
'credit_card': CreditCardPayment(),
'paypal': PayPalPayment(),
'bank_transfer': BankTransferPayment()
}
return PaymentProcessorFactory(payment_processors)

def process(self, data):
"""处理订单"""
order_type = data['type']
processor = self.order_types.get(order_type)

if not processor:
raise ValueError(f"Unsupported order type: {order_type}")

return processor.process(data)

```### 改进后评分

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 模块化 | 3/10 | 10/10 | +233% |
| 扩展性 | 2/10 | 10/10 | +400% |
| 耦合度 | 4/10 | 9/10 | +125% |
| 内聚性 | 6/10 | 10/10 | +67% |
| 测试性 | 3/10 | 10/10 | +233% |
| **总分** | **18/50** | **49/50** | **+172%** |
```

```
```python

class OrderProcessor:
    def process(self, data):
        if data['type'] == 'new':
            if data['payment'] == 'credit_card':
                if data['card']['type'] == 'visa':
                    self.process_visa(data)
                elif data['card']['type'] == 'mastercard':
                    self.process_mastercard(data)
                elif data['card']['type'] == 'amex':
                    self.process_amex(data)
            elif data['payment'] == 'paypal':
                self.process_paypal(data)
            elif data['payment'] == 'bank_transfer':
                self.process_bank_transfer(data)
        elif data['type'] == 'update':
            self.process_update(data)
        elif data['type'] == 'cancel':
            self.process_cancel(data)

### 可维护性评分

| 指标 | 得分 | 满分 | 等级 |
|------|------|------|------|
| 模块化 | 3/10 | 10 | 差 |
| 扩展性 | 2/10 | 10 | 差 |
| 耦合度 | 4/10 | 10 | 差 |
| 内聚性 | 6/10 | 10 | 中等 |
| 测试性 | 3/10 | 10 | 差 |
| **总分** | **18/50** | **50** | **差** |

### 问题分析

1. **模块化程度低**:
 - 所有逻辑集中在一个方法中
 - 缺少清晰的职责划分

2. **扩展性差**:
 - 添加新的订单类型需要修改现有代码
 - 添加新的支付方式需要修改现有代码

3. **高耦合**:
 - 订单处理与支付处理紧密耦合
 - 难以独立测试各个部分

4. **测试困难**:
 - 需要模拟大量场景
 - 难以隔离测试各个分支

### 改进建议

````python
````python

from abc import ABC, abstractmethod

class OrderType(ABC):
"""订单类型基类"""

@abstractmethod
def process(self, data):
"""处理订单"""
pass

class NewOrder(OrderType):
"""新订单"""

def __init__(self, payment_processor):
self.payment_processor = payment_processor

def process(self, data):
"""处理新订单"""
return self.payment_processor.process(data['payment'], data)

class UpdateOrder(OrderType):
"""更新订单"""

def process(self, data):
"""处理订单更新"""
return self.process_update(data)

def process_update(self, data):
"""更新订单逻辑"""
pass

class CancelOrder(OrderType):
"""取消订单"""

def process(self, data):
"""处理订单取消"""
return self.process_cancel(data)

def process_cancel(self, data):
"""取消订单逻辑"""
pass

class PaymentProcessor(ABC):
"""支付处理器基类"""

@abstractmethod
def process(self, payment_type, data):
"""处理支付"""
pass

class CreditCardPayment(PaymentProcessor):
"""信用卡支付"""

def __init__(self):
self.card_processors = {
'visa': self.process_visa,
'mastercard': self.process_mastercard,
'amex': self.process_amex
}

def process(self, payment_type, data):
"""处理信用卡支付"""
card_type = data['card']['type']
processor = self.card_processors.get(card_type)

if not processor:
raise ValueError(f"Unsupported card type: {card_type}")

return processor(data)

def process_visa(self, data):
"""处理 Visa 卡"""
pass

def process_mastercard(self, data):
"""处理万事达卡"""
pass

def process_amex(self, data):
"""处理美国运通卡"""
pass

class PayPalPayment(PaymentProcessor):
"""PayPal 支付"""

def process(self, payment_type, data):
"""处理 PayPal 支付"""
return self.process_paypal(data)

def process_paypal(self, data):
"""PayPal 支付逻辑"""
pass

class BankTransferPayment(PaymentProcessor):
"""银行转账"""

def process(self, payment_type, data):
"""处理银行转账"""
return self.process_bank_transfer(data)

def process_bank_transfer(self, data):
"""银行转账逻辑"""
pass

class OrderProcessor:
"""订单处理器"""

def __init__(self):
self.order_types = {
'new': NewOrder(self._create_payment_processor()),
'update': UpdateOrder(),
'cancel': CancelOrder()
}

def _create_payment_processor(self):
"""创建支付处理器"""
payment_processors = {
'credit_card': CreditCardPayment(),
'paypal': PayPalPayment(),
'bank_transfer': BankTransferPayment()
}
return PaymentProcessorFactory(payment_processors)

def process(self, data):
"""处理订单"""
order_type = data['type']
processor = self.order_types.get(order_type)

if not processor:
raise ValueError(f"Unsupported order type: {order_type}")

return processor.process(data)

```### 改进后评分

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 模块化 | 3/10 | 10/10 | +233% |
| 扩展性 | 2/10 | 10/10 | +400% |
| 耦合度 | 4/10 | 9/10 | +125% |
| 内聚性 | 6/10 | 10/10 | +67% |
| 测试性 | 3/10 | 10/10 | +233% |
| **总分** | **18/50** | **49/50** | **+172%** |
```

#### 代码质量提升#

##### 1. 重构策略#

### 示例：代码重构

用户请求：
"重构这段代码以提高质量"
Claude Code 生成的重构方案：

#### 代码重构#

##### 原始代码#

```
python复制`python

def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
price = product['price'] * quantity

if discount_code == 'SAVE10':
price *= 0.9
elif discount_code == 'SAVE20':
price *= 0.8
elif discount_code == 'SAVE30':
price *= 0.7

if shipping_method == 'standard':
price += 5
elif shipping_method == 'express':
price += 10
elif shipping_method == 'overnight':
price += 20

if customer_level == 'gold':
price *= 0.95
elif customer_level == 'platinum':
price *= 0.9

return price

```### 重构步骤

#### 步骤 1: 提取折扣策略

```
python

class DiscountStrategy:
    """折扣策略"""

    DISCOUNTS = {
        'SAVE10': 0.9,
        'SAVE20': 0.8,
        'SAVE30': 0.7
    }

    @classmethod
    def apply_discount(cls, price, discount_code):
        """应用折扣"""
        discount = cls.DISCOUNTS.get(discount_code, 1.0)
        return price * discount

#### 步骤 2: 提取运费策略

````python
````python

class ShippingStrategy:
"""运费策略"""

SHIPPING_COSTS = {
'standard': 5,
'express': 10,
'overnight': 20
}

@classmethod
def calculate_shipping(cls, shipping_method):
"""计算运费"""
return cls.SHIPPING_COSTS.get(shipping_method, 0)

```#### 步骤 3: 提取客户等级策略

```
python

class CustomerLevelStrategy:
    """客户等级策略"""

    LEVEL_DISCOUNTS = {
        'gold': 0.95,
        'platinum': 0.9
    }

    @classmethod
    def apply_level_discount(cls, price, customer_level):
        """应用客户等级折扣"""
        discount = cls.LEVEL_DISCOUNTS.get(customer_level, 1.0)
        return price * discount

#### 步骤 4: 重构主函数

````python
````python

def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
"""
计算商品价格

参数:
product: 商品信息
quantity: 数量
discount_code: 折扣码
shipping_method: 配送方式
customer_level: 客户等级

返回:
最终价格
"""
 # 计算基础价格
base_price = product['price'] * quantity

 # 应用折扣
discounted_price = DiscountStrategy.apply_discount(
base_price,
discount_code
)

 # 添加运费
price_with_shipping = discounted_price + ShippingStrategy.calculate_shipping(
shipping_method
)

 # 应用客户等级折扣
final_price = CustomerLevelStrategy.apply_level_discount(
price_with_shipping,
customer_level
)

return final_price

```### 重构效果

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 圈复杂度 | 9 | 1 | 89% ↓ |
| 可读性 | 5/10 | 9/10 | +80% |
| 可测试性 | 3/10 | 10/10 | +233% |
| 可扩展性 | 2/10 | 9/10 | +350% |

```
### 2. 性能优化

# 示例：性能优化
用户请求：
"优化这段代码的性能"
Claude Code 生成的优化方案：
## 性能优化
### 原始代码
````python
`python

def find_duplicate_products(products):
"""查找重复商品"""
duplicates = []

for i, product1 in enumerate(products):
for j, product2 in enumerate(products):
if i != j and product1['name'] == product2['name']:
duplicates.append({
'product1': product1,
'product2': product2
})

return duplicates

```### 性能分析

| 指标 | 值 |
|------|-----|
| 时间复杂度 | O(n²) |
| 空间复杂度 | O(n) |
| 执行时间 (1000 项) | 500ms |
| 执行时间 (10000 项) | 50000ms |

### 优化方案

```
python

def find_duplicate_products(products):
    """
    查找重复商品（优化后）

    使用字典来跟踪已见过的商品，将时间复杂度从 O(n²) 降低到 O(n)
    """
    product_map = {}
    duplicates = []

    for product in products:
        name = product['name']

        if name in product_map:
            # 找到重复
            for existing_product in product_map[name]:
                duplicates.append({
                    'product1': existing_product,
                    'product2': product
                })
            product_map[name].append(product)
        else:
            product_map[name] = [product]

    return duplicates

### 进一步优化（使用集合）

````python
````python

def find_duplicate_products(products):
"""
查找重复商品（进一步优化）

使用集合来快速判断重复
"""
seen = set()
duplicates = []

for product in products:
name = product['name']

if name in seen:
duplicates.append(product)
else:
seen.add(name)

return duplicates

```### 优化效果

| 指标 | 原始 | 优化 1 | 优化 2 |
|------|------|--------|--------|
| 时间复杂度 | O(n²) | O(n) | O(n) |
| 空间复杂度 | O(n) | O(n) | O(n) |
| 执行时间 (1000 项) | 500ms | 5ms | 3ms |
| 执行时间 (10000 项) | 50000ms | 50ms | 30ms |
| 性能提升 | - | 99% ↓ | 99.4% ↓ |

```
## 代码质量检查清单

### 1. 代码风格

- [ ] 遵循 PEP 8 (Python) 或相应的语言规范
- [ ] 使用一致的命名约定
- [ ] 添加适当的注释和文档字符串
- [ ] 保持代码格式一致

### 2. 代码结构

- [ ] 函数和类职责单一
- [ ] 避免过长的函数和类
- [ ] 合理使用设计模式
- [ ] 保持低耦合高内聚

### 3. 错误处理

- [ ] 适当的异常处理
- [ ] 有意义的错误消息
- [ ] 资源正确释放
- [ ] 边界条件处理

### 4. 性能

- [ ] 避免不必要的计算
- [ ] 使用适当的数据结构
- [ ] 避免内存泄漏
- [ ] 优化数据库查询

### 5. 安全

- [ ] 输入验证
- [ ] 防止 SQL 注入
- [ ] 防止 XSS 攻击
- [ ] 敏感数据保护

### 6. 测试

- [ ] 单元测试覆盖
- [ ] 集成测试
- [ ] 边界测试
- [ ] 性能测试

## 总结

代码质量评估与提升包括：

1. **代码质量指标**: 可读性、可维护性、性能
2. **重构策略**: 提取方法、应用设计模式、简化逻辑
3. **性能优化**: 算法优化、数据结构优化、缓存策略
4. **质量检查清单**: 代码风格、结构、错误处理、性能、安全、测试

通过系统化的质量评估和持续的代码改进，开发者可以构建更健壮、可维护的代码库。

在下一节中，我们将探讨跨语言代码生成与理解。

```
```
```

```
`python

def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
price = product['price'] * quantity

if discount_code == 'SAVE10':
price *= 0.9
elif discount_code == 'SAVE20':
price *= 0.8
elif discount_code == 'SAVE30':
price *= 0.7

if shipping_method == 'standard':
price += 5
elif shipping_method == 'express':
price += 10
elif shipping_method == 'overnight':
price += 20

if customer_level == 'gold':
price *= 0.95
elif customer_level == 'platinum':
price *= 0.9

return price

```### 重构步骤

#### 步骤 1: 提取折扣策略

```
python

class DiscountStrategy:
    """折扣策略"""

    DISCOUNTS = {
        'SAVE10': 0.9,
        'SAVE20': 0.8,
        'SAVE30': 0.7
    }

    @classmethod
    def apply_discount(cls, price, discount_code):
        """应用折扣"""
        discount = cls.DISCOUNTS.get(discount_code, 1.0)
        return price * discount

#### 步骤 2: 提取运费策略

````python
````python

class ShippingStrategy:
"""运费策略"""

SHIPPING_COSTS = {
'standard': 5,
'express': 10,
'overnight': 20
}

@classmethod
def calculate_shipping(cls, shipping_method):
"""计算运费"""
return cls.SHIPPING_COSTS.get(shipping_method, 0)

```#### 步骤 3: 提取客户等级策略

```
python

class CustomerLevelStrategy:
    """客户等级策略"""

    LEVEL_DISCOUNTS = {
        'gold': 0.95,
        'platinum': 0.9
    }

    @classmethod
    def apply_level_discount(cls, price, customer_level):
        """应用客户等级折扣"""
        discount = cls.LEVEL_DISCOUNTS.get(customer_level, 1.0)
        return price * discount

#### 步骤 4: 重构主函数

````python
````python

def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
"""
计算商品价格

参数:
product: 商品信息
quantity: 数量
discount_code: 折扣码
shipping_method: 配送方式
customer_level: 客户等级

返回:
最终价格
"""
 # 计算基础价格
base_price = product['price'] * quantity

 # 应用折扣
discounted_price = DiscountStrategy.apply_discount(
base_price,
discount_code
)

 # 添加运费
price_with_shipping = discounted_price + ShippingStrategy.calculate_shipping(
shipping_method
)

 # 应用客户等级折扣
final_price = CustomerLevelStrategy.apply_level_discount(
price_with_shipping,
customer_level
)

return final_price

```### 重构效果

| 指标 | 改进前 | 改进后 | 改善 |
|------|--------|--------|------|
| 圈复杂度 | 9 | 1 | 89% ↓ |
| 可读性 | 5/10 | 9/10 | +80% |
| 可测试性 | 3/10 | 10/10 | +233% |
| 可扩展性 | 2/10 | 9/10 | +350% |

```
### 2. 性能优化

# 示例：性能优化
用户请求：
"优化这段代码的性能"
Claude Code 生成的优化方案：
## 性能优化
### 原始代码
````python
`python

def find_duplicate_products(products):
"""查找重复商品"""
duplicates = []

for i, product1 in enumerate(products):
for j, product2 in enumerate(products):
if i != j and product1['name'] == product2['name']:
duplicates.append({
'product1': product1,
'product2': product2
})

return duplicates

```### 性能分析

| 指标 | 值 |
|------|-----|
| 时间复杂度 | O(n²) |
| 空间复杂度 | O(n) |
| 执行时间 (1000 项) | 500ms |
| 执行时间 (10000 项) | 50000ms |

### 优化方案

```
python

def find_duplicate_products(products):
    """
    查找重复商品（优化后）

    使用字典来跟踪已见过的商品，将时间复杂度从 O(n²) 降低到 O(n)
    """
    product_map = {}
    duplicates = []

    for product in products:
        name = product['name']

        if name in product_map:
            # 找到重复
            for existing_product in product_map[name]:
                duplicates.append({
                    'product1': existing_product,
                    'product2': product
                })
            product_map[name].append(product)
        else:
            product_map[name] = [product]

    return duplicates

### 进一步优化（使用集合）

````python
````python

def find_duplicate_products(products):
"""
查找重复商品（进一步优化）

使用集合来快速判断重复
"""
seen = set()
duplicates = []

for product in products:
name = product['name']

if name in seen:
duplicates.append(product)
else:
seen.add(name)

return duplicates

```### 优化效果

| 指标 | 原始 | 优化 1 | 优化 2 |
|------|------|--------|--------|
| 时间复杂度 | O(n²) | O(n) | O(n) |
| 空间复杂度 | O(n) | O(n) | O(n) |
| 执行时间 (1000 项) | 500ms | 5ms | 3ms |
| 执行时间 (10000 项) | 50000ms | 50ms | 30ms |
| 性能提升 | - | 99% ↓ | 99.4% ↓ |

```
## 代码质量检查清单

### 1. 代码风格

- [ ] 遵循 PEP 8 (Python) 或相应的语言规范
- [ ] 使用一致的命名约定
- [ ] 添加适当的注释和文档字符串
- [ ] 保持代码格式一致

### 2. 代码结构

- [ ] 函数和类职责单一
- [ ] 避免过长的函数和类
- [ ] 合理使用设计模式
- [ ] 保持低耦合高内聚

### 3. 错误处理

- [ ] 适当的异常处理
- [ ] 有意义的错误消息
- [ ] 资源正确释放
- [ ] 边界条件处理

### 4. 性能

- [ ] 避免不必要的计算
- [ ] 使用适当的数据结构
- [ ] 避免内存泄漏
- [ ] 优化数据库查询

### 5. 安全

- [ ] 输入验证
- [ ] 防止 SQL 注入
- [ ] 防止 XSS 攻击
- [ ] 敏感数据保护

### 6. 测试

- [ ] 单元测试覆盖
- [ ] 集成测试
- [ ] 边界测试
- [ ] 性能测试

## 总结

代码质量评估与提升包括：

1. **代码质量指标**: 可读性、可维护性、性能
2. **重构策略**: 提取方法、应用设计模式、简化逻辑
3. **性能优化**: 算法优化、数据结构优化、缓存策略
4. **质量检查清单**: 代码风格、结构、错误处理、性能、安全、测试

通过系统化的质量评估和持续的代码改进，开发者可以构建更健壮、可维护的代码库。

在下一节中，我们将探讨跨语言代码生成与理解。

```
```
```

---

## 5 跨语言代码生成与理解

**URL**: https://claudecode.tangshuang.net/course/27.5%20%E8%B7%A8%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E7%90%86%E8%A7%A3

#### 跨语言代码生成概述#

Claude Code 具备强大的跨语言代码生成与理解能力。开发者可以在不同编程语言之间进行代码转换、理解多种语言的代码库，并实现跨语言的系统集成。

#### 代码语言转换#

##### 1. Python 到 JavaScript#

### 示例：Python 代码转换为 JavaScript

用户请求：
"将这段 Python 代码转换为 JavaScript"

原始 Python 代码：

```
python复制````python

class User:
def __init__(self, name, email):
self.name = name
self.email = email

def get_info(self):
return {
'name': self.name,
'email': self.email
}

def update_email(self, new_email):
self.email = new_email

@staticmethod
def validate_email(email):
return '@' in email and '.' in email

def process_users(users):
result = []
for user in users:
if User.validate_email(user.email):
result.append(user.get_info())
return result

users = [
User('Alice', 'alice@example.com'),
User('Bob', 'bob@example.com'),
User('Charlie', 'invalid-email')
]

processed = process_users(users)
print(processed)

```> 生成的 JavaScript 代码：
```
javascript

class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }

    getInfo() {
        return {
            name: this.name,
            email: this.email
        };
    }

    updateEmail(newEmail) {
        this.email = newEmail;
    }

    static validateEmail(email) {
        return email.includes('@') && email.includes('.');
    }
}

function processUsers(users) {
    const result = [];
    for (const user of users) {
        if (User.validateEmail(user.email)) {
            result.push(user.getInfo());
        }
    }
    return result;
}

const users = [
    new User('Alice', 'alice@example.com'),
    new User('Bob', 'bob@example.com'),
    new User('Charlie', 'invalid-email')
];

const processed = processUsers(users);
console.log(processed);

### 2. JavaScript 到 Python

````javascript
````javascript

// 示例：JavaScript 代码转换为 Python

用户请求：
"将这段 JavaScript 代码转换为 Python"

原始 JavaScript 代码：
```javascript
```javascript

class Calculator {
    constructor() {
        this.history = [];
    }

    add(a, b) {
        const result = a + b;
        this.history.push({ operation: 'add', a, b, result });
        return result;
    }

    subtract(a, b) {
        const result = a - b;
        this.history.push({ operation: 'subtract', a, b, result });
        return result;
    }

    multiply(a, b) {
        const result = a * b;
        this.history.push({ operation: 'multiply', a, b, result });
        return result;
    }

    divide(a, b) {
        if (b === 0) {
            throw new Error('Division by zero');
        }
        const result = a / b;
        this.history.push({ operation: 'divide', a, b, result });
        return result;
    }

    getHistory() {
        return this.history;
    }
}

const calc = new Calculator();
console.log(calc.add(5, 3));
console.log(calc.subtract(10, 4));
console.log(calc.multiply(6, 7));
console.log(calc.divide(20, 4));
console.log(calc.getHistory());

```> 生成的 Python 代码：
class Calculator:
"""计算器类"""
def __init__(self):
self.history = []
def add(self, a, b):
"""加法"""
result = a + b
self.history.append({
'operation': 'add',
'a': a,
'b': b,
'result': result
})
return result
def subtract(self, a, b):
"""减法"""
result = a - b
self.history.append({
'operation': 'subtract',
'a': a,
'b': b,
'result': result
})
return result
def multiply(self, a, b):
"""乘法"""
result = a * b
self.history.append({
'operation': 'multiply',
'a': a,
```

```
````python

class User:
def __init__(self, name, email):
self.name = name
self.email = email

def get_info(self):
return {
'name': self.name,
'email': self.email
}

def update_email(self, new_email):
self.email = new_email

@staticmethod
def validate_email(email):
return '@' in email and '.' in email

def process_users(users):
result = []
for user in users:
if User.validate_email(user.email):
result.append(user.get_info())
return result

users = [
User('Alice', 'alice@example.com'),
User('Bob', 'bob@example.com'),
User('Charlie', 'invalid-email')
]

processed = process_users(users)
print(processed)

```> 生成的 JavaScript 代码：
```
javascript

class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }

    getInfo() {
        return {
            name: this.name,
            email: this.email
        };
    }

    updateEmail(newEmail) {
        this.email = newEmail;
    }

    static validateEmail(email) {
        return email.includes('@') && email.includes('.');
    }
}

function processUsers(users) {
    const result = [];
    for (const user of users) {
        if (User.validateEmail(user.email)) {
            result.push(user.getInfo());
        }
    }
    return result;
}

const users = [
    new User('Alice', 'alice@example.com'),
    new User('Bob', 'bob@example.com'),
    new User('Charlie', 'invalid-email')
];

const processed = processUsers(users);
console.log(processed);

### 2. JavaScript 到 Python

````javascript
````javascript

// 示例：JavaScript 代码转换为 Python

用户请求：
"将这段 JavaScript 代码转换为 Python"

原始 JavaScript 代码：
```javascript
```javascript

class Calculator {
    constructor() {
        this.history = [];
    }

    add(a, b) {
        const result = a + b;
        this.history.push({ operation: 'add', a, b, result });
        return result;
    }

    subtract(a, b) {
        const result = a - b;
        this.history.push({ operation: 'subtract', a, b, result });
        return result;
    }

    multiply(a, b) {
        const result = a * b;
        this.history.push({ operation: 'multiply', a, b, result });
        return result;
    }

    divide(a, b) {
        if (b === 0) {
            throw new Error('Division by zero');
        }
        const result = a / b;
        this.history.push({ operation: 'divide', a, b, result });
        return result;
    }

    getHistory() {
        return this.history;
    }
}

const calc = new Calculator();
console.log(calc.add(5, 3));
console.log(calc.subtract(10, 4));
console.log(calc.multiply(6, 7));
console.log(calc.divide(20, 4));
console.log(calc.getHistory());

```> 生成的 Python 代码：
class Calculator:
"""计算器类"""
def __init__(self):
self.history = []
def add(self, a, b):
"""加法"""
result = a + b
self.history.append({
'operation': 'add',
'a': a,
'b': b,
'result': result
})
return result
def subtract(self, a, b):
"""减法"""
result = a - b
self.history.append({
'operation': 'subtract',
'a': a,
'b': b,
'result': result
})
return result
def multiply(self, a, b):
"""乘法"""
result = a * b
self.history.append({
'operation': 'multiply',
'a': a,
```

'b': b,
'result': result
})
return result
def divide(self, a, b):
"""除法"""
if b == 0:
raise ZeroDivisionError('Division by zero')
result = a / b
self.history.append({
'operation': 'divide',
'a': a,
'b': b,
'result': result
})
return result
def get_history(self):
"""获取历史记录"""
return self.history
calc = Calculator()
print(calc.add(5, 3))
print(calc.subtract(10, 4))
print(calc.multiply(6, 7))
print(calc.divide(20, 4))
print(calc.get_history())

```
bash复制### 3. Java 到 Python

```java
```java

// 示例：Java 代码转换为 Python

用户请求：
"将这段 Java 代码转换为 Python"

原始 Java 代码：
```java
```java

import java.util.*;

public class OrderProcessor {
    private List<Order> orders;

    public OrderProcessor() {
        this.orders = new ArrayList<>();
    }

    public void addOrder(Order order) {
        orders.add(order);
    }

    public List<Order> getOrdersByStatus(String status) {
        List<Order> result = new ArrayList<>();
        for (Order order : orders) {
            if (order.getStatus().equals(status)) {
                result.add(order);
            }
        }
        return result;
    }

    public double getTotalAmount() {
        double total = 0.0;
        for (Order order : orders) {
            total += order.getAmount();
        }
        return total;
    }

    public static class Order {
        private String id;
        private String status;
        private double amount;

        public Order(String id, String status, double amount) {
            this.id = id;
            this.status = status;
            this.amount = amount;
        }

        public String getId() {
            return id;
        }

        public String getStatus() {
            return status;
        }

        public double getAmount() {
            return amount;
        }
    }
}

生成的 Python 代码：

```python

from typing import List

class Order:
"""订单类"""

def __init__(self, order_id: str, status: str, amount: float):
self.id = order_id
self.status = status
self.amount = amount

class OrderProcessor:
"""订单处理器"""

def __init__(self):
self.orders: List[Order] = []

def add_order(self, order: Order):
"""添加订单"""
self.orders.append(order)

def get_orders_by_status(self, status: str) -> List[Order]:
"""根据状态获取订单"""
return [
order for order in self.orders
if order.status == status
]

def get_total_amount(self) -> float:
"""获取总金额"""
return sum(order.amount for order in self.orders)

## 跨语言代码理解

### 1. 理解多语言项目

```python
python

# 示例：理解包含多种语言的项目

用户请求：
"理解这个多语言项目的结构"

Claude Code 生成的项目分析：

## 多语言项目结构分析

project/
├── backend/              # Python 后端
│   ├── app/
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── routes.py
│   │   └── services.py
│   ├── requirements.txt
│   └── main.py
├── frontend/             # JavaScript/React 前端
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── services/
│   │   └── App.js
│   ├── package.json
│   └── webpack.config.js
├── mobile/               # Kotlin/Android 移动端
│   ├── app/
│   │   ├── MainActivity.kt
│   │   ├── adapters/
│   │   └── viewmodels/
│   └── build.gradle
└── shared/               # 共享类型定义
└── types/
├── user.ts
├── product.ts
└── order.ts

## 语言职责划分
### Python 后端 (backend/)
- **职责**: API 服务、业务逻辑、数据处理
- **框架**: Flask/FastAPI
- **数据库**: PostgreSQL/MySQL
- **主要功能**:
- 用户认证和授权
- 商品管理
- 订单处理
- 支付集成
### JavaScript 前端 (frontend/)
- **职责**: 用户界面、交互逻辑
- **框架**: React
- **构建工具**: Webpack
- **主要功能**:
- 商品展示
- 购物车管理
- 订单创建
- 用户个人中心
### Kotlin 移动端 (mobile/)
- **职责**: 移动应用、原生功能
- **框架**: Android SDK
- **主要功能**:
- 推送通知
- 本地存储
- 设备集成
- 离线支持
### 共享类型定义 (shared/)
- **职责**: 跨语言类型定义
- **格式**: TypeScript
- **主要功能**:
- 统一数据结构
- API 接口定义
- 类型安全
```

```
### 3. Java 到 Python

```java
```java

// 示例：Java 代码转换为 Python

用户请求：
"将这段 Java 代码转换为 Python"

原始 Java 代码：
```java
```java

import java.util.*;

public class OrderProcessor {
    private List<Order> orders;

    public OrderProcessor() {
        this.orders = new ArrayList<>();
    }

    public void addOrder(Order order) {
        orders.add(order);
    }

    public List<Order> getOrdersByStatus(String status) {
        List<Order> result = new ArrayList<>();
        for (Order order : orders) {
            if (order.getStatus().equals(status)) {
                result.add(order);
            }
        }
        return result;
    }

    public double getTotalAmount() {
        double total = 0.0;
        for (Order order : orders) {
            total += order.getAmount();
        }
        return total;
    }

    public static class Order {
        private String id;
        private String status;
        private double amount;

        public Order(String id, String status, double amount) {
            this.id = id;
            this.status = status;
            this.amount = amount;
        }

        public String getId() {
            return id;
        }

        public String getStatus() {
            return status;
        }

        public double getAmount() {
            return amount;
        }
    }
}

生成的 Python 代码：

```python

from typing import List

class Order:
"""订单类"""

def __init__(self, order_id: str, status: str, amount: float):
self.id = order_id
self.status = status
self.amount = amount

class OrderProcessor:
"""订单处理器"""

def __init__(self):
self.orders: List[Order] = []

def add_order(self, order: Order):
"""添加订单"""
self.orders.append(order)

def get_orders_by_status(self, status: str) -> List[Order]:
"""根据状态获取订单"""
return [
order for order in self.orders
if order.status == status
]

def get_total_amount(self) -> float:
"""获取总金额"""
return sum(order.amount for order in self.orders)

## 跨语言代码理解

### 1. 理解多语言项目

```python
python

# 示例：理解包含多种语言的项目

用户请求：
"理解这个多语言项目的结构"

Claude Code 生成的项目分析：

## 多语言项目结构分析

project/
├── backend/              # Python 后端
│   ├── app/
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── routes.py
│   │   └── services.py
│   ├── requirements.txt
│   └── main.py
├── frontend/             # JavaScript/React 前端
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── services/
│   │   └── App.js
│   ├── package.json
│   └── webpack.config.js
├── mobile/               # Kotlin/Android 移动端
│   ├── app/
│   │   ├── MainActivity.kt
│   │   ├── adapters/
│   │   └── viewmodels/
│   └── build.gradle
└── shared/               # 共享类型定义
└── types/
├── user.ts
├── product.ts
└── order.ts

## 语言职责划分
### Python 后端 (backend/)
- **职责**: API 服务、业务逻辑、数据处理
- **框架**: Flask/FastAPI
- **数据库**: PostgreSQL/MySQL
- **主要功能**:
- 用户认证和授权
- 商品管理
- 订单处理
- 支付集成
### JavaScript 前端 (frontend/)
- **职责**: 用户界面、交互逻辑
- **框架**: React
- **构建工具**: Webpack
- **主要功能**:
- 商品展示
- 购物车管理
- 订单创建
- 用户个人中心
### Kotlin 移动端 (mobile/)
- **职责**: 移动应用、原生功能
- **框架**: Android SDK
- **主要功能**:
- 推送通知
- 本地存储
- 设备集成
- 离线支持
### 共享类型定义 (shared/)
- **职责**: 跨语言类型定义
- **格式**: TypeScript
- **主要功能**:
- 统一数据结构
- API 接口定义
- 类型安全
```

##### 2. 跨语言 API 设计#

```
bash复制python

# 示例：设计跨语言 API

用户请求：
"设计一个跨语言的 API 接口"

Claude Code 生成的 API 设计：

## 跨语言 API 设计

### API 规范 (OpenAPI)

openapi: 3.0.0
info:
title: E-commerce API
version: 1.0.0
description: 跨语言电商 API

paths:
/users:
post:
summary: 创建用户
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/UserCreate'
responses:
'201':
description: 用户创建成功
content:
application/json:
schema:
$ref: '#/components/schemas/User'
get:
summary: 获取用户列表
responses:
'200':
description: 成功
content:
application/json:
schema:
type: array
items:
$ref: '#/components/schemas/User'

/users/{user_id}:
get:
summary: 获取用户详情
parameters:
 - name: user_id
in: path
required: true
schema:
type: integer
responses:
'200':
description: 成功
content:
application/json:
schema:
$ref: '#/components/schemas/User'

components:
schemas:
User:
type: object
properties:
id:
type: integer
name:
type: string
email:
type: string
format: email
created_at:
type: string
format: date-time

UserCreate:
type: object
required:
 - name
 - email
properties:
name:
type: string
email:
type: string
format: email
password:
type: string

`> >
### Python 后端实现
```python
python

# backend/app/routes.py
from flask import Blueprint, request, jsonify
from app.models import User
from app.services import UserService

user_bp = Blueprint('users', __name__)

@user_bp.route('/users', methods=['POST'])
def create_user():
    """创建用户"""
    data = request.get_json()

    user = UserService.create_user(
        name=data['name'],
        email=data['email'],
        password=data['password']
    )

    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    }), 201

@user_bp.route('/users', methods=['GET'])
def get_users():
    """获取用户列表"""
    users = UserService.get_all_users()

    return jsonify([
        {
            'id': user.id,
            'name': user.name,
            'email': user.email,
            'created_at': user.created_at.isoformat()
        }
        for user in users
    ])

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户详情"""
    user = UserService.get_user(user_id)

    if not user:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    })

```### JavaScript 前端实现

// frontend/src/services/userService.js
class UserService {
static async createUser(userData) {
const response = await fetch('/api/users', {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify(userData)
});
if (!response.ok) {
throw new Error('Failed to create user');
}
return response.json();
}
static async getUsers() {
const response = await fetch('/api/users');
if (!response.ok) {
throw new Error('Failed to fetch users');
}
return response.json();
}
static async getUser(userId) {
const response = await fetch(`/api/users/${userId}`);
if (!response.ok) {
throw new Error('Failed to fetch user');
}
return response.json();
}
}
export default UserService;
```

```
python

# 示例：设计跨语言 API

用户请求：
"设计一个跨语言的 API 接口"

Claude Code 生成的 API 设计：

## 跨语言 API 设计

### API 规范 (OpenAPI)

openapi: 3.0.0
info:
title: E-commerce API
version: 1.0.0
description: 跨语言电商 API

paths:
/users:
post:
summary: 创建用户
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/UserCreate'
responses:
'201':
description: 用户创建成功
content:
application/json:
schema:
$ref: '#/components/schemas/User'
get:
summary: 获取用户列表
responses:
'200':
description: 成功
content:
application/json:
schema:
type: array
items:
$ref: '#/components/schemas/User'

/users/{user_id}:
get:
summary: 获取用户详情
parameters:
 - name: user_id
in: path
required: true
schema:
type: integer
responses:
'200':
description: 成功
content:
application/json:
schema:
$ref: '#/components/schemas/User'

components:
schemas:
User:
type: object
properties:
id:
type: integer
name:
type: string
email:
type: string
format: email
created_at:
type: string
format: date-time

UserCreate:
type: object
required:
 - name
 - email
properties:
name:
type: string
email:
type: string
format: email
password:
type: string

`> >
### Python 后端实现
```python
python

# backend/app/routes.py
from flask import Blueprint, request, jsonify
from app.models import User
from app.services import UserService

user_bp = Blueprint('users', __name__)

@user_bp.route('/users', methods=['POST'])
def create_user():
    """创建用户"""
    data = request.get_json()

    user = UserService.create_user(
        name=data['name'],
        email=data['email'],
        password=data['password']
    )

    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    }), 201

@user_bp.route('/users', methods=['GET'])
def get_users():
    """获取用户列表"""
    users = UserService.get_all_users()

    return jsonify([
        {
            'id': user.id,
            'name': user.name,
            'email': user.email,
            'created_at': user.created_at.isoformat()
        }
        for user in users
    ])

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """获取用户详情"""
    user = UserService.get_user(user_id)

    if not user:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'created_at': user.created_at.isoformat()
    })

```### JavaScript 前端实现

// frontend/src/services/userService.js
class UserService {
static async createUser(userData) {
const response = await fetch('/api/users', {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify(userData)
});
if (!response.ok) {
throw new Error('Failed to create user');
}
return response.json();
}
static async getUsers() {
const response = await fetch('/api/users');
if (!response.ok) {
throw new Error('Failed to fetch users');
}
return response.json();
}
static async getUser(userId) {
const response = await fetch(`/api/users/${userId}`);
if (!response.ok) {
throw new Error('Failed to fetch user');
}
return response.json();
}
}
export default UserService;
```

##### Kotlin 移动端实现#

```
kotlin复制```kotlin

// mobile/app/src/main/java/com/example/app/data/UserService.kt
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*

data class User(
    val id: Int,
    val name: String,
    val email: String,
    val created_at: String
)

data class UserCreate(
    val name: String,
    val email: String,
    val password: String
)

interface UserApi {
    @POST("users")
    suspend fun createUser(@Body user: UserCreate): User

    @GET("users")
    suspend fun getUsers(): List<User>

    @GET("users/{user_id}")
    suspend fun getUser(@Path("user_id") userId: Int): User
}

class UserService {
    private val api: UserApi

    init {
        val retrofit = Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        api = retrofit.create(UserApi::class.java)
    }

    suspend fun createUser(user: UserCreate): User {
        return api.createUser(user)
    }

    suspend fun getUsers(): List<User> {
        return api.getUsers()
    }

    suspend fun getUser(userId: Int): User {
        return api.getUser(userId)
    }
}

```## 跨语言代码生成

### 1. 从类型定义生成代码

// 示例：从 TypeScript 类型定义生成多语言代码
用户请求：
"从这些 TypeScript 类型定义生成 Python 和 Java 代码"
TypeScript 类型定义：
````typescript
`typescript

interface User {
id: number;
name: string;
email: string;
age?: number;
createdAt: Date;
roles: string[];
}

interface Product {
id: number;
name: string;
price: number;
stock: number;
category: string;
tags: string[];
}

interface Order {
id: number;
userId: number;
items: OrderItem[];
totalAmount: number;
status: 'pending' | 'paid' | 'shipped' | 'completed';
createdAt: Date;
}

interface OrderItem {
productId: number;
quantity: number;
price: number;
}

生成的 Python 代码：
```python
python

from typing import List, Optional
from datetime import datetime
from enum import Enum

class OrderStatus(str, Enum):
    """订单状态枚举"""
    PENDING = 'pending'
    PAID = 'paid'
    SHIPPED = 'shipped'
    COMPLETED = 'completed'

class User:
    """用户模型"""

    def __init__(
        self,
        id: int,
        name: str,
        email: str,
        created_at: datetime,
        age: Optional[int] = None,
        roles: Optional[List[str]] = None
    ):
        self.id = id
        self.name = name
        self.email = email
        self.age = age
        self.created_at = created_at
        self.roles = roles or []

class Product:
    """商品模型"""

    def __init__(
        self,
        id: int,
        name: str,
        price: float,
        stock: int,
        category: str,
        tags: Optional[List[str]] = None
    ):
        self.id = id
        self.name = name
        self.price = price
        self.stock = stock
        self.category = category
        self.tags = tags or []

class OrderItem:
    """订单项模型"""

    def __init__(
        self,
        product_id: int,
        quantity: int,
        price: float
    ):
        self.product_id = product_id
        self.quantity = quantity
        self.price = price

class Order:
    """订单模型"""

    def __init__(
        self,
        id: int,
        user_id: int,
        items: List[OrderItem],
        total_amount: float,
        status: OrderStatus,
        created_at: datetime
    ):
        self.id = id
        self.user_id = user_id
        self.items = items
        self.total_amount = total_amount
        self.status = status
        self.created_at = created_at

生成的 Java 代码：

```java

import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;

public class User {
private int id;
private String name;
private String email;
private Integer age;
private LocalDateTime createdAt;
private List<String> roles;

public User(int id, String name, String email, LocalDateTime createdAt) {
this.id = id;
this.name = name;
this.email = email;
this.createdAt = createdAt;
this.roles = new ArrayList<>();
}

// Getters and Setters
public int getId() { return id; }
public void setId(int id) { this.id = id; }

public String getName() { return name; }
public void setName(String name) { this.name = name; }

public String getEmail() { return email; }
public void setEmail(String email) { this.email = email; }

public Integer getAge() { return age; }
public void setAge(Integer age) { this.age = age; }

public LocalDateTime getCreatedAt() { return createdAt; }
public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

public List<String> getRoles() { return roles; }
public void setRoles(List<String> roles) { this.roles = roles; }
}

public enum OrderStatus {
PENDING,
PAID,
SHIPPED,
COMPLETED
}

public class OrderItem {
private int productId;
private int quantity;
private double price;

public OrderItem(int productId, int quantity, double price) {
this.productId = productId;
this.quantity = quantity;
this.price = price;
}

// Getters and Setters
public int getProductId() { return productId; }
public void setProductId(int productId) { this.productId = productId; }

public int getQuantity() { return quantity; }
public void setQuantity(int quantity) { this.quantity = quantity; }

public double getPrice() { return price; }
public void setPrice(double price) { this.price = price; }
}

public class Order {
private int id;
private int userId;
private List<OrderItem> items;
private double totalAmount;
private OrderStatus status;
private LocalDateTime createdAt;

public Order(int id, int userId, double totalAmount, OrderStatus status, LocalDateTime createdAt) {
this.id = id;
this.userId = userId;
this.totalAmount = totalAmount;
this.status = status;
this.createdAt = createdAt;
this.items = new ArrayList<>();
}

// Getters and Setters
public int getId() { return id; }
public void setId(int id) { this.id = id; }

public int getUserId() { return userId; }
public void setUserId(int userId) { this.userId = userId; }

public List<OrderItem> getItems() { return items; }
public void setItems(List<OrderItem> items) { this.items = items; }

public double getTotalAmount() { return totalAmount; }
public void setTotalAmount(double totalAmount) { this.totalAmount = totalAmount; }

public OrderStatus getStatus() { return status; }
public void setStatus(OrderStatus status) { this.status = status; }

public LocalDateTime getCreatedAt() { return createdAt; }
public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
```

```
```kotlin

// mobile/app/src/main/java/com/example/app/data/UserService.kt
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*

data class User(
    val id: Int,
    val name: String,
    val email: String,
    val created_at: String
)

data class UserCreate(
    val name: String,
    val email: String,
    val password: String
)

interface UserApi {
    @POST("users")
    suspend fun createUser(@Body user: UserCreate): User

    @GET("users")
    suspend fun getUsers(): List<User>

    @GET("users/{user_id}")
    suspend fun getUser(@Path("user_id") userId: Int): User
}

class UserService {
    private val api: UserApi

    init {
        val retrofit = Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        api = retrofit.create(UserApi::class.java)
    }

    suspend fun createUser(user: UserCreate): User {
        return api.createUser(user)
    }

    suspend fun getUsers(): List<User> {
        return api.getUsers()
    }

    suspend fun getUser(userId: Int): User {
        return api.getUser(userId)
    }
}

```## 跨语言代码生成

### 1. 从类型定义生成代码

// 示例：从 TypeScript 类型定义生成多语言代码
用户请求：
"从这些 TypeScript 类型定义生成 Python 和 Java 代码"
TypeScript 类型定义：
````typescript
`typescript

interface User {
id: number;
name: string;
email: string;
age?: number;
createdAt: Date;
roles: string[];
}

interface Product {
id: number;
name: string;
price: number;
stock: number;
category: string;
tags: string[];
}

interface Order {
id: number;
userId: number;
items: OrderItem[];
totalAmount: number;
status: 'pending' | 'paid' | 'shipped' | 'completed';
createdAt: Date;
}

interface OrderItem {
productId: number;
quantity: number;
price: number;
}

生成的 Python 代码：
```python
python

from typing import List, Optional
from datetime import datetime
from enum import Enum

class OrderStatus(str, Enum):
    """订单状态枚举"""
    PENDING = 'pending'
    PAID = 'paid'
    SHIPPED = 'shipped'
    COMPLETED = 'completed'

class User:
    """用户模型"""

    def __init__(
        self,
        id: int,
        name: str,
        email: str,
        created_at: datetime,
        age: Optional[int] = None,
        roles: Optional[List[str]] = None
    ):
        self.id = id
        self.name = name
        self.email = email
        self.age = age
        self.created_at = created_at
        self.roles = roles or []

class Product:
    """商品模型"""

    def __init__(
        self,
        id: int,
        name: str,
        price: float,
        stock: int,
        category: str,
        tags: Optional[List[str]] = None
    ):
        self.id = id
        self.name = name
        self.price = price
        self.stock = stock
        self.category = category
        self.tags = tags or []

class OrderItem:
    """订单项模型"""

    def __init__(
        self,
        product_id: int,
        quantity: int,
        price: float
    ):
        self.product_id = product_id
        self.quantity = quantity
        self.price = price

class Order:
    """订单模型"""

    def __init__(
        self,
        id: int,
        user_id: int,
        items: List[OrderItem],
        total_amount: float,
        status: OrderStatus,
        created_at: datetime
    ):
        self.id = id
        self.user_id = user_id
        self.items = items
        self.total_amount = total_amount
        self.status = status
        self.created_at = created_at

生成的 Java 代码：

```java

import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;

public class User {
private int id;
private String name;
private String email;
private Integer age;
private LocalDateTime createdAt;
private List<String> roles;

public User(int id, String name, String email, LocalDateTime createdAt) {
this.id = id;
this.name = name;
this.email = email;
this.createdAt = createdAt;
this.roles = new ArrayList<>();
}

// Getters and Setters
public int getId() { return id; }
public void setId(int id) { this.id = id; }

public String getName() { return name; }
public void setName(String name) { this.name = name; }

public String getEmail() { return email; }
public void setEmail(String email) { this.email = email; }

public Integer getAge() { return age; }
public void setAge(Integer age) { this.age = age; }

public LocalDateTime getCreatedAt() { return createdAt; }
public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

public List<String> getRoles() { return roles; }
public void setRoles(List<String> roles) { this.roles = roles; }
}

public enum OrderStatus {
PENDING,
PAID,
SHIPPED,
COMPLETED
}

public class OrderItem {
private int productId;
private int quantity;
private double price;

public OrderItem(int productId, int quantity, double price) {
this.productId = productId;
this.quantity = quantity;
this.price = price;
}

// Getters and Setters
public int getProductId() { return productId; }
public void setProductId(int productId) { this.productId = productId; }

public int getQuantity() { return quantity; }
public void setQuantity(int quantity) { this.quantity = quantity; }

public double getPrice() { return price; }
public void setPrice(double price) { this.price = price; }
}

public class Order {
private int id;
private int userId;
private List<OrderItem> items;
private double totalAmount;
private OrderStatus status;
private LocalDateTime createdAt;

public Order(int id, int userId, double totalAmount, OrderStatus status, LocalDateTime createdAt) {
this.id = id;
this.userId = userId;
this.totalAmount = totalAmount;
this.status = status;
this.createdAt = createdAt;
this.items = new ArrayList<>();
}

// Getters and Setters
public int getId() { return id; }
public void setId(int id) { this.id = id; }

public int getUserId() { return userId; }
public void setUserId(int userId) { this.userId = userId; }

public List<OrderItem> getItems() { return items; }
public void setItems(List<OrderItem> items) { this.items = items; }

public double getTotalAmount() { return totalAmount; }
public void setTotalAmount(double totalAmount) { this.totalAmount = totalAmount; }

public OrderStatus getStatus() { return status; }
public void setStatus(OrderStatus status) { this.status = status; }

public LocalDateTime getCreatedAt() { return createdAt; }
public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
```

---

## 6 大规模代码库处理

**URL**: https://claudecode.tangshuang.net/course/27.6%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BB%A3%E7%A0%81%E5%BA%93%E5%A4%84%E7%90%86

#### 大规模代码库处理概述#

Claude Code 具备处理大规模代码库的能力。通过智能的代码分析、索引和搜索技术，开发者可以高效地理解和修改包含数百万行代码的大型项目。

#### 代码库索引与搜索#

##### 1. 代码库索引#

### 示例：索引大型代码库

用户请求：
"索引这个大型代码库"

Claude Code 生成的索引报告：

#### 代码库索引报告#

##### 代码库统计#

##### 目录结构#

```
bash复制├── src/
│   ├── core/              # 核心模块 (456 files)
│   │   ├── auth/          # 认证模块
│   │   ├── database/      # 数据库模块
│   │   ├── cache/         # 缓存模块
│   │   └── messaging/     # 消息模块
│   ├── services/          # 服务层 (1,234 files)
│   │   ├── user/          # 用户服务
│   │   ├── product/       # 商品服务
│   │   ├── order/         # 订单服务
│   │   └── payment/       # 支付服务
│   ├── api/               # API 层 (890 files)
│   │   ├── v1/            # API v1
│   │   ├── v2/            # API v2
│   │   └── internal/      # 内部 API
│   └── utils/             # 工具模块 (567 files)
├── tests/                 # 测试代码 (2,345 files)
├── docs/                  # 文档 (1,234 files)
├── scripts/               # 脚本 (456 files)
└── config/                # 配置 (234 files)
```
### 依赖关系图

```mermaid
mermaid

graph TD
    A[core/auth] --> B[core/database]
    A --> C[core/cache]
    D[services/user] --> A
    D --> B
    E[services/product] --> B
    E --> C
    F[services/order] --> D
    F --> E
    F --> G[services/payment]
    G --> A
    G --> B
    H[api/v1] --> D
    H --> E
    H --> F
    H --> G

### 热点文件

| 文件 | 修改次数 | 贡献者 | 复杂度 |
|------|----------|--------|--------|
| src/services/order/order_service.py | 234 | 5 | 高 |
| src/core/auth/jwt_handler.py | 189 | 3 | 中 |
| src/api/v1/order_routes.py | 167 | 4 | 高 |
| src/services/product/product_service.py | 145 | 3 | 中 |
| src/core/database/connection_pool.py | 123 | 2 | 高 |

### 代码质量指标

| 指标 | 平均值 | 良好 | 需要改进 |
|------|--------|------|----------|
| 圈复杂度 | 8.5 | < 10 | 234 files |
| 代码重复率 | 12.3% | < 5% | 567 files |
| 测试覆盖率 | 78.5% | > 80% | 345 files |
| 文档覆盖率 | 65.2% | > 70% | 456 files |

### 2. 智能代码搜索
```python
python

# 示例：智能代码搜索

用户请求：
"搜索所有处理订单支付的方法"

Claude Code 生成的搜索结果：

## 智能代码搜索结果

### 搜索查询: "订单支付处理"

### 匹配结果 (23 个文件)

#### 1. src/services/payment/payment_service.py
```python
```python

def process_payment(self, order_id: int, payment_method: str, amount: float) -> PaymentResult:
    """
    处理订单支付

    参数:
        order_id: 订单 ID
        payment_method: 支付方式
        amount: 支付金额

    返回:
        支付结果
    """
    # 验证订单
    order = self.order_service.get_order(order_id)
    if not order:
        raise OrderNotFoundError(order_id)

    # 验证金额
    if order.total_amount != amount:
        raise InvalidAmountError(order.total_amount, amount)

    # 处理支付
    if payment_method == 'credit_card':
        return self._process_credit_card_payment(order)
    elif payment_method == 'paypal':
        return self._process_paypal_payment(order)
    elif payment_method == 'bank_transfer':
        return self._process_bank_transfer_payment(order)
    else:
        raise UnsupportedPaymentMethodError(payment_method)
> **位置**: [payment_service.py:45-78](file:///src/services/payment/payment_service.py#L45-78)
> **复杂度**: 中
> **测试覆盖**: 85%

#### 2. src/services/order/order_service.py

```python

def complete_payment(self, order_id: int, transaction_id: str) -> Order:
"""
完成订单支付
```

```
├── src/
│   ├── core/              # 核心模块 (456 files)
│   │   ├── auth/          # 认证模块
│   │   ├── database/      # 数据库模块
│   │   ├── cache/         # 缓存模块
│   │   └── messaging/     # 消息模块
│   ├── services/          # 服务层 (1,234 files)
│   │   ├── user/          # 用户服务
│   │   ├── product/       # 商品服务
│   │   ├── order/         # 订单服务
│   │   └── payment/       # 支付服务
│   ├── api/               # API 层 (890 files)
│   │   ├── v1/            # API v1
│   │   ├── v2/            # API v2
│   │   └── internal/      # 内部 API
│   └── utils/             # 工具模块 (567 files)
├── tests/                 # 测试代码 (2,345 files)
├── docs/                  # 文档 (1,234 files)
├── scripts/               # 脚本 (456 files)
└── config/                # 配置 (234 files)
```
### 依赖关系图

```mermaid
mermaid

graph TD
    A[core/auth] --> B[core/database]
    A --> C[core/cache]
    D[services/user] --> A
    D --> B
    E[services/product] --> B
    E --> C
    F[services/order] --> D
    F --> E
    F --> G[services/payment]
    G --> A
    G --> B
    H[api/v1] --> D
    H --> E
    H --> F
    H --> G

### 热点文件

| 文件 | 修改次数 | 贡献者 | 复杂度 |
|------|----------|--------|--------|
| src/services/order/order_service.py | 234 | 5 | 高 |
| src/core/auth/jwt_handler.py | 189 | 3 | 中 |
| src/api/v1/order_routes.py | 167 | 4 | 高 |
| src/services/product/product_service.py | 145 | 3 | 中 |
| src/core/database/connection_pool.py | 123 | 2 | 高 |

### 代码质量指标

| 指标 | 平均值 | 良好 | 需要改进 |
|------|--------|------|----------|
| 圈复杂度 | 8.5 | < 10 | 234 files |
| 代码重复率 | 12.3% | < 5% | 567 files |
| 测试覆盖率 | 78.5% | > 80% | 345 files |
| 文档覆盖率 | 65.2% | > 70% | 456 files |

### 2. 智能代码搜索
```python
python

# 示例：智能代码搜索

用户请求：
"搜索所有处理订单支付的方法"

Claude Code 生成的搜索结果：

## 智能代码搜索结果

### 搜索查询: "订单支付处理"

### 匹配结果 (23 个文件)

#### 1. src/services/payment/payment_service.py
```python
```python

def process_payment(self, order_id: int, payment_method: str, amount: float) -> PaymentResult:
    """
    处理订单支付

    参数:
        order_id: 订单 ID
        payment_method: 支付方式
        amount: 支付金额

    返回:
        支付结果
    """
    # 验证订单
    order = self.order_service.get_order(order_id)
    if not order:
        raise OrderNotFoundError(order_id)

    # 验证金额
    if order.total_amount != amount:
        raise InvalidAmountError(order.total_amount, amount)

    # 处理支付
    if payment_method == 'credit_card':
        return self._process_credit_card_payment(order)
    elif payment_method == 'paypal':
        return self._process_paypal_payment(order)
    elif payment_method == 'bank_transfer':
        return self._process_bank_transfer_payment(order)
    else:
        raise UnsupportedPaymentMethodError(payment_method)
> **位置**: [payment_service.py:45-78](file:///src/services/payment/payment_service.py#L45-78)
> **复杂度**: 中
> **测试覆盖**: 85%

#### 2. src/services/order/order_service.py

```python

def complete_payment(self, order_id: int, transaction_id: str) -> Order:
"""
完成订单支付
```

参数:
order_id: 订单 ID
transaction_id: 交易 ID

返回:
更新后的订单
"""
order = self.get_order(order_id)
order.status = OrderStatus.PAID
order.transaction_id = transaction_id
order.paid_at = datetime.utcnow()

self.db.session.commit()

### 触发支付完成事件

self.event_publisher.publish(
OrderPaidEvent(order_id, transaction_id)
)

return order

位置: order_service.py:123-145

复杂度: 低
测试覆盖: 92%

###### 3. src/api/v1/payment_routes.py

```
python复制python

@app.route('/orders/<int:order_id>/payment', methods=['POST'])
def create_payment(order_id):
    """
    创建订单支付

    请求体:
        {
            "payment_method": "credit_card",
            "card": {
                "number": "4111111111111111",
                "expiry": "12/25",
                "cvv": "123"
            }
        }

    响应:
        {
            "payment_id": "pay_123",
            "status": "pending",
            "amount": 100.00
        }
    """
    data = request.get_json()

    payment = payment_service.create_payment(
        order_id=order_id,
        payment_method=data['payment_method'],
        payment_data=data.get('card', {})
    )

    return jsonify(payment.to_dict()), 201
> **位置**: [payment_routes.py:23-56](file:///src/api/v1/payment_routes.py#L23-56)
> **复杂度**: 低
> **测试覆盖**: 78%

### 相关文件

| 文件 | 相关性 | 说明 |
|------|--------|------|
| src/services/payment/refund_service.py | 高 | 退款处理 |
| src/services/payment/webhook_handler.py | 高 | 支付回调处理 |
| src/core/payment/gateway_factory.py | 中 | 支付网关工厂 |
| src/tests/test_payment_service.py | 中 | 支付服务测试 |

### 调用关系

`````> > process_payment()
├── get_order()
├── _process_credit_card_payment()
│   ├── gateway.charge()
│   └── create_payment_record()
├── _process_paypal_payment()
│   ├── paypal_client.create_payment()
│   └── create_payment_record()
└── _process_bank_transfer_payment()
├── bank_api.initiate_transfer()
└── create_payment_record()

```## 代码重构与优化

### 1. 大规模重构

# 示例：大规模代码重构
用户请求：
"重构支付模块，将支付网关抽象化"
Claude Code 生成的重构方案：
## 支付模块重构方案
### 当前问题

### 重构目标

### 重构步骤
#### 步骤 1: 定义支付网关接口
````python
`python

# src/core/payment/gateway_interface.py
from abc import ABC, abstractmethod
from typing import Dict, Any

class PaymentGateway(ABC):
"""支付网关接口"""

@abstractmethod
def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
"""
收款

参数:
amount: 收款金额
payment_data: 支付数据

返回:
支付结果
"""
pass

@abstractmethod
def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
"""
退款

参数:
transaction_id: 交易 ID
amount: 退款金额

返回:
退款结果
"""
pass

@abstractmethod
def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
"""
获取交易状态

参数:
transaction_id: 交易 ID

返回:
交易状态
"""
pass

@abstractmethod
def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
"""
验证支付数据

参数:
payment_data: 支付数据

返回:
是否有效
"""
pass

```#### 步骤 2: 实现具体支付网关
```

```
python

@app.route('/orders/<int:order_id>/payment', methods=['POST'])
def create_payment(order_id):
    """
    创建订单支付

    请求体:
        {
            "payment_method": "credit_card",
            "card": {
                "number": "4111111111111111",
                "expiry": "12/25",
                "cvv": "123"
            }
        }

    响应:
        {
            "payment_id": "pay_123",
            "status": "pending",
            "amount": 100.00
        }
    """
    data = request.get_json()

    payment = payment_service.create_payment(
        order_id=order_id,
        payment_method=data['payment_method'],
        payment_data=data.get('card', {})
    )

    return jsonify(payment.to_dict()), 201
> **位置**: [payment_routes.py:23-56](file:///src/api/v1/payment_routes.py#L23-56)
> **复杂度**: 低
> **测试覆盖**: 78%

### 相关文件

| 文件 | 相关性 | 说明 |
|------|--------|------|
| src/services/payment/refund_service.py | 高 | 退款处理 |
| src/services/payment/webhook_handler.py | 高 | 支付回调处理 |
| src/core/payment/gateway_factory.py | 中 | 支付网关工厂 |
| src/tests/test_payment_service.py | 中 | 支付服务测试 |

### 调用关系

`````> > process_payment()
├── get_order()
├── _process_credit_card_payment()
│   ├── gateway.charge()
│   └── create_payment_record()
├── _process_paypal_payment()
│   ├── paypal_client.create_payment()
│   └── create_payment_record()
└── _process_bank_transfer_payment()
├── bank_api.initiate_transfer()
└── create_payment_record()

```## 代码重构与优化

### 1. 大规模重构

# 示例：大规模代码重构
用户请求：
"重构支付模块，将支付网关抽象化"
Claude Code 生成的重构方案：
## 支付模块重构方案
### 当前问题

### 重构目标

### 重构步骤
#### 步骤 1: 定义支付网关接口
````python
`python

# src/core/payment/gateway_interface.py
from abc import ABC, abstractmethod
from typing import Dict, Any

class PaymentGateway(ABC):
"""支付网关接口"""

@abstractmethod
def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
"""
收款

参数:
amount: 收款金额
payment_data: 支付数据

返回:
支付结果
"""
pass

@abstractmethod
def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
"""
退款

参数:
transaction_id: 交易 ID
amount: 退款金额

返回:
退款结果
"""
pass

@abstractmethod
def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
"""
获取交易状态

参数:
transaction_id: 交易 ID

返回:
交易状态
"""
pass

@abstractmethod
def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
"""
验证支付数据

参数:
payment_data: 支付数据

返回:
是否有效
"""
pass

```#### 步骤 2: 实现具体支付网关
```

python

### src/core/payment/gateways/stripe_gateway.py

import stripe
from typing import Dict, Any
from .gateway_interface import PaymentGateway

class StripeGateway(PaymentGateway):
"""Stripe 支付网关"""

```
bash复制def __init__(self, api_key: str):
    stripe.api_key = api_key

def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
    """收款"""
    try:
        charge = stripe.Charge.create(
            amount=int(amount * 100),  # 转换为分
            currency='usd',
            card=payment_data['card'],
            description='Order payment'
        )

        return {
            'success': True,
            'transaction_id': charge.id,
            'status': charge.status,
            'amount': charge.amount / 100
        }
    except stripe.error.CardError as e:
        return {
            'success': False,
            'error': str(e)
        }

def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
    """退款"""
    try:
        refund = stripe.Refund.create(
            charge=transaction_id,
            amount=int(amount * 100)
        )

        return {
            'success': True,
            'refund_id': refund.id,
            'status': refund.status
        }
    except stripe.error.StripeError as e:
        return {
            'success': False,
            'error': str(e)
        }

def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
    """获取交易状态"""
    try:
        charge = stripe.Charge.retrieve(transaction_id)

        return {
            'status': charge.status,
            'amount': charge.amount / 100,
            'paid': charge.paid
        }
    except stripe.error.StripeError as e:
        return {
            'error': str(e)
        }

def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
    """验证支付数据"""
    required_fields = ['card']
    return all(field in payment_data for field in required_fields)
```

```
def __init__(self, api_key: str):
    stripe.api_key = api_key

def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
    """收款"""
    try:
        charge = stripe.Charge.create(
            amount=int(amount * 100),  # 转换为分
            currency='usd',
            card=payment_data['card'],
            description='Order payment'
        )

        return {
            'success': True,
            'transaction_id': charge.id,
            'status': charge.status,
            'amount': charge.amount / 100
        }
    except stripe.error.CardError as e:
        return {
            'success': False,
            'error': str(e)
        }

def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
    """退款"""
    try:
        refund = stripe.Refund.create(
            charge=transaction_id,
            amount=int(amount * 100)
        )

        return {
            'success': True,
            'refund_id': refund.id,
            'status': refund.status
        }
    except stripe.error.StripeError as e:
        return {
            'success': False,
            'error': str(e)
        }

def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
    """获取交易状态"""
    try:
        charge = stripe.Charge.retrieve(transaction_id)

        return {
            'status': charge.status,
            'amount': charge.amount / 100,
            'paid': charge.paid
        }
    except stripe.error.StripeError as e:
        return {
            'error': str(e)
        }

def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
    """验证支付数据"""
    required_fields = ['card']
    return all(field in payment_data for field in required_fields)
```

```
python复制````python

# src/core/payment/gateways/paypal_gateway.py
from paypalrestsdk import Payment
from typing import Dict, Any
from .gateway_interface import PaymentGateway

class PayPalGateway(PaymentGateway):
"""PayPal 支付网关"""

def __init__(self, client_id: str, client_secret: str):
Payment.configure({
'mode': 'sandbox',
'client_id': client_id,
'client_secret': client_secret
})

def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
"""收款"""
payment = Payment({
'intent': 'sale',
'payer': {
'payment_method': 'credit_card',
'funding_instruments': [{
'credit_card': payment_data['card']
}]
},
'transactions': [{
'amount': {
'total': str(amount),
'currency': 'USD'
},
'description': 'Order payment'
}]
})

if payment.create():
return {
'success': True,
'transaction_id': payment.id,
'status': payment.state,
'amount': amount
}
else:
return {
'success': False,
'error': payment.error
}

def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
"""退款"""
payment = Payment.find(transaction_id)

if payment:
sale = payment.transactions[0].related_resources[0].sale
refund = sale.refund({'amount': {'total': str(amount), 'currency': 'USD'}})

if refund.success():
return {
'success': True,
'refund_id': refund.id,
'status': refund.state
}

return {
'success': False,
'error': 'Refund failed'
}

def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
"""获取交易状态"""
payment = Payment.find(transaction_id)

if payment:
return {
'status': payment.state,
'amount': float(payment.transactions[0].amount.total)
}

return {'error': 'Payment not found'}

def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
"""验证支付数据"""
required_fields = ['card']
return all(field in payment_data for field in required_fields)

```#### 步骤 3: 创建支付网关工厂

```
python

# src/core/payment/gateway_factory.py
from typing import Dict
from .gateway_interface import PaymentGateway
from .gateways.stripe_gateway import StripeGateway
from .gateways.paypal_gateway import PayPalGateway

class PaymentGatewayFactory:
    """支付网关工厂"""

    _gateways: Dict[str, PaymentGateway] = {}

    @classmethod
    def register_gateway(cls, name: str, gateway: PaymentGateway):
        """注册支付网关"""
        cls._gateways[name] = gateway

    @classmethod
    def get_gateway(cls, name: str) -> PaymentGateway:
        """获取支付网关"""
        gateway = cls._gateways.get(name)

        if not gateway:
            raise ValueError(f"Payment gateway '{name}' not found")

        return gateway

    @classmethod
    def initialize_gateways(cls, config: Dict):
        """初始化支付网关"""
        if 'stripe' in config:
            cls.register_gateway(
                'stripe',
                StripeGateway(config['stripe']['api_key'])
            )

        if 'paypal' in config:
            cls.register_gateway(
                'paypal',
                PayPalGateway(
                    config['paypal']['client_id'],
                    config['paypal']['client_secret']
                )
            )

#### 步骤 4: 重构支付服务

````python
````python

# src/services/payment/payment_service.py
from typing import Dict, Any
from core.payment.gateway_factory import PaymentGatewayFactory

class PaymentService:
"""支付服务（重构后）"""

def __init__(self):
self.gateway_factory = PaymentGatewayFactory

def process_payment(
self,
order_id: int,
payment_method: str,
payment_data: Dict[str, Any]
) -> Dict[str, Any]:
"""
处理订单支付

参数:
order_id: 订单 ID
payment_method: 支付方式
payment_data: 支付数据

返回:
支付结果
"""
 # 获取订单
order = self.order_service.get_order(order_id)
if not order:
raise OrderNotFoundError(order_id)

 # 获取支付网关
gateway = self.gateway_factory.get_gateway(payment_method)

 # 验证支付数据
if not gateway.validate_payment_data(payment_data):
raise InvalidPaymentDataError()

 # 处理支付
result = gateway.charge(order.total_amount, payment_data)

if result['success']:
 # 创建支付记录
payment = self._create_payment_record(
order_id=order_id,
transaction_id=result['transaction_id'],
amount=result['amount'],
payment_method=payment_method
)

 # 更新订单状态
self.order_service.complete_payment(
order_id,
result['transaction_id']
)

return {
'success': True,
'payment_id': payment.id,
'transaction_id': result['transaction_id'],
'amount': result['amount']
}
else:
return {
'success': False,
'error': result['error']
}

def process_refund(
self,
payment_id: int,
amount: float
) -> Dict[str, Any]:
"""
处理退款

参数:
payment_id: 支付 ID
amount: 退款金额

返回:
退款结果
"""
payment = self.get_payment(payment_id)

if not payment:
raise PaymentNotFoundError(payment_id)

gateway = self.gateway_factory.get_gateway(payment.payment_method)
result = gateway.refund(payment.transaction_id, amount)

if result['success']:
self._create_refund_record(
payment_id=payment_id,
refund_id=result['refund_id'],
amount=amount
)

return result

```### 重构效果

| 指标 | 重构前 | 重构后 | 改善 |
|------|--------|--------|------|
| 代码行数 | 1,234 | 856 | 31% ↓ |
| 圈复杂度 | 12.5 | 4.2 | 66% ↓ |
| 耦合度 | 高 | 低 | - |
| 扩展性 | 差 | 优秀 | - |
| 测试覆盖率 | 65% | 85% | +31% |
| 添加新支付方式 | 修改 5 个文件 | 新增 1 个文件 | 80% ↓ |

```
### 2. 性能优化

# 示例：大规模性能优化
用户请求：
"优化订单查询性能"
Claude Code 生成的优化方案：
## 订单查询性能优化
### 当前性能问题
1. **N+1 查询**: 查询订单时，每个订单项都触发一次商品查询
2. **缺少索引**: 常用查询字段没有索引
3. **缓存缺失**: 热点数据没有缓存
4. **分页低效**: 使用 OFFSET 分页，数据量大时性能差
### 性能分析
````sql
`sql

> -- 当前查询
SELECT * FROM orders WHERE user_id = 123 ORDER BY created_at DESC LIMIT 20 OFFSET 0;

> -- 执行时间: 500ms
> -- 扫描行数: 10,000
> -- 索引使用: 无

```### 优化方案

#### 方案 1: 添加索引

```
sql

-- 添加复合索引
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);

-- 添加商品索引
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- 添加状态索引
CREATE INDEX idx_orders_status ON orders(status);

#### 方案 2: 使用 JOIN 代替 N+1 查询

````python
````python

# 优化前
def get_user_orders(user_id: int, page: int = 1, per_page: int = 20):
"""获取用户订单（优化前）"""
orders = Order.query.filter_by(user_id=user_id)\
.order_by(Order.created_at.desc())\
.paginate(page=page, per_page=per_page)

result = []
for order in orders.items:
order_data = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

for item in order.items:
product = Product.query.get(item.product_id)
order_data['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

result.append(order_data)

return result

# 优化后
def get_user_orders(user_id: int, page: int = 1, per_page: int = 20):
"""获取用户订单（优化后）"""
 # 使用 JOIN 一次性加载所有数据
query = db.session.query(
Order,
OrderItem,
Product
).join(
OrderItem,
Order.id == OrderItem.order_id
).join(
Product,
OrderItem.product_id == Product.id
).filter(
Order.user_id == user_id
).order_by(
Order.created_at.desc()
)

 # 使用游标分页
if page > 1:
last_order_id = request.args.get('last_order_id')
query = query.filter(Order.id < last_order_id)

results = query.limit(per_page).all()

 # 构建结果
orders_map = {}
for order, item, product in results:
if order.id not in orders_map:
orders_map[order.id] = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

orders_map[order.id]['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

return list(orders_map.values())

```#### 方案 3: 添加缓存

```
python

# src/services/cache/order_cache.py
from typing import List, Optional
from datetime import timedelta
import redis
import json

class OrderCache:
    """订单缓存"""

    def __init__(self, redis_url: str = 'redis://localhost:6379'):
        self.redis = redis.from_url(redis_url)
        self.default_ttl = timedelta(minutes=30)

    def get_user_orders(
        self,
        user_id: int,
        page: int = 1,
        per_page: int = 20
    ) -> Optional[List[dict]]:
        """从缓存获取用户订单"""
        cache_key = f"user_orders:{user_id}:{page}:{per_page}"
        cached_data = self.redis.get(cache_key)

        if cached_data:
            return json.loads(cached_data)

        return None

    def set_user_orders(
        self,
        user_id: int,
        orders: List[dict],
        page: int = 1,
        per_page: int = 20,
        ttl: timedelta = None
    ):
        """缓存用户订单"""
        cache_key = f"user_orders:{user_id}:{page}:{per_page}"
        ttl = ttl or self.default_ttl

        self.redis.setex(
            cache_key,
            int(ttl.total_seconds()),
            json.dumps(orders)
        )

    def invalidate_user_orders(self, user_id: int):
        """使用户订单缓存失效"""
        pattern = f"user_orders:{user_id}:*"
        keys = self.redis.keys(pattern)

        if keys:
            self.redis.delete(*keys)

    def invalidate_order(self, order_id: int):
        """使订单缓存失效"""
        # 获取订单的用户 ID
        order = Order.query.get(order_id)
        if order:
            self.invalidate_user_orders(order.user_id)

#### 方案 4: 使用读写分离

````python
````python

# src/core/database/database_manager.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from contextlib import contextmanager

class DatabaseManager:
"""数据库管理器"""

def __init__(self, config: dict):
 # 主数据库（写）
self.master_engine = create_engine(
config['master_url'],
pool_size=20,
max_overflow=40
)

 # 从数据库（读）
self.slave_engines = [
create_engine(url, pool_size=20, max_overflow=40)
for url in config['slave_urls']
]

self.master_session = scoped_session(
sessionmaker(bind=self.master_engine)
)

self.slave_sessions = [
scoped_session(sessionmaker(bind=engine))
for engine in self.slave_engines
]
self.current_slave = 0

@contextmanager
def get_read_session(self):
"""获取读会话"""
session = self.slave_sessions[self.current_slave]
self.current_slave = (self.current_slave + 1) % len(self.slave_sessions)

try:
yield session
finally:
session.remove()

@contextmanager
def get_write_session(self):
"""获取写会话"""
try:
yield self.master_session
finally:
self.master_session.remove()

```### 优化效果

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 查询时间 | 500ms | 50ms | 90% ↓ |
| 数据库连接 | 100 | 20 | 80% ↓ |
| 缓存命中率 | 0% | 85% | +85% |
| 并发处理能力 | 100 req/s | 1000 req/s | +900% |
| CPU 使用率 | 80% | 30% | 62% ↓ |

```
## 总结

大规模代码库处理包括：

1. **代码库索引与搜索**: 代码库统计、依赖关系图、智能代码搜索
2. **代码重构与优化**: 大规模重构、性能优化、缓存策略
3. **工程化实践**: 代码质量监控、自动化测试、持续集成

通过这些技术，开发者可以高效地处理和管理大规模代码库。

在下一章中，我们将探讨智能开发工作流。

```
```

```
````python

# src/core/payment/gateways/paypal_gateway.py
from paypalrestsdk import Payment
from typing import Dict, Any
from .gateway_interface import PaymentGateway

class PayPalGateway(PaymentGateway):
"""PayPal 支付网关"""

def __init__(self, client_id: str, client_secret: str):
Payment.configure({
'mode': 'sandbox',
'client_id': client_id,
'client_secret': client_secret
})

def charge(self, amount: float, payment_data: Dict[str, Any]) -> Dict[str, Any]:
"""收款"""
payment = Payment({
'intent': 'sale',
'payer': {
'payment_method': 'credit_card',
'funding_instruments': [{
'credit_card': payment_data['card']
}]
},
'transactions': [{
'amount': {
'total': str(amount),
'currency': 'USD'
},
'description': 'Order payment'
}]
})

if payment.create():
return {
'success': True,
'transaction_id': payment.id,
'status': payment.state,
'amount': amount
}
else:
return {
'success': False,
'error': payment.error
}

def refund(self, transaction_id: str, amount: float) -> Dict[str, Any]:
"""退款"""
payment = Payment.find(transaction_id)

if payment:
sale = payment.transactions[0].related_resources[0].sale
refund = sale.refund({'amount': {'total': str(amount), 'currency': 'USD'}})

if refund.success():
return {
'success': True,
'refund_id': refund.id,
'status': refund.state
}

return {
'success': False,
'error': 'Refund failed'
}

def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
"""获取交易状态"""
payment = Payment.find(transaction_id)

if payment:
return {
'status': payment.state,
'amount': float(payment.transactions[0].amount.total)
}

return {'error': 'Payment not found'}

def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
"""验证支付数据"""
required_fields = ['card']
return all(field in payment_data for field in required_fields)

```#### 步骤 3: 创建支付网关工厂

```
python

# src/core/payment/gateway_factory.py
from typing import Dict
from .gateway_interface import PaymentGateway
from .gateways.stripe_gateway import StripeGateway
from .gateways.paypal_gateway import PayPalGateway

class PaymentGatewayFactory:
    """支付网关工厂"""

    _gateways: Dict[str, PaymentGateway] = {}

    @classmethod
    def register_gateway(cls, name: str, gateway: PaymentGateway):
        """注册支付网关"""
        cls._gateways[name] = gateway

    @classmethod
    def get_gateway(cls, name: str) -> PaymentGateway:
        """获取支付网关"""
        gateway = cls._gateways.get(name)

        if not gateway:
            raise ValueError(f"Payment gateway '{name}' not found")

        return gateway

    @classmethod
    def initialize_gateways(cls, config: Dict):
        """初始化支付网关"""
        if 'stripe' in config:
            cls.register_gateway(
                'stripe',
                StripeGateway(config['stripe']['api_key'])
            )

        if 'paypal' in config:
            cls.register_gateway(
                'paypal',
                PayPalGateway(
                    config['paypal']['client_id'],
                    config['paypal']['client_secret']
                )
            )

#### 步骤 4: 重构支付服务

````python
````python

# src/services/payment/payment_service.py
from typing import Dict, Any
from core.payment.gateway_factory import PaymentGatewayFactory

class PaymentService:
"""支付服务（重构后）"""

def __init__(self):
self.gateway_factory = PaymentGatewayFactory

def process_payment(
self,
order_id: int,
payment_method: str,
payment_data: Dict[str, Any]
) -> Dict[str, Any]:
"""
处理订单支付

参数:
order_id: 订单 ID
payment_method: 支付方式
payment_data: 支付数据

返回:
支付结果
"""
 # 获取订单
order = self.order_service.get_order(order_id)
if not order:
raise OrderNotFoundError(order_id)

 # 获取支付网关
gateway = self.gateway_factory.get_gateway(payment_method)

 # 验证支付数据
if not gateway.validate_payment_data(payment_data):
raise InvalidPaymentDataError()

 # 处理支付
result = gateway.charge(order.total_amount, payment_data)

if result['success']:
 # 创建支付记录
payment = self._create_payment_record(
order_id=order_id,
transaction_id=result['transaction_id'],
amount=result['amount'],
payment_method=payment_method
)

 # 更新订单状态
self.order_service.complete_payment(
order_id,
result['transaction_id']
)

return {
'success': True,
'payment_id': payment.id,
'transaction_id': result['transaction_id'],
'amount': result['amount']
}
else:
return {
'success': False,
'error': result['error']
}

def process_refund(
self,
payment_id: int,
amount: float
) -> Dict[str, Any]:
"""
处理退款

参数:
payment_id: 支付 ID
amount: 退款金额

返回:
退款结果
"""
payment = self.get_payment(payment_id)

if not payment:
raise PaymentNotFoundError(payment_id)

gateway = self.gateway_factory.get_gateway(payment.payment_method)
result = gateway.refund(payment.transaction_id, amount)

if result['success']:
self._create_refund_record(
payment_id=payment_id,
refund_id=result['refund_id'],
amount=amount
)

return result

```### 重构效果

| 指标 | 重构前 | 重构后 | 改善 |
|------|--------|--------|------|
| 代码行数 | 1,234 | 856 | 31% ↓ |
| 圈复杂度 | 12.5 | 4.2 | 66% ↓ |
| 耦合度 | 高 | 低 | - |
| 扩展性 | 差 | 优秀 | - |
| 测试覆盖率 | 65% | 85% | +31% |
| 添加新支付方式 | 修改 5 个文件 | 新增 1 个文件 | 80% ↓ |

```
### 2. 性能优化

# 示例：大规模性能优化
用户请求：
"优化订单查询性能"
Claude Code 生成的优化方案：
## 订单查询性能优化
### 当前性能问题
1. **N+1 查询**: 查询订单时，每个订单项都触发一次商品查询
2. **缺少索引**: 常用查询字段没有索引
3. **缓存缺失**: 热点数据没有缓存
4. **分页低效**: 使用 OFFSET 分页，数据量大时性能差
### 性能分析
````sql
`sql

> -- 当前查询
SELECT * FROM orders WHERE user_id = 123 ORDER BY created_at DESC LIMIT 20 OFFSET 0;

> -- 执行时间: 500ms
> -- 扫描行数: 10,000
> -- 索引使用: 无

```### 优化方案

#### 方案 1: 添加索引

```
sql

-- 添加复合索引
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);

-- 添加商品索引
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- 添加状态索引
CREATE INDEX idx_orders_status ON orders(status);

#### 方案 2: 使用 JOIN 代替 N+1 查询

````python
````python

# 优化前
def get_user_orders(user_id: int, page: int = 1, per_page: int = 20):
"""获取用户订单（优化前）"""
orders = Order.query.filter_by(user_id=user_id)\
.order_by(Order.created_at.desc())\
.paginate(page=page, per_page=per_page)

result = []
for order in orders.items:
order_data = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

for item in order.items:
product = Product.query.get(item.product_id)
order_data['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

result.append(order_data)

return result

# 优化后
def get_user_orders(user_id: int, page: int = 1, per_page: int = 20):
"""获取用户订单（优化后）"""
 # 使用 JOIN 一次性加载所有数据
query = db.session.query(
Order,
OrderItem,
Product
).join(
OrderItem,
Order.id == OrderItem.order_id
).join(
Product,
OrderItem.product_id == Product.id
).filter(
Order.user_id == user_id
).order_by(
Order.created_at.desc()
)

 # 使用游标分页
if page > 1:
last_order_id = request.args.get('last_order_id')
query = query.filter(Order.id < last_order_id)

results = query.limit(per_page).all()

 # 构建结果
orders_map = {}
for order, item, product in results:
if order.id not in orders_map:
orders_map[order.id] = {
'id': order.id,
'total_amount': order.total_amount,
'status': order.status,
'created_at': order.created_at,
'items': []
}

orders_map[order.id]['items'].append({
'product_id': item.product_id,
'product_name': product.name,
'quantity': item.quantity,
'price': item.price
})

return list(orders_map.values())

```#### 方案 3: 添加缓存

```
python

# src/services/cache/order_cache.py
from typing import List, Optional
from datetime import timedelta
import redis
import json

class OrderCache:
    """订单缓存"""

    def __init__(self, redis_url: str = 'redis://localhost:6379'):
        self.redis = redis.from_url(redis_url)
        self.default_ttl = timedelta(minutes=30)

    def get_user_orders(
        self,
        user_id: int,
        page: int = 1,
        per_page: int = 20
    ) -> Optional[List[dict]]:
        """从缓存获取用户订单"""
        cache_key = f"user_orders:{user_id}:{page}:{per_page}"
        cached_data = self.redis.get(cache_key)

        if cached_data:
            return json.loads(cached_data)

        return None

    def set_user_orders(
        self,
        user_id: int,
        orders: List[dict],
        page: int = 1,
        per_page: int = 20,
        ttl: timedelta = None
    ):
        """缓存用户订单"""
        cache_key = f"user_orders:{user_id}:{page}:{per_page}"
        ttl = ttl or self.default_ttl

        self.redis.setex(
            cache_key,
            int(ttl.total_seconds()),
            json.dumps(orders)
        )

    def invalidate_user_orders(self, user_id: int):
        """使用户订单缓存失效"""
        pattern = f"user_orders:{user_id}:*"
        keys = self.redis.keys(pattern)

        if keys:
            self.redis.delete(*keys)

    def invalidate_order(self, order_id: int):
        """使订单缓存失效"""
        # 获取订单的用户 ID
        order = Order.query.get(order_id)
        if order:
            self.invalidate_user_orders(order.user_id)

#### 方案 4: 使用读写分离

````python
````python

# src/core/database/database_manager.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from contextlib import contextmanager

class DatabaseManager:
"""数据库管理器"""

def __init__(self, config: dict):
 # 主数据库（写）
self.master_engine = create_engine(
config['master_url'],
pool_size=20,
max_overflow=40
)

 # 从数据库（读）
self.slave_engines = [
create_engine(url, pool_size=20, max_overflow=40)
for url in config['slave_urls']
]

self.master_session = scoped_session(
sessionmaker(bind=self.master_engine)
)

self.slave_sessions = [
scoped_session(sessionmaker(bind=engine))
for engine in self.slave_engines
]
self.current_slave = 0

@contextmanager
def get_read_session(self):
"""获取读会话"""
session = self.slave_sessions[self.current_slave]
self.current_slave = (self.current_slave + 1) % len(self.slave_sessions)

try:
yield session
finally:
session.remove()

@contextmanager
def get_write_session(self):
"""获取写会话"""
try:
yield self.master_session
finally:
self.master_session.remove()

```### 优化效果

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 查询时间 | 500ms | 50ms | 90% ↓ |
| 数据库连接 | 100 | 20 | 80% ↓ |
| 缓存命中率 | 0% | 85% | +85% |
| 并发处理能力 | 100 req/s | 1000 req/s | +900% |
| CPU 使用率 | 80% | 30% | 62% ↓ |

```
## 总结

大规模代码库处理包括：

1. **代码库索引与搜索**: 代码库统计、依赖关系图、智能代码搜索
2. **代码重构与优化**: 大规模重构、性能优化、缓存策略
3. **工程化实践**: 代码质量监控、自动化测试、持续集成

通过这些技术，开发者可以高效地处理和管理大规模代码库。

在下一章中，我们将探讨智能开发工作流。

```
```

---

## 1 大语言模型基础

**URL**: https://claudecode.tangshuang.net/course/27.1%20%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80

#### 大语言模型概述#

大语言模型（Large Language Models，LLMs）是现代AI系统的核心组件，它们通过在海量文本数据上进行预训练，学习到了丰富的语言知识和推理能力。Claude Code正是基于强大的大语言模型构建的编程助手。

#### 大语言模型的基本概念#

##### 1. 什么是大语言模型#

大语言模型是一种基于深度学习的AI模型，具有以下特点：

- 大规模参数: 模型参数数量从几十亿到数千亿不等
- 海量训练数据: 在互联网文本、代码、书籍等大规模数据集上训练
- 强大的泛化能力: 能够处理各种自然语言和编程任务
- 上下文理解: 能够理解长文本和复杂上下文

##### 2. 大语言模型的架构#

### 示例：简化的大语言模型架构

用户请求：
"解释大语言模型的基本架构"

Claude Code 生成的解释：

#### 大语言模型架构#

##### Transformer 架构#

```
bash复制↓
嵌入层 (Embedding Layer)
↓
位置编码 (Positional Encoding)
↓
编码器层 (Encoder Layers) × N
↓
解码器层 (Decoder Layers) × N
↓
输出层 (Output Layer)
↓
概率分布
```
### 核心组件

#### 1. 自注意力机制 (Self-Attention)

```python
python

import torch
import torch.nn as nn
import math

class SelfAttention(nn.Module):
    """自注意力机制"""

    def __init__(self, embed_size, heads):
        super(SelfAttention, self).__init__()
        self.embed_size = embed_size
        self.heads = heads
        self.head_dim = embed_size // heads

        assert (self.head_dim * heads == embed_size), "Embed size needs to be divisible by heads"

        self.values = nn.Linear(self.head_dim, self.head_dim, bias=False)
        self.keys = nn.Linear(self.head_dim, self.head_dim, bias=False)
        self.queries = nn.Linear(self.head_dim, self.head_dim, bias=False)

        self.fc_out = nn.Linear(heads * self.head_dim, embed_size)

    def forward(self, values, keys, query, mask):
        N = query.shape[0]
        value_len, key_len, query_len = values.shape[1], keys.shape[1], query.shape[1]

        # 分割成多个头
        values = values.reshape(N, value_len, self.heads, self.head_dim)
        keys = keys.reshape(N, key_len, self.heads, self.head_dim)
        queries = query.reshape(N, query_len, self.heads, self.head_dim)

        # 计算注意力分数
        energy = torch.einsum("nqhd,nkhd->nhqk", [queries, keys])

        # 应用掩码
        if mask is not None:
            energy = energy.masked_fill(mask == 0, float("-1e20"))

        # 计算注意力权重
        attention = torch.softmax(energy / (self.embed_size ** (1/2)), dim=3)

        # 应用注意力权重
        out = torch.einsum("nhql,nlhd->nqhd", [attention, values])

        # 合并多头
        out = out.reshape(N, query_len, self.heads * self.head_dim)

        return self.fc_out(out)

> **自注意力机制的作用**:
> - 捕捉序列中的长距离依赖关系
> - 动态调整不同位置的重要性
> - 实现并行计算

#### 2. 前馈神经网络 (Feed-Forward Network)

```python

class FeedForward(nn.Module):
"""前馈神经网络"""

def __init__(self, embed_size, ff_hidden_size, dropout=0.1):
super(FeedForward, self).__init__()
self.linear1 = nn.Linear(embed_size, ff_hidden_size)
self.linear2 = nn.Linear(ff_hidden_size, embed_size)
self.dropout = nn.Dropout(dropout)
self.activation = nn.GELU()

def forward(self, x):
x = self.linear1(x)
x = self.activation(x)
x = self.dropout(x)
x = self.linear2(x)
x = self.dropout(x)
return x

**前馈神经网络的作用**:
> - 增强模型的表达能力
> - 引入非线性变换
> - 处理特征交互

#### 3. Transformer Block

```python
python
```

```
↓
嵌入层 (Embedding Layer)
↓
位置编码 (Positional Encoding)
↓
编码器层 (Encoder Layers) × N
↓
解码器层 (Decoder Layers) × N
↓
输出层 (Output Layer)
↓
概率分布
```
### 核心组件

#### 1. 自注意力机制 (Self-Attention)

```python
python

import torch
import torch.nn as nn
import math

class SelfAttention(nn.Module):
    """自注意力机制"""

    def __init__(self, embed_size, heads):
        super(SelfAttention, self).__init__()
        self.embed_size = embed_size
        self.heads = heads
        self.head_dim = embed_size // heads

        assert (self.head_dim * heads == embed_size), "Embed size needs to be divisible by heads"

        self.values = nn.Linear(self.head_dim, self.head_dim, bias=False)
        self.keys = nn.Linear(self.head_dim, self.head_dim, bias=False)
        self.queries = nn.Linear(self.head_dim, self.head_dim, bias=False)

        self.fc_out = nn.Linear(heads * self.head_dim, embed_size)

    def forward(self, values, keys, query, mask):
        N = query.shape[0]
        value_len, key_len, query_len = values.shape[1], keys.shape[1], query.shape[1]

        # 分割成多个头
        values = values.reshape(N, value_len, self.heads, self.head_dim)
        keys = keys.reshape(N, key_len, self.heads, self.head_dim)
        queries = query.reshape(N, query_len, self.heads, self.head_dim)

        # 计算注意力分数
        energy = torch.einsum("nqhd,nkhd->nhqk", [queries, keys])

        # 应用掩码
        if mask is not None:
            energy = energy.masked_fill(mask == 0, float("-1e20"))

        # 计算注意力权重
        attention = torch.softmax(energy / (self.embed_size ** (1/2)), dim=3)

        # 应用注意力权重
        out = torch.einsum("nhql,nlhd->nqhd", [attention, values])

        # 合并多头
        out = out.reshape(N, query_len, self.heads * self.head_dim)

        return self.fc_out(out)

> **自注意力机制的作用**:
> - 捕捉序列中的长距离依赖关系
> - 动态调整不同位置的重要性
> - 实现并行计算

#### 2. 前馈神经网络 (Feed-Forward Network)

```python

class FeedForward(nn.Module):
"""前馈神经网络"""

def __init__(self, embed_size, ff_hidden_size, dropout=0.1):
super(FeedForward, self).__init__()
self.linear1 = nn.Linear(embed_size, ff_hidden_size)
self.linear2 = nn.Linear(ff_hidden_size, embed_size)
self.dropout = nn.Dropout(dropout)
self.activation = nn.GELU()

def forward(self, x):
x = self.linear1(x)
x = self.activation(x)
x = self.dropout(x)
x = self.linear2(x)
x = self.dropout(x)
return x

**前馈神经网络的作用**:
> - 增强模型的表达能力
> - 引入非线性变换
> - 处理特征交互

#### 3. Transformer Block

```python
python
```

class TransformerBlock(nn.Module):
"""Transformer块"""

```
bash复制def __init__(self, embed_size, heads, ff_hidden_size, dropout=0.1):
    super(TransformerBlock, self).__init__()
    self.attention = SelfAttention(embed_size, heads)
    self.norm1 = nn.LayerNorm(embed_size)
    self.norm2 = nn.LayerNorm(embed_size)
    self.feed_forward = FeedForward(embed_size, ff_hidden_size, dropout)
    self.dropout = nn.Dropout(dropout)

def forward(self, value, key, query, mask):
    # 多头注意力 + 残差连接 + 层归一化
    attention = self.attention(value, key, query, mask)
    x = self.dropout(attention) + query
    x = self.norm1(x)

    # 前馈网络 + 残差连接 + 层归一化
    forward = self.feed_forward(x)
    out = self.dropout(forward) + x
    out = self.norm2(out)

    return out
```

```
def __init__(self, embed_size, heads, ff_hidden_size, dropout=0.1):
    super(TransformerBlock, self).__init__()
    self.attention = SelfAttention(embed_size, heads)
    self.norm1 = nn.LayerNorm(embed_size)
    self.norm2 = nn.LayerNorm(embed_size)
    self.feed_forward = FeedForward(embed_size, ff_hidden_size, dropout)
    self.dropout = nn.Dropout(dropout)

def forward(self, value, key, query, mask):
    # 多头注意力 + 残差连接 + 层归一化
    attention = self.attention(value, key, query, mask)
    x = self.dropout(attention) + query
    x = self.norm1(x)

    # 前馈网络 + 残差连接 + 层归一化
    forward = self.feed_forward(x)
    out = self.dropout(forward) + x
    out = self.norm2(out)

    return out
```

Transformer Block的作用:

- 结合注意力和前馈网络
- 残差连接防止梯度消失
- 层归一化稳定训练

#### 大语言模型的训练#

##### 1. 预训练#

```
python复制python

# 示例：大语言模型预训练

用户请求：
"解释大语言模型的预训练过程"

Claude Code 生成的解释：

## 预训练过程

### 训练目标

#### 1. 掩码语言模型 (Masked Language Modeling, MLM)

```python
```python

class MaskedLanguageModel(nn.Module):
    """掩码语言模型"""

    def __init__(self, vocab_size, embed_size, num_layers, heads, ff_hidden_size, max_length):
        super(MaskedLanguageModel, self).__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.positional_encoding = PositionalEncoding(embed_size, max_length)
        self.transformer_blocks = nn.ModuleList([
            TransformerBlock(embed_size, heads, ff_hidden_size)
            for _ in range(num_layers)
        ])
        self.fc_out = nn.Linear(embed_size, vocab_size)
        self.dropout = nn.Dropout(0.1)

    def forward(self, x, mask):
        # 嵌入 + 位置编码
        x = self.embedding(x)
        x = self.positional_encoding(x)
        x = self.dropout(x)

        # Transformer层
        for block in self.transformer_blocks:
            x = block(x, x, x, mask)

        # 输出层
        out = self.fc_out(x)

        return out

def mask_tokens(inputs, tokenizer, mlm_probability=0.15):
    """掩码token"""
    labels = inputs.clone()
    probability_matrix = torch.full(labels.shape, mlm_probability)

    special_tokens_mask = [
        tokenizer.get_special_tokens_mask(val, already_has_special_tokens=True) for val in labels.tolist()
    ]
    probability_matrix.masked_fill_(torch.tensor(special_tokens_mask, dtype=torch.bool), value=0.0)

    masked_indices = torch.bernoulli(probability_matrix).bool()
    labels[~masked_indices] = -100

    indices_replaced = torch.bernoulli(torch.full(labels.shape, 0.8)).bool() & masked_indices
    inputs[indices_replaced] = tokenizer.convert_tokens_to_ids(tokenizer.mask_token)

    indices_random = torch.bernoulli(torch.full(labels.shape, 0.5)).bool() & masked_indices & ~indices_replaced
    random_words = torch.randint(len(tokenizer), labels.shape, dtype=torch.long)
    inputs[indices_random] = random_words[indices_random]

    return inputs, labels

> **MLM训练目标**:
> - 随机掩码输入token的一部分
> - 预测被掩码的token
> - 学习双向上下文表示

#### 2. 因果语言模型 (Causal Language Modeling, CLM)

```python

class CausalLanguageModel(nn.Module):
"""因果语言模型"""

def __init__(self, vocab_size, embed_size, num_layers, heads, ff_hidden_size, max_length):
super(CausalLanguageModel, self).__init__()
self.embedding = nn.Embedding(vocab_size, embed_size)
self.positional_encoding = PositionalEncoding(embed_size, max_length)
self.transformer_blocks = nn.ModuleList([
TransformerBlock(embed_size, heads, ff_hidden_size)
for _ in range(num_layers)
])
self.fc_out = nn.Linear(embed_size, vocab_size)
self.dropout = nn.Dropout(0.1)

def forward(self, x, mask):
 # 嵌入 + 位置编码
x = self.embedding(x)
x = self.positional_encoding(x)
x = self.dropout(x)

 # Transformer层
for block in self.transformer_blocks:
x = block(x, x, x, mask)

 # 输出层
out = self.fc_out(x)

return out

def create_causal_mask(size):
"""创建因果掩码"""
mask = torch.triu(torch.ones(size, size), diagonal=1)
mask = mask.masked_fill(mask == 1, float('-inf'))
return mask

**CLM训练目标**:
> - 预测下一个token
> - 学习单向上下文表示
> - 适用于文本生成任务

### 2. 微调

```python
python

# 示例：大语言模型微调

用户请求：
"解释大语言模型的微调过程"

Claude Code 生成的解释：

## 微调过程

### 指令微调 (Instruction Tuning)

class InstructionDataset(torch.utils.data.Dataset):
"""指令数据集"""

def __init__(self, data, tokenizer, max_length=512):
self.data = data
self.tokenizer = tokenizer
self.max_length = max_length

def __len__(self):
return len(self.data)

def __getitem__(self, idx):
item = self.data[idx]

 # 格式化指令
prompt = f"指令: {item['instruction']}\n"
if 'input' in item and item['input']:
prompt += f"输入: {item['input']}\n"
prompt += f"输出: {item['output']}"

 # 编码
encoded = self.tokenizer(
prompt,
max_length=self.max_length,
padding='max_length',
truncation=True,
return_tensors='pt'
)

return {
'input_ids': encoded['input_ids'].squeeze(),
'attention_mask': encoded['attention_mask'].squeeze(),
'labels': encoded['input_ids'].squeeze()
}

def fine_tune_model(model, train_dataset, val_dataset, config):
"""微调模型"""
 # 数据加载器
train_loader = torch.utils.data.DataLoader(
train_dataset,
batch_size=config['batch_size'],
shuffle=True
)

val_loader = torch.utils.data.DataLoader(
val_dataset,
batch_size=config['batch_size'],
shuffle=False
)

 # 优化器
optimizer = torch.optim.AdamW(
model.parameters(),
lr=config['learning_rate'],
weight_decay=config['weight_decay']
)

 # 学习率调度器
scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(
optimizer,
T_max=config['num_epochs']
)

 # 训练循环
for epoch in range(config['num_epochs']):
model.train()
total_loss = 0

for batch in train_loader:
optimizer.zero_grad()

 # 前向传播
outputs = model(
input_ids=batch['input_ids'],
attention_mask=batch['attention_mask'],
labels=batch['labels']
)

loss = outputs.loss

 # 反向传播
loss.backward()
torch.nn.utils.clip_grad_norm_(model.parameters(), config['max_grad_norm'])
optimizer.step()

total_loss += loss.item()

 # 验证
val_loss = evaluate_model(model, val_loader)

 # 学习率调度
scheduler.step()

print(f"Epoch {epoch + 1}/{config['num_epochs']}")
print(f"  Train Loss: {total_loss / len(train_loader):.4f}")
print(f"  Val Loss: {val_loss:.4f}")

def evaluate_model(model, val_loader):
"""评估模型"""
model.eval()
total_loss = 0

with torch.no_grad():
for batch in val_loader:
outputs = model(
input_ids=batch['input_ids'],
attention_mask=batch['attention_mask'],
labels=batch['labels']
)
total_loss += outputs.loss.item()

return total_loss / len(val_loader)

**指令微调的作用**:
- 使模型理解并遵循指令
- 提高模型在特定任务上的表现
- 增强模型的交互能力
### 3. RLHF (Reinforcement Learning from Human Feedback)
```

```
python

# 示例：大语言模型预训练

用户请求：
"解释大语言模型的预训练过程"

Claude Code 生成的解释：

## 预训练过程

### 训练目标

#### 1. 掩码语言模型 (Masked Language Modeling, MLM)

```python
```python

class MaskedLanguageModel(nn.Module):
    """掩码语言模型"""

    def __init__(self, vocab_size, embed_size, num_layers, heads, ff_hidden_size, max_length):
        super(MaskedLanguageModel, self).__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.positional_encoding = PositionalEncoding(embed_size, max_length)
        self.transformer_blocks = nn.ModuleList([
            TransformerBlock(embed_size, heads, ff_hidden_size)
            for _ in range(num_layers)
        ])
        self.fc_out = nn.Linear(embed_size, vocab_size)
        self.dropout = nn.Dropout(0.1)

    def forward(self, x, mask):
        # 嵌入 + 位置编码
        x = self.embedding(x)
        x = self.positional_encoding(x)
        x = self.dropout(x)

        # Transformer层
        for block in self.transformer_blocks:
            x = block(x, x, x, mask)

        # 输出层
        out = self.fc_out(x)

        return out

def mask_tokens(inputs, tokenizer, mlm_probability=0.15):
    """掩码token"""
    labels = inputs.clone()
    probability_matrix = torch.full(labels.shape, mlm_probability)

    special_tokens_mask = [
        tokenizer.get_special_tokens_mask(val, already_has_special_tokens=True) for val in labels.tolist()
    ]
    probability_matrix.masked_fill_(torch.tensor(special_tokens_mask, dtype=torch.bool), value=0.0)

    masked_indices = torch.bernoulli(probability_matrix).bool()
    labels[~masked_indices] = -100

    indices_replaced = torch.bernoulli(torch.full(labels.shape, 0.8)).bool() & masked_indices
    inputs[indices_replaced] = tokenizer.convert_tokens_to_ids(tokenizer.mask_token)

    indices_random = torch.bernoulli(torch.full(labels.shape, 0.5)).bool() & masked_indices & ~indices_replaced
    random_words = torch.randint(len(tokenizer), labels.shape, dtype=torch.long)
    inputs[indices_random] = random_words[indices_random]

    return inputs, labels

> **MLM训练目标**:
> - 随机掩码输入token的一部分
> - 预测被掩码的token
> - 学习双向上下文表示

#### 2. 因果语言模型 (Causal Language Modeling, CLM)

```python

class CausalLanguageModel(nn.Module):
"""因果语言模型"""

def __init__(self, vocab_size, embed_size, num_layers, heads, ff_hidden_size, max_length):
super(CausalLanguageModel, self).__init__()
self.embedding = nn.Embedding(vocab_size, embed_size)
self.positional_encoding = PositionalEncoding(embed_size, max_length)
self.transformer_blocks = nn.ModuleList([
TransformerBlock(embed_size, heads, ff_hidden_size)
for _ in range(num_layers)
])
self.fc_out = nn.Linear(embed_size, vocab_size)
self.dropout = nn.Dropout(0.1)

def forward(self, x, mask):
 # 嵌入 + 位置编码
x = self.embedding(x)
x = self.positional_encoding(x)
x = self.dropout(x)

 # Transformer层
for block in self.transformer_blocks:
x = block(x, x, x, mask)

 # 输出层
out = self.fc_out(x)

return out

def create_causal_mask(size):
"""创建因果掩码"""
mask = torch.triu(torch.ones(size, size), diagonal=1)
mask = mask.masked_fill(mask == 1, float('-inf'))
return mask

**CLM训练目标**:
> - 预测下一个token
> - 学习单向上下文表示
> - 适用于文本生成任务

### 2. 微调

```python
python

# 示例：大语言模型微调

用户请求：
"解释大语言模型的微调过程"

Claude Code 生成的解释：

## 微调过程

### 指令微调 (Instruction Tuning)

class InstructionDataset(torch.utils.data.Dataset):
"""指令数据集"""

def __init__(self, data, tokenizer, max_length=512):
self.data = data
self.tokenizer = tokenizer
self.max_length = max_length

def __len__(self):
return len(self.data)

def __getitem__(self, idx):
item = self.data[idx]

 # 格式化指令
prompt = f"指令: {item['instruction']}\n"
if 'input' in item and item['input']:
prompt += f"输入: {item['input']}\n"
prompt += f"输出: {item['output']}"

 # 编码
encoded = self.tokenizer(
prompt,
max_length=self.max_length,
padding='max_length',
truncation=True,
return_tensors='pt'
)

return {
'input_ids': encoded['input_ids'].squeeze(),
'attention_mask': encoded['attention_mask'].squeeze(),
'labels': encoded['input_ids'].squeeze()
}

def fine_tune_model(model, train_dataset, val_dataset, config):
"""微调模型"""
 # 数据加载器
train_loader = torch.utils.data.DataLoader(
train_dataset,
batch_size=config['batch_size'],
shuffle=True
)

val_loader = torch.utils.data.DataLoader(
val_dataset,
batch_size=config['batch_size'],
shuffle=False
)

 # 优化器
optimizer = torch.optim.AdamW(
model.parameters(),
lr=config['learning_rate'],
weight_decay=config['weight_decay']
)

 # 学习率调度器
scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(
optimizer,
T_max=config['num_epochs']
)

 # 训练循环
for epoch in range(config['num_epochs']):
model.train()
total_loss = 0

for batch in train_loader:
optimizer.zero_grad()

 # 前向传播
outputs = model(
input_ids=batch['input_ids'],
attention_mask=batch['attention_mask'],
labels=batch['labels']
)

loss = outputs.loss

 # 反向传播
loss.backward()
torch.nn.utils.clip_grad_norm_(model.parameters(), config['max_grad_norm'])
optimizer.step()

total_loss += loss.item()

 # 验证
val_loss = evaluate_model(model, val_loader)

 # 学习率调度
scheduler.step()

print(f"Epoch {epoch + 1}/{config['num_epochs']}")
print(f"  Train Loss: {total_loss / len(train_loader):.4f}")
print(f"  Val Loss: {val_loss:.4f}")

def evaluate_model(model, val_loader):
"""评估模型"""
model.eval()
total_loss = 0

with torch.no_grad():
for batch in val_loader:
outputs = model(
input_ids=batch['input_ids'],
attention_mask=batch['attention_mask'],
labels=batch['labels']
)
total_loss += outputs.loss.item()

return total_loss / len(val_loader)

**指令微调的作用**:
- 使模型理解并遵循指令
- 提高模型在特定任务上的表现
- 增强模型的交互能力
### 3. RLHF (Reinforcement Learning from Human Feedback)
```

python

### 示例：RLHF训练

用户请求：
"解释RLHF训练过程"

Claude Code 生成的解释：

#### RLHF训练过程#

##### 训练步骤#

###### 步骤1: 奖励模型训练

```
python复制```python

class RewardModel(nn.Module):
    """奖励模型"""

    def __init__(self, base_model):
        super(RewardModel, self).__init__()
        self.base_model = base_model
        self.reward_head = nn.Linear(base_model.config.hidden_size, 1)

    def forward(self, input_ids, attention_mask):
        outputs = self.base_model(
            input_ids=input_ids,
            attention_mask=attention_mask
        )
        reward = self.reward_head(outputs.last_hidden_state[:, -1, :])
        return reward

def train_reward_model(reward_model, comparison_data, config):
    """训练奖励模型"""
    optimizer = torch.optim.AdamW(reward_model.parameters(), lr=config['learning_rate'])

    for epoch in range(config['num_epochs']):
        total_loss = 0

        for batch in comparison_data:
            optimizer.zero_grad()

            # 计算两个输出的奖励
            reward_chosen = reward_model(
                input_ids=batch['chosen_ids'],
                attention_mask=batch['chosen_mask']
            )

            reward_rejected = reward_model(
                input_ids=batch['rejected_ids'],
                attention_mask=batch['rejected_mask']
            )

            # 计算损失
            loss = -torch.log(torch.sigmoid(reward_chosen - reward_rejected)).mean()

            # 反向传播
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        print(f"Epoch {epoch + 1}, Loss: {total_loss / len(comparison_data):.4f}")

#### 步骤2: PPO训练

````python
````python

def ppo_train(policy_model, reward_model, data, config):
"""PPO训练"""
optimizer = torch.optim.AdamW(policy_model.parameters(), lr=config['learning_rate'])

for epoch in range(config['num_epochs']):
for batch in data:
 # 生成响应
with torch.no_grad():
old_log_probs, old_values = generate_response(
policy_model,
batch['input_ids'],
batch['attention_mask']
)

 # 计算奖励
rewards = reward_model(
input_ids=batch['response_ids'],
attention_mask=batch['response_mask']
)

 # 计算优势
advantages = compute_advantages(rewards, old_values)

 # PPO更新
for _ in range(config['ppo_epochs']):
 # 重新采样
log_probs, values = generate_response(
policy_model,
batch['input_ids'],
batch['attention_mask']
)

 # 计算比率
ratio = torch.exp(log_probs - old_log_probs)

 # 计算PPO损失
surr1 = ratio * advantages
surr2 = torch.clamp(ratio, 1 - config['clip_eps'], 1 + config['clip_eps']) * advantages
policy_loss = -torch.min(surr1, surr2).mean()

 # 价值函数损失
value_loss = nn.MSELoss()(values, rewards)

 # 总损失
loss = policy_loss + config['value_coef'] * value_loss

 # 反向传播
optimizer.zero_grad()
loss.backward()
optimizer.step()

```> **RLHF的作用**:
> - 使模型输出更符合人类偏好
> - 提高模型的有用性和安全性
> - 减少有害输出
```

```
```python

class RewardModel(nn.Module):
    """奖励模型"""

    def __init__(self, base_model):
        super(RewardModel, self).__init__()
        self.base_model = base_model
        self.reward_head = nn.Linear(base_model.config.hidden_size, 1)

    def forward(self, input_ids, attention_mask):
        outputs = self.base_model(
            input_ids=input_ids,
            attention_mask=attention_mask
        )
        reward = self.reward_head(outputs.last_hidden_state[:, -1, :])
        return reward

def train_reward_model(reward_model, comparison_data, config):
    """训练奖励模型"""
    optimizer = torch.optim.AdamW(reward_model.parameters(), lr=config['learning_rate'])

    for epoch in range(config['num_epochs']):
        total_loss = 0

        for batch in comparison_data:
            optimizer.zero_grad()

            # 计算两个输出的奖励
            reward_chosen = reward_model(
                input_ids=batch['chosen_ids'],
                attention_mask=batch['chosen_mask']
            )

            reward_rejected = reward_model(
                input_ids=batch['rejected_ids'],
                attention_mask=batch['rejected_mask']
            )

            # 计算损失
            loss = -torch.log(torch.sigmoid(reward_chosen - reward_rejected)).mean()

            # 反向传播
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        print(f"Epoch {epoch + 1}, Loss: {total_loss / len(comparison_data):.4f}")

#### 步骤2: PPO训练

````python
````python

def ppo_train(policy_model, reward_model, data, config):
"""PPO训练"""
optimizer = torch.optim.AdamW(policy_model.parameters(), lr=config['learning_rate'])

for epoch in range(config['num_epochs']):
for batch in data:
 # 生成响应
with torch.no_grad():
old_log_probs, old_values = generate_response(
policy_model,
batch['input_ids'],
batch['attention_mask']
)

 # 计算奖励
rewards = reward_model(
input_ids=batch['response_ids'],
attention_mask=batch['response_mask']
)

 # 计算优势
advantages = compute_advantages(rewards, old_values)

 # PPO更新
for _ in range(config['ppo_epochs']):
 # 重新采样
log_probs, values = generate_response(
policy_model,
batch['input_ids'],
batch['attention_mask']
)

 # 计算比率
ratio = torch.exp(log_probs - old_log_probs)

 # 计算PPO损失
surr1 = ratio * advantages
surr2 = torch.clamp(ratio, 1 - config['clip_eps'], 1 + config['clip_eps']) * advantages
policy_loss = -torch.min(surr1, surr2).mean()

 # 价值函数损失
value_loss = nn.MSELoss()(values, rewards)

 # 总损失
loss = policy_loss + config['value_coef'] * value_loss

 # 反向传播
optimizer.zero_grad()
loss.backward()
optimizer.step()

```> **RLHF的作用**:
> - 使模型输出更符合人类偏好
> - 提高模型的有用性和安全性
> - 减少有害输出
```

#### 大语言模型的应用#

##### 1. 代码生成#

### 示例：代码生成应用

用户请求：
"展示大语言模型在代码生成中的应用"
Claude Code 生成的示例：

#### 代码生成应用#

##### 基础代码生成#

```
python复制`python

def generate_code(prompt, model, tokenizer, max_length=512):
"""生成代码"""
 # 编码输入
inputs = tokenizer(prompt, return_tensors='pt')

 # 生成代码
with torch.no_grad():
outputs = model.generate(
inputs['input_ids'],
attention_mask=inputs['attention_mask'],
max_length=max_length,
temperature=0.7,
top_p=0.95,
do_sample=True,
pad_token_id=tokenizer.eos_token_id
)

 # 解码输出
generated_code = tokenizer.decode(outputs[0], skip_special_tokens=True)

return generated_code

# 使用示例
prompt = """
编写一个Python函数，实现快速排序算法。
"""

code = generate_code(prompt, model, tokenizer)
print(code)

```### 代码补全

```
python

def complete_code(partial_code, model, tokenizer, max_length=256):
    """补全代码"""
    # 编码输入
    inputs = tokenizer(partial_code, return_tensors='pt')

    # 补全代码
    with torch.no_grad():
        outputs = model.generate(
            inputs['input_ids'],
            attention_mask=inputs['attention_mask'],
            max_length=max_length,
            temperature=0.5,
            top_p=0.9,
            do_sample=True,
            pad_token_id=tokenizer.eos_token_id
        )

    # 解码输出
    completed_code = tokenizer.decode(outputs[0], skip_special_tokens=True)

    return completed_code

# 使用示例
partial_code = """
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
"""

completed_code = complete_code(partial_code, model, tokenizer)
print(completed_code)

### 代码解释

````python
````python

def explain_code(code, model, tokenizer, max_length=512):
"""解释代码"""
prompt = f"""
请解释以下代码的功能：
```python
```python

{code}

```

"""

    # 编码输入
    inputs = tokenizer(prompt, return_tensors='pt')

    # 生成解释
    with torch.no_grad():
        outputs = model.generate(
            inputs['input_ids'],
            attention_mask=inputs['attention_mask'],
            max_length=max_length,
            temperature=0.7,
            top_p=0.95,
            do_sample=True,
            pad_token_id=tokenizer.eos_token_id
        )

    # 解码输出
    explanation = tokenizer.decode(outputs[0], skip_special_tokens=True)

    return explanation

# 使用示例
code = """
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
"""

explanation = explain_code(code, model, tokenizer)
print(explanation)
```
```
```

```
`python

def generate_code(prompt, model, tokenizer, max_length=512):
"""生成代码"""
 # 编码输入
inputs = tokenizer(prompt, return_tensors='pt')

 # 生成代码
with torch.no_grad():
outputs = model.generate(
inputs['input_ids'],
attention_mask=inputs['attention_mask'],
max_length=max_length,
temperature=0.7,
top_p=0.95,
do_sample=True,
pad_token_id=tokenizer.eos_token_id
)

 # 解码输出
generated_code = tokenizer.decode(outputs[0], skip_special_tokens=True)

return generated_code

# 使用示例
prompt = """
编写一个Python函数，实现快速排序算法。
"""

code = generate_code(prompt, model, tokenizer)
print(code)

```### 代码补全

```
python

def complete_code(partial_code, model, tokenizer, max_length=256):
    """补全代码"""
    # 编码输入
    inputs = tokenizer(partial_code, return_tensors='pt')

    # 补全代码
    with torch.no_grad():
        outputs = model.generate(
            inputs['input_ids'],
            attention_mask=inputs['attention_mask'],
            max_length=max_length,
            temperature=0.5,
            top_p=0.9,
            do_sample=True,
            pad_token_id=tokenizer.eos_token_id
        )

    # 解码输出
    completed_code = tokenizer.decode(outputs[0], skip_special_tokens=True)

    return completed_code

# 使用示例
partial_code = """
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
"""

completed_code = complete_code(partial_code, model, tokenizer)
print(completed_code)

### 代码解释

````python
````python

def explain_code(code, model, tokenizer, max_length=512):
"""解释代码"""
prompt = f"""
请解释以下代码的功能：
```python
```python

{code}

```

"""

    # 编码输入
    inputs = tokenizer(prompt, return_tensors='pt')

    # 生成解释
    with torch.no_grad():
        outputs = model.generate(
            inputs['input_ids'],
            attention_mask=inputs['attention_mask'],
            max_length=max_length,
            temperature=0.7,
            top_p=0.95,
            do_sample=True,
            pad_token_id=tokenizer.eos_token_id
        )

    # 解码输出
    explanation = tokenizer.decode(outputs[0], skip_special_tokens=True)

    return explanation

# 使用示例
code = """
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
"""

explanation = explain_code(code, model, tokenizer)
print(explanation)
```
```
```

---

## 2 工具调用机制

**URL**: https://claudecode.tangshuang.net/course/27.2%20%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6

#### 工具调用机制概述#

工具调用（Tool Calling）是Agentic AI系统的核心能力之一，它允许AI模型通过调用外部工具来扩展其能力，执行实际的操作，而不仅仅是生成文本。

#### 工具调用的基本概念#

##### 1. 什么是工具调用#

工具调用是指AI模型根据用户的请求，识别需要使用的工具，生成工具调用参数，执行工具调用，并将结果整合到最终响应中的过程。

工具调用的特点:

- 结构化输出: 模型输出结构化的工具调用指令
- 参数验证: 验证工具调用参数的有效性
- 结果整合: 将工具执行结果整合到响应中
- 错误处理: 处理工具调用失败的情况

##### 2. 工具调用流程#

用户请求
↓
意图识别
↓
工具选择
↓
参数生成
↓
工具执行
↓
结果处理
↓
响应生成

#### 工具定义与注册#

##### 1. 工具定义#

```
python复制python

# 示例：工具定义

用户请求：
"定义一个文件读取工具"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, Optional
import json
from dataclasses import dataclass, asdict
from enum import Enum

class ToolType(Enum):
    """工具类型"""
    FILE_OPERATION = "file_operation"
    CODE_EXECUTION = "code_execution"
    API_CALL = "api_call"
    SEARCH = "search"
    CALCULATION = "calculation"

@dataclass
class ToolParameter:
    """工具参数"""
    name: str
    type: str
    description: str
    required: bool
    default: Optional[Any] = None

@dataclass
class ToolDefinition:
    """工具定义"""
    name: str
    description: str
    type: ToolType
    parameters: list[ToolParameter]
    function: callable

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'name': self.name,
            'description': self.description,
            'type': self.type.value,
            'parameters': [asdict(param) for param in self.parameters]
        }
```

```
python

# 示例：工具定义

用户请求：
"定义一个文件读取工具"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, Optional
import json
from dataclasses import dataclass, asdict
from enum import Enum

class ToolType(Enum):
    """工具类型"""
    FILE_OPERATION = "file_operation"
    CODE_EXECUTION = "code_execution"
    API_CALL = "api_call"
    SEARCH = "search"
    CALCULATION = "calculation"

@dataclass
class ToolParameter:
    """工具参数"""
    name: str
    type: str
    description: str
    required: bool
    default: Optional[Any] = None

@dataclass
class ToolDefinition:
    """工具定义"""
    name: str
    description: str
    type: ToolType
    parameters: list[ToolParameter]
    function: callable

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'name': self.name,
            'description': self.description,
            'type': self.type.value,
            'parameters': [asdict(param) for param in self.parameters]
        }
```

### 文件读取工具

def read_file(file_path: str) -> str:
"""读取文件内容"""
try:
with open(file_path, 'r', encoding='utf-8') as f:
return f.read()
except FileNotFoundError:
return f"Error: File not found: {file_path}"
except Exception as e:
return f"Error: {str(e)}"

read_file_tool = ToolDefinition(
name="read_file",
description="读取指定文件的内容",
type=ToolType.FILE_OPERATION,
parameters=[
ToolParameter(
name="file_path",
type="string",
description="要读取的文件路径",
required=True
)
],
function=read_file
)

### 文件写入工具

def write_file(file_path: str, content: str) -> str:
"""写入内容到文件"""
try:
with open(file_path, 'w', encoding='utf-8') as f:
f.write(content)
return f"Success: File written to {file_path}"
except Exception as e:
return f"Error: {str(e)}"

write_file_tool = ToolDefinition(
name="write_file",
description="将内容写入到指定文件",
type=ToolType.FILE_OPERATION,
parameters=[
ToolParameter(
name="file_path",
type="string",
description="要写入的文件路径",
required=True
),
ToolParameter(
name="content",
type="string",
description="要写入的内容",
required=True
)
],
function=write_file
)

### 代码执行工具

def execute_code(code: str, language: str = "python") -> str:
"""执行代码"""
try:
if language == "python":
import subprocess
result = subprocess.run(
['python', '-c', code],
capture_output=True,
text=True,
timeout=10
)
if result.returncode == 0:
return result.stdout
else:
return f"Error: {result.stderr}"
else:
return f"Error: Unsupported language: {language}"
except subprocess.TimeoutExpired:
return "Error: Code execution timeout"
except Exception as e:
return f"Error: {str(e)}"

execute_code_tool = ToolDefinition(
name="execute_code",
description="执行代码并返回结果",
type=ToolType.CODE_EXECUTION,
parameters=[
ToolParameter(
name="code",
type="string",
description="要执行的代码",
required=True
),
ToolParameter(
name="language",
type="string",
description="编程语言",
required=False,
default="python"
)
],
function=execute_code
)

##### 2. 工具注册#

```
python复制
# 示例：工具注册

用户请求：
"实现一个工具注册系统"

Claude Code 生成的代码：

```python
```python

from typing import Dict, List, Optional

class ToolRegistry:
    """工具注册表"""

    def __init__(self):
        self.tools: Dict[str, ToolDefinition] = {}
        self.categories: Dict[str, List[str]] = {}

    def register(self, tool: ToolDefinition, category: Optional[str] = None):
        """注册工具"""
        self.tools[tool.name] = tool

        if category:
            if category not in self.categories:
                self.categories[category] = []
            self.categories[category].append(tool.name)

    def unregister(self, tool_name: str):
        """注销工具"""
        if tool_name in self.tools:
            del self.tools[tool_name]

            for category, tools in self.categories.items():
                if tool_name in tools:
                    tools.remove(tool_name)

    def get_tool(self, tool_name: str) -> Optional[ToolDefinition]:
        """获取工具"""
        return self.tools.get(tool_name)

    def list_tools(self, category: Optional[str] = None) -> List[ToolDefinition]:
        """列出工具"""
        if category:
            tool_names = self.categories.get(category, [])
            return [self.tools[name] for name in tool_names]
        else:
            return list(self.tools.values())

    def search_tools(self, keyword: str) -> List[ToolDefinition]:
        """搜索工具"""
        results = []
        keyword = keyword.lower()

        for tool in self.tools.values():
            if (keyword in tool.name.lower() or
                keyword in tool.description.lower()):
                results.append(tool)

        return results

    def get_tool_schema(self, tool_name: str) -> Optional[Dict[str, Any]]:
        """获取工具schema"""
        tool = self.get_tool(tool_name)
        if tool:
            return tool.to_dict()
        return None

    def get_all_schemas(self) -> Dict[str, Dict[str, Any]]:
        """获取所有工具schema"""
        return {
            name: tool.to_dict()
            for name, tool in self.tools.items()
        }

# 使用示例
registry = ToolRegistry()

# 注册工具
registry.register(read_file_tool, category="file_operations")
registry.register(write_file_tool, category="file_operations")
registry.register(execute_code_tool, category="code_execution")

# 列出所有工具
print("All tools:")
for tool in registry.list_tools():
    print(f"  - {tool.name}: {tool.description}")

# 列出特定类别的工具
print("\nFile operation tools:")
for tool in registry.list_tools(category="file_operations"):
    print(f"  - {tool.name}: {tool.description}")

# 搜索工具
print("\nSearch results for 'file':")
for tool in registry.search_tools("file"):
    print(f"  - {tool.name}: {tool.description}")

# 获取工具schema
print("\nTool schema for read_file:")
print(json.dumps(registry.get_tool_schema("read_file"), indent=2))

## 工具调用执行

### 1. 工具调用解析

# 示例：工具调用解析
用户请求：
"实现工具调用解析器"
Claude Code 生成的代码：
````python
`python

import re
from typing import Dict, Any, List, Optional
import json

class ToolCallParser:
"""工具调用解析器"""

def __init__(self, registry: ToolRegistry):
self.registry = registry

def parse_tool_calls(self, text: str) -> List[Dict[str, Any]]:
"""解析工具调用"""
tool_calls = []

 # 匹配工具调用模式
pattern = r'<tool_call>\s*<name>(.*?)</name>\s*<parameters>(.*?)</parameters>\s*</tool_call>'
matches = re.finditer(pattern, text, re.DOTALL)

for match in matches:
tool_name = match.group(1).strip()
parameters_str = match.group(2).strip()

 # 解析参数
try:
parameters = json.loads(parameters_str)
except json.JSONDecodeError:
parameters = self._parse_parameters(parameters_str)

tool_calls.append({
'tool': tool_name,
'parameters': parameters
})

return tool_calls

def _parse_parameters(self, parameters_str: str) -> Dict[str, Any]:
"""解析参数字符串"""
parameters = {}

 # 匹配参数
param_pattern = r'<(\w+)>(.*?)</\1>'
matches = re.findall(param_pattern, parameters_str, re.DOTALL)

for name, value in matches:
parameters[name] = value.strip()

return parameters

def validate_tool_call(self, tool_call: Dict[str, Any]) -> tuple[bool, Optional[str]]:
"""验证工具调用"""
tool_name = tool_call['tool']
parameters = tool_call['parameters']

 # 检查工具是否存在
tool = self.registry.get_tool(tool_name)
if not tool:
return False, f"Tool not found: {tool_name}"

 # 检查必需参数
for param in tool.parameters:
if param.required and param.name not in parameters:
return False, f"Missing required parameter: {param.name}"

 # 检查参数类型
for param in tool.parameters:
if param.name in parameters:
value = parameters[param.name]
if not self._check_parameter_type(value, param.type):
return False, f"Invalid type for parameter {param.name}: expected {param.type}"

return True, None

def _check_parameter_type(self, value: Any, expected_type: str) -> bool:
"""检查参数类型"""
type_mapping = {
'string': str,
'integer': int,
'float': float,
'boolean': bool,
'array': list,
'object': dict
}

expected_python_type = type_mapping.get(expected_type)
if expected_python_type:
return isinstance(value, expected_python_type)

return True

# 使用示例
parser = ToolCallParser(registry)

# 解析工具调用
text = """
I'll read the file for you.

<tool_call>
<name>read_file</name>
<parameters>{"file_path": "/path/to/file.txt"}</parameters>
</tool_call>
"""

tool_calls = parser.parse_tool_calls(text)
print("Parsed tool calls:")
for tool_call in tool_calls:
print(f"  Tool: {tool_call['tool']}")
print(f"  Parameters: {tool_call['parameters']}")

 # 验证工具调用
is_valid, error = parser.validate_tool_call(tool_call)
if is_valid:
print(f"  Status: Valid")
else:
print(f"  Status: Invalid - {error}")

```### 2. 工具调用执行
```

```
# 示例：工具注册

用户请求：
"实现一个工具注册系统"

Claude Code 生成的代码：

```python
```python

from typing import Dict, List, Optional

class ToolRegistry:
    """工具注册表"""

    def __init__(self):
        self.tools: Dict[str, ToolDefinition] = {}
        self.categories: Dict[str, List[str]] = {}

    def register(self, tool: ToolDefinition, category: Optional[str] = None):
        """注册工具"""
        self.tools[tool.name] = tool

        if category:
            if category not in self.categories:
                self.categories[category] = []
            self.categories[category].append(tool.name)

    def unregister(self, tool_name: str):
        """注销工具"""
        if tool_name in self.tools:
            del self.tools[tool_name]

            for category, tools in self.categories.items():
                if tool_name in tools:
                    tools.remove(tool_name)

    def get_tool(self, tool_name: str) -> Optional[ToolDefinition]:
        """获取工具"""
        return self.tools.get(tool_name)

    def list_tools(self, category: Optional[str] = None) -> List[ToolDefinition]:
        """列出工具"""
        if category:
            tool_names = self.categories.get(category, [])
            return [self.tools[name] for name in tool_names]
        else:
            return list(self.tools.values())

    def search_tools(self, keyword: str) -> List[ToolDefinition]:
        """搜索工具"""
        results = []
        keyword = keyword.lower()

        for tool in self.tools.values():
            if (keyword in tool.name.lower() or
                keyword in tool.description.lower()):
                results.append(tool)

        return results

    def get_tool_schema(self, tool_name: str) -> Optional[Dict[str, Any]]:
        """获取工具schema"""
        tool = self.get_tool(tool_name)
        if tool:
            return tool.to_dict()
        return None

    def get_all_schemas(self) -> Dict[str, Dict[str, Any]]:
        """获取所有工具schema"""
        return {
            name: tool.to_dict()
            for name, tool in self.tools.items()
        }

# 使用示例
registry = ToolRegistry()

# 注册工具
registry.register(read_file_tool, category="file_operations")
registry.register(write_file_tool, category="file_operations")
registry.register(execute_code_tool, category="code_execution")

# 列出所有工具
print("All tools:")
for tool in registry.list_tools():
    print(f"  - {tool.name}: {tool.description}")

# 列出特定类别的工具
print("\nFile operation tools:")
for tool in registry.list_tools(category="file_operations"):
    print(f"  - {tool.name}: {tool.description}")

# 搜索工具
print("\nSearch results for 'file':")
for tool in registry.search_tools("file"):
    print(f"  - {tool.name}: {tool.description}")

# 获取工具schema
print("\nTool schema for read_file:")
print(json.dumps(registry.get_tool_schema("read_file"), indent=2))

## 工具调用执行

### 1. 工具调用解析

# 示例：工具调用解析
用户请求：
"实现工具调用解析器"
Claude Code 生成的代码：
````python
`python

import re
from typing import Dict, Any, List, Optional
import json

class ToolCallParser:
"""工具调用解析器"""

def __init__(self, registry: ToolRegistry):
self.registry = registry

def parse_tool_calls(self, text: str) -> List[Dict[str, Any]]:
"""解析工具调用"""
tool_calls = []

 # 匹配工具调用模式
pattern = r'<tool_call>\s*<name>(.*?)</name>\s*<parameters>(.*?)</parameters>\s*</tool_call>'
matches = re.finditer(pattern, text, re.DOTALL)

for match in matches:
tool_name = match.group(1).strip()
parameters_str = match.group(2).strip()

 # 解析参数
try:
parameters = json.loads(parameters_str)
except json.JSONDecodeError:
parameters = self._parse_parameters(parameters_str)

tool_calls.append({
'tool': tool_name,
'parameters': parameters
})

return tool_calls

def _parse_parameters(self, parameters_str: str) -> Dict[str, Any]:
"""解析参数字符串"""
parameters = {}

 # 匹配参数
param_pattern = r'<(\w+)>(.*?)</\1>'
matches = re.findall(param_pattern, parameters_str, re.DOTALL)

for name, value in matches:
parameters[name] = value.strip()

return parameters

def validate_tool_call(self, tool_call: Dict[str, Any]) -> tuple[bool, Optional[str]]:
"""验证工具调用"""
tool_name = tool_call['tool']
parameters = tool_call['parameters']

 # 检查工具是否存在
tool = self.registry.get_tool(tool_name)
if not tool:
return False, f"Tool not found: {tool_name}"

 # 检查必需参数
for param in tool.parameters:
if param.required and param.name not in parameters:
return False, f"Missing required parameter: {param.name}"

 # 检查参数类型
for param in tool.parameters:
if param.name in parameters:
value = parameters[param.name]
if not self._check_parameter_type(value, param.type):
return False, f"Invalid type for parameter {param.name}: expected {param.type}"

return True, None

def _check_parameter_type(self, value: Any, expected_type: str) -> bool:
"""检查参数类型"""
type_mapping = {
'string': str,
'integer': int,
'float': float,
'boolean': bool,
'array': list,
'object': dict
}

expected_python_type = type_mapping.get(expected_type)
if expected_python_type:
return isinstance(value, expected_python_type)

return True

# 使用示例
parser = ToolCallParser(registry)

# 解析工具调用
text = """
I'll read the file for you.

<tool_call>
<name>read_file</name>
<parameters>{"file_path": "/path/to/file.txt"}</parameters>
</tool_call>
"""

tool_calls = parser.parse_tool_calls(text)
print("Parsed tool calls:")
for tool_call in tool_calls:
print(f"  Tool: {tool_call['tool']}")
print(f"  Parameters: {tool_call['parameters']}")

 # 验证工具调用
is_valid, error = parser.validate_tool_call(tool_call)
if is_valid:
print(f"  Status: Valid")
else:
print(f"  Status: Invalid - {error}")

```### 2. 工具调用执行
```

python

### 示例：工具调用执行

用户请求：
"实现工具调用执行器"

Claude Code 生成的代码：

from typing import Dict, Any, List
import asyncio
from concurrent.futures import ThreadPoolExecutor

class ToolExecutor:
"""工具执行器"""

def init(self, registry: ToolRegistry):
self.registry = registry
self.executor = ThreadPoolExecutor(max_workers=4)

async def execute_tool_call(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:
"""执行工具调用"""
tool_name = tool_call['tool']
parameters = tool_call['parameters']

### 获取工具

tool = self.registry.get_tool(tool_name)
if not tool:
return {
'success': False,
'error': f"Tool not found: {tool_name}",
'tool': tool_name
}

### 执行工具

loop = asyncio.get_event_loop()
result = await loop.run_in_executor(
self.executor,
tool.function,
**parameters
)

return {
'success': True,
'result': result,
'tool': tool_name
}

except Exception as e:
return {
'success': False,
'error': str(e),
'tool': tool_name
}

async def execute_tool_calls(self, tool_calls: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
"""执行多个工具调用"""
tasks = [
self.execute_tool_call(tool_call)
for tool_call in tool_calls
]

results = await asyncio.gather(*tasks, return_exceptions=True)

return results

def execute_tool_call_sync(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:
"""同步执行工具调用"""
tool_name = tool_call['tool']
parameters = tool_call['parameters']

### 获取工具

tool = self.registry.get_tool(tool_name)
if not tool:
return {
'success': False,
'error': f"Tool not found: {tool_name}",
'tool': tool_name
}

### 执行工具

result = tool.function(**parameters)

return {
'success': True,
'result': result,
'tool': tool_name
}

except Exception as e:
return {
'success': False,
'error': str(e),
'tool': tool_name
}

### 使用示例

executor = ToolExecutor(registry)

### 执行工具调用

tool_calls = [
{
'tool': 'read_file',
'parameters': {'file_path': '/path/to/file.txt'}
},
{
'tool': 'execute_code',
'parameters': {'code': 'print("Hello, World!")', 'language': 'python'}
}
]

### 异步执行

async def main():
results = await executor.execute_tool_calls(tool_calls)

print("Execution results:")
for result in results:
if result['success']:
print(f"  {result['tool']}: Success")
print(f"    Result: {result['result']}")
else:
print(f"  {result['tool']}: Failed")
print(f"    Error: {result['error']}")

### 同步执行

def main_sync():
for tool_call in tool_calls:
result = executor.execute_tool_call_sync(tool_call)

if result['success']:
print(f"{result['tool']}: Success")
print(f"  Result: {result['result']}")
else:
print(f"{result['tool']}: Failed")
print(f"  Error: {result['error']}")

#### 工具调用优化#

##### 1. 缓存机制#

```
python复制python

# 示例：工具调用缓存

用户请求：
"实现工具调用缓存"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, Optional
import hashlib
import json
from datetime import datetime, timedelta

class ToolCallCache:
    """工具调用缓存"""

    def __init__(self, ttl: int = 3600):
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.ttl = ttl

    def _generate_key(self, tool_name: str, parameters: Dict[str, Any]) -> str:
        """生成缓存键"""
        key_data = {
            'tool': tool_name,
            'parameters': parameters
        }
        key_str = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()

    def get(self, tool_name: str, parameters: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """获取缓存"""
        key = self._generate_key(tool_name, parameters)

        if key in self.cache:
            cached = self.cache[key]

            # 检查是否过期
            if datetime.utcnow() - cached['timestamp'] < timedelta(seconds=self.ttl):
                return cached['result']
            else:
                del self.cache[key]

        return None

    def set(self, tool_name: str, parameters: Dict[str, Any], result: Dict[str, Any]):
        """设置缓存"""
        key = self._generate_key(tool_name, parameters)

        self.cache[key] = {
            'result': result,
            'timestamp': datetime.utcnow()
        }

    def clear(self):
        """清空缓存"""
        self.cache.clear()

    def cleanup(self):
        """清理过期缓存"""
        current_time = datetime.utcnow()
        expired_keys = [
            key for key, cached in self.cache.items()
            if current_time - cached['timestamp'] >= timedelta(seconds=self.ttl)
        ]

        for key in expired_keys:
            del self.cache[key]

class CachedToolExecutor(ToolExecutor):
    """带缓存的工具执行器"""

    def __init__(self, registry: ToolRegistry, cache: ToolCallCache):
        super().__init__(registry)
        self.cache = cache

    async def execute_tool_call(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:
        """执行工具调用（带缓存）"""
        tool_name = tool_call['tool']
        parameters = tool_call['parameters']

        # 检查缓存
        cached_result = self.cache.get(tool_name, parameters)
        if cached_result:
            return cached_result

        # 执行工具调用
        result = await super().execute_tool_call(tool_call)

        # 缓存结果
        if result['success']:
            self.cache.set(tool_name, parameters, result)

        return result

### 2. 批量执行

```python

# 示例：批量工具调用

用户请求：
"实现批量工具调用"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, List
import asyncio

class BatchToolExecutor(ToolExecutor):
    """批量工具执行器"""

    async def execute_batch(self, batch: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """批量执行工具调用"""
        # 按工具类型分组
        tool_groups = {}
        for tool_call in batch:
            tool_name = tool_call['tool']
            if tool_name not in tool_groups:
                tool_groups[tool_name] = []
            tool_groups[tool_name].append(tool_call)

        # 并行执行不同工具的调用
        tasks = [
            self._execute_tool_group(tool_name, tool_calls)
            for tool_name, tool_calls in tool_groups.items()
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 合并结果
        all_results = []
        for result_list in results:
            if isinstance(result_list, list):
                all_results.extend(result_list)

        return all_results

    async def _execute_tool_group(self, tool_name: str, tool_calls: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """执行同一工具的多个调用"""
        tool = self.registry.get_tool(tool_name)
        if not tool:
            return [
                {
                    'success': False,
                    'error': f"Tool not found: {tool_name}",
                    'tool': tool_name
                }
                for _ in tool_calls
            ]

        results = []
        for tool_call in tool_calls:
            result = await super().execute_tool_call(tool_call)
            results.append(result)

        return results
```

```
python

# 示例：工具调用缓存

用户请求：
"实现工具调用缓存"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, Optional
import hashlib
import json
from datetime import datetime, timedelta

class ToolCallCache:
    """工具调用缓存"""

    def __init__(self, ttl: int = 3600):
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.ttl = ttl

    def _generate_key(self, tool_name: str, parameters: Dict[str, Any]) -> str:
        """生成缓存键"""
        key_data = {
            'tool': tool_name,
            'parameters': parameters
        }
        key_str = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()

    def get(self, tool_name: str, parameters: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """获取缓存"""
        key = self._generate_key(tool_name, parameters)

        if key in self.cache:
            cached = self.cache[key]

            # 检查是否过期
            if datetime.utcnow() - cached['timestamp'] < timedelta(seconds=self.ttl):
                return cached['result']
            else:
                del self.cache[key]

        return None

    def set(self, tool_name: str, parameters: Dict[str, Any], result: Dict[str, Any]):
        """设置缓存"""
        key = self._generate_key(tool_name, parameters)

        self.cache[key] = {
            'result': result,
            'timestamp': datetime.utcnow()
        }

    def clear(self):
        """清空缓存"""
        self.cache.clear()

    def cleanup(self):
        """清理过期缓存"""
        current_time = datetime.utcnow()
        expired_keys = [
            key for key, cached in self.cache.items()
            if current_time - cached['timestamp'] >= timedelta(seconds=self.ttl)
        ]

        for key in expired_keys:
            del self.cache[key]

class CachedToolExecutor(ToolExecutor):
    """带缓存的工具执行器"""

    def __init__(self, registry: ToolRegistry, cache: ToolCallCache):
        super().__init__(registry)
        self.cache = cache

    async def execute_tool_call(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:
        """执行工具调用（带缓存）"""
        tool_name = tool_call['tool']
        parameters = tool_call['parameters']

        # 检查缓存
        cached_result = self.cache.get(tool_name, parameters)
        if cached_result:
            return cached_result

        # 执行工具调用
        result = await super().execute_tool_call(tool_call)

        # 缓存结果
        if result['success']:
            self.cache.set(tool_name, parameters, result)

        return result

### 2. 批量执行

```python

# 示例：批量工具调用

用户请求：
"实现批量工具调用"

Claude Code 生成的代码：

```python
```python

from typing import Dict, Any, List
import asyncio

class BatchToolExecutor(ToolExecutor):
    """批量工具执行器"""

    async def execute_batch(self, batch: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """批量执行工具调用"""
        # 按工具类型分组
        tool_groups = {}
        for tool_call in batch:
            tool_name = tool_call['tool']
            if tool_name not in tool_groups:
                tool_groups[tool_name] = []
            tool_groups[tool_name].append(tool_call)

        # 并行执行不同工具的调用
        tasks = [
            self._execute_tool_group(tool_name, tool_calls)
            for tool_name, tool_calls in tool_groups.items()
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 合并结果
        all_results = []
        for result_list in results:
            if isinstance(result_list, list):
                all_results.extend(result_list)

        return all_results

    async def _execute_tool_group(self, tool_name: str, tool_calls: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """执行同一工具的多个调用"""
        tool = self.registry.get_tool(tool_name)
        if not tool:
            return [
                {
                    'success': False,
                    'error': f"Tool not found: {tool_name}",
                    'tool': tool_name
                }
                for _ in tool_calls
            ]

        results = []
        for tool_call in tool_calls:
            result = await super().execute_tool_call(tool_call)
            results.append(result)

        return results
```

#### 总结#

工具调用机制包括：

True. 工具调用的基本概念: 什么是工具调用、工具调用流程
True. 工具定义与注册: 工具定义、工具注册
True. 工具调用执行: 工具调用解析、工具调用执行
True. 工具调用优化: 缓存机制、批量执行

通过工具调用机制，Claude Code可以执行各种实际操作，大大扩展了其能力。

在下一节中，我们将探讨自主规划算法。

---

## 3 自主规划算法

**URL**: https://claudecode.tangshuang.net/course/27.3%20%E8%87%AA%E4%B8%BB%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95

#### 自主规划算法概述#

自主规划算法是Agentic AI系统的核心能力之一，它允许AI系统根据目标自主分解任务、制定执行计划、监控执行进度，并根据实际情况调整计划。

#### 规划算法的基本概念#

##### 1. 什么是自主规划#

自主规划是指AI系统在没有人类干预的情况下，根据给定的目标，自动生成和执行任务计划的过程。

自主规划的特点:

- 目标驱动: 以目标为导向进行规划
- 任务分解: 将复杂目标分解为可执行的子任务
- 动态调整: 根据执行情况动态调整计划
- 资源管理: 合理分配和利用资源

##### 2. 规划算法分类#

#### 任务分解算法#

##### 1. 层次任务分解#

### 示例：层次任务分解

用户请求：
"实现一个层次任务分解算法"

Claude Code 生成的代码：

```
python复制````python

from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class TaskStatus(Enum):
"""任务状态"""
PENDING = "pending"
IN_PROGRESS = "in_progress"
COMPLETED = "completed"
FAILED = "failed"
CANCELLED = "cancelled"

class TaskPriority(Enum):
"""任务优先级"""
CRITICAL = 1
HIGH = 2
MEDIUM = 3
LOW = 4

@dataclass
class Task:
"""任务"""
id: str
name: str
description: str
status: TaskStatus = TaskStatus.PENDING
priority: TaskPriority = TaskPriority.MEDIUM
dependencies: List[str] = field(default_factory=list)
subtasks: List['Task'] = field(default_factory=list)
estimated_duration: Optional[float] = None
actual_duration: Optional[float] = None
result: Optional[Any] = None
error: Optional[str] = None
metadata: Dict[str, Any] = field(default_factory=dict)

class HierarchicalTaskPlanner:
"""层次任务规划器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.task_graph: Dict[str, List[str]] = {}

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
self.task_graph[task.id] = task.dependencies
logger.info(f"Task added: {task.id}")

def decompose_task(self, task_id: str, max_depth: int = 3) -> List[Task]:
"""分解任务"""
task = self.tasks.get(task_id)
if not task:
raise ValueError(f"Task not found: {task_id}")

if max_depth <= 0:
return [task]

 # 生成子任务
subtasks = self._generate_subtasks(task)

 # 递归分解子任务
all_tasks = [task]
for subtask in subtasks:
self.add_task(subtask)
task.subtasks.append(subtask)
all_tasks.extend(self.decompose_task(subtask.id, max_depth - 1))

 # 更新任务图
self.task_graph[task.id] = [subtask.id for subtask in subtasks]

return all_tasks

def _generate_subtasks(self, task: Task) -> List[Task]:
"""生成子任务"""
subtasks = []

 # 根据任务类型生成子任务
task_type = task.metadata.get('type', 'default')

if task_type == 'code_generation':
subtasks = self._generate_code_generation_subtasks(task)
elif task_type == 'code_review':
subtasks = self._generate_code_review_subtasks(task)
elif task_type == 'testing':
subtasks = self._generate_testing_subtasks(task)
elif task_type == 'deployment':
subtasks = self._generate_deployment_subtasks(task)
else:
subtasks = self._generate_default_subtasks(task)

return subtasks

def _generate_code_generation_subtasks(self, task: Task) -> List[Task]:
"""生成代码生成子任务"""
subtasks = [
Task(
id=f"{task.id}_analyze_requirements",
name="Analyze Requirements",
description="Analyze the requirements for code generation",
priority=TaskPriority.HIGH,
metadata={'type': 'analysis'}
),
Task(
id=f"{task.id}_design_architecture",
name="Design Architecture",
description="Design the system architecture",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_analyze_requirements"],
metadata={'type': 'design'}
),
Task(
id=f"{task.id}_generate_code",
name="Generate Code",
description="Generate the code",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_design_architecture"],
metadata={'type': 'code_generation'}
),
Task(
id=f"{task.id}_review_code",
name="Review Code",
description="Review the generated code",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_generate_code"],
metadata={'type': 'code_review'}
)
]

return subtasks

def _generate_code_review_subtasks(self, task: Task) -> List[Task]:
"""生成代码审查子任务"""
subtasks = [
Task(
id=f"{task.id}_static_analysis",
name="Static Analysis",
description="Perform static code analysis",
priority=TaskPriority.HIGH,
metadata={'type': 'analysis'}
),
Task(
id=f"{task.id}_security_check",
name="Security Check",
description="Check for security vulnerabilities",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_static_analysis"],
metadata={'type': 'security'}
),
Task(
id=f"{task.id}_performance_check",
name="Performance Check",
description="Check for performance issues",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_static_analysis"],
metadata={'type': 'performance'}
),
Task(
id=f"{task.id}_generate_report",
name="Generate Report",
description="Generate review report",
priority=TaskPriority.MEDIUM,
dependencies=[
f"{task.id}_security_check",
f"{task.id}_performance_check"
```

```
````python

from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class TaskStatus(Enum):
"""任务状态"""
PENDING = "pending"
IN_PROGRESS = "in_progress"
COMPLETED = "completed"
FAILED = "failed"
CANCELLED = "cancelled"

class TaskPriority(Enum):
"""任务优先级"""
CRITICAL = 1
HIGH = 2
MEDIUM = 3
LOW = 4

@dataclass
class Task:
"""任务"""
id: str
name: str
description: str
status: TaskStatus = TaskStatus.PENDING
priority: TaskPriority = TaskPriority.MEDIUM
dependencies: List[str] = field(default_factory=list)
subtasks: List['Task'] = field(default_factory=list)
estimated_duration: Optional[float] = None
actual_duration: Optional[float] = None
result: Optional[Any] = None
error: Optional[str] = None
metadata: Dict[str, Any] = field(default_factory=dict)

class HierarchicalTaskPlanner:
"""层次任务规划器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.task_graph: Dict[str, List[str]] = {}

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
self.task_graph[task.id] = task.dependencies
logger.info(f"Task added: {task.id}")

def decompose_task(self, task_id: str, max_depth: int = 3) -> List[Task]:
"""分解任务"""
task = self.tasks.get(task_id)
if not task:
raise ValueError(f"Task not found: {task_id}")

if max_depth <= 0:
return [task]

 # 生成子任务
subtasks = self._generate_subtasks(task)

 # 递归分解子任务
all_tasks = [task]
for subtask in subtasks:
self.add_task(subtask)
task.subtasks.append(subtask)
all_tasks.extend(self.decompose_task(subtask.id, max_depth - 1))

 # 更新任务图
self.task_graph[task.id] = [subtask.id for subtask in subtasks]

return all_tasks

def _generate_subtasks(self, task: Task) -> List[Task]:
"""生成子任务"""
subtasks = []

 # 根据任务类型生成子任务
task_type = task.metadata.get('type', 'default')

if task_type == 'code_generation':
subtasks = self._generate_code_generation_subtasks(task)
elif task_type == 'code_review':
subtasks = self._generate_code_review_subtasks(task)
elif task_type == 'testing':
subtasks = self._generate_testing_subtasks(task)
elif task_type == 'deployment':
subtasks = self._generate_deployment_subtasks(task)
else:
subtasks = self._generate_default_subtasks(task)

return subtasks

def _generate_code_generation_subtasks(self, task: Task) -> List[Task]:
"""生成代码生成子任务"""
subtasks = [
Task(
id=f"{task.id}_analyze_requirements",
name="Analyze Requirements",
description="Analyze the requirements for code generation",
priority=TaskPriority.HIGH,
metadata={'type': 'analysis'}
),
Task(
id=f"{task.id}_design_architecture",
name="Design Architecture",
description="Design the system architecture",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_analyze_requirements"],
metadata={'type': 'design'}
),
Task(
id=f"{task.id}_generate_code",
name="Generate Code",
description="Generate the code",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_design_architecture"],
metadata={'type': 'code_generation'}
),
Task(
id=f"{task.id}_review_code",
name="Review Code",
description="Review the generated code",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_generate_code"],
metadata={'type': 'code_review'}
)
]

return subtasks

def _generate_code_review_subtasks(self, task: Task) -> List[Task]:
"""生成代码审查子任务"""
subtasks = [
Task(
id=f"{task.id}_static_analysis",
name="Static Analysis",
description="Perform static code analysis",
priority=TaskPriority.HIGH,
metadata={'type': 'analysis'}
),
Task(
id=f"{task.id}_security_check",
name="Security Check",
description="Check for security vulnerabilities",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_static_analysis"],
metadata={'type': 'security'}
),
Task(
id=f"{task.id}_performance_check",
name="Performance Check",
description="Check for performance issues",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_static_analysis"],
metadata={'type': 'performance'}
),
Task(
id=f"{task.id}_generate_report",
name="Generate Report",
description="Generate review report",
priority=TaskPriority.MEDIUM,
dependencies=[
f"{task.id}_security_check",
f"{task.id}_performance_check"
```

],
metadata={'type': 'reporting'}
)
]

return subtasks

def _generate_testing_subtasks(self, task: Task) -> List[Task]:
"""生成测试子任务"""
subtasks = [
Task(
id=f"{task.id}_unit_tests",
name="Unit Tests",
description="Write and run unit tests",
priority=TaskPriority.HIGH,
metadata={'type': 'testing'}
),
Task(
id=f"{task.id}_integration_tests",
name="Integration Tests",
description="Write and run integration tests",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_unit_tests"],
metadata={'type': 'testing'}
),
Task(
id=f"{task.id}_e2e_tests",
name="E2E Tests",
description="Write and run end-to-end tests",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_integration_tests"],
metadata={'type': 'testing'}
)
]

return subtasks

def _generate_deployment_subtasks(self, task: Task) -> List[Task]:
"""生成部署子任务"""
subtasks = [
Task(
id=f"{task.id}_build",
name="Build",
description="Build the application",
priority=TaskPriority.HIGH,
metadata={'type': 'build'}
),
Task(
id=f"{task.id}_test",
name="Test",
description="Run tests",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_build"],
metadata={'type': 'testing'}
),
Task(
id=f"{task.id}_deploy",
name="Deploy",
description="Deploy to production",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_test"],
metadata={'type': 'deployment'}
),
Task(
id=f"{task.id}_verify",
name="Verify",
description="Verify deployment",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_deploy"],
metadata={'type': 'verification'}
)
]

return subtasks

def _generate_default_subtasks(self, task: Task) -> List[Task]:
"""生成默认子任务"""
subtasks = [
Task(
id=f"{task.id}_prepare",
name="Prepare",
description="Prepare for task execution",
priority=TaskPriority.HIGH,
metadata={'type': 'preparation'}
),
Task(
id=f"{task.id}_execute",
name="Execute",
description="Execute the task",
priority=TaskPriority.HIGH,
dependencies=[f"{task.id}_prepare"],
metadata={'type': 'execution'}
),
Task(
id=f"{task.id}_finalize",
name="Finalize",
description="Finalize the task",
priority=TaskPriority.MEDIUM,
dependencies=[f"{task.id}_execute"],
metadata={'type': 'finalization'}
)
]

return subtasks

def get_execution_plan(self, task_id: str) -> List[Task]:
"""获取执行计划"""
plan = []
visited = set()

def dfs(current_task_id):
if current_task_id in visited:
return
visited.add(current_task_id)

### 先执行依赖任务

for dep_id in self.task_graph.get(current_task_id, []):
dfs(dep_id)

### 添加当前任务

task = self.tasks.get(current_task_id)
if task:
plan.append(task)

dfs(task_id)

return plan

def visualize_plan(self, task_id: str) -> str:
"""可视化执行计划"""
plan = self.get_execution_plan(task_id)

visualization = "Execution Plan:\n"
for i, task in enumerate(plan, 1):
status_icon = {
TaskStatus.PENDING: "○",
TaskStatus.IN_PROGRESS: "◐",
TaskStatus.COMPLETED: "●",
TaskStatus.FAILED: "✗",
TaskStatus.CANCELLED: "⊘"
}.get(task.status, "?")

visualization += f"{i}. {status_icon} {task.name}\n"

if task.subtasks:
for j, subtask in enumerate(task.subtasks, 1):
subtask_icon = {
TaskStatus.PENDING: "○",
TaskStatus.IN_PROGRESS: "◐",
TaskStatus.COMPLETED: "●",
TaskStatus.FAILED: "✗",
TaskStatus.CANCELLED: "⊘"
}.get(subtask.status, "?")

visualization += f"   {j}. {subtask_icon} {subtask.name}\n"

return visualization

### 使用示例

planner = HierarchicalTaskPlanner()

### 添加主任务

main_task = Task(
id="main",
name="Develop User Authentication System",
description="Develop a complete user authentication system",
priority=TaskPriority.HIGH,
metadata={'type': 'code_generation'}
)

planner.add_task(main_task)

### 分解任务

planner.decompose_task("main", max_depth=2)

### 获取执行计划

plan = planner.get_execution_plan("main")

print("Execution Plan:")
for task in plan:
print(f"  - {task.name}")

### 可视化计划

print("\n" + planner.visualize_plan("main"))

```
bash复制> - 递归分解复杂任务
> - 自动生成子任务
> - 维护任务依赖关系
> - 生成执行计划
```

```
> - 递归分解复杂任务
> - 自动生成子任务
> - 维护任务依赖关系
> - 生成执行计划
```

##### 2. 动态任务调整#

### 示例：动态任务调整

用户请求：
"实现动态任务调整算法"
Claude Code 生成的代码：

```
python复制`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class DynamicTaskPlanner(HierarchicalTaskPlanner):
"""动态任务规划器"""

def __init__(self):
super().__init__()
self.execution_history: Dict[str, List[Dict[str, Any]]] = {}
self.performance_metrics: Dict[str, Dict[str, float]] = {}

def monitor_execution(self, task_id: str, status: TaskStatus, result: Optional[Any] = None, error: Optional[str] = None):
"""监控任务执行"""
task = self.tasks.get(task_id)
if not task:
return

 # 更新任务状态
task.status = status
task.result = result
task.error = error

 # 记录执行历史
if task_id not in self.execution_history:
self.execution_history[task_id] = []

self.execution_history[task_id].append({
'timestamp': datetime.utcnow(),
'status': status,
'result': result,
'error': error
})

logger.info(f"Task {task_id} status updated to {status}")

def analyze_performance(self, task_id: str) -> Dict[str, float]:
"""分析任务性能"""
if task_id not in self.execution_history:
return {}

history = self.execution_history[task_id]

 # 计算性能指标
metrics = {
'total_executions': len(history),
'success_rate': 0.0,
'avg_duration': 0.0,
'failure_rate': 0.0
}

successful = [h for h in history if h['status'] == TaskStatus.COMPLETED]
failed = [h for h in history if h['status'] == TaskStatus.FAILED]

if len(history) > 0:
metrics['success_rate'] = len(successful) / len(history)
metrics['failure_rate'] = len(failed) / len(history)

self.performance_metrics[task_id] = metrics

return metrics

def adjust_plan(self, task_id: str) -> List[Task]:
"""调整执行计划"""
task = self.tasks.get(task_id)
if not task:
return []

 # 分析性能
metrics = self.analyze_performance(task_id)

 # 根据性能调整计划
if metrics.get('failure_rate', 0) > 0.5:
 # 失败率高，添加重试任务
return self._add_retry_tasks(task)
elif metrics.get('avg_duration', 0) > 3600:
 # 执行时间长，优化任务
return self._optimize_tasks(task)
else:
 # 正常情况，返回原计划
return self.get_execution_plan(task_id)

def _add_retry_tasks(self, task: Task) -> List[Task]:
"""添加重试任务"""
retry_task = Task(
id=f"{task.id}_retry",
name=f"Retry {task.name}",
description=f"Retry failed task: {task.description}",
priority=TaskPriority.HIGH,
dependencies=[task.id],
metadata={'type': 'retry', 'original_task_id': task.id}
)

self.add_task(retry_task)

 # 更新任务图
self.task_graph[task.id].append(retry_task.id)

return self.get_execution_plan(task.id)

def _optimize_tasks(self, task: Task) -> List[Task]:
"""优化任务"""
 # 分解长时间运行的任务
if task.subtasks:
 # 已经有子任务，优化子任务
for subtask in task.subtasks:
if subtask.estimated_duration and subtask.estimated_duration > 1800:
self.decompose_task(subtask.id, max_depth=1)
else:
 # 分解当前任务
self.decompose_task(task.id, max_depth=2)

return self.get_execution_plan(task.id)

def predict_completion_time(self, task_id: str) -> Optional[float]:
"""预测完成时间"""
plan = self.get_execution_plan(task_id)

total_time = 0.0
for task in plan:
if task.estimated_duration:
total_time += task.estimated_duration
elif task.id in self.performance_metrics:
 # 使用历史平均时间
avg_duration = self.performance_metrics[task.id].get('avg_duration', 0)
total_time += avg_duration

return total_time if total_time > 0 else None

# 使用示例
planner = DynamicTaskPlanner()

# 添加任务
task = Task(
id="task1",
name="Process Large Dataset",
description="Process a large dataset",
priority=TaskPriority.HIGH,
estimated_duration=7200,
metadata={'type': 'data_processing'}
)

planner.add_task(task)

# 分解任务
planner.decompose_task("task1", max_depth=2)

# 模拟执行
planner.monitor_execution("task1", TaskStatus.IN_PROGRESS)

# 模拟失败
planner.monitor_execution("task1", TaskStatus.FAILED, error="Timeout")

# 分析性能
metrics = planner.analyze_performance("task1")
print(f"Performance metrics: {metrics}")

# 调整计划
adjusted_plan = planner.adjust_plan("task1")

print("\nAdjusted plan:")
for task in adjusted_plan:
print(f"  - {task.name}")

```> **动态任务调整特点**:
> - 实时监控任务执行
> - 分析任务性能
> - 根据性能调整计划
> - 预测完成时间

```
## 规划算法优化

### 1. 并行任务调度

# 示例：并行任务调度
用户请求：
"实现并行任务调度算法"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Set, Optional
from collections import defaultdict, deque
import logging

logger = logging.getLogger(__name__)

class ParallelTaskScheduler:
"""并行任务调度器"""

def __init__(self, max_workers: int = 4):
self.max_workers = max_workers
self.tasks: Dict[str, Task] = {}
self.dependencies: Dict[str, Set[str]] = defaultdict(set)
self.dependents: Dict[str, Set[str]] = defaultdict(set)
self.ready_tasks: Set[str] = set()
self.running_tasks: Set[str] = set()
self.completed_tasks: Set[str] = set()

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task

 # 添加依赖关系
for dep_id in task.dependencies:
self.dependencies[task.id].add(dep_id)
self.dependents[dep_id].add(task.id)

 # 如果没有依赖，标记为就绪
if not task.dependencies:
self.ready_tasks.add(task.id)

logger.info(f"Task added: {task.id}")

def get_ready_tasks(self) -> List[Task]:
"""获取就绪任务"""
available = self.ready_tasks - self.running_tasks
return [self.tasks[task_id] for task_id in available]

def start_task(self, task_id: str):
"""开始任务"""
if task_id in self.ready_tasks and task_id not in self.running_tasks:
self.running_tasks.add(task_id)
self.ready_tasks.remove(task_id)
logger.info(f"Task started: {task_id}")

def complete_task(self, task_id: str, result: Optional[Any] = None, error: Optional[str] = None):
"""完成任务"""
if task_id not in self.running_tasks:
logger.warning(f"Task not running: {task_id}")
return

 # 更新任务状态
task = self.tasks[task_id]
task.status = TaskStatus.COMPLETED if not error else TaskStatus.FAILED
task.result = result
task.error = error

 # 更新集合
self.running_tasks.remove(task_id)
self.completed_tasks.add(task_id)

 # 检查依赖此任务的任务
for dependent_id in self.dependents[task_id]:
self.dependencies[dependent_id].remove(task_id)

 # 如果所有依赖都完成，标记为就绪
if not self.dependencies[dependent_id]:
self.ready_tasks.add(dependent_id)

logger.info(f"Task completed: {task_id}")

def get_schedule(self) -> List[List[str]]:
"""获取调度计划"""
schedule = []
remaining = set(self.tasks.keys())

while remaining:
 # 获取当前可以执行的任务
current_batch = []
for task_id in remaining:
task = self.tasks[task_id]
if all(dep in self.completed_tasks for dep in task.dependencies):
current_batch.append(task_id)

 # 限制并发数
current_batch = current_batch[:self.max_workers]

if not current_batch:
logger.warning("Circular dependency detected")
break

schedule.append(current_batch)

 # 更新剩余任务
remaining -= set(current_batch)
self.completed_tasks.update(current_batch)

return schedule

def visualize_schedule(self) -> str:
"""可视化调度"""
schedule = self.get_schedule()

visualization = "Task Schedule:\n"
for i, batch in enumerate(schedule, 1):
visualization += f"Batch {i} (parallel):\n"
for task_id in batch:
task = self.tasks[task_id]
visualization += f"  - {task.name}\n"

return visualization

# 使用示例
scheduler = ParallelTaskScheduler(max_workers=3)

# 添加任务
tasks = [
Task(id="A", name="Task A", description="Task A", priority=TaskPriority.HIGH),
Task(id="B", name="Task B", description="Task B", priority=TaskPriority.HIGH, dependencies=["A"]),
Task(id="C", name="Task C", description="Task C", priority=TaskPriority.HIGH, dependencies=["A"]),
Task(id="D", name="Task D", description="Task D", priority=TaskPriority.HIGH, dependencies=["B", "C"]),
Task(id="E", name="Task E", description="Task E", priority=TaskPriority.HIGH, dependencies=["B"]),
Task(id="F", name="Task F", description="Task F", priority=TaskPriority.HIGH, dependencies=["C"]),
Task(id="G", name="Task G", description="Task G", priority=TaskPriority.HIGH, dependencies=["D", "E", "F"])
]

for task in tasks:
scheduler.add_task(task)

# 获取调度计划
schedule = scheduler.get_schedule()

print("Schedule:")
for i, batch in enumerate(schedule, 1):
print(f"Batch {i}: {[scheduler.tasks[task_id].name for task_id in batch]}")

# 可视化调度
print("\n" + scheduler.visualize_schedule())

```> **并行任务调度特点**:
> - 识别可并行执行的任务
> - 限制并发任务数量
> - 处理任务依赖关系
> - 生成调度计划
```
## 总结

自主规划算法包括：

1. **规划算法的基本概念**: 什么是自主规划、规划算法分类
2. **任务分解算法**: 层次任务分解、动态任务调整
3. **规划算法优化**: 并行任务调度

通过自主规划算法，Claude Code可以自主分解任务、制定执行计划，并根据实际情况动态调整。

在下一节中，我们将探讨记忆系统设计。

```
```

```
`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class DynamicTaskPlanner(HierarchicalTaskPlanner):
"""动态任务规划器"""

def __init__(self):
super().__init__()
self.execution_history: Dict[str, List[Dict[str, Any]]] = {}
self.performance_metrics: Dict[str, Dict[str, float]] = {}

def monitor_execution(self, task_id: str, status: TaskStatus, result: Optional[Any] = None, error: Optional[str] = None):
"""监控任务执行"""
task = self.tasks.get(task_id)
if not task:
return

 # 更新任务状态
task.status = status
task.result = result
task.error = error

 # 记录执行历史
if task_id not in self.execution_history:
self.execution_history[task_id] = []

self.execution_history[task_id].append({
'timestamp': datetime.utcnow(),
'status': status,
'result': result,
'error': error
})

logger.info(f"Task {task_id} status updated to {status}")

def analyze_performance(self, task_id: str) -> Dict[str, float]:
"""分析任务性能"""
if task_id not in self.execution_history:
return {}

history = self.execution_history[task_id]

 # 计算性能指标
metrics = {
'total_executions': len(history),
'success_rate': 0.0,
'avg_duration': 0.0,
'failure_rate': 0.0
}

successful = [h for h in history if h['status'] == TaskStatus.COMPLETED]
failed = [h for h in history if h['status'] == TaskStatus.FAILED]

if len(history) > 0:
metrics['success_rate'] = len(successful) / len(history)
metrics['failure_rate'] = len(failed) / len(history)

self.performance_metrics[task_id] = metrics

return metrics

def adjust_plan(self, task_id: str) -> List[Task]:
"""调整执行计划"""
task = self.tasks.get(task_id)
if not task:
return []

 # 分析性能
metrics = self.analyze_performance(task_id)

 # 根据性能调整计划
if metrics.get('failure_rate', 0) > 0.5:
 # 失败率高，添加重试任务
return self._add_retry_tasks(task)
elif metrics.get('avg_duration', 0) > 3600:
 # 执行时间长，优化任务
return self._optimize_tasks(task)
else:
 # 正常情况，返回原计划
return self.get_execution_plan(task_id)

def _add_retry_tasks(self, task: Task) -> List[Task]:
"""添加重试任务"""
retry_task = Task(
id=f"{task.id}_retry",
name=f"Retry {task.name}",
description=f"Retry failed task: {task.description}",
priority=TaskPriority.HIGH,
dependencies=[task.id],
metadata={'type': 'retry', 'original_task_id': task.id}
)

self.add_task(retry_task)

 # 更新任务图
self.task_graph[task.id].append(retry_task.id)

return self.get_execution_plan(task.id)

def _optimize_tasks(self, task: Task) -> List[Task]:
"""优化任务"""
 # 分解长时间运行的任务
if task.subtasks:
 # 已经有子任务，优化子任务
for subtask in task.subtasks:
if subtask.estimated_duration and subtask.estimated_duration > 1800:
self.decompose_task(subtask.id, max_depth=1)
else:
 # 分解当前任务
self.decompose_task(task.id, max_depth=2)

return self.get_execution_plan(task.id)

def predict_completion_time(self, task_id: str) -> Optional[float]:
"""预测完成时间"""
plan = self.get_execution_plan(task_id)

total_time = 0.0
for task in plan:
if task.estimated_duration:
total_time += task.estimated_duration
elif task.id in self.performance_metrics:
 # 使用历史平均时间
avg_duration = self.performance_metrics[task.id].get('avg_duration', 0)
total_time += avg_duration

return total_time if total_time > 0 else None

# 使用示例
planner = DynamicTaskPlanner()

# 添加任务
task = Task(
id="task1",
name="Process Large Dataset",
description="Process a large dataset",
priority=TaskPriority.HIGH,
estimated_duration=7200,
metadata={'type': 'data_processing'}
)

planner.add_task(task)

# 分解任务
planner.decompose_task("task1", max_depth=2)

# 模拟执行
planner.monitor_execution("task1", TaskStatus.IN_PROGRESS)

# 模拟失败
planner.monitor_execution("task1", TaskStatus.FAILED, error="Timeout")

# 分析性能
metrics = planner.analyze_performance("task1")
print(f"Performance metrics: {metrics}")

# 调整计划
adjusted_plan = planner.adjust_plan("task1")

print("\nAdjusted plan:")
for task in adjusted_plan:
print(f"  - {task.name}")

```> **动态任务调整特点**:
> - 实时监控任务执行
> - 分析任务性能
> - 根据性能调整计划
> - 预测完成时间

```
## 规划算法优化

### 1. 并行任务调度

# 示例：并行任务调度
用户请求：
"实现并行任务调度算法"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Set, Optional
from collections import defaultdict, deque
import logging

logger = logging.getLogger(__name__)

class ParallelTaskScheduler:
"""并行任务调度器"""

def __init__(self, max_workers: int = 4):
self.max_workers = max_workers
self.tasks: Dict[str, Task] = {}
self.dependencies: Dict[str, Set[str]] = defaultdict(set)
self.dependents: Dict[str, Set[str]] = defaultdict(set)
self.ready_tasks: Set[str] = set()
self.running_tasks: Set[str] = set()
self.completed_tasks: Set[str] = set()

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task

 # 添加依赖关系
for dep_id in task.dependencies:
self.dependencies[task.id].add(dep_id)
self.dependents[dep_id].add(task.id)

 # 如果没有依赖，标记为就绪
if not task.dependencies:
self.ready_tasks.add(task.id)

logger.info(f"Task added: {task.id}")

def get_ready_tasks(self) -> List[Task]:
"""获取就绪任务"""
available = self.ready_tasks - self.running_tasks
return [self.tasks[task_id] for task_id in available]

def start_task(self, task_id: str):
"""开始任务"""
if task_id in self.ready_tasks and task_id not in self.running_tasks:
self.running_tasks.add(task_id)
self.ready_tasks.remove(task_id)
logger.info(f"Task started: {task_id}")

def complete_task(self, task_id: str, result: Optional[Any] = None, error: Optional[str] = None):
"""完成任务"""
if task_id not in self.running_tasks:
logger.warning(f"Task not running: {task_id}")
return

 # 更新任务状态
task = self.tasks[task_id]
task.status = TaskStatus.COMPLETED if not error else TaskStatus.FAILED
task.result = result
task.error = error

 # 更新集合
self.running_tasks.remove(task_id)
self.completed_tasks.add(task_id)

 # 检查依赖此任务的任务
for dependent_id in self.dependents[task_id]:
self.dependencies[dependent_id].remove(task_id)

 # 如果所有依赖都完成，标记为就绪
if not self.dependencies[dependent_id]:
self.ready_tasks.add(dependent_id)

logger.info(f"Task completed: {task_id}")

def get_schedule(self) -> List[List[str]]:
"""获取调度计划"""
schedule = []
remaining = set(self.tasks.keys())

while remaining:
 # 获取当前可以执行的任务
current_batch = []
for task_id in remaining:
task = self.tasks[task_id]
if all(dep in self.completed_tasks for dep in task.dependencies):
current_batch.append(task_id)

 # 限制并发数
current_batch = current_batch[:self.max_workers]

if not current_batch:
logger.warning("Circular dependency detected")
break

schedule.append(current_batch)

 # 更新剩余任务
remaining -= set(current_batch)
self.completed_tasks.update(current_batch)

return schedule

def visualize_schedule(self) -> str:
"""可视化调度"""
schedule = self.get_schedule()

visualization = "Task Schedule:\n"
for i, batch in enumerate(schedule, 1):
visualization += f"Batch {i} (parallel):\n"
for task_id in batch:
task = self.tasks[task_id]
visualization += f"  - {task.name}\n"

return visualization

# 使用示例
scheduler = ParallelTaskScheduler(max_workers=3)

# 添加任务
tasks = [
Task(id="A", name="Task A", description="Task A", priority=TaskPriority.HIGH),
Task(id="B", name="Task B", description="Task B", priority=TaskPriority.HIGH, dependencies=["A"]),
Task(id="C", name="Task C", description="Task C", priority=TaskPriority.HIGH, dependencies=["A"]),
Task(id="D", name="Task D", description="Task D", priority=TaskPriority.HIGH, dependencies=["B", "C"]),
Task(id="E", name="Task E", description="Task E", priority=TaskPriority.HIGH, dependencies=["B"]),
Task(id="F", name="Task F", description="Task F", priority=TaskPriority.HIGH, dependencies=["C"]),
Task(id="G", name="Task G", description="Task G", priority=TaskPriority.HIGH, dependencies=["D", "E", "F"])
]

for task in tasks:
scheduler.add_task(task)

# 获取调度计划
schedule = scheduler.get_schedule()

print("Schedule:")
for i, batch in enumerate(schedule, 1):
print(f"Batch {i}: {[scheduler.tasks[task_id].name for task_id in batch]}")

# 可视化调度
print("\n" + scheduler.visualize_schedule())

```> **并行任务调度特点**:
> - 识别可并行执行的任务
> - 限制并发任务数量
> - 处理任务依赖关系
> - 生成调度计划
```
## 总结

自主规划算法包括：

1. **规划算法的基本概念**: 什么是自主规划、规划算法分类
2. **任务分解算法**: 层次任务分解、动态任务调整
3. **规划算法优化**: 并行任务调度

通过自主规划算法，Claude Code可以自主分解任务、制定执行计划，并根据实际情况动态调整。

在下一节中，我们将探讨记忆系统设计。

```
```

---

## 4 记忆系统设计

**URL**: https://claudecode.tangshuang.net/course/27.4%20%E8%AE%B0%E5%BF%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1

#### 记忆系统概述#

记忆系统是Agentic AI系统的重要组成部分，它使AI能够存储、检索和利用过去的信息，从而实现长期学习和持续改进。

#### 记忆系统的基本概念#

##### 1. 什么是记忆系统#

记忆系统是指AI系统用于存储、组织和检索信息的机制，类似于人类的记忆功能。

记忆系统的特点:

- 持久化存储: 长期保存重要信息
- 快速检索: 高效地检索相关信息
- 智能组织: 自动组织和分类信息
- 上下文感知: 根据上下文检索信息

##### 2. 记忆类型#

#### 记忆存储机制#

##### 1. 向量存储#

### 示例：向量存储

用户请求：
"实现一个基于向量的记忆存储系统"

Claude Code 生成的代码：

```
python复制````python

from typing import Dict, List, Any, Optional
import numpy as np
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

class Memory:
"""记忆"""

def __init__(self, id: str, content: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None):
self.id = id
self.content = content
self.embedding = embedding
self.metadata = metadata or {}
self.created_at = datetime.utcnow()
self.accessed_at = datetime.utcnow()
self.access_count = 0

def to_dict(self) -> Dict[str, Any]:
"""转换为字典"""
return {
'id': self.id,
'content': self.content,
'embedding': self.embedding.tolist(),
'metadata': self.metadata,
'created_at': self.created_at.isoformat(),
'accessed_at': self.accessed_at.isoformat(),
'access_count': self.access_count
}

class VectorMemoryStore:
"""向量记忆存储"""

def __init__(self, embedding_dim: int = 768):
self.embedding_dim = embedding_dim
self.memories: Dict[str, Memory] = {}
self.index: Dict[str, List[str]] = {}

def add_memory(self, content: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None) -> Memory:
"""添加记忆"""
memory_id = f"mem_{len(self.memories)}"
memory = Memory(memory_id, content, embedding, metadata)

self.memories[memory_id] = memory

 # 建立索引
self._index_memory(memory)

logger.info(f"Memory added: {memory_id}")
return memory

def _index_memory(self, memory: Memory):
"""索引记忆"""
 # 按类型索引
memory_type = memory.metadata.get('type', 'default')
if memory_type not in self.index:
self.index[memory_type] = []
self.index[memory_type].append(memory.id)

 # 按标签索引
tags = memory.metadata.get('tags', [])
for tag in tags:
if tag not in self.index:
self.index[tag] = []
self.index[tag].append(memory.id)

def retrieve_similar(self, query_embedding: np.ndarray, top_k: int = 5, threshold: float = 0.7) -> List[Memory]:
"""检索相似记忆"""
if not self.memories:
return []

 # 计算相似度
similarities = []
for memory_id, memory in self.memories.items():
similarity = self._cosine_similarity(query_embedding, memory.embedding)
if similarity >= threshold:
similarities.append((memory_id, similarity))

 # 按相似度排序
similarities.sort(key=lambda x: x[1], reverse=True)

 # 获取top_k个记忆
top_memories = []
for memory_id, similarity in similarities[:top_k]:
memory = self.memories[memory_id]
memory.accessed_at = datetime.utcnow()
memory.access_count += 1
top_memories.append(memory)

return top_memories

def _cosine_similarity(self, embedding1: np.ndarray, embedding2: np.ndarray) -> float:
"""计算余弦相似度"""
dot_product = np.dot(embedding1, embedding2)
norm1 = np.linalg.norm(embedding1)
norm2 = np.linalg.norm(embedding2)

if norm1 == 0 or norm2 == 0:
return 0.0

return dot_product / (norm1 * norm2)

def retrieve_by_type(self, memory_type: str, limit: int = 10) -> List[Memory]:
"""按类型检索记忆"""
memory_ids = self.index.get(memory_type, [])
memories = [self.memories[mid] for mid in memory_ids[:limit]]
```

```
````python

from typing import Dict, List, Any, Optional
import numpy as np
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

class Memory:
"""记忆"""

def __init__(self, id: str, content: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None):
self.id = id
self.content = content
self.embedding = embedding
self.metadata = metadata or {}
self.created_at = datetime.utcnow()
self.accessed_at = datetime.utcnow()
self.access_count = 0

def to_dict(self) -> Dict[str, Any]:
"""转换为字典"""
return {
'id': self.id,
'content': self.content,
'embedding': self.embedding.tolist(),
'metadata': self.metadata,
'created_at': self.created_at.isoformat(),
'accessed_at': self.accessed_at.isoformat(),
'access_count': self.access_count
}

class VectorMemoryStore:
"""向量记忆存储"""

def __init__(self, embedding_dim: int = 768):
self.embedding_dim = embedding_dim
self.memories: Dict[str, Memory] = {}
self.index: Dict[str, List[str]] = {}

def add_memory(self, content: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None) -> Memory:
"""添加记忆"""
memory_id = f"mem_{len(self.memories)}"
memory = Memory(memory_id, content, embedding, metadata)

self.memories[memory_id] = memory

 # 建立索引
self._index_memory(memory)

logger.info(f"Memory added: {memory_id}")
return memory

def _index_memory(self, memory: Memory):
"""索引记忆"""
 # 按类型索引
memory_type = memory.metadata.get('type', 'default')
if memory_type not in self.index:
self.index[memory_type] = []
self.index[memory_type].append(memory.id)

 # 按标签索引
tags = memory.metadata.get('tags', [])
for tag in tags:
if tag not in self.index:
self.index[tag] = []
self.index[tag].append(memory.id)

def retrieve_similar(self, query_embedding: np.ndarray, top_k: int = 5, threshold: float = 0.7) -> List[Memory]:
"""检索相似记忆"""
if not self.memories:
return []

 # 计算相似度
similarities = []
for memory_id, memory in self.memories.items():
similarity = self._cosine_similarity(query_embedding, memory.embedding)
if similarity >= threshold:
similarities.append((memory_id, similarity))

 # 按相似度排序
similarities.sort(key=lambda x: x[1], reverse=True)

 # 获取top_k个记忆
top_memories = []
for memory_id, similarity in similarities[:top_k]:
memory = self.memories[memory_id]
memory.accessed_at = datetime.utcnow()
memory.access_count += 1
top_memories.append(memory)

return top_memories

def _cosine_similarity(self, embedding1: np.ndarray, embedding2: np.ndarray) -> float:
"""计算余弦相似度"""
dot_product = np.dot(embedding1, embedding2)
norm1 = np.linalg.norm(embedding1)
norm2 = np.linalg.norm(embedding2)

if norm1 == 0 or norm2 == 0:
return 0.0

return dot_product / (norm1 * norm2)

def retrieve_by_type(self, memory_type: str, limit: int = 10) -> List[Memory]:
"""按类型检索记忆"""
memory_ids = self.index.get(memory_type, [])
memories = [self.memories[mid] for mid in memory_ids[:limit]]
```

return memories

def retrieve_by_tag(self, tag: str, limit: int = 10) -> List[Memory]:
"""按标签检索记忆"""
memory_ids = self.index.get(tag, [])
memories = [self.memories[mid] for mid in memory_ids[:limit]]

return memories

def update_memory(self, memory_id: str, content: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None):
"""更新记忆"""
memory = self.memories.get(memory_id)
if not memory:
raise ValueError(f"Memory not found: {memory_id}")

if content:
memory.content = content

if metadata:
memory.metadata.update(metadata)

logger.info(f"Memory updated: {memory_id}")

def delete_memory(self, memory_id: str):
"""删除记忆"""
if memory_id in self.memories:

### 删除索引

memory = self.memories[memory_id]
memory_type = memory.metadata.get('type', 'default')
if memory_type in self.index and memory_id in self.index[memory_type]:
self.index[memory_type].remove(memory_id)

tags = memory.metadata.get('tags', [])
for tag in tags:
if tag in self.index and memory_id in self.index[tag]:
self.index[tag].remove(memory_id)

### 删除记忆

del self.memories[memory_id]

logger.info(f"Memory deleted: {memory_id}")

def get_memory(self, memory_id: str) -> Optional[Memory]:
"""获取记忆"""
memory = self.memories.get(memory_id)
if memory:
memory.accessed_at = datetime.utcnow()
memory.access_count += 1

return memory

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
total_memories = len(self.memories)
total_accesses = sum(m.access_count for m in self.memories.values())

type_counts = {}
for memory in self.memories.values():
memory_type = memory.metadata.get('type', 'default')
type_counts[memory_type] = type_counts.get(memory_type, 0) + 1

return {
'total_memories': total_memories,
'total_accesses': total_accesses,
'type_counts': type_counts,
'index_size': len(self.index)
}

### 使用示例

store = VectorMemoryStore()

### 添加记忆

memories = [
("The quick brown fox jumps over the lazy dog", np.random.rand(768), {'type': 'fact', 'tags': ['animal', 'action']}),
("Python is a high-level programming language", np.random.rand(768), {'type': 'knowledge', 'tags': ['programming', 'language']}),
("The capital of France is Paris", np.random.rand(768), {'type': 'fact', 'tags': ['geography', 'city']}),
("Machine learning is a subset of AI", np.random.rand(768), {'type': 'knowledge', 'tags': ['AI', 'technology']}),
]

for content, embedding, metadata in memories:
store.add_memory(content, embedding, metadata)

### 检索相似记忆

query_embedding = np.random.rand(768)
similar_memories = store.retrieve_similar(query_embedding, top_k=3)

print("Similar memories:")
for memory in similar_memories:
print(f"  - {memory.content}")

### 按类型检索

fact_memories = store.retrieve_by_type('fact')

print("\nFact memories:")
for memory in fact_memories:
print(f"  - {memory.content}")

### 获取统计信息

stats = store.get_statistics()
print(f"\nStatistics: {stats}")

```
bash复制> - 使用向量表示记忆内容
> - 基于相似度检索
> - 支持多种索引方式
> - 记录访问统计
```

```
> - 使用向量表示记忆内容
> - 基于相似度检索
> - 支持多种索引方式
> - 记录访问统计
```

##### 2. 层次化存储#

### 示例：层次化存储

用户请求：
"实现一个层次化的记忆存储系统"
Claude Code 生成的代码：

```
python复制`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import json
import logging

logger = logging.getLogger(__name__)

class MemoryLevel(Enum):
"""记忆层级"""
WORKING = "working"
SHORT_TERM = "short_term"
LONG_TERM = "long_term"

class HierarchicalMemoryStore:
"""层次化记忆存储"""

def __init__(self):
self.working_memory: Dict[str, Memory] = {}
self.short_term_memory: Dict[str, Memory] = {}
self.long_term_memory: Dict[str, Memory] = {}

 # 配置
self.working_memory_limit = 10
self.short_term_memory_limit = 100
self.short_term_memory_ttl = timedelta(hours=24)

def add_memory(self, content: str, embedding: np.ndarray, level: MemoryLevel = MemoryLevel.SHORT_TERM, metadata: Optional[Dict[str, Any]] = None) -> Memory:
"""添加记忆"""
memory_id = f"mem_{datetime.utcnow().timestamp()}"
memory = Memory(memory_id, content, embedding, metadata)

 # 根据层级存储
if level == MemoryLevel.WORKING:
self._add_to_working_memory(memory)
elif level == MemoryLevel.SHORT_TERM:
self._add_to_short_term_memory(memory)
elif level == MemoryLevel.LONG_TERM:
self._add_to_long_term_memory(memory)

logger.info(f"Memory added to {level.value}: {memory_id}")
return memory

def _add_to_working_memory(self, memory: Memory):
"""添加到工作记忆"""
 # 检查容量
if len(self.working_memory) >= self.working_memory_limit:
 # 移除最旧的
oldest_id = min(self.working_memory.keys(), key=lambda k: self.working_memory[k].created_at)
self._evict_from_working_memory(oldest_id)

self.working_memory[memory.id] = memory

def _add_to_short_term_memory(self, memory: Memory):
"""添加到短期记忆"""
 # 检查容量
if len(self.short_term_memory) >= self.short_term_memory_limit:
 # 移除最旧的
oldest_id = min(self.short_term_memory.keys(), key=lambda k: self.short_term_memory[k].created_at)
self._evict_from_short_term_memory(oldest_id)

self.short_term_memory[memory.id] = memory

def _add_to_long_term_memory(self, memory: Memory):
"""添加到长期记忆"""
self.long_term_memory[memory.id] = memory

def _evict_from_working_memory(self, memory_id: str):
"""从工作记忆中驱逐"""
memory = self.working_memory.pop(memory_id)
 # 移动到短期记忆
self._add_to_short_term_memory(memory)
logger.info(f"Memory evicted from working memory: {memory_id}")

def _evict_from_short_term_memory(self, memory_id: str):
"""从短期记忆中驱逐"""
memory = self.short_term_memory.pop(memory_id)
 # 移动到长期记忆
self._add_to_long_term_memory(memory)
logger.info(f"Memory evicted from short-term memory: {memory_id}")

def retrieve(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Memory]:
"""检索记忆"""
 # 从所有层级检索
all_memories = {
 **self.working_memory,
 **self.short_term_memory,
 **self.long_term_memory
}

 # 计算相似度
similarities = []
for memory_id, memory in all_memories.items():
similarity = self._cosine_similarity(query_embedding, memory.embedding)
similarities.append((memory, similarity))

 # 按相似度排序
similarities.sort(key=lambda x: x[1], reverse=True)

 # 获取top_k个记忆
top_memories = [memory for memory, similarity in similarities[:top_k]]

return top_memories

def _cosine_similarity(self, embedding1: np.ndarray, embedding2: np.ndarray) -> float:
"""计算余弦相似度"""
dot_product = np.dot(embedding1, embedding2)
norm1 = np.linalg.norm(embedding1)
norm2 = np.linalg.norm(embedding2)

if norm1 == 0 or norm2 == 0:
return 0.0

return dot_product / (norm1 * norm2)

def promote_memory(self, memory_id: str, target_level: MemoryLevel):
"""提升记忆层级"""
memory = None
source_level = None

 # 查找记忆
if memory_id in self.working_memory:
memory = self.working_memory.pop(memory_id)
source_level = MemoryLevel.WORKING
elif memory_id in self.short_term_memory:
memory = self.short_term_memory.pop(memory_id)
source_level = MemoryLevel.SHORT_TERM
elif memory_id in self.long_term_memory:
memory = self.long_term_memory.pop(memory_id)
source_level = MemoryLevel.LONG_TERM

if not memory:
raise ValueError(f"Memory not found: {memory_id}")

 # 移动到目标层级
if target_level == MemoryLevel.WORKING:
self._add_to_working_memory(memory)
elif target_level == MemoryLevel.SHORT_TERM:
self._add_to_short_term_memory(memory)
elif target_level == MemoryLevel.LONG_TERM:
self._add_to_long_term_memory(memory)

logger.info(f"Memory promoted from {source_level.value} to {target_level.value}: {memory_id}")

def cleanup_expired(self):
"""清理过期记忆"""
current_time = datetime.utcnow()
expired_ids = []

 # 检查短期记忆
for memory_id, memory in self.short_term_memory.items():
if current_time - memory.created_at > self.short_term_memory_ttl:
expired_ids.append(memory_id)

 # 移除过期记忆
for memory_id in expired_ids:
memory = self.short_term_memory.pop(memory_id)
 # 移动到长期记忆
self._add_to_long_term_memory(memory)
logger.info(f"Expired memory moved to long-term: {memory_id}")

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
return {
'working_memory_size': len(self.working_memory),
'short_term_memory_size': len(self.short_term_memory),
'long_term_memory_size': len(self.long_term_memory),
'total_memories': len(self.working_memory) + len(self.short_term_memory) + len(self.long_term_memory)
}

# 使用示例
store = HierarchicalMemoryStore()

# 添加记忆到不同层级
store.add_memory("Current task context", np.random.rand(768), MemoryLevel.WORKING, {'type': 'context'})
store.add_memory("Recent conversation", np.random.rand(768), MemoryLevel.SHORT_TERM, {'type': 'conversation'})
store.add_memory("Important knowledge", np.random.rand(768), MemoryLevel.LONG_TERM, {'type': 'knowledge'})

# 获取统计信息
stats = store.get_statistics()
print(f"Statistics: {stats}")

# 检索记忆
query_embedding = np.random.rand(768)
memories = store.retrieve(query_embedding, top_k=3)

print("\nRetrieved memories:")
for memory in memories:
print(f"  - {memory.content}")

# 提升记忆层级
if store.short_term_memory:
memory_id = list(store.short_term_memory.keys())[0]
store.promote_memory(memory_id, MemoryLevel.LONG_TERM)

```> **层次化存储特点**:
> - 分层存储不同重要性的记忆
> - 自动驱逐和提升记忆
> - 限制各层容量
> - 定期清理过期记忆

```
## 记忆检索优化

### 1. 上下文感知检索

# 示例：上下文感知检索
用户请求：
"实现上下文感知的记忆检索"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ContextAwareMemoryStore(VectorMemoryStore):
"""上下文感知记忆存储"""

def __init__(self, embedding_dim: int = 768):
super().__init__(embedding_dim)
self.context_history: List[Dict[str, Any]] = []
self.context_window_size = 10

def add_context(self, context: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None):
"""添加上下文"""
context_entry = {
'content': context,
'embedding': embedding,
'metadata': metadata or {},
'timestamp': datetime.utcnow()
}

self.context_history.append(context_entry)

 # 限制上下文历史大小
if len(self.context_history) > self.context_window_size:
self.context_history.pop(0)

logger.info(f"Context added: {context[:50]}...")

def retrieve_with_context(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Dict[str, Any]]:
"""带上下文的检索"""
 # 获取当前上下文
current_context = self._get_current_context()

 # 结合上下文和查询
context_enhanced_embedding = self._combine_context_and_query(current_context, query_embedding)

 # 检索记忆
memories = self.retrieve_similar(context_enhanced_embedding, top_k)

 # 添加上下文信息
results = []
for memory in memories:
results.append({
'memory': memory,
'context_relevance': self._calculate_context_relevance(memory, current_context),
'query_relevance': self._cosine_similarity(query_embedding, memory.embedding)
})

 # 按综合相关性排序
results.sort(key=lambda x: 0.7 * x['query_relevance'] + 0.3 * x['context_relevance'], reverse=True)

return results

def _get_current_context(self) -> List[Dict[str, Any]]:
"""获取当前上下文"""
return self.context_history[-self.context_window_size:]

def _combine_context_and_query(self, context: List[Dict[str, Any]], query_embedding: np.ndarray) -> np.ndarray:
"""结合上下文和查询"""
if not context:
return query_embedding

 # 计算上下文的平均嵌入
context_embeddings = [c['embedding'] for c in context]
avg_context_embedding = np.mean(context_embeddings, axis=0)

 # 加权组合
combined = 0.7 * query_embedding + 0.3 * avg_context_embedding

return combined

def _calculate_context_relevance(self, memory: Memory, context: List[Dict[str, Any]]) -> float:
"""计算上下文相关性"""
if not context:
return 0.0

 # 计算记忆与上下文的平均相似度
similarities = []
for ctx in context:
similarity = self._cosine_similarity(memory.embedding, ctx['embedding'])
similarities.append(similarity)

return np.mean(similarities)

def retrieve_temporal(self, time_range: timedelta, top_k: int = 10) -> List[Memory]:
"""按时间范围检索"""
current_time = datetime.utcnow()
cutoff_time = current_time - time_range

 # 筛选时间范围内的记忆
recent_memories = [
memory for memory in self.memories.values()
if memory.created_at >= cutoff_time
]

 # 按创建时间排序
recent_memories.sort(key=lambda m: m.created_at, reverse=True)

return recent_memories[:top_k]

# 使用示例
store = ContextAwareMemoryStore()

# 添加上下文
contexts = [
("User is asking about Python programming", np.random.rand(768)),
("User wants to learn about data structures", np.random.rand(768)),
("User is interested in algorithms", np.random.rand(768)),
]

for content, embedding in contexts:
store.add_context(content, embedding)

# 添加记忆
memories = [
("Python lists are mutable sequences", np.random.rand(768), {'type': 'knowledge', 'topic': 'python'}),
("Dictionaries are key-value pairs", np.random.rand(768), {'type': 'knowledge', 'topic': 'python'}),
("Binary search has O(log n) complexity", np.random.rand(768), {'type': 'knowledge', 'topic': 'algorithms'}),
]

for content, embedding, metadata in memories:
store.add_memory(content, embedding, metadata)

# 带上下文的检索
query_embedding = np.random.rand(768)
results = store.retrieve_with_context(query_embedding, top_k=3)

print("Retrieved with context:")
for result in results:
print(f"  - {result['memory'].content}")
print(f"    Query relevance: {result['query_relevance']:.3f}")
print(f"    Context relevance: {result['context_relevance']:.3f}")

```> **上下文感知检索特点**:
> - 维护上下文历史
> - 结合上下文和查询
> - 计算上下文相关性
> - 按时间范围检索
```
## 总结

记忆系统设计包括：

1. **记忆系统的基本概念**: 什么是记忆系统、记忆类型
2. **记忆存储机制**: 向量存储、层次化存储
3. **记忆检索优化**: 上下文感知检索

通过记忆系统，Claude Code能够存储和检索重要信息，实现长期学习和持续改进。

在下一节中，我们将探讨多智能体协作。

```
```

```
`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import json
import logging

logger = logging.getLogger(__name__)

class MemoryLevel(Enum):
"""记忆层级"""
WORKING = "working"
SHORT_TERM = "short_term"
LONG_TERM = "long_term"

class HierarchicalMemoryStore:
"""层次化记忆存储"""

def __init__(self):
self.working_memory: Dict[str, Memory] = {}
self.short_term_memory: Dict[str, Memory] = {}
self.long_term_memory: Dict[str, Memory] = {}

 # 配置
self.working_memory_limit = 10
self.short_term_memory_limit = 100
self.short_term_memory_ttl = timedelta(hours=24)

def add_memory(self, content: str, embedding: np.ndarray, level: MemoryLevel = MemoryLevel.SHORT_TERM, metadata: Optional[Dict[str, Any]] = None) -> Memory:
"""添加记忆"""
memory_id = f"mem_{datetime.utcnow().timestamp()}"
memory = Memory(memory_id, content, embedding, metadata)

 # 根据层级存储
if level == MemoryLevel.WORKING:
self._add_to_working_memory(memory)
elif level == MemoryLevel.SHORT_TERM:
self._add_to_short_term_memory(memory)
elif level == MemoryLevel.LONG_TERM:
self._add_to_long_term_memory(memory)

logger.info(f"Memory added to {level.value}: {memory_id}")
return memory

def _add_to_working_memory(self, memory: Memory):
"""添加到工作记忆"""
 # 检查容量
if len(self.working_memory) >= self.working_memory_limit:
 # 移除最旧的
oldest_id = min(self.working_memory.keys(), key=lambda k: self.working_memory[k].created_at)
self._evict_from_working_memory(oldest_id)

self.working_memory[memory.id] = memory

def _add_to_short_term_memory(self, memory: Memory):
"""添加到短期记忆"""
 # 检查容量
if len(self.short_term_memory) >= self.short_term_memory_limit:
 # 移除最旧的
oldest_id = min(self.short_term_memory.keys(), key=lambda k: self.short_term_memory[k].created_at)
self._evict_from_short_term_memory(oldest_id)

self.short_term_memory[memory.id] = memory

def _add_to_long_term_memory(self, memory: Memory):
"""添加到长期记忆"""
self.long_term_memory[memory.id] = memory

def _evict_from_working_memory(self, memory_id: str):
"""从工作记忆中驱逐"""
memory = self.working_memory.pop(memory_id)
 # 移动到短期记忆
self._add_to_short_term_memory(memory)
logger.info(f"Memory evicted from working memory: {memory_id}")

def _evict_from_short_term_memory(self, memory_id: str):
"""从短期记忆中驱逐"""
memory = self.short_term_memory.pop(memory_id)
 # 移动到长期记忆
self._add_to_long_term_memory(memory)
logger.info(f"Memory evicted from short-term memory: {memory_id}")

def retrieve(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Memory]:
"""检索记忆"""
 # 从所有层级检索
all_memories = {
 **self.working_memory,
 **self.short_term_memory,
 **self.long_term_memory
}

 # 计算相似度
similarities = []
for memory_id, memory in all_memories.items():
similarity = self._cosine_similarity(query_embedding, memory.embedding)
similarities.append((memory, similarity))

 # 按相似度排序
similarities.sort(key=lambda x: x[1], reverse=True)

 # 获取top_k个记忆
top_memories = [memory for memory, similarity in similarities[:top_k]]

return top_memories

def _cosine_similarity(self, embedding1: np.ndarray, embedding2: np.ndarray) -> float:
"""计算余弦相似度"""
dot_product = np.dot(embedding1, embedding2)
norm1 = np.linalg.norm(embedding1)
norm2 = np.linalg.norm(embedding2)

if norm1 == 0 or norm2 == 0:
return 0.0

return dot_product / (norm1 * norm2)

def promote_memory(self, memory_id: str, target_level: MemoryLevel):
"""提升记忆层级"""
memory = None
source_level = None

 # 查找记忆
if memory_id in self.working_memory:
memory = self.working_memory.pop(memory_id)
source_level = MemoryLevel.WORKING
elif memory_id in self.short_term_memory:
memory = self.short_term_memory.pop(memory_id)
source_level = MemoryLevel.SHORT_TERM
elif memory_id in self.long_term_memory:
memory = self.long_term_memory.pop(memory_id)
source_level = MemoryLevel.LONG_TERM

if not memory:
raise ValueError(f"Memory not found: {memory_id}")

 # 移动到目标层级
if target_level == MemoryLevel.WORKING:
self._add_to_working_memory(memory)
elif target_level == MemoryLevel.SHORT_TERM:
self._add_to_short_term_memory(memory)
elif target_level == MemoryLevel.LONG_TERM:
self._add_to_long_term_memory(memory)

logger.info(f"Memory promoted from {source_level.value} to {target_level.value}: {memory_id}")

def cleanup_expired(self):
"""清理过期记忆"""
current_time = datetime.utcnow()
expired_ids = []

 # 检查短期记忆
for memory_id, memory in self.short_term_memory.items():
if current_time - memory.created_at > self.short_term_memory_ttl:
expired_ids.append(memory_id)

 # 移除过期记忆
for memory_id in expired_ids:
memory = self.short_term_memory.pop(memory_id)
 # 移动到长期记忆
self._add_to_long_term_memory(memory)
logger.info(f"Expired memory moved to long-term: {memory_id}")

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
return {
'working_memory_size': len(self.working_memory),
'short_term_memory_size': len(self.short_term_memory),
'long_term_memory_size': len(self.long_term_memory),
'total_memories': len(self.working_memory) + len(self.short_term_memory) + len(self.long_term_memory)
}

# 使用示例
store = HierarchicalMemoryStore()

# 添加记忆到不同层级
store.add_memory("Current task context", np.random.rand(768), MemoryLevel.WORKING, {'type': 'context'})
store.add_memory("Recent conversation", np.random.rand(768), MemoryLevel.SHORT_TERM, {'type': 'conversation'})
store.add_memory("Important knowledge", np.random.rand(768), MemoryLevel.LONG_TERM, {'type': 'knowledge'})

# 获取统计信息
stats = store.get_statistics()
print(f"Statistics: {stats}")

# 检索记忆
query_embedding = np.random.rand(768)
memories = store.retrieve(query_embedding, top_k=3)

print("\nRetrieved memories:")
for memory in memories:
print(f"  - {memory.content}")

# 提升记忆层级
if store.short_term_memory:
memory_id = list(store.short_term_memory.keys())[0]
store.promote_memory(memory_id, MemoryLevel.LONG_TERM)

```> **层次化存储特点**:
> - 分层存储不同重要性的记忆
> - 自动驱逐和提升记忆
> - 限制各层容量
> - 定期清理过期记忆

```
## 记忆检索优化

### 1. 上下文感知检索

# 示例：上下文感知检索
用户请求：
"实现上下文感知的记忆检索"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ContextAwareMemoryStore(VectorMemoryStore):
"""上下文感知记忆存储"""

def __init__(self, embedding_dim: int = 768):
super().__init__(embedding_dim)
self.context_history: List[Dict[str, Any]] = []
self.context_window_size = 10

def add_context(self, context: str, embedding: np.ndarray, metadata: Optional[Dict[str, Any]] = None):
"""添加上下文"""
context_entry = {
'content': context,
'embedding': embedding,
'metadata': metadata or {},
'timestamp': datetime.utcnow()
}

self.context_history.append(context_entry)

 # 限制上下文历史大小
if len(self.context_history) > self.context_window_size:
self.context_history.pop(0)

logger.info(f"Context added: {context[:50]}...")

def retrieve_with_context(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Dict[str, Any]]:
"""带上下文的检索"""
 # 获取当前上下文
current_context = self._get_current_context()

 # 结合上下文和查询
context_enhanced_embedding = self._combine_context_and_query(current_context, query_embedding)

 # 检索记忆
memories = self.retrieve_similar(context_enhanced_embedding, top_k)

 # 添加上下文信息
results = []
for memory in memories:
results.append({
'memory': memory,
'context_relevance': self._calculate_context_relevance(memory, current_context),
'query_relevance': self._cosine_similarity(query_embedding, memory.embedding)
})

 # 按综合相关性排序
results.sort(key=lambda x: 0.7 * x['query_relevance'] + 0.3 * x['context_relevance'], reverse=True)

return results

def _get_current_context(self) -> List[Dict[str, Any]]:
"""获取当前上下文"""
return self.context_history[-self.context_window_size:]

def _combine_context_and_query(self, context: List[Dict[str, Any]], query_embedding: np.ndarray) -> np.ndarray:
"""结合上下文和查询"""
if not context:
return query_embedding

 # 计算上下文的平均嵌入
context_embeddings = [c['embedding'] for c in context]
avg_context_embedding = np.mean(context_embeddings, axis=0)

 # 加权组合
combined = 0.7 * query_embedding + 0.3 * avg_context_embedding

return combined

def _calculate_context_relevance(self, memory: Memory, context: List[Dict[str, Any]]) -> float:
"""计算上下文相关性"""
if not context:
return 0.0

 # 计算记忆与上下文的平均相似度
similarities = []
for ctx in context:
similarity = self._cosine_similarity(memory.embedding, ctx['embedding'])
similarities.append(similarity)

return np.mean(similarities)

def retrieve_temporal(self, time_range: timedelta, top_k: int = 10) -> List[Memory]:
"""按时间范围检索"""
current_time = datetime.utcnow()
cutoff_time = current_time - time_range

 # 筛选时间范围内的记忆
recent_memories = [
memory for memory in self.memories.values()
if memory.created_at >= cutoff_time
]

 # 按创建时间排序
recent_memories.sort(key=lambda m: m.created_at, reverse=True)

return recent_memories[:top_k]

# 使用示例
store = ContextAwareMemoryStore()

# 添加上下文
contexts = [
("User is asking about Python programming", np.random.rand(768)),
("User wants to learn about data structures", np.random.rand(768)),
("User is interested in algorithms", np.random.rand(768)),
]

for content, embedding in contexts:
store.add_context(content, embedding)

# 添加记忆
memories = [
("Python lists are mutable sequences", np.random.rand(768), {'type': 'knowledge', 'topic': 'python'}),
("Dictionaries are key-value pairs", np.random.rand(768), {'type': 'knowledge', 'topic': 'python'}),
("Binary search has O(log n) complexity", np.random.rand(768), {'type': 'knowledge', 'topic': 'algorithms'}),
]

for content, embedding, metadata in memories:
store.add_memory(content, embedding, metadata)

# 带上下文的检索
query_embedding = np.random.rand(768)
results = store.retrieve_with_context(query_embedding, top_k=3)

print("Retrieved with context:")
for result in results:
print(f"  - {result['memory'].content}")
print(f"    Query relevance: {result['query_relevance']:.3f}")
print(f"    Context relevance: {result['context_relevance']:.3f}")

```> **上下文感知检索特点**:
> - 维护上下文历史
> - 结合上下文和查询
> - 计算上下文相关性
> - 按时间范围检索
```
## 总结

记忆系统设计包括：

1. **记忆系统的基本概念**: 什么是记忆系统、记忆类型
2. **记忆存储机制**: 向量存储、层次化存储
3. **记忆检索优化**: 上下文感知检索

通过记忆系统，Claude Code能够存储和检索重要信息，实现长期学习和持续改进。

在下一节中，我们将探讨多智能体协作。

```
```

---

## 5 多智能体协作

**URL**: https://claudecode.tangshuang.net/course/27.5%20%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E4%BD%9C

#### 多智能体协作概述#

多智能体协作是指多个AI智能体协同工作，共同完成复杂任务的能力。通过协作，智能体可以共享信息、分工合作、互相补充，从而提高整体效率和效果。

#### 多智能体协作的基本概念#

##### 1. 什么是多智能体协作#

多智能体协作是指多个AI智能体通过通信、协调和合作，共同完成单个智能体难以完成的复杂任务。

多智能体协作的特点:

- 分布式决策: 每个智能体独立决策
- 信息共享: 智能体之间共享信息
- 任务分工: 智能体分工合作
- 协同优化: 整体优化而非局部优化

##### 2. 协作模式#

#### 智能体通信机制#

##### 1. 消息传递#

### 示例：消息传递机制

用户请求：
"实现智能体之间的消息传递机制"

Claude Code 生成的代码：

```
python复制````python

from typing import Dict, List, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import logging
import asyncio
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)

class MessageType(Enum):
"""消息类型"""
REQUEST = "request"
RESPONSE = "response"
NOTIFICATION = "notification"
BROADCAST = "broadcast"

@dataclass
class Message:
"""消息"""
id: str
type: MessageType
sender: str
receiver: str
content: Dict[str, Any]
timestamp: datetime = field(default_factory=datetime.utcnow)
reply_to: Optional[str] = None
metadata: Dict[str, Any] = field(default_factory=dict)

class MessageBus:
"""消息总线"""

def __init__(self):
self.agents: Dict[str, 'Agent'] = {}
self.message_queue: asyncio.Queue = asyncio.Queue()
self.message_handlers: Dict[str, Callable] = {}
self.running = False

def register_agent(self, agent: 'Agent'):
"""注册智能体"""
self.agents[agent.id] = agent
logger.info(f"Agent registered: {agent.id}")

def unregister_agent(self, agent_id: str):
"""注销智能体"""
if agent_id in self.agents:
del self.agents[agent_id]
logger.info(f"Agent unregistered: {agent_id}")

async def send_message(self, message: Message):
"""发送消息"""
receiver = self.agents.get(message.receiver)

if not receiver:
logger.warning(f"Receiver not found: {message.receiver}")
return

 # 添加到消息队列
await self.message_queue.put(message)
logger.info(f"Message sent from {message.sender} to {message.receiver}")

async def broadcast_message(self, message: Message):
"""广播消息"""
for agent_id, agent in self.agents.items():
if agent_id != message.sender:
broadcast_msg = Message(
id=f"{message.id}_to_{agent_id}",
type=message.type,
sender=message.sender,
receiver=agent_id,
content=message.content,
timestamp=message.timestamp,
metadata=message.metadata
)
await self.send_message(broadcast_msg)

logger.info(f"Message broadcasted from {message.sender}")

def register_handler(self, message_type: str, handler: Callable):
"""注册消息处理器"""
self.message_handlers[message_type] = handler
logger.info(f"Handler registered for message type: {message_type}")

async def start(self):
"""启动消息总线"""
self.running = True
logger.info("Message bus started")

 # 启动消息处理循环
asyncio.create_task(self._process_messages())

async def stop(self):
"""停止消息总线"""
self.running = False
logger.info("Message bus stopped")

async def _process_messages(self):
"""处理消息"""
while self.running:
try:
 # 获取消息
message = await asyncio.wait_for(
self.message_queue.get(),
timeout=1.0
)

 # 传递给接收者
receiver = self.agents.get(message.receiver)
if receiver:
await receiver.receive_message(message)

except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"Error processing message: {e}")

class Agent:
"""智能体基类"""

def __init__(self, agent_id: str, message_bus: MessageBus):
self.id = agent_id
self.message_bus = message_bus
self.message_handlers: Dict[str, Callable] = {}
self.knowledge_base: Dict[str, Any] = {}

async def receive_message(self, message: Message):
"""接收消息"""
logger.info(f"Agent {self.id} received message from {message.sender}")

 # 查找处理器
handler = self.message_handlers.get(message.type.value)

if handler:
 # 调用处理器
response = await handler(message)

 # 如果是请求消息，发送响应
if message.type == MessageType.REQUEST:
response_message = Message(
id=f"response_{message.id}",
type=MessageType.RESPONSE,
sender=self.id,
receiver=message.sender,
content=response,
reply_to=message.id
)
await self.message_bus.send_message(response_message)
else:
logger.warning(f"No handler for message type: {message.type.value}")
```

```
````python

from typing import Dict, List, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import logging
import asyncio
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)

class MessageType(Enum):
"""消息类型"""
REQUEST = "request"
RESPONSE = "response"
NOTIFICATION = "notification"
BROADCAST = "broadcast"

@dataclass
class Message:
"""消息"""
id: str
type: MessageType
sender: str
receiver: str
content: Dict[str, Any]
timestamp: datetime = field(default_factory=datetime.utcnow)
reply_to: Optional[str] = None
metadata: Dict[str, Any] = field(default_factory=dict)

class MessageBus:
"""消息总线"""

def __init__(self):
self.agents: Dict[str, 'Agent'] = {}
self.message_queue: asyncio.Queue = asyncio.Queue()
self.message_handlers: Dict[str, Callable] = {}
self.running = False

def register_agent(self, agent: 'Agent'):
"""注册智能体"""
self.agents[agent.id] = agent
logger.info(f"Agent registered: {agent.id}")

def unregister_agent(self, agent_id: str):
"""注销智能体"""
if agent_id in self.agents:
del self.agents[agent_id]
logger.info(f"Agent unregistered: {agent_id}")

async def send_message(self, message: Message):
"""发送消息"""
receiver = self.agents.get(message.receiver)

if not receiver:
logger.warning(f"Receiver not found: {message.receiver}")
return

 # 添加到消息队列
await self.message_queue.put(message)
logger.info(f"Message sent from {message.sender} to {message.receiver}")

async def broadcast_message(self, message: Message):
"""广播消息"""
for agent_id, agent in self.agents.items():
if agent_id != message.sender:
broadcast_msg = Message(
id=f"{message.id}_to_{agent_id}",
type=message.type,
sender=message.sender,
receiver=agent_id,
content=message.content,
timestamp=message.timestamp,
metadata=message.metadata
)
await self.send_message(broadcast_msg)

logger.info(f"Message broadcasted from {message.sender}")

def register_handler(self, message_type: str, handler: Callable):
"""注册消息处理器"""
self.message_handlers[message_type] = handler
logger.info(f"Handler registered for message type: {message_type}")

async def start(self):
"""启动消息总线"""
self.running = True
logger.info("Message bus started")

 # 启动消息处理循环
asyncio.create_task(self._process_messages())

async def stop(self):
"""停止消息总线"""
self.running = False
logger.info("Message bus stopped")

async def _process_messages(self):
"""处理消息"""
while self.running:
try:
 # 获取消息
message = await asyncio.wait_for(
self.message_queue.get(),
timeout=1.0
)

 # 传递给接收者
receiver = self.agents.get(message.receiver)
if receiver:
await receiver.receive_message(message)

except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"Error processing message: {e}")

class Agent:
"""智能体基类"""

def __init__(self, agent_id: str, message_bus: MessageBus):
self.id = agent_id
self.message_bus = message_bus
self.message_handlers: Dict[str, Callable] = {}
self.knowledge_base: Dict[str, Any] = {}

async def receive_message(self, message: Message):
"""接收消息"""
logger.info(f"Agent {self.id} received message from {message.sender}")

 # 查找处理器
handler = self.message_handlers.get(message.type.value)

if handler:
 # 调用处理器
response = await handler(message)

 # 如果是请求消息，发送响应
if message.type == MessageType.REQUEST:
response_message = Message(
id=f"response_{message.id}",
type=MessageType.RESPONSE,
sender=self.id,
receiver=message.sender,
content=response,
reply_to=message.id
)
await self.message_bus.send_message(response_message)
else:
logger.warning(f"No handler for message type: {message.type.value}")
```

def register_handler(self, message_type: str, handler: Callable):
"""注册消息处理器"""
self.message_handlers[message_type] = handler
logger.info(f"Agent {self.id} registered handler for {message_type}")

async def send_request(self, receiver_id: str, content: Dict[str, Any]) -> Message:
"""发送请求"""
message = Message(
id=f"req_{datetime.utcnow().timestamp()}",
type=MessageType.REQUEST,
sender=self.id,
receiver=receiver_id,
content=content
)

await self.message_bus.send_message(message)
return message

async def send_response(self, original_message: Message, content: Dict[str, Any]):
"""发送响应"""
message = Message(
id=f"resp_{datetime.utcnow().timestamp()}",
type=MessageType.RESPONSE,
sender=self.id,
receiver=original_message.sender,
content=content,
reply_to=original_message.id
)

await self.message_bus.send_message(message)

async def send_notification(self, receiver_id: str, content: Dict[str, Any]):
"""发送通知"""
message = Message(
id=f"notif_{datetime.utcnow().timestamp()}",
type=MessageType.NOTIFICATION,
sender=self.id,
receiver=receiver_id,
content=content
)

await self.message_bus.send_message(message)

async def broadcast(self, content: Dict[str, Any]):
"""广播消息"""
message = Message(
id=f"broadcast_{datetime.utcnow().timestamp()}",
type=MessageType.BROADCAST,
sender=self.id,
receiver="all",
content=content
)

await self.message_bus.broadcast_message(message)

def update_knowledge(self, key: str, value: Any):
"""更新知识库"""
self.knowledge_base[key] = value
logger.info(f"Agent {self.id} updated knowledge: {key}")

def get_knowledge(self, key: str) -> Optional[Any]:
"""获取知识"""
return self.knowledge_base.get(key)

### 使用示例

async def main():
"""主函数"""

### 创建消息总线

message_bus = MessageBus()
await message_bus.start()

### 创建智能体

agent1 = Agent("agent1", message_bus)
agent2 = Agent("agent2", message_bus)
agent3 = Agent("agent3", message_bus)

### 注册智能体

message_bus.register_agent(agent1)
message_bus.register_agent(agent2)
message_bus.register_agent(agent3)

### 注册消息处理器

async def handle_request(message: Message) -> Dict[str, Any]:
"""处理请求"""
print(f"Agent {agent1.id} handling request from {message.sender}")
return {'status': 'success', 'data': 'processed'}

agent1.register_handler('request', handle_request)

async def handle_notification(message: Message) -> Dict[str, Any]:
"""处理通知"""
print(f"Agent {agent2.id} received notification from {message.sender}")
return {'status': 'acknowledged'}

agent2.register_handler('notification', handle_notification)

### 发送消息

await agent1.send_request('agent2', {'task': 'process_data'})
await agent2.send_notification('agent3', {'event': 'update'})
await agent3.broadcast({'announcement': 'system_ready'})

### 等待消息处理

await asyncio.sleep(1)

### 停止消息总线

await message_bus.stop()

if name == 'main':
asyncio.run(main())

```
bash复制> - 异步消息传递
> - 支持点对点和广播
> - 消息类型分类
> - 请求-响应模式
```

```
> - 异步消息传递
> - 支持点对点和广播
> - 消息类型分类
> - 请求-响应模式
```

##### 2. 共享知识库#

### 示例：共享知识库

用户请求：
"实现智能体之间的共享知识库"
Claude Code 生成的代码：

```
python复制`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import json

logger = logging.getLogger(__name__)

class SharedKnowledgeBase:
"""共享知识库"""

def __init__(self):
self.knowledge: Dict[str, Any] = {}
self.access_log: List[Dict[str, Any]] = []
self.version: int = 0

def add_knowledge(self, key: str, value: Any, agent_id: str) -> bool:
"""添加知识"""
if key in self.knowledge:
logger.warning(f"Knowledge key already exists: {key}")
return False

self.knowledge[key] = {
'value': value,
'agent_id': agent_id,
'created_at': datetime.utcnow(),
'version': self.version
}

self.version += 1
self._log_access(agent_id, 'add', key)

logger.info(f"Knowledge added: {key} by {agent_id}")
return True

def update_knowledge(self, key: str, value: Any, agent_id: str) -> bool:
"""更新知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return False

old_value = self.knowledge[key]['value']
self.knowledge[key]['value'] = value
self.knowledge[key]['updated_at'] = datetime.utcnow()
self.knowledge[key]['updated_by'] = agent_id
self.knowledge[key]['version'] = self.version
self.knowledge[key]['old_value'] = old_value

self.version += 1
self._log_access(agent_id, 'update', key)

logger.info(f"Knowledge updated: {key} by {agent_id}")
return True

def get_knowledge(self, key: str, agent_id: str) -> Optional[Any]:
"""获取知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return None

self._log_access(agent_id, 'read', key)

return self.knowledge[key]['value']

def delete_knowledge(self, key: str, agent_id: str) -> bool:
"""删除知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return False

del self.knowledge[key]
self._log_access(agent_id, 'delete', key)

logger.info(f"Knowledge deleted: {key} by {agent_id}")
return True

def search_knowledge(self, query: str, agent_id: str) -> List[Dict[str, Any]]:
"""搜索知识"""
results = []
query_lower = query.lower()

for key, knowledge in self.knowledge.items():
if query_lower in key.lower():
results.append({
'key': key,
'value': knowledge['value'],
'agent_id': knowledge['agent_id'],
'version': knowledge['version']
})

self._log_access(agent_id, 'search', query)

logger.info(f"Knowledge search: {query} by {agent_id}, found {len(results)} results")
return results

def get_all_knowledge(self, agent_id: str) -> Dict[str, Any]:
"""获取所有知识"""
self._log_access(agent_id, 'read_all', 'all')

return {key: knowledge['value'] for key, knowledge in self.knowledge.items()}

def get_knowledge_by_agent(self, agent_id: str) -> Dict[str, Any]:
"""获取智能体的知识"""
agent_knowledge = {}

for key, knowledge in self.knowledge.items():
if knowledge['agent_id'] == agent_id:
agent_knowledge[key] = knowledge['value']

return agent_knowledge

def merge_knowledge(self, other_knowledge: Dict[str, Any], agent_id: str) -> int:
"""合并知识"""
merged_count = 0

for key, value in other_knowledge.items():
if key not in self.knowledge:
self.add_knowledge(key, value, agent_id)
merged_count += 1

logger.info(f"Knowledge merged: {merged_count} items by {agent_id}")
return merged_count

def _log_access(self, agent_id: str, action: str, key: str):
"""记录访问日志"""
self.access_log.append({
'agent_id': agent_id,
'action': action,
'key': key,
'timestamp': datetime.utcnow()
})

def get_access_log(self, agent_id: Optional[str] = None) -> List[Dict[str, Any]]:
"""获取访问日志"""
if agent_id:
return [log for log in self.access_log if log['agent_id'] == agent_id]
return self.access_log

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
agent_counts = {}

for knowledge in self.knowledge.values():
agent_id = knowledge['agent_id']
agent_counts[agent_id] = agent_counts.get(agent_id, 0) + 1

return {
'total_knowledge': len(self.knowledge),
'version': self.version,
'agent_counts': agent_counts,
'total_accesses': len(self.access_log)
}

class KnowledgeSharingAgent(Agent):
"""知识共享智能体"""

def __init__(self, agent_id: str, message_bus: MessageBus, knowledge_base: SharedKnowledgeBase):
super().__init__(agent_id, message_bus)
self.knowledge_base = knowledge_base

async def share_knowledge(self, key: str, value: Any):
"""分享知识"""
success = self.knowledge_base.add_knowledge(key, value, self.id)

if success:
 # 广播知识更新
await self.broadcast({
'type': 'knowledge_update',
'key': key,
'agent_id': self.id
})

async def request_knowledge(self, key: str, target_agent_id: str) -> Optional[Any]:
"""请求知识"""
 # 发送知识请求
await self.send_request(target_agent_id, {
'type': 'knowledge_request',
'key': key
})

 # 等待响应
await asyncio.sleep(0.5)

 # 从知识库获取
return self.knowledge_base.get_knowledge(key, self.id)

async def sync_knowledge(self):
"""同步知识"""
 # 获取其他智能体的知识
other_agents = [aid for aid in self.message_bus.agents.keys() if aid != self.id]

for agent_id in other_agents:
await self.send_request(agent_id, {
'type': 'knowledge_sync_request'
})

# 使用示例
async def main():
"""主函数"""
 # 创建消息总线
message_bus = MessageBus()
await message_bus.start()

 # 创建共享知识库
knowledge_base = SharedKnowledgeBase()

 # 创建智能体
agent1 = KnowledgeSharingAgent("agent1", message_bus, knowledge_base)
agent2 = KnowledgeSharingAgent("agent2", message_bus, knowledge_base)
agent3 = KnowledgeSharingAgent("agent3", message_bus, knowledge_base)

 # 注册智能体
message_bus.register_agent(agent1)
message_bus.register_agent(agent2)
message_bus.register_agent(agent3)

 # 分享知识
await agent1.share_knowledge("python_syntax", "Python uses indentation for code blocks")
await agent2.share_knowledge("javascript_syntax", "JavaScript uses curly braces for code blocks")
await agent3.share_knowledge("java_syntax", "Java uses curly braces and semicolons")

 # 请求知识
python_syntax = await agent2.request_knowledge("python_syntax", "agent1")
print(f"Python syntax: {python_syntax}")

 # 获取统计信息
stats = knowledge_base.get_statistics()
print(f"Knowledge base statistics: {stats}")

 # 停止消息总线
await message_bus.stop()

if __name__ == '__main__':
asyncio.run(main())

```> **共享知识库特点**:
> - 集中式知识存储
> - 访问控制和日志
> - 知识搜索和检索
> - 智能体间知识同步

```
## 协作任务执行

### 1. 任务分配

# 示例：任务分配
用户请求：
"实现智能体之间的任务分配机制"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

class Task:
"""任务"""

def __init__(self, task_id: str, name: str, description: str, requirements: List[str], estimated_duration: float):
self.id = task_id
self.name = name
self.description = description
self.requirements = requirements
self.estimated_duration = estimated_duration
self.assigned_to: Optional[str] = None
self.status = "pending"
self.created_at = datetime.utcnow()
self.started_at: Optional[datetime] = None
self.completed_at: Optional[datetime] = None
self.result: Optional[Any] = None

class TaskAllocator:
"""任务分配器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.agents: Dict[str, Dict[str, Any]] = {}
self.agent_workload: Dict[str, float] = {}

def register_agent(self, agent_id: str, capabilities: List[str], max_workload: float = 1.0):
"""注册智能体"""
self.agents[agent_id] = {
'capabilities': capabilities,
'max_workload': max_workload,
'current_workload': 0.0
}
self.agent_workload[agent_id] = 0.0

logger.info(f"Agent registered: {agent_id} with capabilities {capabilities}")

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
logger.info(f"Task added: {task.id}")

def allocate_task(self, task_id: str) -> Optional[str]:
"""分配任务"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return None

 # 查找合适的智能体
suitable_agents = self._find_suitable_agents(task)

if not suitable_agents:
logger.warning(f"No suitable agents for task: {task_id}")
return None

 # 选择负载最低的智能体
selected_agent = self._select_least_loaded_agent(suitable_agents)

 # 分配任务
task.assigned_to = selected_agent
task.status = "assigned"
self.agents[selected_agent]['current_workload'] += task.estimated_duration
self.agent_workload[selected_agent] = self.agents[selected_agent]['current_workload']

logger.info(f"Task {task_id} assigned to {selected_agent}")
return selected_agent

def _find_suitable_agents(self, task: Task) -> List[str]:
"""查找合适的智能体"""
suitable_agents = []

for agent_id, agent_info in self.agents.items():
 # 检查能力匹配
capabilities_match = all(
req in agent_info['capabilities']
for req in task.requirements
)

 # 检查负载
has_capacity = (
agent_info['current_workload'] + task.estimated_duration
<= agent_info['max_workload']
)

if capabilities_match and has_capacity:
suitable_agents.append(agent_id)

return suitable_agents

def _select_least_loaded_agent(self, agents: List[str]) -> str:
"""选择负载最低的智能体"""
return min(agents, key=lambda aid: self.agent_workload[aid])

def complete_task(self, task_id: str, result: Any):
"""完成任务"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return

 # 更新任务状态
task.status = "completed"
task.completed_at = datetime.utcnow()
task.result = result

 # 更新智能体负载
if task.assigned_to:
self.agents[task.assigned_to]['current_workload'] -= task.estimated_duration
self.agent_workload[task.assigned_to] = self.agents[task.assigned_to]['current_workload']

logger.info(f"Task {task_id} completed by {task.assigned_to}")

def get_agent_tasks(self, agent_id: str) -> List[Task]:
"""获取智能体的任务"""
return [
task for task in self.tasks.values()
if task.assigned_to == agent_id and task.status != "completed"
]

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
total_tasks = len(self.tasks)
completed_tasks = len([t for t in self.tasks.values() if t.status == "completed"])
pending_tasks = len([t for t in self.tasks.values() if t.status == "pending"])
assigned_tasks = len([t for t in self.tasks.values() if t.status == "assigned"])

return {
'total_tasks': total_tasks,
'completed_tasks': completed_tasks,
'pending_tasks': pending_tasks,
'assigned_tasks': assigned_tasks,
'agent_workload': self.agent_workload.copy()
}

# 使用示例
async def main():
"""主函数"""
allocator = TaskAllocator()

 # 注册智能体
allocator.register_agent("agent1", ["code_generation", "code_review"], max_workload=2.0)
allocator.register_agent("agent2", ["code_review", "testing"], max_workload=1.5)
allocator.register_agent("agent3", ["code_generation", "testing"], max_workload=2.0)

 # 添加任务
tasks = [
Task("task1", "Generate User Module", "Generate user authentication module", ["code_generation"], 1.0),
Task("task2", "Review User Module", "Review user authentication module", ["code_review"], 0.5),
Task("task3", "Generate Product Module", "Generate product management module", ["code_generation"], 1.0),
Task("task4", "Test User Module", "Test user authentication module", ["testing"], 0.5),
Task("task5", "Review Product Module", "Review product management module", ["code_review"], 0.5),
Task("task6", "Test Product Module", "Test product management module", ["testing"], 0.5),
]

for task in tasks:
allocator.add_task(task)

 # 分配任务
for task in tasks:
allocator.allocate_task(task.id)

 # 获取统计信息
stats = allocator.get_statistics()
print(f"Allocation statistics: {stats}")

 # 获取智能体任务
for agent_id in ["agent1", "agent2", "agent3"]:
agent_tasks = allocator.get_agent_tasks(agent_id)
print(f"\nAgent {agent_id} tasks:")
for task in agent_tasks:
print(f"  - {task.name} ({task.estimated_duration}h)")

if __name__ == '__main__':
asyncio.run(main())

```> **任务分配特点**:
> - 基于能力匹配
> - 考虑负载均衡
> - 动态调整分配
> - 任务状态跟踪
```
## 总结

多智能体协作包括：

1. **多智能体协作的基本概念**: 什么是多智能体协作、协作模式
2. **智能体通信机制**: 消息传递、共享知识库
3. **协作任务执行**: 任务分配

通过多智能体协作，Claude Code可以实现更复杂的任务，提高整体效率和效果。

至此，第27章"Agentic AI 核心技术"全部完成。接下来我们将创建第28章"Claude Code 架构解析"。

```
```

```
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import json

logger = logging.getLogger(__name__)

class SharedKnowledgeBase:
"""共享知识库"""

def __init__(self):
self.knowledge: Dict[str, Any] = {}
self.access_log: List[Dict[str, Any]] = []
self.version: int = 0

def add_knowledge(self, key: str, value: Any, agent_id: str) -> bool:
"""添加知识"""
if key in self.knowledge:
logger.warning(f"Knowledge key already exists: {key}")
return False

self.knowledge[key] = {
'value': value,
'agent_id': agent_id,
'created_at': datetime.utcnow(),
'version': self.version
}

self.version += 1
self._log_access(agent_id, 'add', key)

logger.info(f"Knowledge added: {key} by {agent_id}")
return True

def update_knowledge(self, key: str, value: Any, agent_id: str) -> bool:
"""更新知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return False

old_value = self.knowledge[key]['value']
self.knowledge[key]['value'] = value
self.knowledge[key]['updated_at'] = datetime.utcnow()
self.knowledge[key]['updated_by'] = agent_id
self.knowledge[key]['version'] = self.version
self.knowledge[key]['old_value'] = old_value

self.version += 1
self._log_access(agent_id, 'update', key)

logger.info(f"Knowledge updated: {key} by {agent_id}")
return True

def get_knowledge(self, key: str, agent_id: str) -> Optional[Any]:
"""获取知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return None

self._log_access(agent_id, 'read', key)

return self.knowledge[key]['value']

def delete_knowledge(self, key: str, agent_id: str) -> bool:
"""删除知识"""
if key not in self.knowledge:
logger.warning(f"Knowledge key not found: {key}")
return False

del self.knowledge[key]
self._log_access(agent_id, 'delete', key)

logger.info(f"Knowledge deleted: {key} by {agent_id}")
return True

def search_knowledge(self, query: str, agent_id: str) -> List[Dict[str, Any]]:
"""搜索知识"""
results = []
query_lower = query.lower()

for key, knowledge in self.knowledge.items():
if query_lower in key.lower():
results.append({
'key': key,
'value': knowledge['value'],
'agent_id': knowledge['agent_id'],
'version': knowledge['version']
})

self._log_access(agent_id, 'search', query)

logger.info(f"Knowledge search: {query} by {agent_id}, found {len(results)} results")
return results

def get_all_knowledge(self, agent_id: str) -> Dict[str, Any]:
"""获取所有知识"""
self._log_access(agent_id, 'read_all', 'all')

return {key: knowledge['value'] for key, knowledge in self.knowledge.items()}

def get_knowledge_by_agent(self, agent_id: str) -> Dict[str, Any]:
"""获取智能体的知识"""
agent_knowledge = {}

for key, knowledge in self.knowledge.items():
if knowledge['agent_id'] == agent_id:
agent_knowledge[key] = knowledge['value']

return agent_knowledge

def merge_knowledge(self, other_knowledge: Dict[str, Any], agent_id: str) -> int:
"""合并知识"""
merged_count = 0

for key, value in other_knowledge.items():
if key not in self.knowledge:
self.add_knowledge(key, value, agent_id)
merged_count += 1

logger.info(f"Knowledge merged: {merged_count} items by {agent_id}")
return merged_count

def _log_access(self, agent_id: str, action: str, key: str):
"""记录访问日志"""
self.access_log.append({
'agent_id': agent_id,
'action': action,
'key': key,
'timestamp': datetime.utcnow()
})

def get_access_log(self, agent_id: Optional[str] = None) -> List[Dict[str, Any]]:
"""获取访问日志"""
if agent_id:
return [log for log in self.access_log if log['agent_id'] == agent_id]
return self.access_log

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
agent_counts = {}

for knowledge in self.knowledge.values():
agent_id = knowledge['agent_id']
agent_counts[agent_id] = agent_counts.get(agent_id, 0) + 1

return {
'total_knowledge': len(self.knowledge),
'version': self.version,
'agent_counts': agent_counts,
'total_accesses': len(self.access_log)
}

class KnowledgeSharingAgent(Agent):
"""知识共享智能体"""

def __init__(self, agent_id: str, message_bus: MessageBus, knowledge_base: SharedKnowledgeBase):
super().__init__(agent_id, message_bus)
self.knowledge_base = knowledge_base

async def share_knowledge(self, key: str, value: Any):
"""分享知识"""
success = self.knowledge_base.add_knowledge(key, value, self.id)

if success:
 # 广播知识更新
await self.broadcast({
'type': 'knowledge_update',
'key': key,
'agent_id': self.id
})

async def request_knowledge(self, key: str, target_agent_id: str) -> Optional[Any]:
"""请求知识"""
 # 发送知识请求
await self.send_request(target_agent_id, {
'type': 'knowledge_request',
'key': key
})

 # 等待响应
await asyncio.sleep(0.5)

 # 从知识库获取
return self.knowledge_base.get_knowledge(key, self.id)

async def sync_knowledge(self):
"""同步知识"""
 # 获取其他智能体的知识
other_agents = [aid for aid in self.message_bus.agents.keys() if aid != self.id]

for agent_id in other_agents:
await self.send_request(agent_id, {
'type': 'knowledge_sync_request'
})

# 使用示例
async def main():
"""主函数"""
 # 创建消息总线
message_bus = MessageBus()
await message_bus.start()

 # 创建共享知识库
knowledge_base = SharedKnowledgeBase()

 # 创建智能体
agent1 = KnowledgeSharingAgent("agent1", message_bus, knowledge_base)
agent2 = KnowledgeSharingAgent("agent2", message_bus, knowledge_base)
agent3 = KnowledgeSharingAgent("agent3", message_bus, knowledge_base)

 # 注册智能体
message_bus.register_agent(agent1)
message_bus.register_agent(agent2)
message_bus.register_agent(agent3)

 # 分享知识
await agent1.share_knowledge("python_syntax", "Python uses indentation for code blocks")
await agent2.share_knowledge("javascript_syntax", "JavaScript uses curly braces for code blocks")
await agent3.share_knowledge("java_syntax", "Java uses curly braces and semicolons")

 # 请求知识
python_syntax = await agent2.request_knowledge("python_syntax", "agent1")
print(f"Python syntax: {python_syntax}")

 # 获取统计信息
stats = knowledge_base.get_statistics()
print(f"Knowledge base statistics: {stats}")

 # 停止消息总线
await message_bus.stop()

if __name__ == '__main__':
asyncio.run(main())

```> **共享知识库特点**:
> - 集中式知识存储
> - 访问控制和日志
> - 知识搜索和检索
> - 智能体间知识同步

```
## 协作任务执行

### 1. 任务分配

# 示例：任务分配
用户请求：
"实现智能体之间的任务分配机制"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

class Task:
"""任务"""

def __init__(self, task_id: str, name: str, description: str, requirements: List[str], estimated_duration: float):
self.id = task_id
self.name = name
self.description = description
self.requirements = requirements
self.estimated_duration = estimated_duration
self.assigned_to: Optional[str] = None
self.status = "pending"
self.created_at = datetime.utcnow()
self.started_at: Optional[datetime] = None
self.completed_at: Optional[datetime] = None
self.result: Optional[Any] = None

class TaskAllocator:
"""任务分配器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.agents: Dict[str, Dict[str, Any]] = {}
self.agent_workload: Dict[str, float] = {}

def register_agent(self, agent_id: str, capabilities: List[str], max_workload: float = 1.0):
"""注册智能体"""
self.agents[agent_id] = {
'capabilities': capabilities,
'max_workload': max_workload,
'current_workload': 0.0
}
self.agent_workload[agent_id] = 0.0

logger.info(f"Agent registered: {agent_id} with capabilities {capabilities}")

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
logger.info(f"Task added: {task.id}")

def allocate_task(self, task_id: str) -> Optional[str]:
"""分配任务"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return None

 # 查找合适的智能体
suitable_agents = self._find_suitable_agents(task)

if not suitable_agents:
logger.warning(f"No suitable agents for task: {task_id}")
return None

 # 选择负载最低的智能体
selected_agent = self._select_least_loaded_agent(suitable_agents)

 # 分配任务
task.assigned_to = selected_agent
task.status = "assigned"
self.agents[selected_agent]['current_workload'] += task.estimated_duration
self.agent_workload[selected_agent] = self.agents[selected_agent]['current_workload']

logger.info(f"Task {task_id} assigned to {selected_agent}")
return selected_agent

def _find_suitable_agents(self, task: Task) -> List[str]:
"""查找合适的智能体"""
suitable_agents = []

for agent_id, agent_info in self.agents.items():
 # 检查能力匹配
capabilities_match = all(
req in agent_info['capabilities']
for req in task.requirements
)

 # 检查负载
has_capacity = (
agent_info['current_workload'] + task.estimated_duration
<= agent_info['max_workload']
)

if capabilities_match and has_capacity:
suitable_agents.append(agent_id)

return suitable_agents

def _select_least_loaded_agent(self, agents: List[str]) -> str:
"""选择负载最低的智能体"""
return min(agents, key=lambda aid: self.agent_workload[aid])

def complete_task(self, task_id: str, result: Any):
"""完成任务"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return

 # 更新任务状态
task.status = "completed"
task.completed_at = datetime.utcnow()
task.result = result

 # 更新智能体负载
if task.assigned_to:
self.agents[task.assigned_to]['current_workload'] -= task.estimated_duration
self.agent_workload[task.assigned_to] = self.agents[task.assigned_to]['current_workload']

logger.info(f"Task {task_id} completed by {task.assigned_to}")

def get_agent_tasks(self, agent_id: str) -> List[Task]:
"""获取智能体的任务"""
return [
task for task in self.tasks.values()
if task.assigned_to == agent_id and task.status != "completed"
]

def get_statistics(self) -> Dict[str, Any]:
"""获取统计信息"""
total_tasks = len(self.tasks)
completed_tasks = len([t for t in self.tasks.values() if t.status == "completed"])
pending_tasks = len([t for t in self.tasks.values() if t.status == "pending"])
assigned_tasks = len([t for t in self.tasks.values() if t.status == "assigned"])

return {
'total_tasks': total_tasks,
'completed_tasks': completed_tasks,
'pending_tasks': pending_tasks,
'assigned_tasks': assigned_tasks,
'agent_workload': self.agent_workload.copy()
}

# 使用示例
async def main():
"""主函数"""
allocator = TaskAllocator()

 # 注册智能体
allocator.register_agent("agent1", ["code_generation", "code_review"], max_workload=2.0)
allocator.register_agent("agent2", ["code_review", "testing"], max_workload=1.5)
allocator.register_agent("agent3", ["code_generation", "testing"], max_workload=2.0)

 # 添加任务
tasks = [
Task("task1", "Generate User Module", "Generate user authentication module", ["code_generation"], 1.0),
Task("task2", "Review User Module", "Review user authentication module", ["code_review"], 0.5),
Task("task3", "Generate Product Module", "Generate product management module", ["code_generation"], 1.0),
Task("task4", "Test User Module", "Test user authentication module", ["testing"], 0.5),
Task("task5", "Review Product Module", "Review product management module", ["code_review"], 0.5),
Task("task6", "Test Product Module", "Test product management module", ["testing"], 0.5),
]

for task in tasks:
allocator.add_task(task)

 # 分配任务
for task in tasks:
allocator.allocate_task(task.id)

 # 获取统计信息
stats = allocator.get_statistics()
print(f"Allocation statistics: {stats}")

 # 获取智能体任务
for agent_id in ["agent1", "agent2", "agent3"]:
agent_tasks = allocator.get_agent_tasks(agent_id)
print(f"\nAgent {agent_id} tasks:")
for task in agent_tasks:
print(f"  - {task.name} ({task.estimated_duration}h)")

if __name__ == '__main__':
asyncio.run(main())

```> **任务分配特点**:
> - 基于能力匹配
> - 考虑负载均衡
> - 动态调整分配
> - 任务状态跟踪
```
## 总结

多智能体协作包括：

1. **多智能体协作的基本概念**: 什么是多智能体协作、协作模式
2. **智能体通信机制**: 消息传递、共享知识库
3. **协作任务执行**: 任务分配

通过多智能体协作，Claude Code可以实现更复杂的任务，提高整体效率和效果。

至此，第27章"Agentic AI 核心技术"全部完成。接下来我们将创建第28章"Claude Code 架构解析"。

```
```

---

## 2 Claude Code 架构设计

**URL**: https://claudecode.tangshuang.net/course/27.2%20Claude%20Code%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1

#### 27.2.1 架构概述#

Claude Code 是基于 Claude 大语言模型构建的代码助手，采用分层架构设计，具有良好的可扩展性和可维护性。

##### 27.2.1.1 架构目标#

- 高性能：提供快速的代码生成和响应
- 可扩展：支持插件和工具扩展
- 可维护：模块化设计，易于维护
- 安全：保障代码和数据安全
- 易用：提供友好的用户界面

##### 27.2.1.2 架构原则#

True. 分层架构：将系统分为多个层次
True. 模块化设计：每个模块负责单一功能
True. 松耦合：模块之间依赖关系弱
True. 高内聚：模块内部功能紧密相关
True. 可扩展：支持功能扩展

#### 27.2.2 架构分层#

##### 27.2.2.1 核心层#

```
bash复制Core Layer(
  model=ClaudeModel(),
  tokenizer=ClaudeTokenizer(),
  engine=ClaudeEngine()
)
```

```
Core Layer(
  model=ClaudeModel(),
  tokenizer=ClaudeTokenizer(),
  engine=ClaudeEngine()
)
```

##### 27.2.2.2 服务层#

```
bash复制Service Layer(
  code_service=CodeService(),
  tool_service=ToolService(),
  plugin_service=PluginService()
)
```

```
Service Layer(
  code_service=CodeService(),
  tool_service=ToolService(),
  plugin_service=PluginService()
)
```

##### 27.2.2.3 接口层#

```
bash复制Interface Layer(
  api_interface=APIInterface(),
  cli_interface=CLIInterface(),
  ui_interface=UIInterface()
)
```

```
Interface Layer(
  api_interface=APIInterface(),
  cli_interface=CLIInterface(),
  ui_interface=UIInterface()
)
```

#### 27.2.3 核心组件#

##### 27.2.3.1 Claude 模型#

```
python复制class ClaudeModel:
    def __init__(self, model_path):
        self.model = load_model(model_path)
        self.tokenizer = load_tokenizer(model_path)
    
    def generate(self, prompt, max_length=1000):
        inputs = self.tokenizer(prompt, return_tensors='pt')
        outputs = self.model.generate(**inputs, max_length=max_length)
        return self.tokenizer.decode(outputs[0], skip_special_tokens=True)
```

```
class ClaudeModel:
    def __init__(self, model_path):
        self.model = load_model(model_path)
        self.tokenizer = load_tokenizer(model_path)
    
    def generate(self, prompt, max_length=1000):
        inputs = self.tokenizer(prompt, return_tensors='pt')
        outputs = self.model.generate(**inputs, max_length=max_length)
        return self.tokenizer.decode(outputs[0], skip_special_tokens=True)
```

##### 27.2.3.2 代码引擎#

```
python复制class CodeEngine:
    def __init__(self, model):
        self.model = model
    
    def generate_code(self, prompt, language='python'):
        code_prompt = f'Generate {language} code for: {prompt}'
        return self.model.generate(code_prompt)
    
    def explain_code(self, code):
        explain_prompt = f'Explain this code: {code}'
        return self.model.generate(explain_prompt)
    
    def refactor_code(self, code):
        refactor_prompt = f'Refactor this code: {code}'
        return self.model.generate(refactor_prompt)
```

```
class CodeEngine:
    def __init__(self, model):
        self.model = model
    
    def generate_code(self, prompt, language='python'):
        code_prompt = f'Generate {language} code for: {prompt}'
        return self.model.generate(code_prompt)
    
    def explain_code(self, code):
        explain_prompt = f'Explain this code: {code}'
        return self.model.generate(explain_prompt)
    
    def refactor_code(self, code):
        refactor_prompt = f'Refactor this code: {code}'
        return self.model.generate(refactor_prompt)
```

##### 27.2.3.3 工具管理器#

```
python复制class ToolManager:
    def __init__(self):
        self.tools = {}
    
    def register_tool(self, name, tool):
        self.tools[name] = tool
    
    def call_tool(self, name, args):
        if name not in self.tools:
            raise ValueError(f'Tool {name} not found')
        return self.tools[name](args)
```

```
class ToolManager:
    def __init__(self):
        self.tools = {}
    
    def register_tool(self, name, tool):
        self.tools[name] = tool
    
    def call_tool(self, name, args):
        if name not in self.tools:
            raise ValueError(f'Tool {name} not found')
        return self.tools[name](args)
```

#### 27.2.4 插件系统#

##### 27.2.4.1 插件接口#

```
python复制class PluginInterface:
    def __init__(self):
        self.name = 'Plugin'
        self.version = '1.0.0'
    
    def initialize(self, context):
        pass
    
    def execute(self, command):
        pass
    
    def cleanup(self):
        pass
```

```
class PluginInterface:
    def __init__(self):
        self.name = 'Plugin'
        self.version = '1.0.0'
    
    def initialize(self, context):
        pass
    
    def execute(self, command):
        pass
    
    def cleanup(self):
        pass
```

##### 27.2.4.2 插件加载器#

```
python复制class PluginLoader:
    def __init__(self):
        self.plugins = []
    
    def load_plugins(self, plugin_dir):
        for plugin_file in os.listdir(plugin_dir):
            if plugin_file.endswith('.py'):
                module = importlib.import_module(plugin_file[:-3])
                for name in dir(module):
                    obj = getattr(module, name)
                    if isinstance(obj, type) and issubclass(obj, PluginInterface):
                        self.plugins.append(obj())
    
    def initialize_plugins(self, context):
        for plugin in self.plugins:
            plugin.initialize(context)
```

```
class PluginLoader:
    def __init__(self):
        self.plugins = []
    
    def load_plugins(self, plugin_dir):
        for plugin_file in os.listdir(plugin_dir):
            if plugin_file.endswith('.py'):
                module = importlib.import_module(plugin_file[:-3])
                for name in dir(module):
                    obj = getattr(module, name)
                    if isinstance(obj, type) and issubclass(obj, PluginInterface):
                        self.plugins.append(obj())
    
    def initialize_plugins(self, context):
        for plugin in self.plugins:
            plugin.initialize(context)
```

#### 27.2.5 数据处理#

##### 27.2.5.1 代码解析#

```
python复制class CodeParser:
    def __init__(self):
        self.parser = ast
    
    def parse(self, code):
        return self.parser.parse(code)
    
    def get_functions(self, code):
        tree = self.parse(code)
        functions = []
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                functions.append(node.name)
        return functions
    
    def get_classes(self, code):
        tree = self.parse(code)
        classes = []
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                classes.append(node.name)
        return classes
```

```
class CodeParser:
    def __init__(self):
        self.parser = ast
    
    def parse(self, code):
        return self.parser.parse(code)
    
    def get_functions(self, code):
        tree = self.parse(code)
        functions = []
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                functions.append(node.name)
        return functions
    
    def get_classes(self, code):
        tree = self.parse(code)
        classes = []
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                classes.append(node.name)
        return classes
```

##### 27.2.5.2 代码生成#

```
python复制class CodeGenerator:
    def __init__(self):
        self.generator = ast
    
    def generate_function(self, name, parameters, body):
        func_def = ast.FunctionDef(
            name=name,
            args=ast.arguments(
                args=[ast.arg(arg=param) for param in parameters]
            ),
            body=body
        )
        return ast.unparse(func_def)
```

```
class CodeGenerator:
    def __init__(self):
        self.generator = ast
    
    def generate_function(self, name, parameters, body):
        func_def = ast.FunctionDef(
            name=name,
            args=ast.arguments(
                args=[ast.arg(arg=param) for param in parameters]
            ),
            body=body
        )
        return ast.unparse(func_def)
```

#### 27.2.6 性能优化#

##### 27.2.6.1 缓存机制#

```
python复制class Cache:
    def __init__(self, max_size=1000):
        self.cache = {} 
        self.max_size = max_size
    
    def get(self, key):
        return self.cache.get(key)
    
    def set(self, key, value):
        if len(self.cache) >= self.max_size:
            self.cache.pop(next(iter(self.cache)))
        self.cache[key] = value
```

```
class Cache:
    def __init__(self, max_size=1000):
        self.cache = {} 
        self.max_size = max_size
    
    def get(self, key):
        return self.cache.get(key)
    
    def set(self, key, value):
        if len(self.cache) >= self.max_size:
            self.cache.pop(next(iter(self.cache)))
        self.cache[key] = value
```

##### 27.2.6.2 异步处理#

```
python复制class AsyncHandler:
    def __init__(self):
        self.loop = asyncio.get_event_loop()
    
    async def handle_request(self, request):
        # 异步处理请求
        result = await self.process_request(request)
        return result
    
    async def process_request(self, request):
        # 实际处理逻辑
        return request
```

```
class AsyncHandler:
    def __init__(self):
        self.loop = asyncio.get_event_loop()
    
    async def handle_request(self, request):
        # 异步处理请求
        result = await self.process_request(request)
        return result
    
    async def process_request(self, request):
        # 实际处理逻辑
        return request
```

#### 27.2.7 安全设计#

##### 27.2.7.1 代码安全#

```
python复制class CodeSecurity:
    def __init__(self):
        self.sanitizer = CodeSanitizer()
    
    def sanitize_code(self, code):
        # 移除危险代码
        sanitized_code = self.sanitizer.sanitize(code)
        return sanitized_code
    
    def validate_code(self, code):
        # 验证代码安全性
        if self.contains_dangerous_code(code):
            raise ValueError('Dangerous code detected')
        return True
```

```
class CodeSecurity:
    def __init__(self):
        self.sanitizer = CodeSanitizer()
    
    def sanitize_code(self, code):
        # 移除危险代码
        sanitized_code = self.sanitizer.sanitize(code)
        return sanitized_code
    
    def validate_code(self, code):
        # 验证代码安全性
        if self.contains_dangerous_code(code):
            raise ValueError('Dangerous code detected')
        return True
```

##### 27.2.7.2 数据安全#

```
python复制class DataSecurity:
    def __init__(self):
        self.encryptor = Encryptor()
    
    def encrypt_data(self, data):
        # 加密敏感数据
        encrypted_data = self.encryptor.encrypt(data)
        return encrypted_data
    
    def decrypt_data(self, encrypted_data):
        # 解密数据
        data = self.encryptor.decrypt(encrypted_data)
        return data
```

```
class DataSecurity:
    def __init__(self):
        self.encryptor = Encryptor()
    
    def encrypt_data(self, data):
        # 加密敏感数据
        encrypted_data = self.encryptor.encrypt(data)
        return encrypted_data
    
    def decrypt_data(self, encrypted_data):
        # 解密数据
        data = self.encryptor.decrypt(encrypted_data)
        return data
```

#### 27.2.8 部署架构#

##### 27.2.8.1 云部署#

```
bash复制Cloud Deployment(
  frontend=ReactApp(),
  backend=FastAPI(),
  database=PostgreSQL(),
  model=ClaudeModel()
)
```

```
Cloud Deployment(
  frontend=ReactApp(),
  backend=FastAPI(),
  database=PostgreSQL(),
  model=ClaudeModel()
)
```

##### 27.2.8.2 本地部署#

```
bash复制Local Deployment(
  app=DesktopApp(),
  model=ClaudeModel(),
  storage=LocalStorage()
)
```

```
Local Deployment(
  app=DesktopApp(),
  model=ClaudeModel(),
  storage=LocalStorage()
)
```

#### 27.2.9 架构演进#

##### 27.2.9.1 版本历史#

```
bash复制- v1.0: 基础版本，支持代码生成
- v2.0: 增加插件系统
- v3.0: 支持多语言
- v4.0: 优化性能
- v5.0: 增强安全
```

```
- v1.0: 基础版本，支持代码生成
- v2.0: 增加插件系统
- v3.0: 支持多语言
- v4.0: 优化性能
- v5.0: 增强安全
```

##### 27.2.9.2 未来规划#

```
bash复制- v6.0: 支持多模态
- v7.0: 增强可解释性
- v8.0: 优化资源利用
- v9.0: 支持分布式部署
- v10.0: 实现自主学习
```

```
- v6.0: 支持多模态
- v7.0: 增强可解释性
- v8.0: 优化资源利用
- v9.0: 支持分布式部署
- v10.0: 实现自主学习
```

#### 27.2.10 架构最佳实践#

##### 27.2.10.1 模块化设计#

```
python复制# 模块化设计示例
class ModuleA:
    def __init__(self):
        pass
    
    def do_something(self):
        pass

class ModuleB:
    def __init__(self, module_a):
        self.module_a = module_a
    
    def do_something_else(self):
        self.module_a.do_something()
```

```
# 模块化设计示例
class ModuleA:
    def __init__(self):
        pass
    
    def do_something(self):
        pass

class ModuleB:
    def __init__(self, module_a):
        self.module_a = module_a
    
    def do_something_else(self):
        self.module_a.do_something()
```

##### 27.2.10.2 松耦合#

```
python复制# 松耦合示例
class ServiceA:
    def __init__(self):
        pass
    
    def get_data(self):
        return data

class ServiceB:
    def __init__(self, service_a):
        self.service_a = service_a
    
    def process_data(self):
        data = self.service_a.get_data()
        return processed_data
```

```
# 松耦合示例
class ServiceA:
    def __init__(self):
        pass
    
    def get_data(self):
        return data

class ServiceB:
    def __init__(self, service_a):
        self.service_a = service_a
    
    def process_data(self):
        data = self.service_a.get_data()
        return processed_data
```

##### 27.2.10.3 高内聚#

```
python复制# 高内聚示例
class UserService:
    def __init__(self):
        pass
    
    def create_user(self, user_data):
        pass
    
    def get_user(self, user_id):
        pass
    
    def update_user(self, user_id, user_data):
        pass
    
    def delete_user(self, user_id):
        pass
```

```
# 高内聚示例
class UserService:
    def __init__(self):
        pass
    
    def create_user(self, user_data):
        pass
    
    def get_user(self, user_id):
        pass
    
    def update_user(self, user_id, user_data):
        pass
    
    def delete_user(self, user_id):
        pass
```

#### 27.2.11 架构案例分析#

##### 27.2.11.1 代码生成架构#

```
bash复制Code Generation Architecture(
  model=ClaudeModel(),
  parser=CodeParser(),
  generator=CodeGenerator(),
  validator=CodeValidator()
)
```

```
Code Generation Architecture(
  model=ClaudeModel(),
  parser=CodeParser(),
  generator=CodeGenerator(),
  validator=CodeValidator()
)
```

##### 27.2.11.2 插件系统架构#

```
bash复制Plugin System Architecture(
  loader=PluginLoader(),
  manager=PluginManager(),
  interface=PluginInterface(),
  registry=PluginRegistry()
)
```

```
Plugin System Architecture(
  loader=PluginLoader(),
  manager=PluginManager(),
  interface=PluginInterface(),
  registry=PluginRegistry()
)
```

#### 27.2.12 总结#

Claude Code 采用分层架构设计，具有良好的可扩展性和可维护性。核心层提供基础模型和引擎，服务层提供代码服务和工具服务，接口层提供多种用户接口。

架构设计遵循模块化、松耦合、高内聚等原则，支持插件扩展和工具集成。同时，架构注重性能优化和安全设计，保障系统的高效运行和数据安全。

未来，Claude Code 将继续优化架构，支持更多功能和场景，为开发者提供更强大的代码助手服务。

---

## 3 Claude Code 核心算法

**URL**: https://claudecode.tangshuang.net/course/27.3%20Claude%20Code%20%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95

#### 27.3.1 算法概述#

Claude Code 采用多种核心算法实现代码生成、理解和重构功能。这些算法基于大语言模型和代码分析技术，具有高效、准确的特点。

##### 27.3.1.1 算法目标#

- 高效：快速生成高质量代码
- 准确：理解和生成正确的代码
- 智能：能够理解上下文和语义
- 可扩展：支持多种编程语言和场景

##### 27.3.1.2 算法分类#

True. 代码生成算法
True. 代码理解算法
True. 代码重构算法
True. 代码优化算法
True. 代码调试算法

#### 27.3.2 代码生成算法#

##### 27.3.2.1 基于 Transformer 的代码生成#

```
python复制class CodeGenerator:
    def __init__(self, model):
        self.model = model
    
    def generate_code(self, prompt, language='python'):
        # 构建代码生成提示
        code_prompt = f'Generate {language} code for: {prompt}'
        
        # 使用 Transformer 模型生成代码
        inputs = self.tokenizer(code_prompt, return_tensors='pt')
        outputs = self.model.generate(**inputs, max_length=1000)
        
        # 解码生成的代码
        code = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        return code
```

```
class CodeGenerator:
    def __init__(self, model):
        self.model = model
    
    def generate_code(self, prompt, language='python'):
        # 构建代码生成提示
        code_prompt = f'Generate {language} code for: {prompt}'
        
        # 使用 Transformer 模型生成代码
        inputs = self.tokenizer(code_prompt, return_tensors='pt')
        outputs = self.model.generate(**inputs, max_length=1000)
        
        # 解码生成的代码
        code = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        return code
```

##### 27.3.2.2 基于模板的代码生成#

```
python复制class TemplateCodeGenerator:
    def __init__(self):
        self.templates = {
            'python': {
                'function': 'def {name}({params}):\n    {body}',
                'class': 'class {name}:\n    {body}'
            }
        }
    
    def generate_code(self, template_name, template_data):
        template = self.templates['python'][template_name]
        code = template.format(**template_data)
        return code
```

```
class TemplateCodeGenerator:
    def __init__(self):
        self.templates = {
            'python': {
                'function': 'def {name}({params}):\n    {body}',
                'class': 'class {name}:\n    {body}'
            }
        }
    
    def generate_code(self, template_name, template_data):
        template = self.templates['python'][template_name]
        code = template.format(**template_data)
        return code
```

##### 27.3.2.3 基于示例的代码生成#

```
python复制class ExampleBasedCodeGenerator:
    def __init__(self):
        self.examples = []
    
    def add_example(self, input, output):
        self.examples.append({'input': input, 'output': output})
    
    def generate_code(self, input):
        # 找到最相似的示例
        best_example = self.find_best_example(input)
        
        # 基于示例生成代码
        code = self.adapt_example(best_example, input)
        
        return code
```

```
class ExampleBasedCodeGenerator:
    def __init__(self):
        self.examples = []
    
    def add_example(self, input, output):
        self.examples.append({'input': input, 'output': output})
    
    def generate_code(self, input):
        # 找到最相似的示例
        best_example = self.find_best_example(input)
        
        # 基于示例生成代码
        code = self.adapt_example(best_example, input)
        
        return code
```

#### 27.3.3 代码理解算法#

##### 27.3.3.1 代码解析算法#

```
python复制class CodeParser:
    def __init__(self):
        self.parser = ast
    
    def parse_code(self, code):
        # 解析代码为抽象语法树
        tree = self.parser.parse(code)
        return tree
    
    def analyze_code(self, code):
        # 分析代码结构
        tree = self.parse_code(code)
        analysis = {
            'functions': [],
            'classes': [],
            'variables': []
        }
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                analysis['functions'].append(node.name)
            elif isinstance(node, ast.ClassDef):
                analysis['classes'].append(node.name)
            elif isinstance(node, ast.Assign):
                analysis['variables'].extend([target.id for target in node.targets if isinstance(target, ast.Name)])
        
        return analysis
```

```
class CodeParser:
    def __init__(self):
        self.parser = ast
    
    def parse_code(self, code):
        # 解析代码为抽象语法树
        tree = self.parser.parse(code)
        return tree
    
    def analyze_code(self, code):
        # 分析代码结构
        tree = self.parse_code(code)
        analysis = {
            'functions': [],
            'classes': [],
            'variables': []
        }
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                analysis['functions'].append(node.name)
            elif isinstance(node, ast.ClassDef):
                analysis['classes'].append(node.name)
            elif isinstance(node, ast.Assign):
                analysis['variables'].extend([target.id for target in node.targets if isinstance(target, ast.Name)])
        
        return analysis
```

##### 27.3.3.2 代码语义理解#

```
python复制class CodeSemanticAnalyzer:
    def __init__(self):
        self.model = TransformerModel.from_pretrained('code-semantic-model')
    
    def analyze_semantics(self, code):
        # 分析代码语义
        inputs = self.tokenizer(code, return_tensors='pt')
        outputs = self.model(**inputs)
        
        # 获取语义表示
        semantic_embedding = outputs.last_hidden_state.mean(dim=1)
        
        return semantic_embedding
```

```
class CodeSemanticAnalyzer:
    def __init__(self):
        self.model = TransformerModel.from_pretrained('code-semantic-model')
    
    def analyze_semantics(self, code):
        # 分析代码语义
        inputs = self.tokenizer(code, return_tensors='pt')
        outputs = self.model(**inputs)
        
        # 获取语义表示
        semantic_embedding = outputs.last_hidden_state.mean(dim=1)
        
        return semantic_embedding
```

##### 27.3.3.3 代码依赖分析#

```
python复制class CodeDependencyAnalyzer:
    def __init__(self):
        self.dependency_graph = {}
    
    def analyze_dependencies(self, code):
        # 分析代码依赖关系
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    self.add_dependency(alias.name)
            elif isinstance(node, ast.ImportFrom):
                self.add_dependency(node.module)
        
        return self.dependency_graph
    
    def add_dependency(self, module):
        if module not in self.dependency_graph:
            self.dependency_graph[module] = []
```

```
class CodeDependencyAnalyzer:
    def __init__(self):
        self.dependency_graph = {}
    
    def analyze_dependencies(self, code):
        # 分析代码依赖关系
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    self.add_dependency(alias.name)
            elif isinstance(node, ast.ImportFrom):
                self.add_dependency(node.module)
        
        return self.dependency_graph
    
    def add_dependency(self, module):
        if module not in self.dependency_graph:
            self.dependency_graph[module] = []
```

#### 27.3.4 代码重构算法#

##### 27.3.4.1 代码简化算法#

```
python复制class CodeSimplifier:
    def __init__(self):
        pass
    
    def simplify_code(self, code):
        # 简化代码
        tree = ast.parse(code)
        simplified_tree = self.simplify_ast(tree)
        simplified_code = ast.unparse(simplified_tree)
        return simplified_code
    
    def simplify_ast(self, tree):
        # 简化抽象语法树
        for node in ast.walk(tree):
            if isinstance(node, ast.If):
                # 简化条件判断
                node = self.simplify_if(node)
            elif isinstance(node, ast.For):
                # 简化循环
                node = self.simplify_for(node)
        return tree
```

```
class CodeSimplifier:
    def __init__(self):
        pass
    
    def simplify_code(self, code):
        # 简化代码
        tree = ast.parse(code)
        simplified_tree = self.simplify_ast(tree)
        simplified_code = ast.unparse(simplified_tree)
        return simplified_code
    
    def simplify_ast(self, tree):
        # 简化抽象语法树
        for node in ast.walk(tree):
            if isinstance(node, ast.If):
                # 简化条件判断
                node = self.simplify_if(node)
            elif isinstance(node, ast.For):
                # 简化循环
                node = self.simplify_for(node)
        return tree
```

##### 27.3.4.2 代码提取算法#

```
python复制class CodeExtractor:
    def __init__(self):
        pass
    
    def extract_function(self, code, function_name):
        # 提取函数
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name == function_name:
                return ast.unparse(node)
        
        return None
    
    def extract_class(self, code, class_name):
        # 提取类
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef) and node.name == class_name:
                return ast.unparse(node)
        
        return None
```

```
class CodeExtractor:
    def __init__(self):
        pass
    
    def extract_function(self, code, function_name):
        # 提取函数
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name == function_name:
                return ast.unparse(node)
        
        return None
    
    def extract_class(self, code, class_name):
        # 提取类
        tree = ast.parse(code)
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef) and node.name == class_name:
                return ast.unparse(node)
        
        return None
```

##### 27.3.4.3 代码合并算法#

```
python复制class CodeMerger:
    def __init__(self):
        pass
    
    def merge_functions(self, functions):
        # 合并多个函数
        merged_code = '\n'.join(functions)
        return merged_code
    
    def merge_classes(self, classes):
        # 合并多个类
        merged_code = '\n'.join(classes)
        return merged_code
```

```
class CodeMerger:
    def __init__(self):
        pass
    
    def merge_functions(self, functions):
        # 合并多个函数
        merged_code = '\n'.join(functions)
        return merged_code
    
    def merge_classes(self, classes):
        # 合并多个类
        merged_code = '\n'.join(classes)
        return merged_code
```

#### 27.3.5 代码优化算法#

##### 27.3.5.1 性能优化算法#

```
python复制class PerformanceOptimizer:
    def __init__(self):
        pass
    
    def optimize_performance(self, code):
        # 优化代码性能
        optimized_code = self.optimize_loops(code)
        optimized_code = self.optimize_memory(optimized_code)
        optimized_code = self.optimize_algorithm(optimized_code)
        return optimized_code
    
    def optimize_loops(self, code):
        # 优化循环
        return code
    
    def optimize_memory(self, code):
        # 优化内存使用
        return code
    
    def optimize_algorithm(self, code):
        # 优化算法
        return code
```

```
class PerformanceOptimizer:
    def __init__(self):
        pass
    
    def optimize_performance(self, code):
        # 优化代码性能
        optimized_code = self.optimize_loops(code)
        optimized_code = self.optimize_memory(optimized_code)
        optimized_code = self.optimize_algorithm(optimized_code)
        return optimized_code
    
    def optimize_loops(self, code):
        # 优化循环
        return code
    
    def optimize_memory(self, code):
        # 优化内存使用
        return code
    
    def optimize_algorithm(self, code):
        # 优化算法
        return code
```

##### 27.3.5.2 可读性优化算法#

```
python复制class ReadabilityOptimizer:
    def __init__(self):
        pass
    
    def optimize_readability(self, code):
        # 优化代码可读性
        optimized_code = self.optimize_naming(code)
        optimized_code = self.optimize_formatting(optimized_code)
        optimized_code = self.optimize_comments(optimized_code)
        return optimized_code
    
    def optimize_naming(self, code):
        # 优化命名
        return code
    
    def optimize_formatting(self, code):
        # 优化格式
        return code
    
    def optimize_comments(self, code):
        # 优化注释
        return code
```

```
class ReadabilityOptimizer:
    def __init__(self):
        pass
    
    def optimize_readability(self, code):
        # 优化代码可读性
        optimized_code = self.optimize_naming(code)
        optimized_code = self.optimize_formatting(optimized_code)
        optimized_code = self.optimize_comments(optimized_code)
        return optimized_code
    
    def optimize_naming(self, code):
        # 优化命名
        return code
    
    def optimize_formatting(self, code):
        # 优化格式
        return code
    
    def optimize_comments(self, code):
        # 优化注释
        return code
```

#### 27.3.6 代码调试算法#

##### 27.3.6.1 错误检测算法#

```
python复制class ErrorDetector:
    def __init__(self):
        pass
    
    def detect_errors(self, code):
        # 检测代码错误
        errors = []
        
        try:
            ast.parse(code)
        except SyntaxError as e:
            errors.append({'type': 'SyntaxError', 'message': str(e)})
        
        return errors
```

```
class ErrorDetector:
    def __init__(self):
        pass
    
    def detect_errors(self, code):
        # 检测代码错误
        errors = []
        
        try:
            ast.parse(code)
        except SyntaxError as e:
            errors.append({'type': 'SyntaxError', 'message': str(e)})
        
        return errors
```

##### 27.3.6.2 错误修复算法#

```
python复制class ErrorFixer:
    def __init__(self):
        pass
    
    def fix_errors(self, code, errors):
        # 修复代码错误
        fixed_code = code
        
        for error in errors:
            if error['type'] == 'SyntaxError':
                fixed_code = self.fix_syntax_error(fixed_code, error)
        
        return fixed_code
    
    def fix_syntax_error(self, code, error):
        # 修复语法错误
        return code
```

```
class ErrorFixer:
    def __init__(self):
        pass
    
    def fix_errors(self, code, errors):
        # 修复代码错误
        fixed_code = code
        
        for error in errors:
            if error['type'] == 'SyntaxError':
                fixed_code = self.fix_syntax_error(fixed_code, error)
        
        return fixed_code
    
    def fix_syntax_error(self, code, error):
        # 修复语法错误
        return code
```

#### 27.3.7 算法评估#

##### 27.3.7.1 评估指标#

```
bash复制- 准确率（Accuracy）
- 召回率（Recall）
- F1 分数（F1 Score）
- 速度（Speed）
- 质量（Quality）
```

```
- 准确率（Accuracy）
- 召回率（Recall）
- F1 分数（F1 Score）
- 速度（Speed）
- 质量（Quality）
```

##### 27.3.7.2 评估方法#

```
python复制class AlgorithmEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, algorithm, dataset):
        # 评估算法性能
        results = {
            'accuracy': 0,
            'recall': 0,
            'f1_score': 0,
            'speed': 0
        }
        
        for example in dataset:
            input = example['input']
            expected_output = example['output']
            
            start_time = time.time()
            actual_output = algorithm(input)
            end_time = time.time()
            
            results['speed'] += end_time - start_time
            
            if actual_output == expected_output:
                results['accuracy'] += 1
        
        results['accuracy'] /= len(dataset)
        results['speed'] /= len(dataset)
        
        return results
```

```
class AlgorithmEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, algorithm, dataset):
        # 评估算法性能
        results = {
            'accuracy': 0,
            'recall': 0,
            'f1_score': 0,
            'speed': 0
        }
        
        for example in dataset:
            input = example['input']
            expected_output = example['output']
            
            start_time = time.time()
            actual_output = algorithm(input)
            end_time = time.time()
            
            results['speed'] += end_time - start_time
            
            if actual_output == expected_output:
                results['accuracy'] += 1
        
        results['accuracy'] /= len(dataset)
        results['speed'] /= len(dataset)
        
        return results
```

#### 27.3.8 算法优化#

##### 27.3.8.1 模型压缩#

```
python复制class ModelCompressor:
    def __init__(self):
        pass
    
    def compress_model(self, model):
        # 压缩模型
        compressed_model = self.prune_model(model)
        compressed_model = self.quantize_model(compressed_model)
        return compressed_model
    
    def prune_model(self, model):
        # 剪枝模型
        return model
    
    def quantize_model(self, model):
        # 量化模型
        return model
```

```
class ModelCompressor:
    def __init__(self):
        pass
    
    def compress_model(self, model):
        # 压缩模型
        compressed_model = self.prune_model(model)
        compressed_model = self.quantize_model(compressed_model)
        return compressed_model
    
    def prune_model(self, model):
        # 剪枝模型
        return model
    
    def quantize_model(self, model):
        # 量化模型
        return model
```

##### 27.3.8.2 算法加速#

```
python复制class AlgorithmAccelerator:
    def __init__(self):
        pass
    
    def accelerate_algorithm(self, algorithm):
        # 加速算法
        accelerated_algorithm = self.parallelize(algorithm)
        accelerated_algorithm = self.optimize_memory(accelerated_algorithm)
        return accelerated_algorithm
    
    def parallelize(self, algorithm):
        # 并行化算法
        return algorithm
    
    def optimize_memory(self, algorithm):
        # 优化内存使用
        return algorithm
```

```
class AlgorithmAccelerator:
    def __init__(self):
        pass
    
    def accelerate_algorithm(self, algorithm):
        # 加速算法
        accelerated_algorithm = self.parallelize(algorithm)
        accelerated_algorithm = self.optimize_memory(accelerated_algorithm)
        return accelerated_algorithm
    
    def parallelize(self, algorithm):
        # 并行化算法
        return algorithm
    
    def optimize_memory(self, algorithm):
        # 优化内存使用
        return algorithm
```

#### 27.3.9 算法案例分析#

##### 27.3.9.1 代码生成案例#

```
python复制# 代码生成案例
code_generator = CodeGenerator(model)
prompt = '生成一个计算斐波那契数列的函数'
code = code_generator.generate_code(prompt)
print(code)
```

```
# 代码生成案例
code_generator = CodeGenerator(model)
prompt = '生成一个计算斐波那契数列的函数'
code = code_generator.generate_code(prompt)
print(code)
```

##### 27.3.9.2 代码理解案例#

```
python复制# 代码理解案例
code_analyzer = CodeAnalyzer()
code = 'def add(a, b):\n    return a + b'
analysis = code_analyzer.analyze_code(code)
print(analysis)
```

```
# 代码理解案例
code_analyzer = CodeAnalyzer()
code = 'def add(a, b):\n    return a + b'
analysis = code_analyzer.analyze_code(code)
print(analysis)
```

##### 27.3.9.3 代码重构案例#

```
python复制# 代码重构案例
code_refactorer = CodeRefactorer()
code = 'def add(a, b):\n    return a + b'
refactored_code = code_refactorer.refactor_code(code)
print(refactored_code)
```

```
# 代码重构案例
code_refactorer = CodeRefactorer()
code = 'def add(a, b):\n    return a + b'
refactored_code = code_refactorer.refactor_code(code)
print(refactored_code)
```

#### 27.3.10 算法未来发展#

##### 27.3.10.1 AI 辅助算法设计#

```
python复制# AI 辅助算法设计
import ai_algorithm_designer

algorithm = ai_algorithm_designer.design('code generation')
```

```
# AI 辅助算法设计
import ai_algorithm_designer

algorithm = ai_algorithm_designer.design('code generation')
```

##### 27.3.10.2 自动化算法优化#

```
python复制# 自动化算法优化
algorithm_optimizer = AlgorithmOptimizer()
optimized_algorithm = algorithm_optimizer.optimize(algorithm)
```

```
# 自动化算法优化
algorithm_optimizer = AlgorithmOptimizer()
optimized_algorithm = algorithm_optimizer.optimize(algorithm)
```

##### 27.3.10.3 自适应算法#

```
python复制# 自适应算法
adaptive_algorithm = AdaptiveAlgorithm()
adaptive_algorithm.adapt_to_environment(environment)
```

```
# 自适应算法
adaptive_algorithm = AdaptiveAlgorithm()
adaptive_algorithm.adapt_to_environment(environment)
```

#### 27.3.11 总结#

Claude Code 采用多种核心算法实现代码生成、理解和重构功能。这些算法基于大语言模型和代码分析技术，具有高效、准确的特点。

随着技术的不断进步，Claude Code 的核心算法将不断优化和升级，为开发者提供更强大的代码助手服务。未来，AI 辅助算法设计、自动化算法优化和自适应算法等新技术将进一步提升 Claude Code 的性能和功能。

---


# 第 25 章

## 1 智能开发工作流概述

**URL**: https://claudecode.tangshuang.net/course/25.1%20%E6%99%BA%E8%83%BD%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A6%82%E8%BF%B0

#### 智能开发工作流概述#

智能开发工作流是利用 AI 技术自动化和增强软件开发过程的各个环节。通过将 Claude Code 集成到开发流程中，开发者可以显著提高开发效率、代码质量和项目交付速度。

#### 传统开发流程 vs 智能开发流程#

##### 传统开发流程#

需求分析 → 设计 → 编码 → 测试 → 部署 → 维护
↓         ↓      ↓      ↓      ↓      ↓
手工     手工   手工   手工   手工   手工
耗时     耗时   耗时   耗时   耗时   耗时

- 各环节依赖人工完成
- 信息传递效率低
- 容易出现错误
- 开发周期长
- 成本高昂

##### 智能开发流程#

```
bash复制需求分析 → 设计 → 编码 → 测试 → 部署 → 维护
↓         ↓      ↓      ↓      ↓      ↓
AI辅助   AI辅助  AI辅助  AI辅助  AI辅助  AI辅助
快速     快速   快速   快速   快速   快速
```

```
需求分析 → 设计 → 编码 → 测试 → 部署 → 维护
↓         ↓      ↓      ↓      ↓      ↓
AI辅助   AI辅助  AI辅助  AI辅助  AI辅助  AI辅助
快速     快速   快速   快速   快速   快速
```

- AI 辅助各个环节
- 自动化程度高
- 减少人为错误
- 开发周期短
- 成本降低

#### 智能开发工作流的核心组件#

##### 1. 智能代码生成#

### 示例：智能代码生成

用户请求：
"生成一个 RESTful API 的用户管理接口"
Claude Code 生成的代码：

```
python复制`python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token
from datetime import datetime
import bcrypt

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'

db = SQLAlchemy(app)
jwt = JWTManager(app)

class User(db.Model):
"""用户模型"""
id = db.Column(db.Integer, primary_key=True)
username = db.Column(db.String(80), unique=True, nullable=False)
email = db.Column(db.String(120), unique=True, nullable=False)
password_hash = db.Column(db.String(128), nullable=False)
created_at = db.Column(db.DateTime, default=datetime.utcnow)
updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

@app.route('/users', methods=['POST'])
def create_user():
"""创建用户"""
data = request.get_json()

if User.query.filter_by(username=data['username']).first():
return jsonify({'error': 'Username already exists'}), 400

if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'Email already exists'}), 400

user = User(
username=data['username'],
email=data['email'],
password_hash=bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')
)

db.session.add(user)
db.session.commit()

return jsonify({
'id': user.id,
'username': user.username,
'email': user.email,
'created_at': user.created_at.isoformat()
}), 201

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
"""获取用户"""
```

```
`python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token
from datetime import datetime
import bcrypt

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'

db = SQLAlchemy(app)
jwt = JWTManager(app)

class User(db.Model):
"""用户模型"""
id = db.Column(db.Integer, primary_key=True)
username = db.Column(db.String(80), unique=True, nullable=False)
email = db.Column(db.String(120), unique=True, nullable=False)
password_hash = db.Column(db.String(128), nullable=False)
created_at = db.Column(db.DateTime, default=datetime.utcnow)
updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

@app.route('/users', methods=['POST'])
def create_user():
"""创建用户"""
data = request.get_json()

if User.query.filter_by(username=data['username']).first():
return jsonify({'error': 'Username already exists'}), 400

if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'Email already exists'}), 400

user = User(
username=data['username'],
email=data['email'],
password_hash=bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')
)

db.session.add(user)
db.session.commit()

return jsonify({
'id': user.id,
'username': user.username,
'email': user.email,
'created_at': user.created_at.isoformat()
}), 201

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
"""获取用户"""
```

user = User.query.get_or_404(user_id)
return jsonify({
'id': user.id,
'username': user.username,
'email': user.email,
'created_at': user.created_at.isoformat(),
'updated_at': user.updated_at.isoformat()
})

@app.route('/users', methods=['GET'])
def get_users():
"""获取用户列表"""
page = request.args.get('page', 1, type=int)
per_page = request.args.get('per_page', 20, type=int)

users = User.query.paginate(page=page, per_page=per_page)

return jsonify({
'users': [
{
'id': user.id,
'username': user.username,
'email': user.email
}
for user in users.items
],
'total': users.total,
'pages': users.pages,
'current_page': page
})

@app.route('/users/int:user_id', methods=['PUT'])
def update_user(user_id):
"""更新用户"""
user = User.query.get_or_404(user_id)
data = request.get_json()

if 'username' in data:
existing_user = User.query.filter_by(username=data['username']).first()
if existing_user and existing_user.id != user_id:
return jsonify({'error': 'Username already exists'}), 400
user.username = data['username']

if 'email' in data:
existing_user = User.query.filter_by(email=data['email']).first()
if existing_user and existing_user.id != user_id:
return jsonify({'error': 'Email already exists'}), 400
user.email = data['email']

if 'password' in data:
user.password_hash = bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')

user.updated_at = datetime.utcnow()
db.session.commit()

return jsonify({
'id': user.id,
'username': user.username,
'email': user.email,
'updated_at': user.updated_at.isoformat()
})

@app.route('/users/int:user_id', methods=['DELETE'])
def delete_user(user_id):
"""删除用户"""
user = User.query.get_or_404(user_id)
db.session.delete(user)
db.session.commit()

return jsonify({'message': 'User deleted successfully'})

if name == 'main':
with app.app_context():
db.create_all()
app.run(debug=True)

```
bash复制> - 快速生成完整的 CRUD 接口
> - 包含数据验证和错误处理
> - 自动生成数据库模型
> - 符合 RESTful 规范
> - 包含分页功能
```

```
> - 快速生成完整的 CRUD 接口
> - 包含数据验证和错误处理
> - 自动生成数据库模型
> - 符合 RESTful 规范
> - 包含分页功能
```

##### 2. 智能代码补全#

### 示例：智能代码补全

```
python复制`python

class UserService:
def __init__(self, db):
self.db = db

def get_user_by_id(self, user_id):
"""根据 ID 获取用户"""
pass

def get_user_by_email(self, email):
"""根据邮箱获取用户"""
pass

def create_user(self, username, email, password):
"""创建用户"""
pass

def update_user(self, user_id, **kwargs):
"""更新用户"""
pass

def delete_user(self, user_id):
"""删除用户"""
pass

```> Claude Code 自动补全：

```
python

class UserService:
    def __init__(self, db):
        self.db = db

    def get_user_by_id(self, user_id):
        """根据 ID 获取用户"""
        user = self.db.session.query(User).filter_by(id=user_id).first()
        if not user:
            raise UserNotFoundError(f"User with id {user_id} not found")
        return user

    def get_user_by_email(self, email):
        """根据邮箱获取用户"""
        user = self.db.session.query(User).filter_by(email=email).first()
        if not user:
            raise UserNotFoundError(f"User with email {email} not found")
        return user

    def create_user(self, username, email, password):
        """创建用户"""
        if self.db.session.query(User).filter_by(username=username).first():
            raise UserAlreadyExistsError(f"User with username {username} already exists")

        if self.db.session.query(User).filter_by(email=email).first():
            raise UserAlreadyExistsError(f"User with email {email} already exists")

        user = User(
            username=username,
            email=email,
            password_hash=self._hash_password(password)
        )

        self.db.session.add(user)
        self.db.session.commit()

        return user

    def update_user(self, user_id, **kwargs):
        """更新用户"""
        user = self.get_user_by_id(user_id)

        if 'username' in kwargs:
            existing_user = self.db.session.query(User).filter_by(
                username=kwargs['username']
            ).first()
            if existing_user and existing_user.id != user_id:
                raise UserAlreadyExistsError(f"Username {kwargs['username']} already exists")
            user.username = kwargs['username']

        if 'email' in kwargs:
            existing_user = self.db.session.query(User).filter_by(
                email=kwargs['email']
            ).first()
            if existing_user and existing_user.id != user_id:
                raise UserAlreadyExistsError(f"Email {kwargs['email']} already exists")
            user.email = kwargs['email']

        if 'password' in kwargs:
            user.password_hash = self._hash_password(kwargs['password'])

        user.updated_at = datetime.utcnow()
        self.db.session.commit()

        return user

    def delete_user(self, user_id):
        """删除用户"""
        user = self.get_user_by_id(user_id)
        self.db.session.delete(user)
        self.db.session.commit()

    def _hash_password(self, password):
        """哈希密码"""
        return bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

> **优势**:
> - 自动实现方法逻辑
> - 包含错误处理
> - 添加数据验证
> - 自动处理密码哈希
> - 更新时间戳

### 3. 智能代码理解

```
python

# 示例：智能代码理解

用户请求：
"理解这段代码的功能"

代码：
```python
```python

def calculate_discount(order):
    if order['customer']['level'] == 'gold':
        discount = 0.1
    elif order['customer']['level'] == 'platinum':
        discount = 0.15
    else:
        discount = 0.05

    if order['total'] > 1000:
        discount += 0.05

    if order['items_count'] > 10:
        discount += 0.03

    discount = min(discount, 0.3)

    return order['total'] * (1 - discount)

Claude Code 的理解：

## 代码功能分析

### 函数: calculate_discount

> **功能**: 计算订单折扣后的价格

> **参数**:
> - `order`: 订单信息字典
 - `customer`: 客户信息
 - `level`: 客户等级 (gold/platinum/regular)
 - `total`: 订单总金额
 - `items_count`: 商品数量

> **返回值**: 折扣后的价格

### 折扣规则

 - Gold 客户: 10% 折扣
 - Platinum 客户: 15% 折扣
 - 普通客户: 5% 折扣

 - 订单金额 > 1000: 额外 5% 折扣

 - 商品数量 > 10: 额外 3% 折扣

 - 最大折扣: 30%

### 计算示例

````python
````python

# 示例 1: Gold 客户，订单金额 1200，商品数量 15
order = {
'customer': {'level': 'gold'},
'total': 1200,
'items_count': 15
}
# 基础折扣: 10%
# 金额折扣: 5%
# 数量折扣: 3%
# 总折扣: 18%
# 最终价格: 1200 * (1 - 0.18) = 984

# 示例 2: Platinum 客户，订单金额 500，商品数量 5
order = {
'customer': {'level': 'platinum'},
'total': 500,
'items_count': 5
}
# 基础折扣: 15%
# 金额折扣: 0%
# 数量折扣: 0%
# 总折扣: 15%
# 最终价格: 500 * (1 - 0.15) = 425

# 示例 3: 普通客户，订单金额 2000，商品数量 20
order = {
'customer': {'level': 'regular'},
'total': 2000,
'items_count': 20
}
# 基础折扣: 5%
# 金额折扣: 5%
# 数量折扣: 3%
# 总折扣: 13%
# 最终价格: 2000 * (1 - 0.13) = 1740

```### 代码质量评估

| 指标 | 评分 | 说明 |
|------|------|------|
| 可读性 | 8/10 | 逻辑清晰，易于理解 |
| 可维护性 | 7/10 | 折扣规则硬编码，不易修改 |
| 可扩展性 | 5/10 | 添加新折扣规则需要修改代码 |
| 测试性 | 8/10 | 容易编写单元测试 |

### 改进建议

```
python

class DiscountCalculator:
    """折扣计算器"""

    CUSTOMER_LEVEL_DISCOUNTS = {
        'gold': 0.1,
        'platinum': 0.15,
        'regular': 0.05
    }

    AMOUNT_THRESHOLD = 1000
    AMOUNT_DISCOUNT = 0.05

    ITEMS_THRESHOLD = 10
    ITEMS_DISCOUNT = 0.03

    MAX_DISCOUNT = 0.3

    def calculate(self, order: dict) -> float:
        """计算折扣后的价格"""
        discount = self._calculate_base_discount(order)
        discount += self._calculate_amount_discount(order)
        discount += self._calculate_items_discount(order)

        discount = min(discount, self.MAX_DISCOUNT)

        return order['total'] * (1 - discount)

    def _calculate_base_discount(self, order: dict) -> float:
        """计算基础折扣"""
        level = order['customer']['level']
        return self.CUSTOMER_LEVEL_DISCOUNTS.get(level, 0.05)

    def _calculate_amount_discount(self, order: dict) -> float:
        """计算金额折扣"""
        if order['total'] > self.AMOUNT_THRESHOLD:
            return self.AMOUNT_DISCOUNT
        return 0

    def _calculate_items_discount(self, order: dict) -> float:
        """计算商品数量折扣"""
        if order['items_count'] > self.ITEMS_THRESHOLD:
            return self.ITEMS_DISCOUNT
        return 0

> **优势**:
> - 折扣规则集中管理
> - 易于扩展新规则
> - 提高代码可维护性

## 智能开发工作流的优势
### 1. 提高开发效率
| 任务 | 传统方式 | 智能方式 | 效率提升 |
|------|----------|----------|----------|
| 生成 CRUD 接口 | 4 小时 | 30 分钟 | 87.5% |
| 编写单元测试 | 2 小时 | 20 分钟 | 83.3% |
| 代码审查 | 1 小时 | 15 分钟 | 75% |
| 文档编写 | 2 小时 | 30 分钟 | 75% |
| Bug 修复 | 1 小时 | 15 分钟 | 75% |
### 2. 提高代码质量
| 指标 | 传统方式 | 智能方式 | 改善 |
|------|----------|----------|------|
| 代码覆盖率 | 65% | 85% | +31% |
| Bug 数量 | 50/月 | 15/月 | 70% ↓ |
| 代码重复率 | 15% | 5% | 67% ↓ |
| 圈复杂度 | 12 | 6 | 50% ↓ |
### 3. 降低开发成本
| 项目 | 传统方式 | 智能方式 | 成本降低 |
|------|----------|----------|----------|
| 人力成本 | 100% | 60% | 40% ↓ |
| 时间成本 | 100% | 50% | 50% ↓ |
| 维护成本 | 100% | 40% | 60% ↓ |
| 总成本 | 100% | 50% | 50% ↓ |
## 智能开发工作流的实施步骤
### 步骤 1: 需求分析

```
python

# 示例：智能需求分析

用户请求：
"分析这个需求并提供实现方案"

需求描述：
"开发一个电商平台的订单管理系统，支持订单创建、支付、发货、退款等功能。"

Claude Code 生成的分析：

## 需求分析

### 核心功能

   - 创建订单
   - 查询订单
   - 更新订单
   - 取消订单

   - 支付订单
   - 退款订单
   - 查询支付状态

   - 创建发货单
   - 更新物流信息
   - 查询物流状态

   - 申请退款
   - 处理退款
   - 查询退款状态

### 技术栈建议

**后端**:
- 框架: Flask/FastAPI
- 数据库: PostgreSQL
- 缓存: Redis
- 消息队列: RabbitMQ

**前端**:
- 框架: React
- 状态管理: Redux
- UI 组件: Ant Design

**支付集成**:
- Stripe
- PayPal
- 支付宝
- 微信支付

### 数据模型设计

```python
```python

class Order(db.Model):
    """订单模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_number = db.Column(db.String(50), unique=True, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class OrderItem(db.Model):
    """订单项模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('products.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price = db.Column(db.Float, nullable=False)

class Payment(db.Model):
    """支付模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    payment_method = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    transaction_id = db.Column(db.String(100))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Shipment(db.Model):
    """发货模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    tracking_number = db.Column(db.String(100), nullable=False)
    shipping_address = db.Column(db.JSON, nullable=False)
    status = db.Column(db.String(20), default='shipped')
    shipped_at = db.Column(db.DateTime, default=datetime.utcnow)
    delivered_at = db.Column(db.DateTime)

class Refund(db.Model):
    """退款模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    payment_id = db.Column(db.Integer, db.ForeignKey('payments.id'), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    reason = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    processed_at = db.Column(db.DateTime)

### API 设计

````yaml
````yaml

# 订单管理
POST   /api/orders              # 创建订单
GET    /api/orders              # 获取订单列表
GET    /api/orders/:id          # 获取订单详情
PUT    /api/orders/:id          # 更新订单
DELETE /api/orders/:id          # 取消订单

# 支付管理
POST   /api/orders/:id/payments # 支付订单
GET    /api/payments/:id        # 获取支付详情
POST   /api/payments/:id/refund # 申请退款

# 发货管理
POST   /api/orders/:id/shipments # 创建发货单
GET    /api/shipments/:id       # 获取发货详情
PUT    /api/shipments/:id       # 更新物流信息

# 退款管理
GET    /api/refunds/:id         # 获取退款详情
PUT    /api/refunds/:id/approve # 批准退款
PUT    /api/refunds/:id/reject  # 拒绝退款

```> >

```
### 步骤 2: 代码生成

# 示例：智能代码生成
用户请求：
"根据需求分析生成订单管理系统的代码"
Claude Code 生成的代码：
# （这里会生成完整的订单管理系统代码，包括模型、服务、API 等）
```
### 步骤 3: 测试生成

```
python

# 示例：智能测试生成

用户请求：
"为订单管理系统生成测试代码"

Claude Code 生成的测试代码：

# （这里会生成完整的测试代码，包括单元测试、集成测试等）

### 步骤 4: 文档生成

# 示例：智能文档生成
用户请求：
"为订单管理系统生成 API 文档"
Claude Code 生成的文档：
# （这里会生成完整的 API 文档，包括接口说明、参数说明、示例等）

```
```
```

```
`python

class UserService:
def __init__(self, db):
self.db = db

def get_user_by_id(self, user_id):
"""根据 ID 获取用户"""
pass

def get_user_by_email(self, email):
"""根据邮箱获取用户"""
pass

def create_user(self, username, email, password):
"""创建用户"""
pass

def update_user(self, user_id, **kwargs):
"""更新用户"""
pass

def delete_user(self, user_id):
"""删除用户"""
pass

```> Claude Code 自动补全：

```
python

class UserService:
    def __init__(self, db):
        self.db = db

    def get_user_by_id(self, user_id):
        """根据 ID 获取用户"""
        user = self.db.session.query(User).filter_by(id=user_id).first()
        if not user:
            raise UserNotFoundError(f"User with id {user_id} not found")
        return user

    def get_user_by_email(self, email):
        """根据邮箱获取用户"""
        user = self.db.session.query(User).filter_by(email=email).first()
        if not user:
            raise UserNotFoundError(f"User with email {email} not found")
        return user

    def create_user(self, username, email, password):
        """创建用户"""
        if self.db.session.query(User).filter_by(username=username).first():
            raise UserAlreadyExistsError(f"User with username {username} already exists")

        if self.db.session.query(User).filter_by(email=email).first():
            raise UserAlreadyExistsError(f"User with email {email} already exists")

        user = User(
            username=username,
            email=email,
            password_hash=self._hash_password(password)
        )

        self.db.session.add(user)
        self.db.session.commit()

        return user

    def update_user(self, user_id, **kwargs):
        """更新用户"""
        user = self.get_user_by_id(user_id)

        if 'username' in kwargs:
            existing_user = self.db.session.query(User).filter_by(
                username=kwargs['username']
            ).first()
            if existing_user and existing_user.id != user_id:
                raise UserAlreadyExistsError(f"Username {kwargs['username']} already exists")
            user.username = kwargs['username']

        if 'email' in kwargs:
            existing_user = self.db.session.query(User).filter_by(
                email=kwargs['email']
            ).first()
            if existing_user and existing_user.id != user_id:
                raise UserAlreadyExistsError(f"Email {kwargs['email']} already exists")
            user.email = kwargs['email']

        if 'password' in kwargs:
            user.password_hash = self._hash_password(kwargs['password'])

        user.updated_at = datetime.utcnow()
        self.db.session.commit()

        return user

    def delete_user(self, user_id):
        """删除用户"""
        user = self.get_user_by_id(user_id)
        self.db.session.delete(user)
        self.db.session.commit()

    def _hash_password(self, password):
        """哈希密码"""
        return bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

> **优势**:
> - 自动实现方法逻辑
> - 包含错误处理
> - 添加数据验证
> - 自动处理密码哈希
> - 更新时间戳

### 3. 智能代码理解

```
python

# 示例：智能代码理解

用户请求：
"理解这段代码的功能"

代码：
```python
```python

def calculate_discount(order):
    if order['customer']['level'] == 'gold':
        discount = 0.1
    elif order['customer']['level'] == 'platinum':
        discount = 0.15
    else:
        discount = 0.05

    if order['total'] > 1000:
        discount += 0.05

    if order['items_count'] > 10:
        discount += 0.03

    discount = min(discount, 0.3)

    return order['total'] * (1 - discount)

Claude Code 的理解：

## 代码功能分析

### 函数: calculate_discount

> **功能**: 计算订单折扣后的价格

> **参数**:
> - `order`: 订单信息字典
 - `customer`: 客户信息
 - `level`: 客户等级 (gold/platinum/regular)
 - `total`: 订单总金额
 - `items_count`: 商品数量

> **返回值**: 折扣后的价格

### 折扣规则

 - Gold 客户: 10% 折扣
 - Platinum 客户: 15% 折扣
 - 普通客户: 5% 折扣

 - 订单金额 > 1000: 额外 5% 折扣

 - 商品数量 > 10: 额外 3% 折扣

 - 最大折扣: 30%

### 计算示例

````python
````python

# 示例 1: Gold 客户，订单金额 1200，商品数量 15
order = {
'customer': {'level': 'gold'},
'total': 1200,
'items_count': 15
}
# 基础折扣: 10%
# 金额折扣: 5%
# 数量折扣: 3%
# 总折扣: 18%
# 最终价格: 1200 * (1 - 0.18) = 984

# 示例 2: Platinum 客户，订单金额 500，商品数量 5
order = {
'customer': {'level': 'platinum'},
'total': 500,
'items_count': 5
}
# 基础折扣: 15%
# 金额折扣: 0%
# 数量折扣: 0%
# 总折扣: 15%
# 最终价格: 500 * (1 - 0.15) = 425

# 示例 3: 普通客户，订单金额 2000，商品数量 20
order = {
'customer': {'level': 'regular'},
'total': 2000,
'items_count': 20
}
# 基础折扣: 5%
# 金额折扣: 5%
# 数量折扣: 3%
# 总折扣: 13%
# 最终价格: 2000 * (1 - 0.13) = 1740

```### 代码质量评估

| 指标 | 评分 | 说明 |
|------|------|------|
| 可读性 | 8/10 | 逻辑清晰，易于理解 |
| 可维护性 | 7/10 | 折扣规则硬编码，不易修改 |
| 可扩展性 | 5/10 | 添加新折扣规则需要修改代码 |
| 测试性 | 8/10 | 容易编写单元测试 |

### 改进建议

```
python

class DiscountCalculator:
    """折扣计算器"""

    CUSTOMER_LEVEL_DISCOUNTS = {
        'gold': 0.1,
        'platinum': 0.15,
        'regular': 0.05
    }

    AMOUNT_THRESHOLD = 1000
    AMOUNT_DISCOUNT = 0.05

    ITEMS_THRESHOLD = 10
    ITEMS_DISCOUNT = 0.03

    MAX_DISCOUNT = 0.3

    def calculate(self, order: dict) -> float:
        """计算折扣后的价格"""
        discount = self._calculate_base_discount(order)
        discount += self._calculate_amount_discount(order)
        discount += self._calculate_items_discount(order)

        discount = min(discount, self.MAX_DISCOUNT)

        return order['total'] * (1 - discount)

    def _calculate_base_discount(self, order: dict) -> float:
        """计算基础折扣"""
        level = order['customer']['level']
        return self.CUSTOMER_LEVEL_DISCOUNTS.get(level, 0.05)

    def _calculate_amount_discount(self, order: dict) -> float:
        """计算金额折扣"""
        if order['total'] > self.AMOUNT_THRESHOLD:
            return self.AMOUNT_DISCOUNT
        return 0

    def _calculate_items_discount(self, order: dict) -> float:
        """计算商品数量折扣"""
        if order['items_count'] > self.ITEMS_THRESHOLD:
            return self.ITEMS_DISCOUNT
        return 0

> **优势**:
> - 折扣规则集中管理
> - 易于扩展新规则
> - 提高代码可维护性

## 智能开发工作流的优势
### 1. 提高开发效率
| 任务 | 传统方式 | 智能方式 | 效率提升 |
|------|----------|----------|----------|
| 生成 CRUD 接口 | 4 小时 | 30 分钟 | 87.5% |
| 编写单元测试 | 2 小时 | 20 分钟 | 83.3% |
| 代码审查 | 1 小时 | 15 分钟 | 75% |
| 文档编写 | 2 小时 | 30 分钟 | 75% |
| Bug 修复 | 1 小时 | 15 分钟 | 75% |
### 2. 提高代码质量
| 指标 | 传统方式 | 智能方式 | 改善 |
|------|----------|----------|------|
| 代码覆盖率 | 65% | 85% | +31% |
| Bug 数量 | 50/月 | 15/月 | 70% ↓ |
| 代码重复率 | 15% | 5% | 67% ↓ |
| 圈复杂度 | 12 | 6 | 50% ↓ |
### 3. 降低开发成本
| 项目 | 传统方式 | 智能方式 | 成本降低 |
|------|----------|----------|----------|
| 人力成本 | 100% | 60% | 40% ↓ |
| 时间成本 | 100% | 50% | 50% ↓ |
| 维护成本 | 100% | 40% | 60% ↓ |
| 总成本 | 100% | 50% | 50% ↓ |
## 智能开发工作流的实施步骤
### 步骤 1: 需求分析

```
python

# 示例：智能需求分析

用户请求：
"分析这个需求并提供实现方案"

需求描述：
"开发一个电商平台的订单管理系统，支持订单创建、支付、发货、退款等功能。"

Claude Code 生成的分析：

## 需求分析

### 核心功能

   - 创建订单
   - 查询订单
   - 更新订单
   - 取消订单

   - 支付订单
   - 退款订单
   - 查询支付状态

   - 创建发货单
   - 更新物流信息
   - 查询物流状态

   - 申请退款
   - 处理退款
   - 查询退款状态

### 技术栈建议

**后端**:
- 框架: Flask/FastAPI
- 数据库: PostgreSQL
- 缓存: Redis
- 消息队列: RabbitMQ

**前端**:
- 框架: React
- 状态管理: Redux
- UI 组件: Ant Design

**支付集成**:
- Stripe
- PayPal
- 支付宝
- 微信支付

### 数据模型设计

```python
```python

class Order(db.Model):
    """订单模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_number = db.Column(db.String(50), unique=True, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class OrderItem(db.Model):
    """订单项模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('products.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price = db.Column(db.Float, nullable=False)

class Payment(db.Model):
    """支付模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    payment_method = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(20), default='pending')
    transaction_id = db.Column(db.String(100))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Shipment(db.Model):
    """发货模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    tracking_number = db.Column(db.String(100), nullable=False)
    shipping_address = db.Column(db.JSON, nullable=False)
    status = db.Column(db.String(20), default='shipped')
    shipped_at = db.Column(db.DateTime, default=datetime.utcnow)
    delivered_at = db.Column(db.DateTime)

class Refund(db.Model):
    """退款模型"""
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('orders.id'), nullable=False)
    payment_id = db.Column(db.Integer, db.ForeignKey('payments.id'), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    reason = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    processed_at = db.Column(db.DateTime)

### API 设计

````yaml
````yaml

# 订单管理
POST   /api/orders              # 创建订单
GET    /api/orders              # 获取订单列表
GET    /api/orders/:id          # 获取订单详情
PUT    /api/orders/:id          # 更新订单
DELETE /api/orders/:id          # 取消订单

# 支付管理
POST   /api/orders/:id/payments # 支付订单
GET    /api/payments/:id        # 获取支付详情
POST   /api/payments/:id/refund # 申请退款

# 发货管理
POST   /api/orders/:id/shipments # 创建发货单
GET    /api/shipments/:id       # 获取发货详情
PUT    /api/shipments/:id       # 更新物流信息

# 退款管理
GET    /api/refunds/:id         # 获取退款详情
PUT    /api/refunds/:id/approve # 批准退款
PUT    /api/refunds/:id/reject  # 拒绝退款

```> >

```
### 步骤 2: 代码生成

# 示例：智能代码生成
用户请求：
"根据需求分析生成订单管理系统的代码"
Claude Code 生成的代码：
# （这里会生成完整的订单管理系统代码，包括模型、服务、API 等）
```
### 步骤 3: 测试生成

```
python

# 示例：智能测试生成

用户请求：
"为订单管理系统生成测试代码"

Claude Code 生成的测试代码：

# （这里会生成完整的测试代码，包括单元测试、集成测试等）

### 步骤 4: 文档生成

# 示例：智能文档生成
用户请求：
"为订单管理系统生成 API 文档"
Claude Code 生成的文档：
# （这里会生成完整的 API 文档，包括接口说明、参数说明、示例等）

```
```
```

---

## 2 代码生成与补全

**URL**: https://claudecode.tangshuang.net/course/25.2%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E8%A1%A5%E5%85%A8

#### 代码生成与补全概述#

Claude Code 提供了强大的代码生成与补全功能，可以根据自然语言描述、代码片段、API 规范等生成高质量的代码，并智能补全未完成的代码。

#### 代码生成#

##### 1. 从自然语言生成代码#

### 示例：从自然语言生成代码

用户请求：
"创建一个用户认证系统，支持注册、登录、密码重置功能"

Claude Code 生成的代码：

```
python复制````python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from flask_mail import Mail, Message
from datetime import datetime, timedelta
import bcrypt
import secrets

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///auth.db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = 'your-email@gmail.com'
app.config['MAIL_PASSWORD'] = 'your-password'

db = SQLAlchemy(app)
jwt = JWTManager(app)
mail = Mail(app)

class User(db.Model):
"""用户模型"""
id = db.Column(db.Integer, primary_key=True)
username = db.Column(db.String(80), unique=True, nullable=False)
email = db.Column(db.String(120), unique=True, nullable=False)
password_hash = db.Column(db.String(128), nullable=False)
is_active = db.Column(db.Boolean, default=True)
created_at = db.Column(db.DateTime, default=datetime.utcnow)
updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

reset_token = db.Column(db.String(100), unique=True)
reset_token_expires = db.Column(db.DateTime)

class PasswordReset(db.Model):
"""密码重置记录"""
id = db.Column(db.Integer, primary_key=True)
user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
token = db.Column(db.String(100), unique=True, nullable=False)
expires_at = db.Column(db.DateTime, nullable=False)
used = db.Column(db.Boolean, default=False)
created_at = db.Column(db.DateTime, default=datetime.utcnow)

@app.route('/register', methods=['POST'])
def register():
"""用户注册"""
data = request.get_json()

 # 验证输入
if not data.get('username') or not data.get('email') or not data.get('password'):
return jsonify({'error': 'Missing required fields'}), 400

 # 检查用户名是否已存在
if User.query.filter_by(username=data['username']).first():
return jsonify({'error': 'Username already exists'}), 400

 # 检查邮箱是否已存在
if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'Email already exists'}), 400

 # 验证密码强度
if len(data['password']) < 8:
return jsonify({'error': 'Password must be at least 8 characters'}), 400

 # 创建用户
user = User(
username=data['username'],
email=data['email'],
password_hash=bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')
)

db.session.add(user)
db.session.commit()

 # 生成访问令牌
access_token = create_access_token(identity=user.id)

return jsonify({
'message': 'User registered successfully',
'user': {
'id': user.id,
'username': user.username,
'email': user.email
},
'access_token': access_token
}), 201

@app.route('/login', methods=['POST'])
def login():
"""用户登录"""
data = request.get_json()

 # 验证输入
if not data.get('username') or not data.get('password'):
return jsonify({'error': 'Missing username or password'}), 400

 # 查找用户
user = User.query.filter_by(username=data['username']).first()

if not user or not bcrypt.checkpw(
data['password'].encode('utf-8'),
user.password_hash.encode('utf-8')
):
return jsonify({'error': 'Invalid username or password'}), 401

if not user.is_active:
return jsonify({'error': 'Account is deactivated'}), 403

 # 生成访问令牌
access_token = create_access_token(identity=user.id)

return jsonify({
'message': 'Login successful',
'user': {
'id': user.id,
'username': user.username,
'email': user.email
},
'access_token': access_token
})

@app.route('/me', methods=['GET'])
@jwt_required()
def get_current_user():
"""获取当前用户信息"""
user_id = get_jwt_identity()
user = User.query.get(user_id)

if not user:
return jsonify({'error': 'User not found'}), 404

return jsonify({
'id': user.id,
```

```
````python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from flask_mail import Mail, Message
from datetime import datetime, timedelta
import bcrypt
import secrets

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///auth.db'
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = 'your-email@gmail.com'
app.config['MAIL_PASSWORD'] = 'your-password'

db = SQLAlchemy(app)
jwt = JWTManager(app)
mail = Mail(app)

class User(db.Model):
"""用户模型"""
id = db.Column(db.Integer, primary_key=True)
username = db.Column(db.String(80), unique=True, nullable=False)
email = db.Column(db.String(120), unique=True, nullable=False)
password_hash = db.Column(db.String(128), nullable=False)
is_active = db.Column(db.Boolean, default=True)
created_at = db.Column(db.DateTime, default=datetime.utcnow)
updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

reset_token = db.Column(db.String(100), unique=True)
reset_token_expires = db.Column(db.DateTime)

class PasswordReset(db.Model):
"""密码重置记录"""
id = db.Column(db.Integer, primary_key=True)
user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
token = db.Column(db.String(100), unique=True, nullable=False)
expires_at = db.Column(db.DateTime, nullable=False)
used = db.Column(db.Boolean, default=False)
created_at = db.Column(db.DateTime, default=datetime.utcnow)

@app.route('/register', methods=['POST'])
def register():
"""用户注册"""
data = request.get_json()

 # 验证输入
if not data.get('username') or not data.get('email') or not data.get('password'):
return jsonify({'error': 'Missing required fields'}), 400

 # 检查用户名是否已存在
if User.query.filter_by(username=data['username']).first():
return jsonify({'error': 'Username already exists'}), 400

 # 检查邮箱是否已存在
if User.query.filter_by(email=data['email']).first():
return jsonify({'error': 'Email already exists'}), 400

 # 验证密码强度
if len(data['password']) < 8:
return jsonify({'error': 'Password must be at least 8 characters'}), 400

 # 创建用户
user = User(
username=data['username'],
email=data['email'],
password_hash=bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')
)

db.session.add(user)
db.session.commit()

 # 生成访问令牌
access_token = create_access_token(identity=user.id)

return jsonify({
'message': 'User registered successfully',
'user': {
'id': user.id,
'username': user.username,
'email': user.email
},
'access_token': access_token
}), 201

@app.route('/login', methods=['POST'])
def login():
"""用户登录"""
data = request.get_json()

 # 验证输入
if not data.get('username') or not data.get('password'):
return jsonify({'error': 'Missing username or password'}), 400

 # 查找用户
user = User.query.filter_by(username=data['username']).first()

if not user or not bcrypt.checkpw(
data['password'].encode('utf-8'),
user.password_hash.encode('utf-8')
):
return jsonify({'error': 'Invalid username or password'}), 401

if not user.is_active:
return jsonify({'error': 'Account is deactivated'}), 403

 # 生成访问令牌
access_token = create_access_token(identity=user.id)

return jsonify({
'message': 'Login successful',
'user': {
'id': user.id,
'username': user.username,
'email': user.email
},
'access_token': access_token
})

@app.route('/me', methods=['GET'])
@jwt_required()
def get_current_user():
"""获取当前用户信息"""
user_id = get_jwt_identity()
user = User.query.get(user_id)

if not user:
return jsonify({'error': 'User not found'}), 404

return jsonify({
'id': user.id,
```

'username': user.username,
'email': user.email,
'is_active': user.is_active,
'created_at': user.created_at.isoformat()
})

@app.route('/request-password-reset', methods=['POST'])
def request_password_reset():
"""请求密码重置"""
data = request.get_json()

if not data.get('email'):
return jsonify({'error': 'Email is required'}), 400

user = User.query.filter_by(email=data['email']).first()

if not user:

### 为了安全，不透露邮箱是否存在

return jsonify({
'message': 'If the email exists, a reset link has been sent'
}), 200

### 生成重置令牌

reset_token = secrets.token_urlsafe(32)
reset_token_expires = datetime.utcnow() + timedelta(hours=1)

### 保存重置令牌

password_reset = PasswordReset(
user_id=user.id,
token=reset_token,
expires_at=reset_token_expires
)

db.session.add(password_reset)
db.session.commit()

### 发送重置邮件

reset_link = f"http://localhost:3000/reset-password?token={reset_token}"

msg = Message(
'Password Reset Request',
recipients=[user.email]
)
msg.body = f'''
Hello {user.username},

You have requested to reset your password. Click the link below to reset your password:

{reset_link}

This link will expire in 1 hour.

If you did not request this password reset, please ignore this email.
'''

mail.send(msg)

return jsonify({
'message': 'If the email exists, a reset link has been sent'
}), 200

@app.route('/reset-password', methods=['POST'])
def reset_password():
"""重置密码"""
data = request.get_json()

if not data.get('token') or not data.get('password'):
return jsonify({'error': 'Token and password are required'}), 400

### 查找重置记录

password_reset = PasswordReset.query.filter_by(
token=data['token'],
used=False
).first()

if not password_reset:
return jsonify({'error': 'Invalid or expired reset token'}), 400

if password_reset.expires_at < datetime.utcnow():
return jsonify({'error': 'Reset token has expired'}), 400

### 验证密码强度

if len(data['password']) < 8:
return jsonify({'error': 'Password must be at least 8 characters'}), 400

### 更新密码

user = User.query.get(password_reset.user_id)
user.password_hash = bcrypt.hashpw(
data['password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')

### 标记重置令牌为已使用

password_reset.used = True

db.session.commit()

return jsonify({'message': 'Password reset successful'}), 200

@app.route('/change-password', methods=['POST'])
@jwt_required()
def change_password():
"""修改密码"""
data = request.get_json()
user_id = get_jwt_identity()

if not data.get('current_password') or not data.get('new_password'):
return jsonify({'error': 'Current password and new password are required'}), 400

user = User.query.get(user_id)

### 验证当前密码

if not bcrypt.checkpw(
data['current_password'].encode('utf-8'),
user.password_hash.encode('utf-8')
):
return jsonify({'error': 'Current password is incorrect'}), 400

### 验证新密码强度

if len(data['new_password']) < 8:
return jsonify({'error': 'New password must be at least 8 characters'}), 400

### 更新密码

user.password_hash = bcrypt.hashpw(
data['new_password'].encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')

db.session.commit()

return jsonify({'message': 'Password changed successfully'}), 200

if name == 'main':
with app.app_context():
db.create_all()
app.run(debug=True)

```
bash复制> - 用户注册功能
> - 用户登录功能
> - JWT 认证
> - 密码重置请求
> - 密码重置
> - 修改密码
> - 邮件发送
> - 数据验证
> - 错误处理
```

```
> - 用户注册功能
> - 用户登录功能
> - JWT 认证
> - 密码重置请求
> - 密码重置
> - 修改密码
> - 邮件发送
> - 数据验证
> - 错误处理
```

##### 2. 从 API 规范生成代码#

### 示例：从 OpenAPI 规范生成代码

用户请求：
"根据这个 OpenAPI 规范生成 API 代码"
OpenAPI 规范：

```
yaml复制`yaml

openapi: 3.0.0
info:
title: Product API
version: 1.0.0

paths:
/products:
get:
summary: Get all products
parameters:
 - name: page
in: query
schema:
type: integer
 - name: per_page
in: query
schema:
type: integer
responses:
'200':
description: Success
content:
application/json:
schema:
type: object
properties:
products:
type: array
items:
$ref: '#/components/schemas/Product'
total:
type: integer
page:
type: integer

post:
summary: Create a product
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/ProductCreate'
responses:
'201':
description: Created
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

/products/{product_id}:
get:
summary: Get a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
responses:
'200':
description: Success
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

put:
summary: Update a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/ProductUpdate'
responses:
'200':
description: Success
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

delete:
summary: Delete a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
responses:
'204':
description: No content

components:
schemas:
Product:
type: object
properties:
id:
type: integer
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string
created_at:
type: string
format: date-time
updated_at:
type: string
format: date-time

ProductCreate:
type: object
required:
 - name
 - price
 - stock
 - category
properties:
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string

ProductUpdate:
type: object
properties:
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string

```> Claude Code 生成的代码：

```
python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from typing import Optional

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///products.db'

db = SQLAlchemy(app)

class Product(db.Model):
    """商品模型"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False)
    stock = db.Column(db.Integer, nullable=False)
    category = db.Column(db.String(100), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        """转换为字典"""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'price': self.price,
            'stock': self.stock,
            'category': self.category,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

@app.route('/products', methods=['GET'])
def get_products():
    """获取所有商品"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    pagination = Product.query.paginate(page=page, per_page=per_page)

    return jsonify({
        'products': [product.to_dict() for product in pagination.items],
        'total': pagination.total,
        'page': page
    })

@app.route('/products', methods=['POST'])
def create_product():
    """创建商品"""
    data = request.get_json()

    # 验证必填字段
    required_fields = ['name', 'price', 'stock', 'category']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'Missing required field: {field}'}), 400

    # 验证数据类型
    if not isinstance(data['price'], (int, float)) or data['price'] < 0:
        return jsonify({'error': 'Price must be a positive number'}), 400

    if not isinstance(data['stock'], int) or data['stock'] < 0:
        return jsonify({'error': 'Stock must be a non-negative integer'}), 400

    # 创建商品
    product = Product(
        name=data['name'],
        description=data.get('description'),
        price=data['price'],
        stock=data['stock'],
        category=data['category']
    )

    db.session.add(product)
    db.session.commit()

    return jsonify(product.to_dict()), 201

@app.route('/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    """获取商品详情"""
    product = Product.query.get_or_404(product_id)
    return jsonify(product.to_dict())

@app.route('/products/<int:product_id>', methods=['PUT'])
def update_product(product_id):
    """更新商品"""
    product = Product.query.get_or_404(product_id)
    data = request.get_json()

    # 更新字段
    if 'name' in data:
        product.name = data['name']

    if 'description' in data:
        product.description = data['description']

    if 'price' in data:
        if not isinstance(data['price'], (int, float)) or data['price'] < 0:
            return jsonify({'error': 'Price must be a positive number'}), 400
        product.price = data['price']

    if 'stock' in data:
        if not isinstance(data['stock'], int) or data['stock'] < 0:
            return jsonify({'error': 'Stock must be a non-negative integer'}), 400
        product.stock = data['stock']

    if 'category' in data:
        product.category = data['category']

    product.updated_at = datetime.utcnow()
    db.session.commit()

    return jsonify(product.to_dict())

@app.route('/products/<int:product_id>', methods=['DELETE'])
def delete_product(product_id):
    """删除商品"""
    product = Product.query.get_or_404(product_id)
    db.session.delete(product)
    db.session.commit()

    return '', 204

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)

> **生成的代码包含**:
> - 完整的 CRUD 操作
> - 数据验证
> - 分页功能
> - 错误处理
> - 符合 OpenAPI 规范

## 代码补全
### 1. 智能方法补全

```
python

# 示例：智能方法补全

用户输入：
```python
```python

class OrderService:
    def __init__(self, db):
        self.db = db

    def create_order(self, user_id, items):
        """创建订单"""
        pass

Claude Code 自动补全：

````python
````python

class OrderService:
def __init__(self, db):
self.db = db

def create_order(self, user_id, items):
"""
创建订单

参数:
user_id: 用户 ID
items: 商品列表 [{'product_id': 1, 'quantity': 2}, ...]

返回:
订单对象
"""
 # 验证用户
user = self.db.session.query(User).filter_by(id=user_id).first()
if not user:
raise UserNotFoundError(f"User with id {user_id} not found")

 # 验证商品
product_ids = [item['product_id'] for item in items]
products = self.db.session.query(Product).filter(
Product.id.in_(product_ids)
).all()

product_map = {product.id: product for product in products}

for item in items:
if item['product_id'] not in product_map:
raise ProductNotFoundError(
f"Product with id {item['product_id']} not found"
)

product = product_map[item['product_id']]
if product.stock < item['quantity']:
raise InsufficientStockError(
f"Insufficient stock for product {product.name}"
)

 # 计算总金额
total_amount = sum(
product_map[item['product_id']].price * item['quantity']
for item in items
)

 # 创建订单
order = Order(
user_id=user_id,
total_amount=total_amount,
status='pending'
)

self.db.session.add(order)
self.db.session.flush()

 # 创建订单项
for item in items:
product = product_map[item['product_id']]
order_item = OrderItem(
order_id=order.id,
product_id=item['product_id'],
quantity=item['quantity'],
price=product.price
)
self.db.session.add(order_item)

 # 扣减库存
product.stock -= item['quantity']

self.db.session.commit()

return order

def get_order(self, order_id):
"""获取订单详情"""
order = self.db.session.query(Order).filter_by(id=order_id).first()
if not order:
raise OrderNotFoundError(f"Order with id {order_id} not found")
return order

def update_order_status(self, order_id, status):
"""更新订单状态"""
order = self.get_order(order_id)
order.status = status
order.updated_at = datetime.utcnow()
self.db.session.commit()
return order

def cancel_order(self, order_id):
"""取消订单"""
order = self.get_order(order_id)

if order.status in ['paid', 'shipped', 'completed']:
raise InvalidOrderStatusError(
f"Cannot cancel order with status {order.status}"
)

 # 恢复库存
for item in order.items:
product = self.db.session.query(Product).filter_by(
id=item.product_id
).first()
if product:
product.stock += item.quantity

order.status = 'cancelled'
order.updated_at = datetime.utcnow()
self.db.session.commit()

return order

def get_user_orders(self, user_id, page=1, per_page=20):
"""获取用户订单列表"""
pagination = self.db.session.query(Order).filter_by(
user_id=user_id
).order_by(
Order.created_at.desc()
).paginate(page=page, per_page=per_page)

return pagination

```> **补全的内容**:
> - 完整的方法实现
> - 数据验证
> - 错误处理
> - 库存管理
> - 相关方法补全

```
### 2. 智能类补全

# 示例：智能类补全
用户输入：
````python
`python

class UserRepository:
def __init__(self, db):
self.db = db

```> Claude Code 自动补全：

```
python

from typing import List, Optional
from datetime import datetime

class UserRepository:
    """用户仓储类"""

    def __init__(self, db):
        self.db = db

    def find_by_id(self, user_id: int) -> Optional[User]:
        """根据 ID 查找用户"""
        return self.db.session.query(User).filter_by(id=user_id).first()

    def find_by_username(self, username: str) -> Optional[User]:
        """根据用户名查找用户"""
        return self.db.session.query(User).filter_by(username=username).first()

    def find_by_email(self, email: str) -> Optional[User]:
        """根据邮箱查找用户"""
        return self.db.session.query(User).filter_by(email=email).first()

    def find_all(self, page: int = 1, per_page: int = 20):
        """查找所有用户"""
        return self.db.session.query(User).paginate(
            page=page,
            per_page=per_page
        )

    def create(self, user: User) -> User:
        """创建用户"""
        self.db.session.add(user)
        self.db.session.commit()
        return user

    def update(self, user: User) -> User:
        """更新用户"""
        user.updated_at = datetime.utcnow()
        self.db.session.commit()
        return user

    def delete(self, user_id: int) -> bool:
        """删除用户"""
        user = self.find_by_id(user_id)
        if not user:
            return False

        self.db.session.delete(user)
        self.db.session.commit()
        return True

    def exists_by_username(self, username: str) -> bool:
        """检查用户名是否存在"""
        return self.db.session.query(User).filter_by(
            username=username
        ).first() is not None

    def exists_by_email(self, email: str) -> bool:
        """检查邮箱是否存在"""
        return self.db.session.query(User).filter_by(
            email=email
        ).first() is not None

    def count(self) -> int:
        """统计用户数量"""
        return self.db.session.query(User).count()

    def search(self, keyword: str, page: int = 1, per_page: int = 20):
        """搜索用户"""
        return self.db.session.query(User).filter(
            User.username.ilike(f'%{keyword}%') |
            User.email.ilike(f'%{keyword}%')
        ).paginate(page=page, per_page=per_page)

> **补全的内容**:
> - 完整的 CRUD 方法
> - 查询方法
> - 存在性检查
> - 搜索功能
> - 分页支持
```

```
`yaml

openapi: 3.0.0
info:
title: Product API
version: 1.0.0

paths:
/products:
get:
summary: Get all products
parameters:
 - name: page
in: query
schema:
type: integer
 - name: per_page
in: query
schema:
type: integer
responses:
'200':
description: Success
content:
application/json:
schema:
type: object
properties:
products:
type: array
items:
$ref: '#/components/schemas/Product'
total:
type: integer
page:
type: integer

post:
summary: Create a product
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/ProductCreate'
responses:
'201':
description: Created
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

/products/{product_id}:
get:
summary: Get a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
responses:
'200':
description: Success
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

put:
summary: Update a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
requestBody:
required: true
content:
application/json:
schema:
$ref: '#/components/schemas/ProductUpdate'
responses:
'200':
description: Success
content:
application/json:
schema:
$ref: '#/components/schemas/Product'

delete:
summary: Delete a product
parameters:
 - name: product_id
in: path
required: true
schema:
type: integer
responses:
'204':
description: No content

components:
schemas:
Product:
type: object
properties:
id:
type: integer
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string
created_at:
type: string
format: date-time
updated_at:
type: string
format: date-time

ProductCreate:
type: object
required:
 - name
 - price
 - stock
 - category
properties:
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string

ProductUpdate:
type: object
properties:
name:
type: string
description:
type: string
price:
type: number
stock:
type: integer
category:
type: string

```> Claude Code 生成的代码：

```
python

from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from typing import Optional

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///products.db'

db = SQLAlchemy(app)

class Product(db.Model):
    """商品模型"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False)
    stock = db.Column(db.Integer, nullable=False)
    category = db.Column(db.String(100), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        """转换为字典"""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'price': self.price,
            'stock': self.stock,
            'category': self.category,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

@app.route('/products', methods=['GET'])
def get_products():
    """获取所有商品"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    pagination = Product.query.paginate(page=page, per_page=per_page)

    return jsonify({
        'products': [product.to_dict() for product in pagination.items],
        'total': pagination.total,
        'page': page
    })

@app.route('/products', methods=['POST'])
def create_product():
    """创建商品"""
    data = request.get_json()

    # 验证必填字段
    required_fields = ['name', 'price', 'stock', 'category']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'Missing required field: {field}'}), 400

    # 验证数据类型
    if not isinstance(data['price'], (int, float)) or data['price'] < 0:
        return jsonify({'error': 'Price must be a positive number'}), 400

    if not isinstance(data['stock'], int) or data['stock'] < 0:
        return jsonify({'error': 'Stock must be a non-negative integer'}), 400

    # 创建商品
    product = Product(
        name=data['name'],
        description=data.get('description'),
        price=data['price'],
        stock=data['stock'],
        category=data['category']
    )

    db.session.add(product)
    db.session.commit()

    return jsonify(product.to_dict()), 201

@app.route('/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    """获取商品详情"""
    product = Product.query.get_or_404(product_id)
    return jsonify(product.to_dict())

@app.route('/products/<int:product_id>', methods=['PUT'])
def update_product(product_id):
    """更新商品"""
    product = Product.query.get_or_404(product_id)
    data = request.get_json()

    # 更新字段
    if 'name' in data:
        product.name = data['name']

    if 'description' in data:
        product.description = data['description']

    if 'price' in data:
        if not isinstance(data['price'], (int, float)) or data['price'] < 0:
            return jsonify({'error': 'Price must be a positive number'}), 400
        product.price = data['price']

    if 'stock' in data:
        if not isinstance(data['stock'], int) or data['stock'] < 0:
            return jsonify({'error': 'Stock must be a non-negative integer'}), 400
        product.stock = data['stock']

    if 'category' in data:
        product.category = data['category']

    product.updated_at = datetime.utcnow()
    db.session.commit()

    return jsonify(product.to_dict())

@app.route('/products/<int:product_id>', methods=['DELETE'])
def delete_product(product_id):
    """删除商品"""
    product = Product.query.get_or_404(product_id)
    db.session.delete(product)
    db.session.commit()

    return '', 204

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)

> **生成的代码包含**:
> - 完整的 CRUD 操作
> - 数据验证
> - 分页功能
> - 错误处理
> - 符合 OpenAPI 规范

## 代码补全
### 1. 智能方法补全

```
python

# 示例：智能方法补全

用户输入：
```python
```python

class OrderService:
    def __init__(self, db):
        self.db = db

    def create_order(self, user_id, items):
        """创建订单"""
        pass

Claude Code 自动补全：

````python
````python

class OrderService:
def __init__(self, db):
self.db = db

def create_order(self, user_id, items):
"""
创建订单

参数:
user_id: 用户 ID
items: 商品列表 [{'product_id': 1, 'quantity': 2}, ...]

返回:
订单对象
"""
 # 验证用户
user = self.db.session.query(User).filter_by(id=user_id).first()
if not user:
raise UserNotFoundError(f"User with id {user_id} not found")

 # 验证商品
product_ids = [item['product_id'] for item in items]
products = self.db.session.query(Product).filter(
Product.id.in_(product_ids)
).all()

product_map = {product.id: product for product in products}

for item in items:
if item['product_id'] not in product_map:
raise ProductNotFoundError(
f"Product with id {item['product_id']} not found"
)

product = product_map[item['product_id']]
if product.stock < item['quantity']:
raise InsufficientStockError(
f"Insufficient stock for product {product.name}"
)

 # 计算总金额
total_amount = sum(
product_map[item['product_id']].price * item['quantity']
for item in items
)

 # 创建订单
order = Order(
user_id=user_id,
total_amount=total_amount,
status='pending'
)

self.db.session.add(order)
self.db.session.flush()

 # 创建订单项
for item in items:
product = product_map[item['product_id']]
order_item = OrderItem(
order_id=order.id,
product_id=item['product_id'],
quantity=item['quantity'],
price=product.price
)
self.db.session.add(order_item)

 # 扣减库存
product.stock -= item['quantity']

self.db.session.commit()

return order

def get_order(self, order_id):
"""获取订单详情"""
order = self.db.session.query(Order).filter_by(id=order_id).first()
if not order:
raise OrderNotFoundError(f"Order with id {order_id} not found")
return order

def update_order_status(self, order_id, status):
"""更新订单状态"""
order = self.get_order(order_id)
order.status = status
order.updated_at = datetime.utcnow()
self.db.session.commit()
return order

def cancel_order(self, order_id):
"""取消订单"""
order = self.get_order(order_id)

if order.status in ['paid', 'shipped', 'completed']:
raise InvalidOrderStatusError(
f"Cannot cancel order with status {order.status}"
)

 # 恢复库存
for item in order.items:
product = self.db.session.query(Product).filter_by(
id=item.product_id
).first()
if product:
product.stock += item.quantity

order.status = 'cancelled'
order.updated_at = datetime.utcnow()
self.db.session.commit()

return order

def get_user_orders(self, user_id, page=1, per_page=20):
"""获取用户订单列表"""
pagination = self.db.session.query(Order).filter_by(
user_id=user_id
).order_by(
Order.created_at.desc()
).paginate(page=page, per_page=per_page)

return pagination

```> **补全的内容**:
> - 完整的方法实现
> - 数据验证
> - 错误处理
> - 库存管理
> - 相关方法补全

```
### 2. 智能类补全

# 示例：智能类补全
用户输入：
````python
`python

class UserRepository:
def __init__(self, db):
self.db = db

```> Claude Code 自动补全：

```
python

from typing import List, Optional
from datetime import datetime

class UserRepository:
    """用户仓储类"""

    def __init__(self, db):
        self.db = db

    def find_by_id(self, user_id: int) -> Optional[User]:
        """根据 ID 查找用户"""
        return self.db.session.query(User).filter_by(id=user_id).first()

    def find_by_username(self, username: str) -> Optional[User]:
        """根据用户名查找用户"""
        return self.db.session.query(User).filter_by(username=username).first()

    def find_by_email(self, email: str) -> Optional[User]:
        """根据邮箱查找用户"""
        return self.db.session.query(User).filter_by(email=email).first()

    def find_all(self, page: int = 1, per_page: int = 20):
        """查找所有用户"""
        return self.db.session.query(User).paginate(
            page=page,
            per_page=per_page
        )

    def create(self, user: User) -> User:
        """创建用户"""
        self.db.session.add(user)
        self.db.session.commit()
        return user

    def update(self, user: User) -> User:
        """更新用户"""
        user.updated_at = datetime.utcnow()
        self.db.session.commit()
        return user

    def delete(self, user_id: int) -> bool:
        """删除用户"""
        user = self.find_by_id(user_id)
        if not user:
            return False

        self.db.session.delete(user)
        self.db.session.commit()
        return True

    def exists_by_username(self, username: str) -> bool:
        """检查用户名是否存在"""
        return self.db.session.query(User).filter_by(
            username=username
        ).first() is not None

    def exists_by_email(self, email: str) -> bool:
        """检查邮箱是否存在"""
        return self.db.session.query(User).filter_by(
            email=email
        ).first() is not None

    def count(self) -> int:
        """统计用户数量"""
        return self.db.session.query(User).count()

    def search(self, keyword: str, page: int = 1, per_page: int = 20):
        """搜索用户"""
        return self.db.session.query(User).filter(
            User.username.ilike(f'%{keyword}%') |
            User.email.ilike(f'%{keyword}%')
        ).paginate(page=page, per_page=per_page)

> **补全的内容**:
> - 完整的 CRUD 方法
> - 查询方法
> - 存在性检查
> - 搜索功能
> - 分页支持
```

---

## 3 代码理解与分析

**URL**: https://claudecode.tangshuang.net/course/25.3%20%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3%E4%B8%8E%E5%88%86%E6%9E%90

#### 代码理解与分析概述#

Claude Code 具备强大的代码理解与分析能力，可以深入分析代码结构、识别潜在问题、提供优化建议，并生成详细的代码分析报告。

#### 代码理解#

##### 1. 代码结构分析#

### 示例：分析代码结构

用户请求：
"分析这个项目的代码结构"

Claude Code 生成的分析报告：

#### 代码结构分析#

##### 项目概览#

```
bash复制├── app/
│   ├── __init__.py
│   ├── models/              # 数据模型层
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── services/            # 业务逻辑层
```

```
├── app/
│   ├── __init__.py
│   ├── models/              # 数据模型层
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── services/            # 业务逻辑层
```

│   │   ├── init.py
│   │   ├── user_service.py
│   │   ├── product_service.py
│   │   └── order_service.py
│   ├── controllers/         # 控制器层
│   │   ├── init.py
│   │   ├── user_controller.py
│   │   ├── product_controller.py
│   │   └── order_controller.py
│   └── utils/               # 工具模块
│       ├── init.py
│       ├── validators.py
│       └── helpers.py
├── tests/                   # 测试代码
│   ├── init.py
│   ├── test_user_service.py
│   ├── test_product_service.py
│   └── test_order_service.py
├── config/                  # 配置文件
│   ├── init.py
│   ├── development.py
│   ├── production.py
│   └── testing.py
└── main.py                  # 应用入口

```
bash复制### 架构模式

> **分层架构**:
> - **表现层 (Controllers)**: 处理 HTTP 请求和响应
> - **业务逻辑层 (Services)**: 实现核心业务逻辑
> - **数据访问层 (Models)**: 定义数据模型和数据库操作
> - **工具层 (Utils)**: 提供通用工具函数

### 依赖关系

```mermaid
mermaid

graph TD
    A[Controllers] --> B[Services]
    B --> C[Models]
    B --> D[Utils]
    C --> E[Database]
    A --> D

### 模块职责

| 模块 | 职责 | 依赖 |
|------|------|------|
| Controllers | 处理 HTTP 请求，调用服务层 | Services, Utils |
| Services | 实现业务逻辑，协调数据操作 | Models, Utils |
| Models | 定义数据模型，数据库操作 | Database |
| Utils | 提供通用工具函数 | 无 |

### 代码统计

| 指标 | 数值 |
|------|------|
| 总文件数 | 23 |
| 总代码行数 | 3,456 |
| Python 文件 | 18 |
| 测试文件 | 4 |
| 配置文件 | 3 |
| 函数总数 | 156 |
| 类总数 | 12 |
| 模块总数 | 10 |

### 代码质量指标

| 指标 | 平均值 | 目标值 | 状态 |
|------|--------|--------|------|
| 圈复杂度 | 6.5 | < 10 | ✓ 良好 |
| 代码重复率 | 8.3% | < 5% | ⚠ 需要改进 |
| 测试覆盖率 | 82.5% | > 80% | ✓ 良好 |
| 文档覆盖率 | 75.2% | > 70% | ✓ 良好 |
| 平均函数长度 | 15.2 行 | < 20 行 | ✓ 良好 |

### 2. 代码逻辑分析
```python
python

# 示例：分析代码逻辑

用户请求：
"分析这个函数的逻辑"

代码：
```python
```python

def calculate_order_total(order):
    total = 0

    # 计算商品总价
    for item in order['items']:
        total += item['price'] * item['quantity']

    # 应用折扣
    if 'discount' in order:
        if order['discount']['type'] == 'percentage':
            total *= (1 - order['discount']['value'] / 100)
        elif order['discount']['type'] == 'fixed':
            total -= order['discount']['value']

    # 应用税费
    if 'tax' in order:
        total *= (1 + order['tax']['rate'] / 100)

    # 应用运费
    if 'shipping' in order:
        total += order['shipping']['cost']

    # 确保总价不为负
    total = max(total, 0)

    return total

Claude Code 生成的分析：

## 代码逻辑分析

### 函数: calculate_order_total

> **功能**: 计算订单总价

> **参数**:
> - `order`: 订单信息字典
 - `items`: 商品列表
 - `price`: 商品单价
 - `quantity`: 商品数量
 - `discount`: 折扣信息（可选）
 - `type`: 折扣类型（percentage/fixed）
 - `value`: 折扣值
 - `tax`: 税费信息（可选）
 - `rate`: 税率
 - `shipping`: 运费信息（可选）
 - `cost`: 运费

> **返回值**: 订单总价

### 逻辑流程

`````> > 开始
↓
初始化 total = 0
↓
遍历订单商品
↓
total += price * quantity
↓
是否有折扣？
↓ 是
折扣类型？
↓ percentage
total *= (1 - value / 100)
↓ fixed
total -= value
↓ 否
↓
是否有税费？
↓ 是
total *= (1 + rate / 100)
↓ 否
↓
是否有运费？
↓ 是
total += cost
↓ 否
↓
total = max(total, 0)
↓
返回 total
```

```
### 架构模式

> **分层架构**:
> - **表现层 (Controllers)**: 处理 HTTP 请求和响应
> - **业务逻辑层 (Services)**: 实现核心业务逻辑
> - **数据访问层 (Models)**: 定义数据模型和数据库操作
> - **工具层 (Utils)**: 提供通用工具函数

### 依赖关系

```mermaid
mermaid

graph TD
    A[Controllers] --> B[Services]
    B --> C[Models]
    B --> D[Utils]
    C --> E[Database]
    A --> D

### 模块职责

| 模块 | 职责 | 依赖 |
|------|------|------|
| Controllers | 处理 HTTP 请求，调用服务层 | Services, Utils |
| Services | 实现业务逻辑，协调数据操作 | Models, Utils |
| Models | 定义数据模型，数据库操作 | Database |
| Utils | 提供通用工具函数 | 无 |

### 代码统计

| 指标 | 数值 |
|------|------|
| 总文件数 | 23 |
| 总代码行数 | 3,456 |
| Python 文件 | 18 |
| 测试文件 | 4 |
| 配置文件 | 3 |
| 函数总数 | 156 |
| 类总数 | 12 |
| 模块总数 | 10 |

### 代码质量指标

| 指标 | 平均值 | 目标值 | 状态 |
|------|--------|--------|------|
| 圈复杂度 | 6.5 | < 10 | ✓ 良好 |
| 代码重复率 | 8.3% | < 5% | ⚠ 需要改进 |
| 测试覆盖率 | 82.5% | > 80% | ✓ 良好 |
| 文档覆盖率 | 75.2% | > 70% | ✓ 良好 |
| 平均函数长度 | 15.2 行 | < 20 行 | ✓ 良好 |

### 2. 代码逻辑分析
```python
python

# 示例：分析代码逻辑

用户请求：
"分析这个函数的逻辑"

代码：
```python
```python

def calculate_order_total(order):
    total = 0

    # 计算商品总价
    for item in order['items']:
        total += item['price'] * item['quantity']

    # 应用折扣
    if 'discount' in order:
        if order['discount']['type'] == 'percentage':
            total *= (1 - order['discount']['value'] / 100)
        elif order['discount']['type'] == 'fixed':
            total -= order['discount']['value']

    # 应用税费
    if 'tax' in order:
        total *= (1 + order['tax']['rate'] / 100)

    # 应用运费
    if 'shipping' in order:
        total += order['shipping']['cost']

    # 确保总价不为负
    total = max(total, 0)

    return total

Claude Code 生成的分析：

## 代码逻辑分析

### 函数: calculate_order_total

> **功能**: 计算订单总价

> **参数**:
> - `order`: 订单信息字典
 - `items`: 商品列表
 - `price`: 商品单价
 - `quantity`: 商品数量
 - `discount`: 折扣信息（可选）
 - `type`: 折扣类型（percentage/fixed）
 - `value`: 折扣值
 - `tax`: 税费信息（可选）
 - `rate`: 税率
 - `shipping`: 运费信息（可选）
 - `cost`: 运费

> **返回值**: 订单总价

### 逻辑流程

`````> > 开始
↓
初始化 total = 0
↓
遍历订单商品
↓
total += price * quantity
↓
是否有折扣？
↓ 是
折扣类型？
↓ percentage
total *= (1 - value / 100)
↓ fixed
total -= value
↓ 否
↓
是否有税费？
↓ 是
total *= (1 + rate / 100)
↓ 否
↓
是否有运费？
↓ 是
total += cost
↓ 否
↓
total = max(total, 0)
↓
返回 total
```

##### 计算步骤#

True. 商品总价计算

- 遍历所有商品
- 累加：单价 × 数量

True. 折扣应用

- 百分比折扣：total × (1 - 折扣值/100)
- 固定金额折扣：total - 折扣值

True. 税费应用

- total × (1 + 税率/100)

True. 运费应用

- total + 运费

True. 价格保护

- 确保总价不为负

##### 计算示例#

```
bash复制python

# 示例 1: 无折扣、无税费、无运费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ]
}
# 商品总价: 100*2 + 50*1 = 250
# 折扣: 0
# 税费: 0
# 运费: 0
# 最终价格: 250

# 示例 2: 百分比折扣 + 税费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ],
    'discount': {'type': 'percentage', 'value': 10},
    'tax': {'rate': 5}
}
# 商品总价: 250
# 折扣: 250 * (1 - 0.1) = 225
# 税费: 225 * (1 + 0.05) = 236.25
# 运费: 0
# 最终价格: 236.25

# 示例 3: 固定折扣 + 税费 + 运费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ],
    'discount': {'type': 'fixed', 'value': 20},
    'tax': {'rate': 5},
    'shipping': {'cost': 10}
}
# 商品总价: 250
# 折扣: 250 - 20 = 230
# 税费: 230 * (1 + 0.05) = 241.5
# 运费: 241.5 + 10 = 251.5
# 最终价格: 251.5

# 示例 4: 折扣超过商品总价
order = {
    'items': [
        {'price': 10, 'quantity': 1}
    ],
    'discount': {'type': 'fixed', 'value': 20}
}
# 商品总价: 10
# 折扣: 10 - 20 = -10
# 价格保护: max(-10, 0) = 0
# 最终价格: 0

### 边界情况

| 情况 | 输入 | 输出 | 说明 |
|------|------|------|------|
| 空订单 | {'items': []} | 0 | 无商品，总价为 0 |
| 折扣为 0 | discount={'value': 0} | 原价 | 折扣值为 0，不影响总价 |
| 折扣超过总价 | discount={'value': 1000} | 0 | 价格保护，确保不为负 |
| 税率为 0 | tax={'rate': 0} | 原价 | 税率为 0，不影响总价 |
| 运费为 0 | shipping={'cost': 0} | 原价 | 运费为 0，不影响总价 |

### 代码质量评估

| 指标 | 评分 | 说明 |
|------|------|------|
| 可读性 | 9/10 | 逻辑清晰，易于理解 |
| 可维护性 | 8/10 | 结构清晰，易于修改 |
| 可扩展性 | 7/10 | 添加新折扣类型需要修改代码 |
| 测试性 | 9/10 | 容易编写单元测试 |
| 性能 | 10/10 | 时间复杂度 O(n)，性能优秀 |

### 改进建议

````python
````python

from enum import Enum
from typing import Optional, List

class DiscountType(Enum):
"""折扣类型"""
PERCENTAGE = 'percentage'
FIXED = 'fixed'

class OrderItem:
"""订单项"""
def __init__(self, price: float, quantity: int):
self.price = price
self.quantity = quantity

class Discount:
"""折扣"""
def __init__(self, discount_type: DiscountType, value: float):
self.type = discount_type
self.value = value

class Tax:
"""税费"""
def __init__(self, rate: float):
self.rate = rate

class Shipping:
"""运费"""
def __init__(self, cost: float):
self.cost = cost

class Order:
"""订单"""
def __init__(
self,
items: List[OrderItem],
discount: Optional[Discount] = None,
tax: Optional[Tax] = None,
shipping: Optional[Shipping] = None
):
self.items = items
self.discount = discount
self.tax = tax
self.shipping = shipping

class OrderCalculator:
"""订单计算器"""

@staticmethod
def calculate_total(order: Order) -> float:
"""计算订单总价"""
total = OrderCalculator._calculate_items_total(order.items)
total = OrderCalculator._apply_discount(total, order.discount)
total = OrderCalculator._apply_tax(total, order.tax)
total = OrderCalculator._apply_shipping(total, order.shipping)
total = max(total, 0)

return total

@staticmethod
def _calculate_items_total(items: List[OrderItem]) -> float:
"""计算商品总价"""
return sum(item.price * item.quantity for item in items)

@staticmethod
def _apply_discount(total: float, discount: Optional[Discount]) -> float:
"""应用折扣"""
if not discount:
return total

if discount.type == DiscountType.PERCENTAGE:
return total * (1 - discount.value / 100)
elif discount.type == DiscountType.FIXED:
return total - discount.value

return total

@staticmethod
def _apply_tax(total: float, tax: Optional[Tax]) -> float:
"""应用税费"""
if not tax:
return total

return total * (1 + tax.rate / 100)

@staticmethod
def _apply_shipping(total: float, shipping: Optional[Shipping]) -> float:
"""应用运费"""
if not shipping:
return total

return total + shipping.cost

```> **改进优势**:
> - 使用类型提示
> - 使用枚举定义折扣类型
> - 提取方法，提高可读性
> - 使用数据类，提高可维护性
```

```
python

# 示例 1: 无折扣、无税费、无运费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ]
}
# 商品总价: 100*2 + 50*1 = 250
# 折扣: 0
# 税费: 0
# 运费: 0
# 最终价格: 250

# 示例 2: 百分比折扣 + 税费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ],
    'discount': {'type': 'percentage', 'value': 10},
    'tax': {'rate': 5}
}
# 商品总价: 250
# 折扣: 250 * (1 - 0.1) = 225
# 税费: 225 * (1 + 0.05) = 236.25
# 运费: 0
# 最终价格: 236.25

# 示例 3: 固定折扣 + 税费 + 运费
order = {
    'items': [
        {'price': 100, 'quantity': 2},
        {'price': 50, 'quantity': 1}
    ],
    'discount': {'type': 'fixed', 'value': 20},
    'tax': {'rate': 5},
    'shipping': {'cost': 10}
}
# 商品总价: 250
# 折扣: 250 - 20 = 230
# 税费: 230 * (1 + 0.05) = 241.5
# 运费: 241.5 + 10 = 251.5
# 最终价格: 251.5

# 示例 4: 折扣超过商品总价
order = {
    'items': [
        {'price': 10, 'quantity': 1}
    ],
    'discount': {'type': 'fixed', 'value': 20}
}
# 商品总价: 10
# 折扣: 10 - 20 = -10
# 价格保护: max(-10, 0) = 0
# 最终价格: 0

### 边界情况

| 情况 | 输入 | 输出 | 说明 |
|------|------|------|------|
| 空订单 | {'items': []} | 0 | 无商品，总价为 0 |
| 折扣为 0 | discount={'value': 0} | 原价 | 折扣值为 0，不影响总价 |
| 折扣超过总价 | discount={'value': 1000} | 0 | 价格保护，确保不为负 |
| 税率为 0 | tax={'rate': 0} | 原价 | 税率为 0，不影响总价 |
| 运费为 0 | shipping={'cost': 0} | 原价 | 运费为 0，不影响总价 |

### 代码质量评估

| 指标 | 评分 | 说明 |
|------|------|------|
| 可读性 | 9/10 | 逻辑清晰，易于理解 |
| 可维护性 | 8/10 | 结构清晰，易于修改 |
| 可扩展性 | 7/10 | 添加新折扣类型需要修改代码 |
| 测试性 | 9/10 | 容易编写单元测试 |
| 性能 | 10/10 | 时间复杂度 O(n)，性能优秀 |

### 改进建议

````python
````python

from enum import Enum
from typing import Optional, List

class DiscountType(Enum):
"""折扣类型"""
PERCENTAGE = 'percentage'
FIXED = 'fixed'

class OrderItem:
"""订单项"""
def __init__(self, price: float, quantity: int):
self.price = price
self.quantity = quantity

class Discount:
"""折扣"""
def __init__(self, discount_type: DiscountType, value: float):
self.type = discount_type
self.value = value

class Tax:
"""税费"""
def __init__(self, rate: float):
self.rate = rate

class Shipping:
"""运费"""
def __init__(self, cost: float):
self.cost = cost

class Order:
"""订单"""
def __init__(
self,
items: List[OrderItem],
discount: Optional[Discount] = None,
tax: Optional[Tax] = None,
shipping: Optional[Shipping] = None
):
self.items = items
self.discount = discount
self.tax = tax
self.shipping = shipping

class OrderCalculator:
"""订单计算器"""

@staticmethod
def calculate_total(order: Order) -> float:
"""计算订单总价"""
total = OrderCalculator._calculate_items_total(order.items)
total = OrderCalculator._apply_discount(total, order.discount)
total = OrderCalculator._apply_tax(total, order.tax)
total = OrderCalculator._apply_shipping(total, order.shipping)
total = max(total, 0)

return total

@staticmethod
def _calculate_items_total(items: List[OrderItem]) -> float:
"""计算商品总价"""
return sum(item.price * item.quantity for item in items)

@staticmethod
def _apply_discount(total: float, discount: Optional[Discount]) -> float:
"""应用折扣"""
if not discount:
return total

if discount.type == DiscountType.PERCENTAGE:
return total * (1 - discount.value / 100)
elif discount.type == DiscountType.FIXED:
return total - discount.value

return total

@staticmethod
def _apply_tax(total: float, tax: Optional[Tax]) -> float:
"""应用税费"""
if not tax:
return total

return total * (1 + tax.rate / 100)

@staticmethod
def _apply_shipping(total: float, shipping: Optional[Shipping]) -> float:
"""应用运费"""
if not shipping:
return total

return total + shipping.cost

```> **改进优势**:
> - 使用类型提示
> - 使用枚举定义折扣类型
> - 提取方法，提高可读性
> - 使用数据类，提高可维护性
```

#### 代码分析#

##### 1. 性能分析#

### 示例：性能分析

用户请求：
"分析这个函数的性能"
代码：

```
python复制`python

def find_duplicates(items):
"""查找重复项"""
duplicates = []

for i, item1 in enumerate(items):
for j, item2 in enumerate(items):
if i != j and item1 == item2:
duplicates.append(item1)
break

return duplicates

```> Claude Code 生成的分析：

## 性能分析

### 函数: find_duplicates

> **功能**: 查找列表中的重复项

### 性能指标

| 指标 | 值 | 说明 |
|------|-----|------|
| 时间复杂度 | O(n²) | 嵌套循环 |
| 空间复杂度 | O(n) | 存储重复项 |
| 执行时间 (1000 项) | 500ms | 较慢 |
| 执行时间 (10000 项) | 50000ms | 很慢 |

### 性能问题

1. **嵌套循环**: O(n²) 时间复杂度
2. **重复比较**: 每对元素比较两次
3. **未使用优化数据结构**: 可以使用集合或字典

### 优化方案

```
python

def find_duplicates_optimized(items):
    """查找重复项（优化后）"""
    seen = set()
    duplicates = set()

    for item in items:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)

    return list(duplicates)

### 优化效果

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 时间复杂度 | O(n²) | O(n) | 显著改善 |
| 空间复杂度 | O(n) | O(n) | 相同 |
| 执行时间 (1000 项) | 500ms | 5ms | 99% ↓ |
| 执行时间 (10000 项) | 50000ms | 50ms | 99.9% ↓ |

### 2. 安全分析

```
python

# 示例：安全分析

用户请求：
"分析这个函数的安全性"

代码：
```python
```python

def execute_query(query):
    """执行 SQL 查询"""
    connection = get_connection()
    cursor = connection.cursor()
    cursor.execute(query)
    results = cursor.fetchall()
    connection.close()
    return results

Claude Code 生成的分析：

## 安全分析

### 函数: execute_query

> **安全风险**: 高

### 安全问题

1. **SQL 注入漏洞**
 - 直接执行用户提供的查询
 - 没有参数化查询
 - 攻击者可以执行任意 SQL

2. **资源泄漏**
 - 连接没有正确关闭
 - 异常情况下连接可能泄漏

### 攻击示例

````python
````python

# 正常查询
query = "SELECT * FROM users WHERE id = 1"
execute_query(query)

# SQL 注入攻击
query = "SELECT * FROM users WHERE id = 1; DROP TABLE users; --"
execute_query(query)
# 结果：删除整个 users 表

```### 修复方案

```
python

def execute_query(query, params=None):
    """执行 SQL 查询（安全版本）"""
    connection = None
    cursor = None

    try:
        connection = get_connection()
        cursor = connection.cursor()

        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)

        results = cursor.fetchall()

        return results

    except Exception as e:
        # 记录错误
        logger.error(f"Query execution failed: {e}")
        raise

    finally:
        # 确保连接关闭
        if cursor:
            cursor.close()
        if connection:
            connection.close()

### 安全最佳实践

### 使用 ORM 的版本

````python
````python

from sqlalchemy.orm import Session

def get_user_by_id(user_id: int, db: Session):
"""根据 ID 获取用户（使用 ORM）"""
return db.query(User).filter_by(id=user_id).first()

```> **优势**:
> - 自动防止 SQL 注入
> - 类型安全
> - 更易维护

```
## 总结

代码理解与分析包括：

1. **代码理解**: 代码结构分析、代码逻辑分析
2. **代码分析**: 性能分析、安全分析

通过这些分析，开发者可以更好地理解代码、识别潜在问题、优化代码性能。

在下一节中，我们将探讨智能测试。

```
```

```
`python

def find_duplicates(items):
"""查找重复项"""
duplicates = []

for i, item1 in enumerate(items):
for j, item2 in enumerate(items):
if i != j and item1 == item2:
duplicates.append(item1)
break

return duplicates

```> Claude Code 生成的分析：

## 性能分析

### 函数: find_duplicates

> **功能**: 查找列表中的重复项

### 性能指标

| 指标 | 值 | 说明 |
|------|-----|------|
| 时间复杂度 | O(n²) | 嵌套循环 |
| 空间复杂度 | O(n) | 存储重复项 |
| 执行时间 (1000 项) | 500ms | 较慢 |
| 执行时间 (10000 项) | 50000ms | 很慢 |

### 性能问题

1. **嵌套循环**: O(n²) 时间复杂度
2. **重复比较**: 每对元素比较两次
3. **未使用优化数据结构**: 可以使用集合或字典

### 优化方案

```
python

def find_duplicates_optimized(items):
    """查找重复项（优化后）"""
    seen = set()
    duplicates = set()

    for item in items:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)

    return list(duplicates)

### 优化效果

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 时间复杂度 | O(n²) | O(n) | 显著改善 |
| 空间复杂度 | O(n) | O(n) | 相同 |
| 执行时间 (1000 项) | 500ms | 5ms | 99% ↓ |
| 执行时间 (10000 项) | 50000ms | 50ms | 99.9% ↓ |

### 2. 安全分析

```
python

# 示例：安全分析

用户请求：
"分析这个函数的安全性"

代码：
```python
```python

def execute_query(query):
    """执行 SQL 查询"""
    connection = get_connection()
    cursor = connection.cursor()
    cursor.execute(query)
    results = cursor.fetchall()
    connection.close()
    return results

Claude Code 生成的分析：

## 安全分析

### 函数: execute_query

> **安全风险**: 高

### 安全问题

1. **SQL 注入漏洞**
 - 直接执行用户提供的查询
 - 没有参数化查询
 - 攻击者可以执行任意 SQL

2. **资源泄漏**
 - 连接没有正确关闭
 - 异常情况下连接可能泄漏

### 攻击示例

````python
````python

# 正常查询
query = "SELECT * FROM users WHERE id = 1"
execute_query(query)

# SQL 注入攻击
query = "SELECT * FROM users WHERE id = 1; DROP TABLE users; --"
execute_query(query)
# 结果：删除整个 users 表

```### 修复方案

```
python

def execute_query(query, params=None):
    """执行 SQL 查询（安全版本）"""
    connection = None
    cursor = None

    try:
        connection = get_connection()
        cursor = connection.cursor()

        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)

        results = cursor.fetchall()

        return results

    except Exception as e:
        # 记录错误
        logger.error(f"Query execution failed: {e}")
        raise

    finally:
        # 确保连接关闭
        if cursor:
            cursor.close()
        if connection:
            connection.close()

### 安全最佳实践

### 使用 ORM 的版本

````python
````python

from sqlalchemy.orm import Session

def get_user_by_id(user_id: int, db: Session):
"""根据 ID 获取用户（使用 ORM）"""
return db.query(User).filter_by(id=user_id).first()

```> **优势**:
> - 自动防止 SQL 注入
> - 类型安全
> - 更易维护

```
## 总结

代码理解与分析包括：

1. **代码理解**: 代码结构分析、代码逻辑分析
2. **代码分析**: 性能分析、安全分析

通过这些分析，开发者可以更好地理解代码、识别潜在问题、优化代码性能。

在下一节中，我们将探讨智能测试。

```
```

---

## 4 智能测试

**URL**: https://claudecode.tangshuang.net/course/25.4%20%E6%99%BA%E8%83%BD%E6%B5%8B%E8%AF%95

#### 智能测试概述#

Claude Code 可以自动生成测试代码、分析测试覆盖率、识别测试盲点，并提供测试优化建议。通过智能测试功能，开发者可以快速构建全面的测试套件，提高代码质量和可靠性。

#### 自动生成测试#

##### 1. 单元测试生成#

### 示例：生成单元测试

用户请求：
"为这个类生成单元测试"

```
python复制````python

class Calculator:
"""计算器类"""

def add(self, a, b):
"""加法"""
return a + b

def subtract(self, a, b):
"""减法"""
return a - b

def multiply(self, a, b):
"""乘法"""
return a * b

def divide(self, a, b):
"""除法"""
if b == 0:
raise ValueError("Cannot divide by zero")
return a / b

def power(self, a, b):
"""幂运算"""
return a ** b

def sqrt(self, a):
"""平方根"""
if a < 0:
raise ValueError("Cannot calculate square root of negative number")
return a ** 0.5

```> Claude Code 生成的测试：

```
python

import unittest
from calculator import Calculator

class TestCalculator(unittest.TestCase):
    """计算器测试类"""

    def setUp(self):
        """测试前设置"""
        self.calculator = Calculator()

    def test_add_positive_numbers(self):
        """测试正数加法"""
        result = self.calculator.add(5, 3)
        self.assertEqual(result, 8)

    def test_add_negative_numbers(self):
        """测试负数加法"""
        result = self.calculator.add(-5, -3)
        self.assertEqual(result, -8)

    def test_add_mixed_numbers(self):
        """测试混合符号加法"""
        result = self.calculator.add(5, -3)
        self.assertEqual(result, 2)

    def test_add_zero(self):
        """测试加零"""
        result = self.calculator.add(5, 0)
        self.assertEqual(result, 5)

    def test_add_float_numbers(self):
        """测试浮点数加法"""
        result = self.calculator.add(5.5, 3.3)
        self.assertAlmostEqual(result, 8.8, places=1)

    def test_subtract_positive_numbers(self):
        """测试正数减法"""
        result = self.calculator.subtract(10, 3)
        self.assertEqual(result, 7)

    def test_subtract_negative_numbers(self):
        """测试负数减法"""
        result = self.calculator.subtract(-10, -3)
        self.assertEqual(result, -7)

    def test_subtract_mixed_numbers(self):
        """测试混合符号减法"""
        result = self.calculator.subtract(10, -3)
        self.assertEqual(result, 13)

    def test_subtract_zero(self):
        """测试减零"""
        result = self.calculator.subtract(10, 0)
```

```
````python

class Calculator:
"""计算器类"""

def add(self, a, b):
"""加法"""
return a + b

def subtract(self, a, b):
"""减法"""
return a - b

def multiply(self, a, b):
"""乘法"""
return a * b

def divide(self, a, b):
"""除法"""
if b == 0:
raise ValueError("Cannot divide by zero")
return a / b

def power(self, a, b):
"""幂运算"""
return a ** b

def sqrt(self, a):
"""平方根"""
if a < 0:
raise ValueError("Cannot calculate square root of negative number")
return a ** 0.5

```> Claude Code 生成的测试：

```
python

import unittest
from calculator import Calculator

class TestCalculator(unittest.TestCase):
    """计算器测试类"""

    def setUp(self):
        """测试前设置"""
        self.calculator = Calculator()

    def test_add_positive_numbers(self):
        """测试正数加法"""
        result = self.calculator.add(5, 3)
        self.assertEqual(result, 8)

    def test_add_negative_numbers(self):
        """测试负数加法"""
        result = self.calculator.add(-5, -3)
        self.assertEqual(result, -8)

    def test_add_mixed_numbers(self):
        """测试混合符号加法"""
        result = self.calculator.add(5, -3)
        self.assertEqual(result, 2)

    def test_add_zero(self):
        """测试加零"""
        result = self.calculator.add(5, 0)
        self.assertEqual(result, 5)

    def test_add_float_numbers(self):
        """测试浮点数加法"""
        result = self.calculator.add(5.5, 3.3)
        self.assertAlmostEqual(result, 8.8, places=1)

    def test_subtract_positive_numbers(self):
        """测试正数减法"""
        result = self.calculator.subtract(10, 3)
        self.assertEqual(result, 7)

    def test_subtract_negative_numbers(self):
        """测试负数减法"""
        result = self.calculator.subtract(-10, -3)
        self.assertEqual(result, -7)

    def test_subtract_mixed_numbers(self):
        """测试混合符号减法"""
        result = self.calculator.subtract(10, -3)
        self.assertEqual(result, 13)

    def test_subtract_zero(self):
        """测试减零"""
        result = self.calculator.subtract(10, 0)
```

```
bash复制    self.assertEqual(result, 10)

def test_multiply_positive_numbers(self):
    """测试正数乘法"""
    result = self.calculator.multiply(5, 3)
    self.assertEqual(result, 15)

def test_multiply_negative_numbers(self):
    """测试负数乘法"""
    result = self.calculator.multiply(-5, -3)
    self.assertEqual(result, 15)

def test_multiply_mixed_numbers(self):
    """测试混合符号乘法"""
    result = self.calculator.multiply(-5, 3)
    self.assertEqual(result, -15)

def test_multiply_by_zero(self):
    """测试乘以零"""
    result = self.calculator.multiply(5, 0)
    self.assertEqual(result, 0)

def test_multiply_float_numbers(self):
    """测试浮点数乘法"""
    result = self.calculator.multiply(2.5, 4)
    self.assertEqual(result, 10.0)

def test_divide_positive_numbers(self):
    """测试正数除法"""
    result = self.calculator.divide(10, 2)
    self.assertEqual(result, 5.0)

def test_divide_negative_numbers(self):
    """测试负数除法"""
    result = self.calculator.divide(-10, -2)
    self.assertEqual(result, 5.0)

def test_divide_mixed_numbers(self):
    """测试混合符号除法"""
    result = self.calculator.divide(-10, 2)
    self.assertEqual(result, -5.0)

def test_divide_by_zero_raises_error(self):
    """测试除以零抛出异常"""
    with self.assertRaises(ValueError) as context:
        self.calculator.divide(10, 0)
    self.assertEqual(str(context.exception), "Cannot divide by zero")

def test_divide_float_numbers(self):
    """测试浮点数除法"""
    result = self.calculator.divide(7, 2)
    self.assertEqual(result, 3.5)

def test_power_positive_exponent(self):
    """测试正指数幂运算"""
    result = self.calculator.power(2, 3)
    self.assertEqual(result, 8)

def test_power_negative_exponent(self):
    """测试负指数幂运算"""
    result = self.calculator.power(2, -2)
    self.assertEqual(result, 0.25)

def test_power_zero_exponent(self):
    """测试零指数幂运算"""
    result = self.calculator.power(5, 0)
    self.assertEqual(result, 1)

def test_power_zero_base(self):
    """测试零底数幂运算"""
    result = self.calculator.power(0, 5)
    self.assertEqual(result, 0)

def test_power_float_exponent(self):
    """测试浮点数指数幂运算"""
    result = self.calculator.power(4, 0.5)
    self.assertEqual(result, 2.0)

def test_sqrt_positive_number(self):
    """测试正数平方根"""
    result = self.calculator.sqrt(16)
    self.assertEqual(result, 4.0)

def test_sqrt_zero(self):
    """测试零平方根"""
    result = self.calculator.sqrt(0)
    self.assertEqual(result, 0.0)

def test_sqrt_negative_number_raises_error(self):
    """测试负数平方根抛出异常"""
    with self.assertRaises(ValueError) as context:
        self.calculator.sqrt(-4)
    self.assertEqual(
        str(context.exception),
        "Cannot calculate square root of negative number"
    )

def test_sqrt_float_number(self):
    """测试浮点数平方根"""
    result = self.calculator.sqrt(2.25)
    self.assertEqual(result, 1.5)
```

```
self.assertEqual(result, 10)

def test_multiply_positive_numbers(self):
    """测试正数乘法"""
    result = self.calculator.multiply(5, 3)
    self.assertEqual(result, 15)

def test_multiply_negative_numbers(self):
    """测试负数乘法"""
    result = self.calculator.multiply(-5, -3)
    self.assertEqual(result, 15)

def test_multiply_mixed_numbers(self):
    """测试混合符号乘法"""
    result = self.calculator.multiply(-5, 3)
    self.assertEqual(result, -15)

def test_multiply_by_zero(self):
    """测试乘以零"""
    result = self.calculator.multiply(5, 0)
    self.assertEqual(result, 0)

def test_multiply_float_numbers(self):
    """测试浮点数乘法"""
    result = self.calculator.multiply(2.5, 4)
    self.assertEqual(result, 10.0)

def test_divide_positive_numbers(self):
    """测试正数除法"""
    result = self.calculator.divide(10, 2)
    self.assertEqual(result, 5.0)

def test_divide_negative_numbers(self):
    """测试负数除法"""
    result = self.calculator.divide(-10, -2)
    self.assertEqual(result, 5.0)

def test_divide_mixed_numbers(self):
    """测试混合符号除法"""
    result = self.calculator.divide(-10, 2)
    self.assertEqual(result, -5.0)

def test_divide_by_zero_raises_error(self):
    """测试除以零抛出异常"""
    with self.assertRaises(ValueError) as context:
        self.calculator.divide(10, 0)
    self.assertEqual(str(context.exception), "Cannot divide by zero")

def test_divide_float_numbers(self):
    """测试浮点数除法"""
    result = self.calculator.divide(7, 2)
    self.assertEqual(result, 3.5)

def test_power_positive_exponent(self):
    """测试正指数幂运算"""
    result = self.calculator.power(2, 3)
    self.assertEqual(result, 8)

def test_power_negative_exponent(self):
    """测试负指数幂运算"""
    result = self.calculator.power(2, -2)
    self.assertEqual(result, 0.25)

def test_power_zero_exponent(self):
    """测试零指数幂运算"""
    result = self.calculator.power(5, 0)
    self.assertEqual(result, 1)

def test_power_zero_base(self):
    """测试零底数幂运算"""
    result = self.calculator.power(0, 5)
    self.assertEqual(result, 0)

def test_power_float_exponent(self):
    """测试浮点数指数幂运算"""
    result = self.calculator.power(4, 0.5)
    self.assertEqual(result, 2.0)

def test_sqrt_positive_number(self):
    """测试正数平方根"""
    result = self.calculator.sqrt(16)
    self.assertEqual(result, 4.0)

def test_sqrt_zero(self):
    """测试零平方根"""
    result = self.calculator.sqrt(0)
    self.assertEqual(result, 0.0)

def test_sqrt_negative_number_raises_error(self):
    """测试负数平方根抛出异常"""
    with self.assertRaises(ValueError) as context:
        self.calculator.sqrt(-4)
    self.assertEqual(
        str(context.exception),
        "Cannot calculate square root of negative number"
    )

def test_sqrt_float_number(self):
    """测试浮点数平方根"""
    result = self.calculator.sqrt(2.25)
    self.assertEqual(result, 1.5)
```

if name == 'main':
unittest.main()

生成的测试包含:

- 正常情况测试
- 边界情况测试
- 异常情况测试
- 数据类型测试
- 浮点数精度测试

##### 2. 集成测试生成#

```
bash复制python

# 示例：生成集成测试

用户请求：
"为这个用户服务生成集成测试"

代码：
```python
```python

class UserService:
    """用户服务"""

    def __init__(self, db):
        self.db = db

    def create_user(self, username, email, password):
        """创建用户"""
        if self._user_exists(username):
            raise ValueError("Username already exists")

        if self._email_exists(email):
            raise ValueError("Email already exists")

        user = User(
            username=username,
            email=email,
            password_hash=self._hash_password(password)
        )

        self.db.session.add(user)
        self.db.session.commit()

        return user

    def get_user(self, user_id):
        """获取用户"""
        user = self.db.session.query(User).filter_by(id=user_id).first()
        if not user:
            raise ValueError("User not found")
        return user

    def update_user(self, user_id, **kwargs):
        """更新用户"""
        user = self.get_user(user_id)

        if 'username' in kwargs:
            if self._user_exists(kwargs['username'], exclude_id=user_id):
                raise ValueError("Username already exists")
            user.username = kwargs['username']

        if 'email' in kwargs:
            if self._email_exists(kwargs['email'], exclude_id=user_id):
                raise ValueError("Email already exists")
            user.email = kwargs['email']

        if 'password' in kwargs:
            user.password_hash = self._hash_password(kwargs['password'])

        self.db.session.commit()

        return user

    def delete_user(self, user_id):
        """删除用户"""
        user = self.get_user(user_id)
        self.db.session.delete(user)
        self.db.session.commit()

    def _user_exists(self, username, exclude_id=None):
        """检查用户名是否存在"""
        query = self.db.session.query(User).filter_by(username=username)
        if exclude_id:
            query = query.filter(User.id != exclude_id)
        return query.first() is not None

    def _email_exists(self, email, exclude_id=None):
        """检查邮箱是否存在"""
        query = self.db.session.query(User).filter_by(email=email)
        if exclude_id:
            query = query.filter(User.id != exclude_id)
        return query.first() is not None

    def _hash_password(self, password):
        """哈希密码"""
        import bcrypt
        return bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

Claude Code 生成的测试：

````python
````python

import unittest
from unittest.mock import Mock, MagicMock
from user_service import UserService
from models import User

class TestUserService(unittest.TestCase):
"""用户服务测试类"""

def setUp(self):
"""测试前设置"""
self.db = Mock()
self.db.session = MagicMock()
self.user_service = UserService(self.db)

def test_create_user_success(self):
"""测试成功创建用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

user = self.user_service.create_user(
username='testuser',
email='test@example.com',
password='password123'
)

self.db.session.add.assert_called_once()
self.db.session.commit.assert_called_once()
self.assertEqual(user.username, 'testuser')
self.assertEqual(user.email, 'test@example.com')

def test_create_user_duplicate_username(self):
"""测试创建用户时用户名重复"""
existing_user = Mock()
self.db.session.query.return_value.filter_by.return_value.first.return_value = existing_user

with self.assertRaises(ValueError) as context:
self.user_service.create_user(
username='existing',
email='test@example.com',
password='password123'
)

self.assertEqual(str(context.exception), "Username already exists")
self.db.session.add.assert_not_called()

def test_create_user_duplicate_email(self):
"""测试创建用户时邮箱重复"""
self.db.session.query.return_value.filter_by.side_effect = [
None,  # username check
Mock()  # email check
]

with self.assertRaises(ValueError) as context:
self.user_service.create_user(
username='testuser',
email='existing@example.com',
password='password123'
)

self.assertEqual(str(context.exception), "Email already exists")
self.db.session.add.assert_not_called()

def test_get_user_success(self):
"""测试成功获取用户"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

result = self.user_service.get_user(1)

self.assertEqual(result.id, 1)
self.assertEqual(result.username, 'testuser')

def test_get_user_not_found(self):
"""测试获取不存在的用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

with self.assertRaises(ValueError) as context:
self.user_service.get_user(999)

self.assertEqual(str(context.exception), "User not found")

def test_update_user_username(self):
"""测试更新用户名"""
user = User(id=1, username='olduser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

updated_user = self.user_service.update_user(1, username='newuser')

self.assertEqual(updated_user.username, 'newuser')
self.db.session.commit.assert_called_once()

def test_update_user_duplicate_username(self):
"""测试更新用户名时重复"""
user = User(id=1, username='olduser', email='test@example.com')
existing_user = User(id=2, username='existing', email='other@example.com')

self.db.session.query.return_value.filter_by.side_effect = [
user,  # get_user
existing_user  # username check
]

with self.assertRaises(ValueError) as context:
self.user_service.update_user(1, username='existing')

self.assertEqual(str(context.exception), "Username already exists")
self.db.session.commit.assert_not_called()

def test_update_user_password(self):
"""测试更新密码"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

updated_user = self.user_service.update_user(1, password='newpassword')

self.assertIsNotNone(updated_user.password_hash)
self.assertNotEqual(updated_user.password_hash, user.password_hash)
self.db.session.commit.assert_called_once()

def test_delete_user_success(self):
"""测试成功删除用户"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

self.user_service.delete_user(1)

self.db.session.delete.assert_called_once_with(user)
self.db.session.commit.assert_called_once()

def test_delete_user_not_found(self):
"""测试删除不存在的用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

with self.assertRaises(ValueError) as context:
self.user_service.delete_user(999)

self.assertEqual(str(context.exception), "User not found")
self.db.session.delete.assert_not_called()

if __name__ == '__main__':
unittest.main()

```> **生成的测试包含**:
> - 成功场景测试
> - 失败场景测试
> - 边界条件测试
> - Mock 和断言
```

```
python

# 示例：生成集成测试

用户请求：
"为这个用户服务生成集成测试"

代码：
```python
```python

class UserService:
    """用户服务"""

    def __init__(self, db):
        self.db = db

    def create_user(self, username, email, password):
        """创建用户"""
        if self._user_exists(username):
            raise ValueError("Username already exists")

        if self._email_exists(email):
            raise ValueError("Email already exists")

        user = User(
            username=username,
            email=email,
            password_hash=self._hash_password(password)
        )

        self.db.session.add(user)
        self.db.session.commit()

        return user

    def get_user(self, user_id):
        """获取用户"""
        user = self.db.session.query(User).filter_by(id=user_id).first()
        if not user:
            raise ValueError("User not found")
        return user

    def update_user(self, user_id, **kwargs):
        """更新用户"""
        user = self.get_user(user_id)

        if 'username' in kwargs:
            if self._user_exists(kwargs['username'], exclude_id=user_id):
                raise ValueError("Username already exists")
            user.username = kwargs['username']

        if 'email' in kwargs:
            if self._email_exists(kwargs['email'], exclude_id=user_id):
                raise ValueError("Email already exists")
            user.email = kwargs['email']

        if 'password' in kwargs:
            user.password_hash = self._hash_password(kwargs['password'])

        self.db.session.commit()

        return user

    def delete_user(self, user_id):
        """删除用户"""
        user = self.get_user(user_id)
        self.db.session.delete(user)
        self.db.session.commit()

    def _user_exists(self, username, exclude_id=None):
        """检查用户名是否存在"""
        query = self.db.session.query(User).filter_by(username=username)
        if exclude_id:
            query = query.filter(User.id != exclude_id)
        return query.first() is not None

    def _email_exists(self, email, exclude_id=None):
        """检查邮箱是否存在"""
        query = self.db.session.query(User).filter_by(email=email)
        if exclude_id:
            query = query.filter(User.id != exclude_id)
        return query.first() is not None

    def _hash_password(self, password):
        """哈希密码"""
        import bcrypt
        return bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')

Claude Code 生成的测试：

````python
````python

import unittest
from unittest.mock import Mock, MagicMock
from user_service import UserService
from models import User

class TestUserService(unittest.TestCase):
"""用户服务测试类"""

def setUp(self):
"""测试前设置"""
self.db = Mock()
self.db.session = MagicMock()
self.user_service = UserService(self.db)

def test_create_user_success(self):
"""测试成功创建用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

user = self.user_service.create_user(
username='testuser',
email='test@example.com',
password='password123'
)

self.db.session.add.assert_called_once()
self.db.session.commit.assert_called_once()
self.assertEqual(user.username, 'testuser')
self.assertEqual(user.email, 'test@example.com')

def test_create_user_duplicate_username(self):
"""测试创建用户时用户名重复"""
existing_user = Mock()
self.db.session.query.return_value.filter_by.return_value.first.return_value = existing_user

with self.assertRaises(ValueError) as context:
self.user_service.create_user(
username='existing',
email='test@example.com',
password='password123'
)

self.assertEqual(str(context.exception), "Username already exists")
self.db.session.add.assert_not_called()

def test_create_user_duplicate_email(self):
"""测试创建用户时邮箱重复"""
self.db.session.query.return_value.filter_by.side_effect = [
None,  # username check
Mock()  # email check
]

with self.assertRaises(ValueError) as context:
self.user_service.create_user(
username='testuser',
email='existing@example.com',
password='password123'
)

self.assertEqual(str(context.exception), "Email already exists")
self.db.session.add.assert_not_called()

def test_get_user_success(self):
"""测试成功获取用户"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

result = self.user_service.get_user(1)

self.assertEqual(result.id, 1)
self.assertEqual(result.username, 'testuser')

def test_get_user_not_found(self):
"""测试获取不存在的用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

with self.assertRaises(ValueError) as context:
self.user_service.get_user(999)

self.assertEqual(str(context.exception), "User not found")

def test_update_user_username(self):
"""测试更新用户名"""
user = User(id=1, username='olduser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

updated_user = self.user_service.update_user(1, username='newuser')

self.assertEqual(updated_user.username, 'newuser')
self.db.session.commit.assert_called_once()

def test_update_user_duplicate_username(self):
"""测试更新用户名时重复"""
user = User(id=1, username='olduser', email='test@example.com')
existing_user = User(id=2, username='existing', email='other@example.com')

self.db.session.query.return_value.filter_by.side_effect = [
user,  # get_user
existing_user  # username check
]

with self.assertRaises(ValueError) as context:
self.user_service.update_user(1, username='existing')

self.assertEqual(str(context.exception), "Username already exists")
self.db.session.commit.assert_not_called()

def test_update_user_password(self):
"""测试更新密码"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

updated_user = self.user_service.update_user(1, password='newpassword')

self.assertIsNotNone(updated_user.password_hash)
self.assertNotEqual(updated_user.password_hash, user.password_hash)
self.db.session.commit.assert_called_once()

def test_delete_user_success(self):
"""测试成功删除用户"""
user = User(id=1, username='testuser', email='test@example.com')
self.db.session.query.return_value.filter_by.return_value.first.return_value = user

self.user_service.delete_user(1)

self.db.session.delete.assert_called_once_with(user)
self.db.session.commit.assert_called_once()

def test_delete_user_not_found(self):
"""测试删除不存在的用户"""
self.db.session.query.return_value.filter_by.return_value.first.return_value = None

with self.assertRaises(ValueError) as context:
self.user_service.delete_user(999)

self.assertEqual(str(context.exception), "User not found")
self.db.session.delete.assert_not_called()

if __name__ == '__main__':
unittest.main()

```> **生成的测试包含**:
> - 成功场景测试
> - 失败场景测试
> - 边界条件测试
> - Mock 和断言
```

#### 测试覆盖率分析#

##### 1. 覆盖率报告#

### 示例：生成测试覆盖率报告

用户请求：
"分析测试覆盖率"
Claude Code 生成的报告：

#### 测试覆盖率报告#

##### 总体覆盖率#

##### 模块覆盖率#

##### 未覆盖的代码#

###### order_service.py

```
python复制`python

# 第 45-50 行：未覆盖
def process_order(self, order_id):
"""处理订单"""
order = self.get_order(order_id)

if order.status == 'cancelled':
raise InvalidOrderStatusError("Cannot process cancelled order")

 # ... 未测试的代码

```> **建议**: 添加取消订单的处理测试

#### order_service.py

```
python

# 第 78-85 行：未覆盖
def refund_order(self, order_id, reason):
    """退款订单"""
    order = self.get_order(order_id)

    if order.status not in ['paid', 'shipped']:
        raise InvalidOrderStatusError("Cannot refund order")

    if not order.payment_id:
        raise PaymentNotFoundError("Payment not found")

    # ... 未测试的代码

> **建议**: 添加退款订单的测试

### 覆盖率提升建议

1. **order_service.py**
 - 添加取消订单处理测试
 - 添加退款订单测试
 - 添加订单状态转换测试

2. **product_service.py**
 - 添加库存不足测试
 - 添加商品分类测试
 - 添加商品搜索测试

### 测试质量评估

| 指标 | 得分 | 说明 |
|------|------|------|
| 测试覆盖率 | 87.5% | 良好 |
| 测试有效性 | 85.2% | 良好 |
| 断言质量 | 90.3% | 优秀 |
| 测试独立性 | 88.7% | 优秀 |
| 测试可维护性 | 82.5% | 良好 |

### 2. 测试盲点识别

```
python

# 示例：识别测试盲点

用户请求：
"识别测试盲点"

Claude Code 生成的分析：

## 测试盲点分析

### 识别的盲点

#### 1. 边界条件盲点

```python
```python

# 代码：order_service.py
def calculate_discount(self, order):
    """计算折扣"""
    if order.total_amount > 1000:
        discount = 0.1
    elif order.total_amount > 500:
        discount = 0.05
    else:
        discount = 0

    return order.total_amount * (1 - discount)

> **盲点**:
> - 未测试边界值：500, 1000
> - 未测试负金额
> - 未测试零金额

> **建议测试**:
````python
````python

def test_discount_boundary_500(self):
"""测试 500 边界"""
order = Order(total_amount=500)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 500 * 0.95)

def test_discount_boundary_1000(self):
"""测试 1000 边界"""
order = Order(total_amount=1000)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 1000 * 0.9)

def test_discount_zero_amount(self):
"""测试零金额"""
order = Order(total_amount=0)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 0)

```#### 2. 异常处理盲点

```
python

# 代码：payment_service.py
def process_payment(self, payment_data):
    """处理支付"""
    try:
        result = self.gateway.charge(payment_data)
        return result
    except PaymentGatewayError as e:
        logger.error(f"Payment failed: {e}")
        raise PaymentProcessingError(str(e))

> **盲点**:
> - 未测试网关超时
> - 未测试网络错误
> - 未测试无效支付数据

> **建议测试**:
````python
````python

def test_payment_gateway_timeout(self):
"""测试网关超时"""
self.gateway.charge.side_effect = TimeoutError()

with self.assertRaises(PaymentProcessingError):
self.service.process_payment(self.payment_data)

def test_payment_network_error(self):
"""测试网络错误"""
self.gateway.charge.side_effect = ConnectionError()

with self.assertRaises(PaymentProcessingError):
self.service.process_payment(self.payment_data)

def test_payment_invalid_data(self):
"""测试无效支付数据"""
invalid_data = {'invalid': 'data'}

with self.assertRaises(ValidationError):
self.service.process_payment(invalid_data)

```#### 3. 并发场景盲点

```
python

# 代码：inventory_service.py
def update_stock(self, product_id, quantity):
    """更新库存"""
    product = self.get_product(product_id)
    product.stock += quantity
    self.db.session.commit()
    return product

> **盲点**:
> - 未测试并发更新
> - 未测试库存不足
> - 未测试负库存

> **建议测试**:
````python
````python

def test_concurrent_stock_update(self):
"""测试并发库存更新"""
product = self.create_product(stock=10)

with ThreadPoolExecutor(max_workers=2) as executor:
future1 = executor.submit(self.service.update_stock, product.id, 5)
future2 = executor.submit(self.service.update_stock, product.id, 3)

result1 = future1.result()
result2 = future2.result()

updated_product = self.service.get_product(product.id)
self.assertEqual(updated_product.stock, 18)

def test_insufficient_stock(self):
"""测试库存不足"""
product = self.create_product(stock=5)

with self.assertRaises(InsufficientStockError):
self.service.update_stock(product.id, -10)

```#### 4. 性能边界盲点

```
python

# 代码：search_service.py
def search_products(self, query, limit=100):
    """搜索商品"""
    results = Product.query.filter(
        Product.name.ilike(f'%{query}%')
    ).limit(limit).all()
    return results

> **盲点**:
> - 未测试大量结果
> - 未测试查询性能
> - 未测试内存使用

> **建议测试**:
````python
````python

def test_search_large_result_set(self):
"""测试大量结果"""
for i in range(1000):
self.create_product(name=f'product{i}')

results = self.service.search_products('product', limit=100)

self.assertEqual(len(results), 100)
self.assertLess(self.service.get_query_time(), 0.1)

```### 盲点优先级

| 盲点类型 | 优先级 | 风险等级 |
|----------|--------|----------|
| 边界条件 | 高 | 高 |
| 异常处理 | 高 | 高 |
| 并发场景 | 中 | 中 |
| 性能边界 | 中 | 中 |

```
## 测试优化建议

### 1. 测试性能优化

# 示例：优化测试性能
问题：测试运行时间过长
优化前：
````python
`python

def test_user_crud_operations(self):
"""测试用户 CRUD 操作"""
for i in range(100):
user = self.service.create_user(f'user{i}', f'user{i}@example.com', 'password')
retrieved_user = self.service.get_user(user.id)
self.assertEqual(retrieved_user.username, f'user{i}')
self.service.delete_user(user.id)

```> 优化后：

```
python

def test_user_crud_operations(self):
    """测试用户 CRUD 操作"""
    users = []

    for i in range(10):
        user = self.service.create_user(f'user{i}', f'user{i}@example.com', 'password')
        users.append(user)

    for user in users:
        retrieved_user = self.service.get_user(user.id)
        self.assertEqual(retrieved_user.username, user.username)

    for user in users:
        self.service.delete_user(user.id)

> **效果**: 测试时间从 50 秒降低到 5 秒

### 2. 测试可维护性优化

```
python

# 示例：提高测试可维护性

问题：测试代码重复

优化前：
```python
```python

def test_create_user_with_valid_data(self):
    """测试创建用户"""
    user = self.service.create_user('testuser', 'test@example.com', 'password123')
    self.assertEqual(user.username, 'testuser')
    self.assertEqual(user.email, 'test@example.com')
    self.assertIsNotNone(user.password_hash)

def test_create_user_with_another_valid_data(self):
    """测试创建另一个用户"""
    user = self.service.create_user('another', 'another@example.com', 'password456')
    self.assertEqual(user.username, 'another')
    self.assertEqual(user.email, 'another@example.com')
    self.assertIsNotNone(user.password_hash)

优化后：
````python
````python

def _create_user_data(self, username='testuser', email='test@example.com', password='password123'):
"""创建用户数据辅助方法"""
return {
'username': username,
'email': email,
'password': password
}

def _assert_user_created(self, user, expected_data):
"""断言用户创建成功辅助方法"""
self.assertEqual(user.username, expected_data['username'])
self.assertEqual(user.email, expected_data['email'])
self.assertIsNotNone(user.password_hash)

def test_create_user_with_valid_data(self):
"""测试创建用户"""
data = self._create_user_data()
user = self.service.create_user(**data)
self._assert_user_created(user, data)

def test_create_user_with_another_valid_data(self):
"""测试创建另一个用户"""
data = self._create_user_data(username='another', email='another@example.com')
user = self.service.create_user(**data)
self._assert_user_created(user, data)

```> **效果**: 减少代码重复，提高可维护性

```
## 总结

智能测试包括：

1. **自动生成测试**: 单元测试生成、集成测试生成
2. **测试覆盖率分析**: 覆盖率报告、测试盲点识别
3. **测试优化建议**: 性能优化、可维护性优化

通过这些功能，开发者可以快速构建全面的测试套件，提高代码质量和可靠性。

在下一节中，我们将探讨智能部署。

```
```

```
`python

# 第 45-50 行：未覆盖
def process_order(self, order_id):
"""处理订单"""
order = self.get_order(order_id)

if order.status == 'cancelled':
raise InvalidOrderStatusError("Cannot process cancelled order")

 # ... 未测试的代码

```> **建议**: 添加取消订单的处理测试

#### order_service.py

```
python

# 第 78-85 行：未覆盖
def refund_order(self, order_id, reason):
    """退款订单"""
    order = self.get_order(order_id)

    if order.status not in ['paid', 'shipped']:
        raise InvalidOrderStatusError("Cannot refund order")

    if not order.payment_id:
        raise PaymentNotFoundError("Payment not found")

    # ... 未测试的代码

> **建议**: 添加退款订单的测试

### 覆盖率提升建议

1. **order_service.py**
 - 添加取消订单处理测试
 - 添加退款订单测试
 - 添加订单状态转换测试

2. **product_service.py**
 - 添加库存不足测试
 - 添加商品分类测试
 - 添加商品搜索测试

### 测试质量评估

| 指标 | 得分 | 说明 |
|------|------|------|
| 测试覆盖率 | 87.5% | 良好 |
| 测试有效性 | 85.2% | 良好 |
| 断言质量 | 90.3% | 优秀 |
| 测试独立性 | 88.7% | 优秀 |
| 测试可维护性 | 82.5% | 良好 |

### 2. 测试盲点识别

```
python

# 示例：识别测试盲点

用户请求：
"识别测试盲点"

Claude Code 生成的分析：

## 测试盲点分析

### 识别的盲点

#### 1. 边界条件盲点

```python
```python

# 代码：order_service.py
def calculate_discount(self, order):
    """计算折扣"""
    if order.total_amount > 1000:
        discount = 0.1
    elif order.total_amount > 500:
        discount = 0.05
    else:
        discount = 0

    return order.total_amount * (1 - discount)

> **盲点**:
> - 未测试边界值：500, 1000
> - 未测试负金额
> - 未测试零金额

> **建议测试**:
````python
````python

def test_discount_boundary_500(self):
"""测试 500 边界"""
order = Order(total_amount=500)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 500 * 0.95)

def test_discount_boundary_1000(self):
"""测试 1000 边界"""
order = Order(total_amount=1000)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 1000 * 0.9)

def test_discount_zero_amount(self):
"""测试零金额"""
order = Order(total_amount=0)
discount = self.service.calculate_discount(order)
self.assertEqual(discount, 0)

```#### 2. 异常处理盲点

```
python

# 代码：payment_service.py
def process_payment(self, payment_data):
    """处理支付"""
    try:
        result = self.gateway.charge(payment_data)
        return result
    except PaymentGatewayError as e:
        logger.error(f"Payment failed: {e}")
        raise PaymentProcessingError(str(e))

> **盲点**:
> - 未测试网关超时
> - 未测试网络错误
> - 未测试无效支付数据

> **建议测试**:
````python
````python

def test_payment_gateway_timeout(self):
"""测试网关超时"""
self.gateway.charge.side_effect = TimeoutError()

with self.assertRaises(PaymentProcessingError):
self.service.process_payment(self.payment_data)

def test_payment_network_error(self):
"""测试网络错误"""
self.gateway.charge.side_effect = ConnectionError()

with self.assertRaises(PaymentProcessingError):
self.service.process_payment(self.payment_data)

def test_payment_invalid_data(self):
"""测试无效支付数据"""
invalid_data = {'invalid': 'data'}

with self.assertRaises(ValidationError):
self.service.process_payment(invalid_data)

```#### 3. 并发场景盲点

```
python

# 代码：inventory_service.py
def update_stock(self, product_id, quantity):
    """更新库存"""
    product = self.get_product(product_id)
    product.stock += quantity
    self.db.session.commit()
    return product

> **盲点**:
> - 未测试并发更新
> - 未测试库存不足
> - 未测试负库存

> **建议测试**:
````python
````python

def test_concurrent_stock_update(self):
"""测试并发库存更新"""
product = self.create_product(stock=10)

with ThreadPoolExecutor(max_workers=2) as executor:
future1 = executor.submit(self.service.update_stock, product.id, 5)
future2 = executor.submit(self.service.update_stock, product.id, 3)

result1 = future1.result()
result2 = future2.result()

updated_product = self.service.get_product(product.id)
self.assertEqual(updated_product.stock, 18)

def test_insufficient_stock(self):
"""测试库存不足"""
product = self.create_product(stock=5)

with self.assertRaises(InsufficientStockError):
self.service.update_stock(product.id, -10)

```#### 4. 性能边界盲点

```
python

# 代码：search_service.py
def search_products(self, query, limit=100):
    """搜索商品"""
    results = Product.query.filter(
        Product.name.ilike(f'%{query}%')
    ).limit(limit).all()
    return results

> **盲点**:
> - 未测试大量结果
> - 未测试查询性能
> - 未测试内存使用

> **建议测试**:
````python
````python

def test_search_large_result_set(self):
"""测试大量结果"""
for i in range(1000):
self.create_product(name=f'product{i}')

results = self.service.search_products('product', limit=100)

self.assertEqual(len(results), 100)
self.assertLess(self.service.get_query_time(), 0.1)

```### 盲点优先级

| 盲点类型 | 优先级 | 风险等级 |
|----------|--------|----------|
| 边界条件 | 高 | 高 |
| 异常处理 | 高 | 高 |
| 并发场景 | 中 | 中 |
| 性能边界 | 中 | 中 |

```
## 测试优化建议

### 1. 测试性能优化

# 示例：优化测试性能
问题：测试运行时间过长
优化前：
````python
`python

def test_user_crud_operations(self):
"""测试用户 CRUD 操作"""
for i in range(100):
user = self.service.create_user(f'user{i}', f'user{i}@example.com', 'password')
retrieved_user = self.service.get_user(user.id)
self.assertEqual(retrieved_user.username, f'user{i}')
self.service.delete_user(user.id)

```> 优化后：

```
python

def test_user_crud_operations(self):
    """测试用户 CRUD 操作"""
    users = []

    for i in range(10):
        user = self.service.create_user(f'user{i}', f'user{i}@example.com', 'password')
        users.append(user)

    for user in users:
        retrieved_user = self.service.get_user(user.id)
        self.assertEqual(retrieved_user.username, user.username)

    for user in users:
        self.service.delete_user(user.id)

> **效果**: 测试时间从 50 秒降低到 5 秒

### 2. 测试可维护性优化

```
python

# 示例：提高测试可维护性

问题：测试代码重复

优化前：
```python
```python

def test_create_user_with_valid_data(self):
    """测试创建用户"""
    user = self.service.create_user('testuser', 'test@example.com', 'password123')
    self.assertEqual(user.username, 'testuser')
    self.assertEqual(user.email, 'test@example.com')
    self.assertIsNotNone(user.password_hash)

def test_create_user_with_another_valid_data(self):
    """测试创建另一个用户"""
    user = self.service.create_user('another', 'another@example.com', 'password456')
    self.assertEqual(user.username, 'another')
    self.assertEqual(user.email, 'another@example.com')
    self.assertIsNotNone(user.password_hash)

优化后：
````python
````python

def _create_user_data(self, username='testuser', email='test@example.com', password='password123'):
"""创建用户数据辅助方法"""
return {
'username': username,
'email': email,
'password': password
}

def _assert_user_created(self, user, expected_data):
"""断言用户创建成功辅助方法"""
self.assertEqual(user.username, expected_data['username'])
self.assertEqual(user.email, expected_data['email'])
self.assertIsNotNone(user.password_hash)

def test_create_user_with_valid_data(self):
"""测试创建用户"""
data = self._create_user_data()
user = self.service.create_user(**data)
self._assert_user_created(user, data)

def test_create_user_with_another_valid_data(self):
"""测试创建另一个用户"""
data = self._create_user_data(username='another', email='another@example.com')
user = self.service.create_user(**data)
self._assert_user_created(user, data)

```> **效果**: 减少代码重复，提高可维护性

```
## 总结

智能测试包括：

1. **自动生成测试**: 单元测试生成、集成测试生成
2. **测试覆盖率分析**: 覆盖率报告、测试盲点识别
3. **测试优化建议**: 性能优化、可维护性优化

通过这些功能，开发者可以快速构建全面的测试套件，提高代码质量和可靠性。

在下一节中，我们将探讨智能部署。

```
```

---

## 5 智能部署

**URL**: https://claudecode.tangshuang.net/course/25.5%20%E6%99%BA%E8%83%BD%E9%83%A8%E7%BD%B2

#### 智能部署概述#

Claude Code 可以自动化部署流程、优化部署配置、监控部署状态，并提供部署优化建议。通过智能部署功能，开发者可以快速、安全地将应用部署到生产环境。

#### 自动化部署#

##### 1. Docker 部署#

### 示例：生成 Docker 部署配置

用户请求：
"为这个 Flask 应用生成 Docker 部署配置"

Claude Code 生成的配置：

#### Dockerfile#

```
dockerfile复制````dockerfile

FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
gcc \
&& rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装 Python 依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非 root 用户
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# 暴露端口
EXPOSE 5000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
CMD curl -f http://localhost:5000/health || exit 1

# 启动应用
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "app:app"]

```## docker-compose.yml

```
yaml

version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
      - REDIS_URL=redis://redis:6379/0
      - SECRET_KEY=${SECRET_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mydb"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - web
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

## nginx.conf

````nginx
````nginx

events {
worker_connections 1024;
}

http {
upstream web {
least_conn;
server web:5000;
}

 # 限流配置
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

server {
listen 80;
server_name example.com;

 # 重定向到 HTTPS
return 301 https://$server_name$request_uri;
}

server {
listen 443 ssl http2;
server_name example.com;

ssl_certificate /etc/nginx/ssl/cert.pem;
ssl_certificate_key /etc/nginx/ssl/key.pem;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers HIGH:!aNULL:!MD5;

 # 日志配置
access_log /var/log/nginx/access.log;
error_log /var/log/nginx/error.log;

 # 静态文件缓存
location /static/ {
alias /app/static/;
expires 30d;
add_header Cache-Control "public, immutable";
}

 # API 限流
location /api/ {
limit_req zone=api_limit burst=20 nodelay;
proxy_pass http://web;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
}

 # 健康检查
location /health {
proxy_pass http://web/health;
access_log off;
}

 # 默认代理
location / {
proxy_pass http://web;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
}
}
}

```## .dockerignore

```
__pycache__
> *.pyc
> *.pyo
> *.pyd
.Python
env/
venv/
ENV/
.venv
.git/
.gitignore
README.md
Dockerfile
docker-compose.yml
nginx.conf
.env
> *.log
tests/
.pytest_cache/
.coverage
htmlcov/
## 部署脚本
```
``bash
`````bash

#!/bin/bash

# deploy.sh - 部署脚本

set -e
```

```
````dockerfile

FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
gcc \
&& rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装 Python 依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非 root 用户
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# 暴露端口
EXPOSE 5000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
CMD curl -f http://localhost:5000/health || exit 1

# 启动应用
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "app:app"]

```## docker-compose.yml

```
yaml

version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
      - REDIS_URL=redis://redis:6379/0
      - SECRET_KEY=${SECRET_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mydb"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - web
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

## nginx.conf

````nginx
````nginx

events {
worker_connections 1024;
}

http {
upstream web {
least_conn;
server web:5000;
}

 # 限流配置
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

server {
listen 80;
server_name example.com;

 # 重定向到 HTTPS
return 301 https://$server_name$request_uri;
}

server {
listen 443 ssl http2;
server_name example.com;

ssl_certificate /etc/nginx/ssl/cert.pem;
ssl_certificate_key /etc/nginx/ssl/key.pem;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers HIGH:!aNULL:!MD5;

 # 日志配置
access_log /var/log/nginx/access.log;
error_log /var/log/nginx/error.log;

 # 静态文件缓存
location /static/ {
alias /app/static/;
expires 30d;
add_header Cache-Control "public, immutable";
}

 # API 限流
location /api/ {
limit_req zone=api_limit burst=20 nodelay;
proxy_pass http://web;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
}

 # 健康检查
location /health {
proxy_pass http://web/health;
access_log off;
}

 # 默认代理
location / {
proxy_pass http://web;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
}
}
}

```## .dockerignore

```
__pycache__
> *.pyc
> *.pyo
> *.pyd
.Python
env/
venv/
ENV/
.venv
.git/
.gitignore
README.md
Dockerfile
docker-compose.yml
nginx.conf
.env
> *.log
tests/
.pytest_cache/
.coverage
htmlcov/
## 部署脚本
```
``bash
`````bash

#!/bin/bash

# deploy.sh - 部署脚本

set -e
```

echo "开始部署..."

### 拉取最新代码

git pull origin main

### 构建镜像

docker-compose build

### 停止旧容器

docker-compose down

### 启动新容器

docker-compose up -d

### 等待服务启动

sleep 10

### 健康检查

if curl -f http://localhost:5000/health; then
echo "部署成功！"
else
echo "部署失败！"
docker-compose logs
exit 1
fi

### 清理旧镜像

docker image prune -f

echo "部署完成！"

#### 回滚脚本#

```
bash复制bash

#!/bin/bash

# rollback.sh - 回滚脚本

set -e

echo "开始回滚..."

# 停止当前容器
docker-compose down

# 拉取上一个版本
git checkout HEAD~1

# 启动旧版本
docker-compose up -d

# 等待服务启动
sleep 10

# 健康检查
if curl -f http://localhost:5000/health; then
    echo "回滚成功！"
else
    echo "回滚失败！"
    docker-compose logs
    exit 1
fi

echo "回滚完成！"

### 2. Kubernetes 部署
```python
python

# 示例：生成 Kubernetes 部署配置

用户请求：
"为这个应用生成 Kubernetes 部署配置"

Claude Code 生成的配置：

## deployment.yaml

```yaml
```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  labels:
    app: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app
        image: myregistry.com/web-app:latest
        ports:
        - containerPort: 5000
        env:
        - name: FLASK_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: secret-key
        - name: REDIS_URL
          value: "redis://redis-service:6379/0"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: web-app-service
spec:
  selector:
    app: web-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

## ingress.yaml

```yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: web-app-ingress
annotations:
cert-manager.io/cluster-issuer: "letsencrypt-prod"
nginx.ingress.kubernetes.io/ssl-redirect: "true"
nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
ingressClassName: nginx
tls:
 - hosts:
 - example.com
secretName: web-app-tls
rules:
 - host: example.com
http:
paths:
 - path: /
pathType: Prefix
backend:
service:
name: web-app-service
port:
number: 80

## configmap.yaml

```yaml
yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  FLASK_ENV: "production"
  LOG_LEVEL: "info"
  MAX_WORKERS: "4"

## secret.yaml

```yaml

apiVersion: v1
kind: Secret
metadata:
name: app-secrets
type: Opaque
stringData:
database-url: "postgresql://user:password@postgres-service:5432/mydb"
secret-key: "your-secret-key-here"

## postgres-deployment.yaml

```yaml
yaml

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: postgres-password
        - name: POSTGRES_DB
          value: mydb
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None

## redis-deployment.yaml

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: redis
spec:
replicas: 1
selector:
matchLabels:
app: redis
template:
metadata:
labels:
app: redis
spec:
containers:
 - name: redis
image: redis:7-alpine
ports:
 - containerPort: 6379
resources:
requests:
memory: "128Mi"
cpu: "100m"
limits:
memory: "256Mi"
cpu: "200m"
> ---
apiVersion: v1
kind: Service
metadata:
name: redis-service
spec:
selector:
app: redis
ports:
 - port: 6379
targetPort: 6379
clusterIP: None

## 部署脚本

```bash
bash

#!/bin/bash

# k8s-deploy.sh - Kubernetes 部署脚本

set -e

NAMESPACE="production"

echo "开始部署到 Kubernetes..."

# 创建命名空间
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 应用配置
kubectl apply -f configmap.yaml -n $NAMESPACE
kubectl apply -f secret.yaml -n $NAMESPACE

# 部署数据库
kubectl apply -f postgres-deployment.yaml -n $NAMESPACE
kubectl apply -f redis-deployment.yaml -n $NAMESPACE

# 等待数据库就绪
kubectl wait --for=condition=ready pod -l app=postgres -n $NAMESPACE --timeout=300s
kubectl wait --for=condition=ready pod -l app=redis -n $NAMESPACE --timeout=300s

# 部署应用
kubectl apply -f deployment.yaml -n $NAMESPACE
kubectl apply -f ingress.yaml -n $NAMESPACE

# 等待应用就绪
kubectl wait --for=condition=ready pod -l app=web-app -n $NAMESPACE --timeout=300s

echo "部署成功！"

## 部署监控
### 1. 健康检查
```python
python

# 示例：实现健康检查

用户请求：
"为应用实现健康检查"

Claude Code 生成的代码：

```python
```python

from flask import Flask, jsonify
import psutil
import time
from datetime import datetime

app = Flask(__name__)

# 健康状态
health_status = {
    'status': 'healthy',
    'last_check': datetime.utcnow(),
    'checks': {}
}

@app.route('/health')
def health_check():
    """健康检查端点"""
    checks = {
        'database': check_database(),
        'redis': check_redis(),
        'disk_space': check_disk_space(),
        'memory': check_memory()
    }

    all_healthy = all(check['status'] == 'ok' for check in checks.values())

    health_status['status'] = 'healthy' if all_healthy else 'unhealthy'
    health_status['last_check'] = datetime.utcnow()
    health_status['checks'] = checks

    status_code = 200 if all_healthy else 503

    return jsonify(health_status), status_code

@app.route('/health/ready')
def readiness_check():
    """就绪检查"""
    try:
        check_database()
        check_redis()
        return jsonify({'status': 'ready'}), 200
    except Exception as e:
        return jsonify({'status': 'not ready', 'error': str(e)}), 503

@app.route('/health/live')
def liveness_check():
    """存活检查"""
    return jsonify({'status': 'alive', 'timestamp': datetime.utcnow().isoformat()}), 200

def check_database():
    """检查数据库连接"""
    try:
        from app import db
        db.session.execute('SELECT 1')
        return {'status': 'ok', 'message': 'Database connection successful'}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

def check_redis():
    """检查 Redis 连接"""
    try:
        from app import redis
        redis.ping()
        return {'status': 'ok', 'message': 'Redis connection successful'}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

def check_disk_space():
    """检查磁盘空间"""
    disk = psutil.disk_usage('/')
    free_percent = (disk.free / disk.total) * 100

    if free_percent < 10:
        return {
            'status': 'error',
            'message': f'Low disk space: {free_percent:.1f}% free'
        }

    return {
        'status': 'ok',
        'message': f'Disk space: {free_percent:.1f}% free'
    }

def check_memory():
    """检查内存使用"""
    memory = psutil.virtual_memory()
    used_percent = memory.percent

    if used_percent > 90:
        return {
            'status': 'error',
            'message': f'High memory usage: {used_percent:.1f}%'
        }

    return {
        'status': 'ok',
        'message': f'Memory usage: {used_percent:.1f}%'
    }

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

### 2. 日志监控

```python

# 示例：实现日志监控

用户请求：
"为应用实现日志监控"

Claude Code 生成的代码：

```python
```python

import logging
from logging.handlers import RotatingFileHandler
import json
from datetime import datetime
from flask import request, g

class JSONFormatter(logging.Formatter):
    """JSON 日志格式化器"""

    def format(self, record):
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'message': record.getMessage(),
            'logger': record.name,
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }

        if hasattr(request, 'path'):
            log_data['request'] = {
                'method': request.method,
                'path': request.path,
                'ip': request.remote_addr
            }

        if hasattr(g, 'user_id'):
            log_data['user_id'] = g.user_id

        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)

        return json.dumps(log_data)

def setup_logging(app):
    """设置日志"""

    # 创建日志目录
    import os
    log_dir = 'logs'
    os.makedirs(log_dir, exist_ok=True)

    # 应用日志
    app_handler = RotatingFileHandler(
        'logs/app.log',
        maxBytes=10485760,  # 10MB
        backupCount=10
    )
    app_handler.setFormatter(JSONFormatter())
    app_handler.setLevel(logging.INFO)

    # 错误日志
    error_handler = RotatingFileHandler(
        'logs/error.log',
        maxBytes=10485760,
        backupCount=10
    )
    error_handler.setFormatter(JSONFormatter())
    error_handler.setLevel(logging.ERROR)

    # 访问日志
    access_handler = RotatingFileHandler(
        'logs/access.log',
        maxBytes=10485760,
        backupCount=10
    )
    access_handler.setFormatter(JSONFormatter())
    access_handler.setLevel(logging.INFO)

    # 配置日志
    app.logger.addHandler(app_handler)
    app.logger.addHandler(error_handler)
    app.logger.setLevel(logging.INFO)

    # 访问日志中间件
    @app.before_request
    def log_request():
        g.start_time = time.time()

    @app.after_request
    def log_response(response):
        if hasattr(g, 'start_time'):
            duration = time.time() - g.start_time
            app.logger.info(
                f"Request completed",
                extra={
                    'status_code': response.status_code,
                    'duration': duration
                }
            )
        return response

    return app

## 部署优化

### 1. 性能优化

# 示例：优化部署性能
用户请求：
"优化应用部署性能"
Claude Code 生成的优化建议：
## 部署性能优化
### 1. 容器优化
#### Dockerfile 优化
````dockerfile
`dockerfile

# 多阶段构建
FROM python:3.11-slim as builder

WORKDIR /app

# 安装构建依赖
RUN apt-get update && apt-get install -y gcc

# 复制依赖文件
COPY requirements.txt .

# 安装 Python 依赖
RUN pip install --user --no-cache-dir -r requirements.txt

# 运行时镜像
FROM python:3.11-slim

WORKDIR /app

# 从构建阶段复制依赖
COPY --from=builder /root/.local /root/.local

# 复制应用代码
COPY . .

# 设置 PATH
ENV PATH=/root/.local/bin:$PATH

# 创建非 root 用户
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# 暴露端口
EXPOSE 5000

# 启动应用
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--threads", "2", "app:app"]

```> **优化效果**:
> - 镜像大小减少 40%
> - 构建时间减少 30%
> - 安全性提高

### 2. Gunicorn 配置优化
```

```
bash

#!/bin/bash

# rollback.sh - 回滚脚本

set -e

echo "开始回滚..."

# 停止当前容器
docker-compose down

# 拉取上一个版本
git checkout HEAD~1

# 启动旧版本
docker-compose up -d

# 等待服务启动
sleep 10

# 健康检查
if curl -f http://localhost:5000/health; then
    echo "回滚成功！"
else
    echo "回滚失败！"
    docker-compose logs
    exit 1
fi

echo "回滚完成！"

### 2. Kubernetes 部署
```python
python

# 示例：生成 Kubernetes 部署配置

用户请求：
"为这个应用生成 Kubernetes 部署配置"

Claude Code 生成的配置：

## deployment.yaml

```yaml
```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  labels:
    app: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app
        image: myregistry.com/web-app:latest
        ports:
        - containerPort: 5000
        env:
        - name: FLASK_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: secret-key
        - name: REDIS_URL
          value: "redis://redis-service:6379/0"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: web-app-service
spec:
  selector:
    app: web-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

## ingress.yaml

```yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: web-app-ingress
annotations:
cert-manager.io/cluster-issuer: "letsencrypt-prod"
nginx.ingress.kubernetes.io/ssl-redirect: "true"
nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
ingressClassName: nginx
tls:
 - hosts:
 - example.com
secretName: web-app-tls
rules:
 - host: example.com
http:
paths:
 - path: /
pathType: Prefix
backend:
service:
name: web-app-service
port:
number: 80

## configmap.yaml

```yaml
yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  FLASK_ENV: "production"
  LOG_LEVEL: "info"
  MAX_WORKERS: "4"

## secret.yaml

```yaml

apiVersion: v1
kind: Secret
metadata:
name: app-secrets
type: Opaque
stringData:
database-url: "postgresql://user:password@postgres-service:5432/mydb"
secret-key: "your-secret-key-here"

## postgres-deployment.yaml

```yaml
yaml

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: postgres-password
        - name: POSTGRES_DB
          value: mydb
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None

## redis-deployment.yaml

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: redis
spec:
replicas: 1
selector:
matchLabels:
app: redis
template:
metadata:
labels:
app: redis
spec:
containers:
 - name: redis
image: redis:7-alpine
ports:
 - containerPort: 6379
resources:
requests:
memory: "128Mi"
cpu: "100m"
limits:
memory: "256Mi"
cpu: "200m"
> ---
apiVersion: v1
kind: Service
metadata:
name: redis-service
spec:
selector:
app: redis
ports:
 - port: 6379
targetPort: 6379
clusterIP: None

## 部署脚本

```bash
bash

#!/bin/bash

# k8s-deploy.sh - Kubernetes 部署脚本

set -e

NAMESPACE="production"

echo "开始部署到 Kubernetes..."

# 创建命名空间
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 应用配置
kubectl apply -f configmap.yaml -n $NAMESPACE
kubectl apply -f secret.yaml -n $NAMESPACE

# 部署数据库
kubectl apply -f postgres-deployment.yaml -n $NAMESPACE
kubectl apply -f redis-deployment.yaml -n $NAMESPACE

# 等待数据库就绪
kubectl wait --for=condition=ready pod -l app=postgres -n $NAMESPACE --timeout=300s
kubectl wait --for=condition=ready pod -l app=redis -n $NAMESPACE --timeout=300s

# 部署应用
kubectl apply -f deployment.yaml -n $NAMESPACE
kubectl apply -f ingress.yaml -n $NAMESPACE

# 等待应用就绪
kubectl wait --for=condition=ready pod -l app=web-app -n $NAMESPACE --timeout=300s

echo "部署成功！"

## 部署监控
### 1. 健康检查
```python
python

# 示例：实现健康检查

用户请求：
"为应用实现健康检查"

Claude Code 生成的代码：

```python
```python

from flask import Flask, jsonify
import psutil
import time
from datetime import datetime

app = Flask(__name__)

# 健康状态
health_status = {
    'status': 'healthy',
    'last_check': datetime.utcnow(),
    'checks': {}
}

@app.route('/health')
def health_check():
    """健康检查端点"""
    checks = {
        'database': check_database(),
        'redis': check_redis(),
        'disk_space': check_disk_space(),
        'memory': check_memory()
    }

    all_healthy = all(check['status'] == 'ok' for check in checks.values())

    health_status['status'] = 'healthy' if all_healthy else 'unhealthy'
    health_status['last_check'] = datetime.utcnow()
    health_status['checks'] = checks

    status_code = 200 if all_healthy else 503

    return jsonify(health_status), status_code

@app.route('/health/ready')
def readiness_check():
    """就绪检查"""
    try:
        check_database()
        check_redis()
        return jsonify({'status': 'ready'}), 200
    except Exception as e:
        return jsonify({'status': 'not ready', 'error': str(e)}), 503

@app.route('/health/live')
def liveness_check():
    """存活检查"""
    return jsonify({'status': 'alive', 'timestamp': datetime.utcnow().isoformat()}), 200

def check_database():
    """检查数据库连接"""
    try:
        from app import db
        db.session.execute('SELECT 1')
        return {'status': 'ok', 'message': 'Database connection successful'}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

def check_redis():
    """检查 Redis 连接"""
    try:
        from app import redis
        redis.ping()
        return {'status': 'ok', 'message': 'Redis connection successful'}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

def check_disk_space():
    """检查磁盘空间"""
    disk = psutil.disk_usage('/')
    free_percent = (disk.free / disk.total) * 100

    if free_percent < 10:
        return {
            'status': 'error',
            'message': f'Low disk space: {free_percent:.1f}% free'
        }

    return {
        'status': 'ok',
        'message': f'Disk space: {free_percent:.1f}% free'
    }

def check_memory():
    """检查内存使用"""
    memory = psutil.virtual_memory()
    used_percent = memory.percent

    if used_percent > 90:
        return {
            'status': 'error',
            'message': f'High memory usage: {used_percent:.1f}%'
        }

    return {
        'status': 'ok',
        'message': f'Memory usage: {used_percent:.1f}%'
    }

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

### 2. 日志监控

```python

# 示例：实现日志监控

用户请求：
"为应用实现日志监控"

Claude Code 生成的代码：

```python
```python

import logging
from logging.handlers import RotatingFileHandler
import json
from datetime import datetime
from flask import request, g

class JSONFormatter(logging.Formatter):
    """JSON 日志格式化器"""

    def format(self, record):
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'message': record.getMessage(),
            'logger': record.name,
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }

        if hasattr(request, 'path'):
            log_data['request'] = {
                'method': request.method,
                'path': request.path,
                'ip': request.remote_addr
            }

        if hasattr(g, 'user_id'):
            log_data['user_id'] = g.user_id

        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)

        return json.dumps(log_data)

def setup_logging(app):
    """设置日志"""

    # 创建日志目录
    import os
    log_dir = 'logs'
    os.makedirs(log_dir, exist_ok=True)

    # 应用日志
    app_handler = RotatingFileHandler(
        'logs/app.log',
        maxBytes=10485760,  # 10MB
        backupCount=10
    )
    app_handler.setFormatter(JSONFormatter())
    app_handler.setLevel(logging.INFO)

    # 错误日志
    error_handler = RotatingFileHandler(
        'logs/error.log',
        maxBytes=10485760,
        backupCount=10
    )
    error_handler.setFormatter(JSONFormatter())
    error_handler.setLevel(logging.ERROR)

    # 访问日志
    access_handler = RotatingFileHandler(
        'logs/access.log',
        maxBytes=10485760,
        backupCount=10
    )
    access_handler.setFormatter(JSONFormatter())
    access_handler.setLevel(logging.INFO)

    # 配置日志
    app.logger.addHandler(app_handler)
    app.logger.addHandler(error_handler)
    app.logger.setLevel(logging.INFO)

    # 访问日志中间件
    @app.before_request
    def log_request():
        g.start_time = time.time()

    @app.after_request
    def log_response(response):
        if hasattr(g, 'start_time'):
            duration = time.time() - g.start_time
            app.logger.info(
                f"Request completed",
                extra={
                    'status_code': response.status_code,
                    'duration': duration
                }
            )
        return response

    return app

## 部署优化

### 1. 性能优化

# 示例：优化部署性能
用户请求：
"优化应用部署性能"
Claude Code 生成的优化建议：
## 部署性能优化
### 1. 容器优化
#### Dockerfile 优化
````dockerfile
`dockerfile

# 多阶段构建
FROM python:3.11-slim as builder

WORKDIR /app

# 安装构建依赖
RUN apt-get update && apt-get install -y gcc

# 复制依赖文件
COPY requirements.txt .

# 安装 Python 依赖
RUN pip install --user --no-cache-dir -r requirements.txt

# 运行时镜像
FROM python:3.11-slim

WORKDIR /app

# 从构建阶段复制依赖
COPY --from=builder /root/.local /root/.local

# 复制应用代码
COPY . .

# 设置 PATH
ENV PATH=/root/.local/bin:$PATH

# 创建非 root 用户
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# 暴露端口
EXPOSE 5000

# 启动应用
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--threads", "2", "app:app"]

```> **优化效果**:
> - 镜像大小减少 40%
> - 构建时间减少 30%
> - 安全性提高

### 2. Gunicorn 配置优化
```

python

### gunicorn_config.py

import multiprocessing

### 工作进程数

workers = multiprocessing.cpu_count() * 2 + 1

### 线程数

threads = 2

### 工作模式

worker_class = 'gevent'

### 工作进程连接数

worker_connections = 1000

### 超时时间

timeout = 30
keepalive = 2

### 最大请求数

max_requests = 1000
max_requests_jitter = 50

### 日志配置

accesslog = '-'
errorlog = '-'
loglevel = 'info'

### 预加载应用

preload_app = True

### 进程名称

proc_name = 'web-app'

- 吞吐量提高 50%
- 响应时间减少 40%
- 资源利用率提高 30%

##### 3. 数据库连接池优化#

```
python复制````python

# config.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
DATABASE_URL,
poolclass=QueuePool,
pool_size=20,
max_overflow=40,
pool_timeout=30,
pool_recycle=3600,
pool_pre_ping=True,
echo=False
)

```> **优化效果**:
> - 数据库连接数减少 60%
> - 查询响应时间减少 30%
> - 连接池效率提高 50%

```
### 2. 成本优化

# 示例：优化部署成本
用户请求：
"优化应用部署成本"
Claude Code 生成的优化建议：
## 部署成本优化
### 1. 资源优化
#### Kubernetes 资源配置
````yaml
`yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: web-app
spec:
replicas: 3
template:
spec:
containers:
 - name: web-app
resources:
requests:
memory: "128Mi"
cpu: "100m"
limits:
memory: "256Mi"
cpu: "200m"

```> **优化效果**:
> - 资源成本降低 50%
> - 资源利用率提高 40%

### 2. 自动扩缩容

```
yaml

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

> **优化效果**:
> - 成本降低 30%
> - 资源利用率提高 50%

### 3. 节点亲和性

````yaml
````yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: web-app
spec:
template:
spec:
affinity:
nodeAffinity:
preferredDuringSchedulingIgnoredDuringExecution:
 - weight: 100
preference:
matchExpressions:
 - key: node-type
operator: In
values:
 - spot

```> **优化效果**:
> - 成本降低 60%
> - 使用 Spot 实例

```
## 总结

智能部署包括：

1. **自动化部署**: Docker 部署、Kubernetes 部署
2. **部署监控**: 健康检查、日志监控
3. **部署优化**: 性能优化、成本优化

通过这些功能，开发者可以快速、安全地将应用部署到生产环境。

在下一节中，我们将探讨智能维护。

```
```
```

```
````python

# config.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
DATABASE_URL,
poolclass=QueuePool,
pool_size=20,
max_overflow=40,
pool_timeout=30,
pool_recycle=3600,
pool_pre_ping=True,
echo=False
)

```> **优化效果**:
> - 数据库连接数减少 60%
> - 查询响应时间减少 30%
> - 连接池效率提高 50%

```
### 2. 成本优化

# 示例：优化部署成本
用户请求：
"优化应用部署成本"
Claude Code 生成的优化建议：
## 部署成本优化
### 1. 资源优化
#### Kubernetes 资源配置
````yaml
`yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: web-app
spec:
replicas: 3
template:
spec:
containers:
 - name: web-app
resources:
requests:
memory: "128Mi"
cpu: "100m"
limits:
memory: "256Mi"
cpu: "200m"

```> **优化效果**:
> - 资源成本降低 50%
> - 资源利用率提高 40%

### 2. 自动扩缩容

```
yaml

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

> **优化效果**:
> - 成本降低 30%
> - 资源利用率提高 50%

### 3. 节点亲和性

````yaml
````yaml

apiVersion: apps/v1
kind: Deployment
metadata:
name: web-app
spec:
template:
spec:
affinity:
nodeAffinity:
preferredDuringSchedulingIgnoredDuringExecution:
 - weight: 100
preference:
matchExpressions:
 - key: node-type
operator: In
values:
 - spot

```> **优化效果**:
> - 成本降低 60%
> - 使用 Spot 实例

```
## 总结

智能部署包括：

1. **自动化部署**: Docker 部署、Kubernetes 部署
2. **部署监控**: 健康检查、日志监控
3. **部署优化**: 性能优化、成本优化

通过这些功能，开发者可以快速、安全地将应用部署到生产环境。

在下一节中，我们将探讨智能维护。

```
```
```

---

## 6 智能维护

**URL**: https://claudecode.tangshuang.net/course/25.6%20%E6%99%BA%E8%83%BD%E7%BB%B4%E6%8A%A4

#### 智能维护概述#

Claude Code 可以自动化维护任务、监控系统健康状态、预测潜在问题，并提供维护优化建议。通过智能维护功能，开发者可以降低维护成本、提高系统可靠性。

#### 自动化维护#

##### 1. 依赖管理#

### 示例：自动化依赖管理

用户请求：
"为项目实现自动化依赖管理"

Claude Code 生成的代码：

#### requirements.txt#

```
bash复制Flask-SQLAlchemy==3.0.5
Flask-JWT-Extended==4.5.2
Flask-Mail==0.9.1
Flask-Migrate==4.0.5
gunicorn==21.2.0
psycopg2-binary==2.9.7
redis==4.6.0
celery==5.3.4
python-dotenv==1.0.0
```
## requirements-dev.txt

```
pytest==7.4.2
pytest-cov==4.1.0
pytest-mock==3.11.1
black==23.9.1
flake8==6.1.0
mypy==1.5.1
isort==5.12.0
pre-commit==3.4.0
## 依赖更新脚本
````python
`python

#!/usr/bin/env python3
"""
依赖更新脚本
自动检查并更新过期的依赖包
"""

import subprocess
import json
from typing import List, Dict
import sys

def get_outdated_packages() -> List[Dict]:
"""获取过期的包"""
result = subprocess.run(
['pip', 'list', '--outdated', '--format=json'],
capture_output=True,
text=True
)

if result.returncode != 0:
print("Error: Failed to get outdated packages")
return []

packages = json.loads(result.stdout)
return packages

def check_compatibility(package: str, version: str) -> bool:
"""检查包的兼容性"""
try:
result = subprocess.run(
['pip', 'install', '--dry-run', f'{package}=={version}'],
capture_output=True,
text=True
)

return result.returncode == 0
except Exception as e:
print(f"Error checking compatibility for {package}: {e}")
return False

def update_package(package: str, version: str) -> bool:
"""更新包"""
try:
result = subprocess.run(
['pip', 'install', '--upgrade', f'{package}=={version}'],
capture_output=True,
text=True
)

return result.returncode == 0
except Exception as e:
print(f"Error updating {package}: {e}")
return False

def update_requirements():
"""更新 requirements.txt"""
try:
result = subprocess.run(
['pip', 'freeze'],
capture_output=True,
text=True
)

with open('requirements.txt', 'w') as f:
f.write(result.stdout)

return True
except Exception as e:
print(f"Error updating requirements.txt: {e}")
return False

def main():
"""主函数"""
print("检查过期依赖...")

outdated_packages = get_outdated_packages()

if not outdated_packages:
print("所有依赖都是最新的！")
return

print(f"\n发现 {len(outdated_packages)} 个过期包:")
for pkg in outdated_packages:
print(f"  - {pkg['name']}: {pkg['version']} -> {pkg['latest_version']}")

print("\n检查兼容性...")
compatible_packages = []

for pkg in outdated_packages:
package_name = pkg['name']
latest_version = pkg['latest_version']

if check_compatibility(package_name, latest_version):
compatible_packages.append(pkg)
print(f"  ✓ {package_name} {latest_version}")
else:
print(f"  ✗ {package_name} {latest_version} (不兼容)")

if not compatible_packages:
print("\n没有可更新的包")
return

print(f"\n准备更新 {len(compatible_packages)} 个包...")
response = input("是否继续？(y/n): ")

if response.lower() != 'y':
print("取消更新")
return

print("\n开始更新...")
for pkg in compatible_packages:
package_name = pkg['name']
latest_version = pkg['latest_version']

print(f"更新 {package_name} 到 {latest_version}...")
if update_package(package_name, latest_version):
print(f"  ✓ {package_name} 更新成功")
else:
print(f"  ✗ {package_name} 更新失败")

print("\n更新 requirements.txt...")
if update_requirements():
print("  ✓ requirements.txt 更新成功")
else:
print("  ✗ requirements.txt 更新失败")

print("\n依赖更新完成！")

if __name__ == '__main__':
main()

```## 依赖安全检查

```
python

#!/usr/bin/env python3
"""
依赖安全检查脚本
检查依赖包的安全漏洞
"""

import subprocess
import json
from typing import List, Dict

def check_security() -> List[Dict]:
    """检查依赖安全性"""
    try:
        result = subprocess.run(
            ['pip', 'audit'],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print("Error: Failed to check security")
            return []

        return json.loads(result.stdout)
    except Exception as e:
        print(f"Error checking security: {e}")
        return []

def main():
    """主函数"""
    print("检查依赖安全性...")

    vulnerabilities = check_security()

    if not vulnerabilities:
        print("未发现安全漏洞！")
        return

    print(f"\n发现 {len(vulnerabilities)} 个安全漏洞:")
    for vuln in vulnerabilities:
        print(f"\n  包: {vuln['name']}")
        print(f"  版本: {vuln['version']}")
        print(f"  漏洞: {vuln['advisory']}")
        print(f"  严重性: {vuln['severity']}")
        print(f"  修复版本: {vuln['fix_versions']}")

if __name__ == '__main__':
    main()

### 2. 数据库维护

```
python

# 示例：自动化数据库维护

用户请求：
"为应用实现自动化数据库维护"

Claude Code 生成的代码：

```python
```python

from datetime import datetime, timedelta
from sqlalchemy import text
from app import db
import logging

logger = logging.getLogger(__name__)

class DatabaseMaintenance:
    """数据库维护类"""

    def __init__(self, db_session):
        self.db = db_session

    def analyze_tables(self):
        """分析表"""
        tables = ['users', 'products', 'orders', 'payments']

        for table in tables:
            try:
                result = self.db.execute(text(f"ANALYZE {table}"))
                logger.info(f"Table {table} analyzed successfully")
            except Exception as e:
                logger.error(f"Error analyzing table {table}: {e}")

    def vacuum_tables(self):
        """清理表"""
        tables = ['users', 'products', 'orders', 'payments']

        for table in tables:
            try:
                result = self.db.execute(text(f"VACUUM ANALYZE {table}"))
                logger.info(f"Table {table} vacuumed successfully")
            except Exception as e:
                logger.error(f"Error vacuuming table {table}: {e}")

    def rebuild_indexes(self):
        """重建索引"""
        indexes = [
            'idx_users_username',
            'idx_users_email',
            'idx_orders_user_id',
            'idx_orders_status',
            'idx_products_name'
        ]

        for index in indexes:
            try:
```

```
Flask-SQLAlchemy==3.0.5
Flask-JWT-Extended==4.5.2
Flask-Mail==0.9.1
Flask-Migrate==4.0.5
gunicorn==21.2.0
psycopg2-binary==2.9.7
redis==4.6.0
celery==5.3.4
python-dotenv==1.0.0
```
## requirements-dev.txt

```
pytest==7.4.2
pytest-cov==4.1.0
pytest-mock==3.11.1
black==23.9.1
flake8==6.1.0
mypy==1.5.1
isort==5.12.0
pre-commit==3.4.0
## 依赖更新脚本
````python
`python

#!/usr/bin/env python3
"""
依赖更新脚本
自动检查并更新过期的依赖包
"""

import subprocess
import json
from typing import List, Dict
import sys

def get_outdated_packages() -> List[Dict]:
"""获取过期的包"""
result = subprocess.run(
['pip', 'list', '--outdated', '--format=json'],
capture_output=True,
text=True
)

if result.returncode != 0:
print("Error: Failed to get outdated packages")
return []

packages = json.loads(result.stdout)
return packages

def check_compatibility(package: str, version: str) -> bool:
"""检查包的兼容性"""
try:
result = subprocess.run(
['pip', 'install', '--dry-run', f'{package}=={version}'],
capture_output=True,
text=True
)

return result.returncode == 0
except Exception as e:
print(f"Error checking compatibility for {package}: {e}")
return False

def update_package(package: str, version: str) -> bool:
"""更新包"""
try:
result = subprocess.run(
['pip', 'install', '--upgrade', f'{package}=={version}'],
capture_output=True,
text=True
)

return result.returncode == 0
except Exception as e:
print(f"Error updating {package}: {e}")
return False

def update_requirements():
"""更新 requirements.txt"""
try:
result = subprocess.run(
['pip', 'freeze'],
capture_output=True,
text=True
)

with open('requirements.txt', 'w') as f:
f.write(result.stdout)

return True
except Exception as e:
print(f"Error updating requirements.txt: {e}")
return False

def main():
"""主函数"""
print("检查过期依赖...")

outdated_packages = get_outdated_packages()

if not outdated_packages:
print("所有依赖都是最新的！")
return

print(f"\n发现 {len(outdated_packages)} 个过期包:")
for pkg in outdated_packages:
print(f"  - {pkg['name']}: {pkg['version']} -> {pkg['latest_version']}")

print("\n检查兼容性...")
compatible_packages = []

for pkg in outdated_packages:
package_name = pkg['name']
latest_version = pkg['latest_version']

if check_compatibility(package_name, latest_version):
compatible_packages.append(pkg)
print(f"  ✓ {package_name} {latest_version}")
else:
print(f"  ✗ {package_name} {latest_version} (不兼容)")

if not compatible_packages:
print("\n没有可更新的包")
return

print(f"\n准备更新 {len(compatible_packages)} 个包...")
response = input("是否继续？(y/n): ")

if response.lower() != 'y':
print("取消更新")
return

print("\n开始更新...")
for pkg in compatible_packages:
package_name = pkg['name']
latest_version = pkg['latest_version']

print(f"更新 {package_name} 到 {latest_version}...")
if update_package(package_name, latest_version):
print(f"  ✓ {package_name} 更新成功")
else:
print(f"  ✗ {package_name} 更新失败")

print("\n更新 requirements.txt...")
if update_requirements():
print("  ✓ requirements.txt 更新成功")
else:
print("  ✗ requirements.txt 更新失败")

print("\n依赖更新完成！")

if __name__ == '__main__':
main()

```## 依赖安全检查

```
python

#!/usr/bin/env python3
"""
依赖安全检查脚本
检查依赖包的安全漏洞
"""

import subprocess
import json
from typing import List, Dict

def check_security() -> List[Dict]:
    """检查依赖安全性"""
    try:
        result = subprocess.run(
            ['pip', 'audit'],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print("Error: Failed to check security")
            return []

        return json.loads(result.stdout)
    except Exception as e:
        print(f"Error checking security: {e}")
        return []

def main():
    """主函数"""
    print("检查依赖安全性...")

    vulnerabilities = check_security()

    if not vulnerabilities:
        print("未发现安全漏洞！")
        return

    print(f"\n发现 {len(vulnerabilities)} 个安全漏洞:")
    for vuln in vulnerabilities:
        print(f"\n  包: {vuln['name']}")
        print(f"  版本: {vuln['version']}")
        print(f"  漏洞: {vuln['advisory']}")
        print(f"  严重性: {vuln['severity']}")
        print(f"  修复版本: {vuln['fix_versions']}")

if __name__ == '__main__':
    main()

### 2. 数据库维护

```
python

# 示例：自动化数据库维护

用户请求：
"为应用实现自动化数据库维护"

Claude Code 生成的代码：

```python
```python

from datetime import datetime, timedelta
from sqlalchemy import text
from app import db
import logging

logger = logging.getLogger(__name__)

class DatabaseMaintenance:
    """数据库维护类"""

    def __init__(self, db_session):
        self.db = db_session

    def analyze_tables(self):
        """分析表"""
        tables = ['users', 'products', 'orders', 'payments']

        for table in tables:
            try:
                result = self.db.execute(text(f"ANALYZE {table}"))
                logger.info(f"Table {table} analyzed successfully")
            except Exception as e:
                logger.error(f"Error analyzing table {table}: {e}")

    def vacuum_tables(self):
        """清理表"""
        tables = ['users', 'products', 'orders', 'payments']

        for table in tables:
            try:
                result = self.db.execute(text(f"VACUUM ANALYZE {table}"))
                logger.info(f"Table {table} vacuumed successfully")
            except Exception as e:
                logger.error(f"Error vacuuming table {table}: {e}")

    def rebuild_indexes(self):
        """重建索引"""
        indexes = [
            'idx_users_username',
            'idx_users_email',
            'idx_orders_user_id',
            'idx_orders_status',
            'idx_products_name'
        ]

        for index in indexes:
            try:
```

```
bash复制            result = self.db.execute(text(f"REINDEX INDEX {index}"))
            logger.info(f"Index {index} rebuilt successfully")
        except Exception as e:
            logger.error(f"Error rebuilding index {index}: {e}")

def clean_old_logs(self, days=30):
    """清理旧日志"""
    cutoff_date = datetime.utcnow() - timedelta(days=days)

    try:
        result = self.db.execute(
            text("""
                DELETE FROM logs
                WHERE created_at < :cutoff_date
            """),
            {'cutoff_date': cutoff_date}
        )

        deleted_count = result.rowcount
        logger.info(f"Deleted {deleted_count} old log entries")

        self.db.commit()

        return deleted_count
    except Exception as e:
        logger.error(f"Error cleaning old logs: {e}")
        self.db.rollback()
        return 0

def clean_old_sessions(self, days=7):
    """清理旧会话"""
    cutoff_date = datetime.utcnow() - timedelta(days=days)

    try:
        result = self.db.execute(
            text("""
                DELETE FROM sessions
                WHERE expires_at < :cutoff_date
            """),
            {'cutoff_date': cutoff_date}
        )

        deleted_count = result.rowcount
        logger.info(f"Deleted {deleted_count} old sessions")

        self.db.commit()

        return deleted_count
    except Exception as e:
        logger.error(f"Error cleaning old sessions: {e}")
        self.db.rollback()
        return 0

def optimize_database(self):
    """优化数据库"""
    try:
        self.analyze_tables()
        self.vacuum_tables()
        self.rebuild_indexes()
        logger.info("Database optimization completed successfully")
    except Exception as e:
        logger.error(f"Error optimizing database: {e}")

def get_database_stats(self):
    """获取数据库统计信息"""
    stats = {}

    try:
        # 表大小
        result = self.db.execute(text("""
            SELECT
                schemaname,
                tablename,
                pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
            FROM pg_tables
            WHERE schemaname = 'public'
            ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        """))

        stats['table_sizes'] = [
            {
                'schema': row[0],
                'table': row[1],
                'size': row[2]
            }
            for row in result
        ]

        # 索引使用情况
        result = self.db.execute(text("""
            SELECT
                schemaname,
                tablename,
                indexname,
                idx_scan,
                idx_tup_read,
                idx_tup_fetch
            FROM pg_stat_user_indexes
            ORDER BY idx_scan DESC
        """))

        stats['index_usage'] = [
            {
                'schema': row[0],
                'table': row[1],
                'index': row[2],
                'scans': row[3],
                'tuples_read': row[4],
                'tuples_fetched': row[5]
            }
            for row in result
        ]

        # 慢查询
        result = self.db.execute(text("""
            SELECT
                query,
                calls,
                total_time,
                mean_time,
                max_time
            FROM pg_stat_statements
            ORDER BY mean_time DESC
            LIMIT 10
        """))

        stats['slow_queries'] = [
            {
                'query': row[0],
                'calls': row[1],
                'total_time': row[2],
                'mean_time': row[3],
                'max_time': row[4]
            }
            for row in result
        ]

        return stats
    except Exception as e:
        logger.error(f"Error getting database stats: {e}")
        return stats
```

```
result = self.db.execute(text(f"REINDEX INDEX {index}"))
            logger.info(f"Index {index} rebuilt successfully")
        except Exception as e:
            logger.error(f"Error rebuilding index {index}: {e}")

def clean_old_logs(self, days=30):
    """清理旧日志"""
    cutoff_date = datetime.utcnow() - timedelta(days=days)

    try:
        result = self.db.execute(
            text("""
                DELETE FROM logs
                WHERE created_at < :cutoff_date
            """),
            {'cutoff_date': cutoff_date}
        )

        deleted_count = result.rowcount
        logger.info(f"Deleted {deleted_count} old log entries")

        self.db.commit()

        return deleted_count
    except Exception as e:
        logger.error(f"Error cleaning old logs: {e}")
        self.db.rollback()
        return 0

def clean_old_sessions(self, days=7):
    """清理旧会话"""
    cutoff_date = datetime.utcnow() - timedelta(days=days)

    try:
        result = self.db.execute(
            text("""
                DELETE FROM sessions
                WHERE expires_at < :cutoff_date
            """),
            {'cutoff_date': cutoff_date}
        )

        deleted_count = result.rowcount
        logger.info(f"Deleted {deleted_count} old sessions")

        self.db.commit()

        return deleted_count
    except Exception as e:
        logger.error(f"Error cleaning old sessions: {e}")
        self.db.rollback()
        return 0

def optimize_database(self):
    """优化数据库"""
    try:
        self.analyze_tables()
        self.vacuum_tables()
        self.rebuild_indexes()
        logger.info("Database optimization completed successfully")
    except Exception as e:
        logger.error(f"Error optimizing database: {e}")

def get_database_stats(self):
    """获取数据库统计信息"""
    stats = {}

    try:
        # 表大小
        result = self.db.execute(text("""
            SELECT
                schemaname,
                tablename,
                pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
            FROM pg_tables
            WHERE schemaname = 'public'
            ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        """))

        stats['table_sizes'] = [
            {
                'schema': row[0],
                'table': row[1],
                'size': row[2]
            }
            for row in result
        ]

        # 索引使用情况
        result = self.db.execute(text("""
            SELECT
                schemaname,
                tablename,
                indexname,
                idx_scan,
                idx_tup_read,
                idx_tup_fetch
            FROM pg_stat_user_indexes
            ORDER BY idx_scan DESC
        """))

        stats['index_usage'] = [
            {
                'schema': row[0],
                'table': row[1],
                'index': row[2],
                'scans': row[3],
                'tuples_read': row[4],
                'tuples_fetched': row[5]
            }
            for row in result
        ]

        # 慢查询
        result = self.db.execute(text("""
            SELECT
                query,
                calls,
                total_time,
                mean_time,
                max_time
            FROM pg_stat_statements
            ORDER BY mean_time DESC
            LIMIT 10
        """))

        stats['slow_queries'] = [
            {
                'query': row[0],
                'calls': row[1],
                'total_time': row[2],
                'mean_time': row[3],
                'max_time': row[4]
            }
            for row in result
        ]

        return stats
    except Exception as e:
        logger.error(f"Error getting database stats: {e}")
        return stats
```

def run_maintenance():
"""运行维护任务"""
maintenance = DatabaseMaintenance(db.session)

```
bash复制print("开始数据库维护...")

# 优化数据库
print("优化数据库...")
maintenance.optimize_database()

# 清理旧数据
print("清理旧日志...")
maintenance.clean_old_logs(days=30)

print("清理旧会话...")
maintenance.clean_old_sessions(days=7)

# 获取统计信息
print("获取数据库统计信息...")
stats = maintenance.get_database_stats()

print("\n数据库统计信息:")
print(f"  表数量: {len(stats['table_sizes'])}")
print(f"  索引数量: {len(stats['index_usage'])}")
print(f"  慢查询数量: {len(stats['slow_queries'])}")

print("\n数据库维护完成！")
```

```
print("开始数据库维护...")

# 优化数据库
print("优化数据库...")
maintenance.optimize_database()

# 清理旧数据
print("清理旧日志...")
maintenance.clean_old_logs(days=30)

print("清理旧会话...")
maintenance.clean_old_sessions(days=7)

# 获取统计信息
print("获取数据库统计信息...")
stats = maintenance.get_database_stats()

print("\n数据库统计信息:")
print(f"  表数量: {len(stats['table_sizes'])}")
print(f"  索引数量: {len(stats['index_usage'])}")
print(f"  慢查询数量: {len(stats['slow_queries'])}")

print("\n数据库维护完成！")
```

if name == 'main':
run_maintenance()

#### 系统监控#

##### 1. 性能监控#

```
bash复制python

# 示例：实现性能监控

用户请求：
"为应用实现性能监控"

Claude Code 生成的代码：

```python
```python

import time
import psutil
from functools import wraps
from flask import request, g
from prometheus_client import Counter, Histogram, Gauge, generate_latest
import logging

logger = logging.getLogger(__name__)

# Prometheus 指标
request_count = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

request_duration = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

active_connections = Gauge(
    'active_connections',
    'Number of active connections'
)

memory_usage = Gauge(
    'memory_usage_bytes',
    'Memory usage in bytes'
)

cpu_usage = Gauge(
    'cpu_usage_percent',
    'CPU usage percentage'
)

disk_usage = Gauge(
    'disk_usage_percent',
    'Disk usage percentage'
)

def track_request_metrics(f):
    """跟踪请求指标"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = time.time()

        # 记录请求开始
        g.start_time = start_time

        try:
            response = f(*args, **kwargs)
            status_code = response.status_code if hasattr(response, 'status_code') else 200

            # 记录请求计数
            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=status_code
            ).inc()

            # 记录请求持续时间
            duration = time.time() - start_time
            request_duration.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown'
            ).observe(duration)

            return response
        except Exception as e:
            # 记录错误
            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=500
            ).inc()
            raise

    return decorated_function

def update_system_metrics():
    """更新系统指标"""
    # 内存使用
    memory = psutil.virtual_memory()
    memory_usage.set(memory.used)

    # CPU 使用
    cpu_usage.set(psutil.cpu_percent())

    # 磁盘使用
    disk = psutil.disk_usage('/')
    disk_usage.set(disk.percent)

    # 活跃连接
    active_connections.set(len(psutil.net_connections()))

class PerformanceMonitor:
    """性能监控类"""

    def __init__(self, app):
        self.app = app
        self.metrics = {}

    def track_function(self, name):
        """跟踪函数性能"""
        def decorator(f):
            @wraps(f)
            def decorated_function(*args, **kwargs):
                start_time = time.time()

                try:
                    result = f(*args, **kwargs)
                    duration = time.time() - start_time

                    self.record_metric(name, duration, success=True)

                    return result
                except Exception as e:
                    duration = time.time() - start_time

                    self.record_metric(name, duration, success=False)

                    logger.error(f"Error in {name}: {e}")
                    raise

            return decorated_function
        return decorator

    def record_metric(self, name, duration, success=True):
        """记录指标"""
        if name not in self.metrics:
            self.metrics[name] = {
                'count': 0,
                'total_duration': 0,
                'success_count': 0,
                'error_count': 0,
                'min_duration': float('inf'),
                'max_duration': 0
            }

        metric = self.metrics[name]
        metric['count'] += 1
        metric['total_duration'] += duration

        if success:
            metric['success_count'] += 1
        else:
            metric['error_count'] += 1

        metric['min_duration'] = min(metric['min_duration'], duration)
        metric['max_duration'] = max(metric['max_duration'], duration)

    def get_metrics(self):
        """获取指标"""
        for name, metric in self.metrics.items():
            if metric['count'] > 0:
                metric['avg_duration'] = metric['total_duration'] / metric['count']
                metric['success_rate'] = metric['success_count'] / metric['count']

        return self.metrics

    def get_slow_functions(self, threshold=1.0):
        """获取慢函数"""
        slow_functions = []

        for name, metric in self.metrics.items():
            if metric['count'] > 0:
                avg_duration = metric['total_duration'] / metric['count']
                if avg_duration > threshold:
                    slow_functions.append({
                        'name': name,
                        'avg_duration': avg_duration,
                        'count': metric['count'],
                        'max_duration': metric['max_duration']
                    })

        return sorted(slow_functions, key=lambda x: x['avg_duration'], reverse=True)

def setup_monitoring(app):
    """设置监控"""

    @app.route('/metrics')
    def metrics():
        """Prometheus 指标端点"""
        return generate_latest()

    @app.before_request
    def before_request():
        """请求前处理"""
        g.start_time = time.time()
        active_connections.inc()

    @app.after_request
    def after_request(response):
        """请求后处理"""
        if hasattr(g, 'start_time'):
            duration = time.time() - g.start_time

            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=response.status_code
            ).inc()

            request_duration.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown'
            ).observe(duration)

        active_connections.dec()

        return response

    # 定期更新系统指标
    def update_metrics():
        while True:
            update_system_metrics()
            time.sleep(5)

    import threading
    thread = threading.Thread(target=update_metrics, daemon=True)
    thread.start()

    return app

### 2. 错误监控

````python
````python

# 示例：实现错误监控

用户请求：
"为应用实现错误监控"

Claude Code 生成的代码：

```python
```python

import logging
import traceback
from datetime import datetime
from typing import Dict, List
from flask import request, g
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration

logger = logging.getLogger(__name__)

class ErrorMonitor:
    """错误监控类"""

    def __init__(self, app):
        self.app = app
        self.errors = []
        self.error_stats = {}

    def capture_exception(self, exception, context=None):
        """捕获异常"""
        error_data = {
            'type': type(exception).__name__,
            'message': str(exception),
            'traceback': traceback.format_exc(),
            'timestamp': datetime.utcnow().isoformat(),
            'context': context or {}
        }

        # 添加请求信息
        if request:
            error_data['request'] = {
                'method': request.method,
                'path': request.path,
                'url': request.url,
                'ip': request.remote_addr,
                'user_agent': request.user_agent.string
            }

        # 添加用户信息
        if hasattr(g, 'user_id'):
            error_data['user_id'] = g.user_id

        self.errors.append(error_data)

        # 更新统计
        error_type = error_data['type']
        if error_type not in self.error_stats:
            self.error_stats[error_type] = {
                'count': 0,
                'last_occurrence': None
            }

        self.error_stats[error_type]['count'] += 1
        self.error_stats[error_type]['last_occurrence'] = error_data['timestamp']

        # 记录日志
        logger.error(
            f"Exception captured: {error_type}",
            extra=error_data
        )

        # 发送到 Sentry
        sentry_sdk.capture_exception(exception)

    def get_errors(self, limit=100):
        """获取错误列表"""
        return self.errors[-limit:]

    def get_error_stats(self):
        """获取错误统计"""
        return self.error_stats

    def get_frequent_errors(self, threshold=10):
        """获取频繁错误"""
        frequent_errors = []

        for error_type, stats in self.error_stats.items():
            if stats['count'] >= threshold:
                frequent_errors.append({
                    'type': error_type,
                    'count': stats['count'],
                    'last_occurrence': stats['last_occurrence']
                })

        return sorted(frequent_errors, key=lambda x: x['count'], reverse=True)

    def clear_errors(self):
        """清除错误"""
        self.errors = []
        self.error_stats = {}

def setup_error_monitoring(app, sentry_dsn):
    """设置错误监控"""

    # 初始化 Sentry
    sentry_sdk.init(
        dsn=sentry_dsn,
        integrations=[FlaskIntegration()],
        traces_sample_rate=1.0,
        profiles_sample_rate=1.0
    )

    error_monitor = ErrorMonitor(app)

    @app.errorhandler(Exception)
    def handle_exception(e):
        """处理异常"""
        error_monitor.capture_exception(e)

        if request.is_json:
            return {'error': str(e)}, 500
        else:
            return str(e), 500

    @app.errorhandler(404)
    def handle_not_found(e):
        """处理 404"""
        logger.warning(f"404 Not Found: {request.path}")
        return {'error': 'Not found'}, 404

    @app.errorhandler(500)
    def handle_server_error(e):
        """处理 500"""
        error_monitor.capture_exception(e)
        return {'error': 'Internal server error'}, 500

    @app.route('/admin/errors')
    def get_errors():
        """获取错误列表"""
        errors = error_monitor.get_errors()
        return {'errors': errors}

    @app.route('/admin/errors/stats')
    def get_error_stats():
        """获取错误统计"""
        stats = error_monitor.get_error_stats()
        return {'stats': stats}

    @app.route('/admin/errors/frequent')
    def get_frequent_errors():
        """获取频繁错误"""
        frequent_errors = error_monitor.get_frequent_errors()
        return {'frequent_errors': frequent_errors}

    return app

```## 预测性维护

### 1. 容量预测

# 示例：实现容量预测
用户请求：
"为应用实现容量预测"
Claude Code 生成的代码：
````python
`python

import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict
import logging

logger = logging.getLogger(__name__)

class CapacityPredictor:
"""容量预测器"""

def __init__(self):
self.history = []
self.predictions = {}

def add_metric(self, timestamp: datetime, metric_name: str, value: float):
"""添加指标"""
self.history.append({
'timestamp': timestamp,
'metric': metric_name,
'value': value
})

def predict_capacity(self, metric_name: str, days: int = 7) -> List[Dict]:
"""预测容量"""
 # 获取历史数据
data = [
entry for entry in self.history
if entry['metric'] == metric_name
]

if len(data) < 30:
logger.warning(f"Insufficient data for {metric_name}")
return []

 # 提取值
values = [entry['value'] for entry in data]

 # 计算趋势
trend = self._calculate_trend(values)

 # 预测未来值
predictions = []
for i in range(days):
predicted_value = values[-1] + trend * (i + 1)
predicted_date = datetime.utcnow() + timedelta(days=i + 1)

predictions.append({
'date': predicted_date.isoformat(),
'value': predicted_value,
'metric': metric_name
})

self.predictions[metric_name] = predictions

return predictions

def _calculate_trend(self, values: List[float]) -> float:
"""计算趋势"""
if len(values) < 2:
return 0

 # 使用线性回归
x = np.arange(len(values))
y = np.array(values)

 # 计算斜率
slope = np.polyfit(x, y, 1)[0]

return slope

def check_capacity_alerts(self, threshold: float = 0.9) -> List[Dict]:
"""检查容量告警"""
alerts = []

for metric_name, predictions in self.predictions.items():
for prediction in predictions:
if prediction['value'] >= threshold:
alerts.append({
'metric': metric_name,
'date': prediction['date'],
'value': prediction['value'],
'threshold': threshold
})

return sorted(alerts, key=lambda x: x['value'], reverse=True)

def get_capacity_recommendations(self) -> List[Dict]:
"""获取容量建议"""
recommendations = []

alerts = self.check_capacity_alerts()

if alerts:
recommendations.append({
'type': 'scale_up',
'message': f"发现 {len(alerts)} 个容量告警，建议扩容",
'alerts': alerts
})

 # 检查资源利用率
for metric_name, predictions in self.predictions.items():
avg_value = np.mean([p['value'] for p in predictions])

if avg_value < 0.3:
recommendations.append({
'type': 'scale_down',
'message': f"{metric_name} 平均利用率较低，建议缩容",
'metric': metric_name,
'avg_value': avg_value
})

return recommendations

def run_capacity_prediction():
"""运行容量预测"""
predictor = CapacityPredictor()

 # 添加历史数据（示例）
now = datetime.utcnow()
for i in range(30):
timestamp = now - timedelta(days=30 - i)
value = 0.5 + (i / 100) + np.random.normal(0, 0.05)
predictor.add_metric(timestamp, 'cpu_usage', value)

 # 预测容量
print("预测 CPU 使用率...")
predictions = predictor.predict_capacity('cpu_usage', days=7)

print("\n预测结果:")
for prediction in predictions:
print(f"  {prediction['date']}: {prediction['value']:.2%}")

 # 检查告警
print("\n检查容量告警...")
alerts = predictor.check_capacity_alerts(threshold=0.9)

if alerts:
print(f"发现 {len(alerts)} 个告警:")
for alert in alerts:
print(f"  {alert['date']}: {alert['value']:.2%} (阈值: {alert['threshold']:.0%})")
else:
print("未发现容量告警")

 # 获取建议
print("\n获取容量建议...")
recommendations = predictor.get_capacity_recommendations()

for rec in recommendations:
print(f"  {rec['type']}: {rec['message']}")

if __name__ == '__main__':
run_capacity_prediction()
```

```
python

# 示例：实现性能监控

用户请求：
"为应用实现性能监控"

Claude Code 生成的代码：

```python
```python

import time
import psutil
from functools import wraps
from flask import request, g
from prometheus_client import Counter, Histogram, Gauge, generate_latest
import logging

logger = logging.getLogger(__name__)

# Prometheus 指标
request_count = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

request_duration = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

active_connections = Gauge(
    'active_connections',
    'Number of active connections'
)

memory_usage = Gauge(
    'memory_usage_bytes',
    'Memory usage in bytes'
)

cpu_usage = Gauge(
    'cpu_usage_percent',
    'CPU usage percentage'
)

disk_usage = Gauge(
    'disk_usage_percent',
    'Disk usage percentage'
)

def track_request_metrics(f):
    """跟踪请求指标"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = time.time()

        # 记录请求开始
        g.start_time = start_time

        try:
            response = f(*args, **kwargs)
            status_code = response.status_code if hasattr(response, 'status_code') else 200

            # 记录请求计数
            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=status_code
            ).inc()

            # 记录请求持续时间
            duration = time.time() - start_time
            request_duration.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown'
            ).observe(duration)

            return response
        except Exception as e:
            # 记录错误
            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=500
            ).inc()
            raise

    return decorated_function

def update_system_metrics():
    """更新系统指标"""
    # 内存使用
    memory = psutil.virtual_memory()
    memory_usage.set(memory.used)

    # CPU 使用
    cpu_usage.set(psutil.cpu_percent())

    # 磁盘使用
    disk = psutil.disk_usage('/')
    disk_usage.set(disk.percent)

    # 活跃连接
    active_connections.set(len(psutil.net_connections()))

class PerformanceMonitor:
    """性能监控类"""

    def __init__(self, app):
        self.app = app
        self.metrics = {}

    def track_function(self, name):
        """跟踪函数性能"""
        def decorator(f):
            @wraps(f)
            def decorated_function(*args, **kwargs):
                start_time = time.time()

                try:
                    result = f(*args, **kwargs)
                    duration = time.time() - start_time

                    self.record_metric(name, duration, success=True)

                    return result
                except Exception as e:
                    duration = time.time() - start_time

                    self.record_metric(name, duration, success=False)

                    logger.error(f"Error in {name}: {e}")
                    raise

            return decorated_function
        return decorator

    def record_metric(self, name, duration, success=True):
        """记录指标"""
        if name not in self.metrics:
            self.metrics[name] = {
                'count': 0,
                'total_duration': 0,
                'success_count': 0,
                'error_count': 0,
                'min_duration': float('inf'),
                'max_duration': 0
            }

        metric = self.metrics[name]
        metric['count'] += 1
        metric['total_duration'] += duration

        if success:
            metric['success_count'] += 1
        else:
            metric['error_count'] += 1

        metric['min_duration'] = min(metric['min_duration'], duration)
        metric['max_duration'] = max(metric['max_duration'], duration)

    def get_metrics(self):
        """获取指标"""
        for name, metric in self.metrics.items():
            if metric['count'] > 0:
                metric['avg_duration'] = metric['total_duration'] / metric['count']
                metric['success_rate'] = metric['success_count'] / metric['count']

        return self.metrics

    def get_slow_functions(self, threshold=1.0):
        """获取慢函数"""
        slow_functions = []

        for name, metric in self.metrics.items():
            if metric['count'] > 0:
                avg_duration = metric['total_duration'] / metric['count']
                if avg_duration > threshold:
                    slow_functions.append({
                        'name': name,
                        'avg_duration': avg_duration,
                        'count': metric['count'],
                        'max_duration': metric['max_duration']
                    })

        return sorted(slow_functions, key=lambda x: x['avg_duration'], reverse=True)

def setup_monitoring(app):
    """设置监控"""

    @app.route('/metrics')
    def metrics():
        """Prometheus 指标端点"""
        return generate_latest()

    @app.before_request
    def before_request():
        """请求前处理"""
        g.start_time = time.time()
        active_connections.inc()

    @app.after_request
    def after_request(response):
        """请求后处理"""
        if hasattr(g, 'start_time'):
            duration = time.time() - g.start_time

            request_count.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown',
                status=response.status_code
            ).inc()

            request_duration.labels(
                method=request.method,
                endpoint=request.endpoint or 'unknown'
            ).observe(duration)

        active_connections.dec()

        return response

    # 定期更新系统指标
    def update_metrics():
        while True:
            update_system_metrics()
            time.sleep(5)

    import threading
    thread = threading.Thread(target=update_metrics, daemon=True)
    thread.start()

    return app

### 2. 错误监控

````python
````python

# 示例：实现错误监控

用户请求：
"为应用实现错误监控"

Claude Code 生成的代码：

```python
```python

import logging
import traceback
from datetime import datetime
from typing import Dict, List
from flask import request, g
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration

logger = logging.getLogger(__name__)

class ErrorMonitor:
    """错误监控类"""

    def __init__(self, app):
        self.app = app
        self.errors = []
        self.error_stats = {}

    def capture_exception(self, exception, context=None):
        """捕获异常"""
        error_data = {
            'type': type(exception).__name__,
            'message': str(exception),
            'traceback': traceback.format_exc(),
            'timestamp': datetime.utcnow().isoformat(),
            'context': context or {}
        }

        # 添加请求信息
        if request:
            error_data['request'] = {
                'method': request.method,
                'path': request.path,
                'url': request.url,
                'ip': request.remote_addr,
                'user_agent': request.user_agent.string
            }

        # 添加用户信息
        if hasattr(g, 'user_id'):
            error_data['user_id'] = g.user_id

        self.errors.append(error_data)

        # 更新统计
        error_type = error_data['type']
        if error_type not in self.error_stats:
            self.error_stats[error_type] = {
                'count': 0,
                'last_occurrence': None
            }

        self.error_stats[error_type]['count'] += 1
        self.error_stats[error_type]['last_occurrence'] = error_data['timestamp']

        # 记录日志
        logger.error(
            f"Exception captured: {error_type}",
            extra=error_data
        )

        # 发送到 Sentry
        sentry_sdk.capture_exception(exception)

    def get_errors(self, limit=100):
        """获取错误列表"""
        return self.errors[-limit:]

    def get_error_stats(self):
        """获取错误统计"""
        return self.error_stats

    def get_frequent_errors(self, threshold=10):
        """获取频繁错误"""
        frequent_errors = []

        for error_type, stats in self.error_stats.items():
            if stats['count'] >= threshold:
                frequent_errors.append({
                    'type': error_type,
                    'count': stats['count'],
                    'last_occurrence': stats['last_occurrence']
                })

        return sorted(frequent_errors, key=lambda x: x['count'], reverse=True)

    def clear_errors(self):
        """清除错误"""
        self.errors = []
        self.error_stats = {}

def setup_error_monitoring(app, sentry_dsn):
    """设置错误监控"""

    # 初始化 Sentry
    sentry_sdk.init(
        dsn=sentry_dsn,
        integrations=[FlaskIntegration()],
        traces_sample_rate=1.0,
        profiles_sample_rate=1.0
    )

    error_monitor = ErrorMonitor(app)

    @app.errorhandler(Exception)
    def handle_exception(e):
        """处理异常"""
        error_monitor.capture_exception(e)

        if request.is_json:
            return {'error': str(e)}, 500
        else:
            return str(e), 500

    @app.errorhandler(404)
    def handle_not_found(e):
        """处理 404"""
        logger.warning(f"404 Not Found: {request.path}")
        return {'error': 'Not found'}, 404

    @app.errorhandler(500)
    def handle_server_error(e):
        """处理 500"""
        error_monitor.capture_exception(e)
        return {'error': 'Internal server error'}, 500

    @app.route('/admin/errors')
    def get_errors():
        """获取错误列表"""
        errors = error_monitor.get_errors()
        return {'errors': errors}

    @app.route('/admin/errors/stats')
    def get_error_stats():
        """获取错误统计"""
        stats = error_monitor.get_error_stats()
        return {'stats': stats}

    @app.route('/admin/errors/frequent')
    def get_frequent_errors():
        """获取频繁错误"""
        frequent_errors = error_monitor.get_frequent_errors()
        return {'frequent_errors': frequent_errors}

    return app

```## 预测性维护

### 1. 容量预测

# 示例：实现容量预测
用户请求：
"为应用实现容量预测"
Claude Code 生成的代码：
````python
`python

import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict
import logging

logger = logging.getLogger(__name__)

class CapacityPredictor:
"""容量预测器"""

def __init__(self):
self.history = []
self.predictions = {}

def add_metric(self, timestamp: datetime, metric_name: str, value: float):
"""添加指标"""
self.history.append({
'timestamp': timestamp,
'metric': metric_name,
'value': value
})

def predict_capacity(self, metric_name: str, days: int = 7) -> List[Dict]:
"""预测容量"""
 # 获取历史数据
data = [
entry for entry in self.history
if entry['metric'] == metric_name
]

if len(data) < 30:
logger.warning(f"Insufficient data for {metric_name}")
return []

 # 提取值
values = [entry['value'] for entry in data]

 # 计算趋势
trend = self._calculate_trend(values)

 # 预测未来值
predictions = []
for i in range(days):
predicted_value = values[-1] + trend * (i + 1)
predicted_date = datetime.utcnow() + timedelta(days=i + 1)

predictions.append({
'date': predicted_date.isoformat(),
'value': predicted_value,
'metric': metric_name
})

self.predictions[metric_name] = predictions

return predictions

def _calculate_trend(self, values: List[float]) -> float:
"""计算趋势"""
if len(values) < 2:
return 0

 # 使用线性回归
x = np.arange(len(values))
y = np.array(values)

 # 计算斜率
slope = np.polyfit(x, y, 1)[0]

return slope

def check_capacity_alerts(self, threshold: float = 0.9) -> List[Dict]:
"""检查容量告警"""
alerts = []

for metric_name, predictions in self.predictions.items():
for prediction in predictions:
if prediction['value'] >= threshold:
alerts.append({
'metric': metric_name,
'date': prediction['date'],
'value': prediction['value'],
'threshold': threshold
})

return sorted(alerts, key=lambda x: x['value'], reverse=True)

def get_capacity_recommendations(self) -> List[Dict]:
"""获取容量建议"""
recommendations = []

alerts = self.check_capacity_alerts()

if alerts:
recommendations.append({
'type': 'scale_up',
'message': f"发现 {len(alerts)} 个容量告警，建议扩容",
'alerts': alerts
})

 # 检查资源利用率
for metric_name, predictions in self.predictions.items():
avg_value = np.mean([p['value'] for p in predictions])

if avg_value < 0.3:
recommendations.append({
'type': 'scale_down',
'message': f"{metric_name} 平均利用率较低，建议缩容",
'metric': metric_name,
'avg_value': avg_value
})

return recommendations

def run_capacity_prediction():
"""运行容量预测"""
predictor = CapacityPredictor()

 # 添加历史数据（示例）
now = datetime.utcnow()
for i in range(30):
timestamp = now - timedelta(days=30 - i)
value = 0.5 + (i / 100) + np.random.normal(0, 0.05)
predictor.add_metric(timestamp, 'cpu_usage', value)

 # 预测容量
print("预测 CPU 使用率...")
predictions = predictor.predict_capacity('cpu_usage', days=7)

print("\n预测结果:")
for prediction in predictions:
print(f"  {prediction['date']}: {prediction['value']:.2%}")

 # 检查告警
print("\n检查容量告警...")
alerts = predictor.check_capacity_alerts(threshold=0.9)

if alerts:
print(f"发现 {len(alerts)} 个告警:")
for alert in alerts:
print(f"  {alert['date']}: {alert['value']:.2%} (阈值: {alert['threshold']:.0%})")
else:
print("未发现容量告警")

 # 获取建议
print("\n获取容量建议...")
recommendations = predictor.get_capacity_recommendations()

for rec in recommendations:
print(f"  {rec['type']}: {rec['message']}")

if __name__ == '__main__':
run_capacity_prediction()
```

---

# 第 26 章

## 1 子Agent概述

**URL**: https://claudecode.tangshuang.net/course/26.1%20%E5%AD%90Agent%E6%A6%82%E8%BF%B0

#### 子Agent概述#

子Agent是Claude Code中的一个重要概念，它允许主Agent将复杂任务分解为多个子任务，并委托给专门的子Agent来处理。通过子Agent机制，Claude Code可以更高效地处理复杂的编程任务，提高任务完成的质量和速度。

#### 子Agent的概念#

##### 1. 什么是子Agent#

子Agent是主Agent的辅助实体，具有以下特点：

- 专业化: 每个子Agent专注于特定的任务领域
- 独立性: 子Agent可以独立完成任务，不依赖主Agent的持续干预
- 协作性: 多个子Agent可以协同工作，完成复杂的任务
- 可复用性: 子Agent可以在不同的任务中被重复使用

##### 2. 子Agent vs 主Agent#

#### 子Agent的类型#

##### 1. 代码生成子Agent#

### 示例：代码生成子Agent

用户请求：
"创建一个用户认证系统的代码生成子Agent"

Claude Code 生成的子Agent：

```
python复制````python

class CodeGenerationAgent:
"""代码生成子Agent"""

def __init__(self, context):
self.context = context
self.templates = {}
self.best_practices = {}

def generate_auth_system(self, requirements):
"""生成认证系统代码"""
 # 分析需求
analysis = self._analyze_requirements(requirements)

 # 选择模板
template = self._select_template(analysis)

 # 生成代码
code = self._generate_code(template, analysis)

 # 应用最佳实践
code = self._apply_best_practices(code)

 # 验证代码
validation = self._validate_code(code)

return {
'code': code,
'validation': validation,
'documentation': self._generate_documentation(code)
}

def _analyze_requirements(self, requirements):
"""分析需求"""
analysis = {
'auth_methods': [],
'security_level': 'medium',
'features': []
}

if 'jwt' in requirements:
analysis['auth_methods'].append('jwt')

if 'oauth' in requirements:
analysis['auth_methods'].append('oauth')

if '2fa' in requirements:
analysis['features'].append('2fa')

if 'session' in requirements:
analysis['auth_methods'].append('session')

return analysis

def _select_template(self, analysis):
"""选择模板"""
if 'jwt' in analysis['auth_methods']:
return 'jwt_auth_template'
elif 'oauth' in analysis['auth_methods']:
return 'oauth_auth_template'
else:
return 'basic_auth_template'

def _generate_code(self, template, analysis):
"""生成代码"""
if template == 'jwt_auth_template':
return self._generate_jwt_auth(analysis)
elif template == 'oauth_auth_template':
return self._generate_oauth_auth(analysis)
else:
return self._generate_basic_auth(analysis)

def _generate_jwt_auth(self, analysis):
"""生成JWT认证代码"""
code = '''
from flask import Flask, request, jsonify
from flask_jwt_extended import (
JWTManager, create_access_token,
jwt_required, get_jwt_identity
)
from datetime import timedelta
import bcrypt

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)

jwt = JWTManager(app)

class AuthService:
"""认证服务"""

def __init__(self, db):
self.db = db

def register(self, username, password):
"""用户注册"""
 # 检查用户名是否存在
if self._user_exists(username):
raise ValueError("Username already exists")
```

```
````python

class CodeGenerationAgent:
"""代码生成子Agent"""

def __init__(self, context):
self.context = context
self.templates = {}
self.best_practices = {}

def generate_auth_system(self, requirements):
"""生成认证系统代码"""
 # 分析需求
analysis = self._analyze_requirements(requirements)

 # 选择模板
template = self._select_template(analysis)

 # 生成代码
code = self._generate_code(template, analysis)

 # 应用最佳实践
code = self._apply_best_practices(code)

 # 验证代码
validation = self._validate_code(code)

return {
'code': code,
'validation': validation,
'documentation': self._generate_documentation(code)
}

def _analyze_requirements(self, requirements):
"""分析需求"""
analysis = {
'auth_methods': [],
'security_level': 'medium',
'features': []
}

if 'jwt' in requirements:
analysis['auth_methods'].append('jwt')

if 'oauth' in requirements:
analysis['auth_methods'].append('oauth')

if '2fa' in requirements:
analysis['features'].append('2fa')

if 'session' in requirements:
analysis['auth_methods'].append('session')

return analysis

def _select_template(self, analysis):
"""选择模板"""
if 'jwt' in analysis['auth_methods']:
return 'jwt_auth_template'
elif 'oauth' in analysis['auth_methods']:
return 'oauth_auth_template'
else:
return 'basic_auth_template'

def _generate_code(self, template, analysis):
"""生成代码"""
if template == 'jwt_auth_template':
return self._generate_jwt_auth(analysis)
elif template == 'oauth_auth_template':
return self._generate_oauth_auth(analysis)
else:
return self._generate_basic_auth(analysis)

def _generate_jwt_auth(self, analysis):
"""生成JWT认证代码"""
code = '''
from flask import Flask, request, jsonify
from flask_jwt_extended import (
JWTManager, create_access_token,
jwt_required, get_jwt_identity
)
from datetime import timedelta
import bcrypt

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)

jwt = JWTManager(app)

class AuthService:
"""认证服务"""

def __init__(self, db):
self.db = db

def register(self, username, password):
"""用户注册"""
 # 检查用户名是否存在
if self._user_exists(username):
raise ValueError("Username already exists")
```

### 哈希密码

password_hash = bcrypt.hashpw(
password.encode('utf-8'),
bcrypt.gensalt()
).decode('utf-8')

### 创建用户

user = User(username=username, password_hash=password_hash)
self.db.session.add(user)
self.db.session.commit()

return user

def login(self, username, password):
"""用户登录"""

### 查找用户

user = User.query.filter_by(username=username).first()

if not user:
raise ValueError("Invalid username or password")

### 验证密码

if not bcrypt.checkpw(
password.encode('utf-8'),
user.password_hash.encode('utf-8')
):
raise ValueError("Invalid username or password")

### 生成访问令牌

access_token = create_access_token(identity=user.id)

return {
'access_token': access_token,
'user': {
'id': user.id,
'username': user.username
}
}

def _user_exists(self, username):
"""检查用户名是否存在"""
return User.query.filter_by(username=username).first() is not None
'''
return code

def _apply_best_practices(self, code):
"""应用最佳实践"""

### 添加错误处理

code = self._add_error_handling(code)

### 添加日志记录

code = self._add_logging(code)

### 添加输入验证

code = self._add_input_validation(code)

return code

def _validate_code(self, code):
"""验证代码"""
validation = {
'syntax': True,
'security': True,
'best_practices': True,
'issues': []
}

### 检查语法

try:
compile(code, '<string>', 'exec')
except SyntaxError as e:
validation['syntax'] = False
validation['issues'].append(f"Syntax error: {e}")

### 检查安全性

if 'SECRET_KEY' in code and 'your-secret-key' in code:
validation['security'] = False
validation['issues'].append("Default secret key detected")

return validation

def _generate_documentation(self, code):
"""生成文档"""
return {
'description': 'JWT-based authentication system',
'endpoints': [
{
'path': '/register',
'method': 'POST',
'description': 'Register a new user',
'parameters': {
'username': 'string (required)',
'password': 'string (required)'
}
},
{
'path': '/login',
'method': 'POST',
'description': 'Login with username and password',
'parameters': {
'username': 'string (required)',
'password': 'string (required)'
}
}
],
'security': {
'password_hashing': 'bcrypt',
'token': 'JWT',
'token_expiry': '24 hours'
}
}

```
bash复制> - 专注于代码生成
> - 包含模板库和最佳实践
> - 自动验证生成的代码
> - 生成配套文档
```

```
> - 专注于代码生成
> - 包含模板库和最佳实践
> - 自动验证生成的代码
> - 生成配套文档
```

##### 2. 代码审查子Agent#

### 示例：代码审查子Agent

用户请求：
"创建一个代码审查子Agent"
Claude Code 生成的子Agent：

```
python复制`python

class CodeReviewAgent:
"""代码审查子Agent"""

def __init__(self, context):
self.context = context
self.rules = self._load_review_rules()
self.patterns = self._load_antipatterns()

def review_code(self, code, language='python'):
"""审查代码"""
review = {
'summary': {},
'issues': [],
'suggestions': [],
'metrics': {}
}

 # 执行静态分析
static_analysis = self._static_analysis(code, language)
review['issues'].extend(static_analysis['issues'])

 # 检查代码模式
pattern_analysis = self._check_patterns(code, language)
review['issues'].extend(pattern_analysis['issues'])
review['suggestions'].extend(pattern_analysis['suggestions'])

 # 计算代码指标
metrics = self._calculate_metrics(code, language)
review['metrics'] = metrics

 # 生成总结
review['summary'] = self._generate_summary(review)

return review

def _static_analysis(self, code, language):
"""静态分析"""
issues = []

 # 检查未使用的导入
unused_imports = self._check_unused_imports(code, language)
issues.extend(unused_imports)

 # 检查未使用的变量
unused_variables = self._check_unused_variables(code, language)
issues.extend(unused_variables)

 # 检查代码复杂度
complexity_issues = self._check_complexity(code, language)
issues.extend(complexity_issues)

 # 检查安全问题
security_issues = self._check_security(code, language)
issues.extend(security_issues)

return {'issues': issues}

def _check_unused_imports(self, code, language):
"""检查未使用的导入"""
issues = []

if language == 'python':
import ast
import re

tree = ast.parse(code)

 # 获取所有导入
imports = set()
for node in ast.walk(tree):
if isinstance(node, ast.Import):
for alias in node.names:
imports.add(alias.name.split('.')[0])
elif isinstance(node, ast.ImportFrom):
if node.module:
imports.add(node.module.split('.')[0])

 # 检查是否使用
for imp in imports:
if imp not in code[code.find(imp):]:
issues.append({
'type': 'unused_import',
'severity': 'warning',
'message': f"Unused import: {imp}",
'line': self._find_line(code, imp)
})

return issues

def _check_complexity(self, code, language):
"""检查代码复杂度"""
issues = []

if language == 'python':
import ast

tree = ast.parse(code)

for node in ast.walk(tree):
if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
complexity = self._calculate_cyclomatic_complexity(node)

if complexity > 10:
issues.append({
'type': 'high_complexity',
'severity': 'warning',
'message': f"Function '{node.name}' has high complexity ({complexity})",
'line': node.lineno,
'complexity': complexity
})

return issues

def _calculate_cyclomatic_complexity(self, node):
"""计算圈复杂度"""
complexity = 1

for child in ast.walk(node):
if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor)):
complexity += 1
elif isinstance(child, ast.ExceptHandler):
complexity += 1
elif isinstance(child, ast.BoolOp):
complexity += len(child.values) - 1

return complexity

def _check_security(self, code, language):
"""检查安全问题"""
issues = []

 # 检查硬编码密钥
if 'password' in code.lower() and '=' in code:
lines = code.split('\n')
for i, line in enumerate(lines, 1):
if 'password' in line.lower() and '"' in line:
issues.append({
'type': 'security',
'severity': 'error',
'message': 'Possible hardcoded password detected',
'line': i
})

 # 检查SQL注入风险
if 'execute' in code and '%' in code:
lines = code.split('\n')
for i, line in enumerate(lines, 1):
if 'execute' in line and '%' in line and not 'param' in line.lower():
issues.append({
'type': 'security',
'severity': 'error',
'message': 'Possible SQL injection vulnerability',
'line': i
})

return issues

def _check_patterns(self, code, language):
"""检查代码模式"""
issues = []
suggestions = []

 # 检查长函数
if language == 'python':
import ast

tree = ast.parse(code)

for node in ast.walk(tree):
if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
end_line = node.end_lineno if hasattr(node, 'end_lineno') else node.lineno
length = end_line - node.lineno

if length > 50:
issues.append({
'type': 'long_function',
'severity': 'warning',
'message': f"Function '{node.name}' is too long ({length} lines)",
'line': node.lineno,
'length': length
})
suggestions.append({
'type': 'refactor',
'message': f"Consider breaking down '{node.name}' into smaller functions",
'line': node.lineno
})

return {'issues': issues, 'suggestions': suggestions}

def _calculate_metrics(self, code, language):
"""计算代码指标"""
metrics = {}

lines = code.split('\n')

 # 总行数
metrics['total_lines'] = len(lines)

 # 代码行数（排除空行和注释）
code_lines = [line for line in lines if line.strip() and not line.strip().startswith('#')]
metrics['code_lines'] = len(code_lines)

 # 注释行数
comment_lines = [line for line in lines if line.strip().startswith('#')]
metrics['comment_lines'] = len(comment_lines)

 # 空行数
blank_lines = [line for line in lines if not line.strip()]
metrics['blank_lines'] = len(blank_lines)

 # 注释率
metrics['comment_ratio'] = metrics['comment_lines'] / metrics['code_lines'] if metrics['code_lines'] > 0 else 0

return metrics

def _generate_summary(self, review):
"""生成审查总结"""
summary = {
'total_issues': len(review['issues']),
'critical_issues': len([i for i in review['issues'] if i['severity'] == 'error']),
'warning_issues': len([i for i in review['issues'] if i['severity'] == 'warning']),
'total_suggestions': len(review['suggestions']),
'code_quality': 'good'
}

 # 评估代码质量
if summary['critical_issues'] > 0:
summary['code_quality'] = 'poor'
elif summary['warning_issues'] > 5:
summary['code_quality'] = 'fair'

return summary

```> **子Agent特点**:
> - 专注于代码审查
> - 包含审查规则库
> - 检查代码模式和反模式
> - 计算代码指标

```
## 子Agent的协作

### 1. 串行协作

# 示例：子Agent串行协作
用户请求：
"使用子Agent完成一个完整的开发任务"
Claude Code 生成的协作流程：
````python
`python

class AgentOrchestrator:
"""Agent协调器"""

def __init__(self, context):
self.context = context
self.agents = {
'code_generator': CodeGenerationAgent(context),
'code_reviewer': CodeReviewAgent(context),
'test_generator': TestGenerationAgent(context),
'documenter': DocumentationAgent(context)
}

def execute_task(self, task):
"""执行任务"""
results = {}

 # 步骤1: 生成代码
print("Step 1: Generating code...")
code_result = self.agents['code_generator'].generate_code(task)
results['code'] = code_result

 # 步骤2: 审查代码
print("Step 2: Reviewing code...")
review_result = self.agents['code_reviewer'].review_code(
code_result['code'],
language=task.get('language', 'python')
)
results['review'] = review_result

 # 步骤3: 修复问题
if review_result['summary']['critical_issues'] > 0:
print("Step 3: Fixing critical issues...")
fixed_code = self._fix_issues(
code_result['code'],
review_result['issues']
)
results['fixed_code'] = fixed_code
else:
results['fixed_code'] = code_result['code']

 # 步骤4: 生成测试
print("Step 4: Generating tests...")
test_result = self.agents['test_generator'].generate_tests(
results['fixed_code'],
language=task.get('language', 'python')
)
results['tests'] = test_result

 # 步骤5: 生成文档
print("Step 5: Generating documentation...")
doc_result = self.agents['documenter'].generate_documentation(
results['fixed_code'],
test_result['tests']
)
results['documentation'] = doc_result

return results

def _fix_issues(self, code, issues):
"""修复代码问题"""
fixed_code = code

for issue in issues:
if issue['type'] == 'security':
fixed_code = self._fix_security_issue(fixed_code, issue)
elif issue['type'] == 'high_complexity':
fixed_code = self._refactor_complex_function(fixed_code, issue)

return fixed_code

def _fix_security_issue(self, code, issue):
"""修复安全问题"""
 # 实现安全修复逻辑
return code

def _refactor_complex_function(self, code, issue):
"""重构复杂函数"""
 # 实现重构逻辑
return code

```> **协作流程**:
1. 代码生成子Agent生成代码
2. 代码审查子Agent审查代码
3. 修复发现的问题
4. 测试生成子Agent生成测试
5. 文档生成子Agent生成文档
```
### 2. 并行协作

# 示例：子Agent并行协作
用户请求：
"使用子Agent并行处理多个任务"
Claude Code 生成的并行协作流程：
````python
`python

import concurrent.futures

class ParallelAgentOrchestrator:
"""并行Agent协调器"""

def __init__(self, context):
self.context = context
self.agents = {
'code_generator': CodeGenerationAgent(context),
'code_reviewer': CodeReviewAgent(context),
'test_generator': TestGenerationAgent(context),
'documenter': DocumentationAgent(context)
}

def execute_parallel_tasks(self, tasks):
"""并行执行任务"""
results = {}

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
 # 提交任务
future_to_task = {
executor.submit(self.agents['code_generator'].generate_code, task): task
for task in tasks
}

 # 收集结果
for future in concurrent.futures.as_completed(future_to_task):
task = future_to_task[future]
try:
result = future.result()
results[task['id']] = result
except Exception as e:
results[task['id']] = {'error': str(e)}

return results

def execute_parallel_analysis(self, code):
"""并行分析代码"""
results = {}

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
 # 提交分析任务
futures = {
'static_analysis': executor.submit(
self.agents['code_reviewer']._static_analysis,
code,
'python'
),
'pattern_analysis': executor.submit(
self.agents['code_reviewer']._check_patterns,
code,
'python'
),
'security_analysis': executor.submit(
self.agents['code_reviewer']._check_security,
code,
'python'
),
'metrics_calculation': executor.submit(
self.agents['code_reviewer']._calculate_metrics,
code,
'python'
)
}

 # 收集结果
for name, future in futures.items():
try:
results[name] = future.result()
except Exception as e:
results[name] = {'error': str(e)}

return results

```> **并行协作优势**:
> - 提高任务执行速度
> - 充分利用系统资源
> - 缩短总执行时间

```
## 子Agent的优势

### 1. 提高效率

| 任务类型 | 单Agent | 多子Agent | 效率提升 |
|----------|---------|-----------|----------|
| 代码生成 + 审查 | 10分钟 | 6分钟 | 40% ↑ |
| 多文件处理 | 15分钟 | 5分钟 | 67% ↑ |
| 复杂任务分解 | 20分钟 | 8分钟 | 60% ↑ |

### 2. 提高质量

| 指标 | 单Agent | 多子Agent | 改善 |
|------|---------|-----------|------|
| 代码质量 | 75% | 90% | +20% |
| 错误率 | 15% | 5% | 67% ↓ |
| 测试覆盖率 | 70% | 85% | +21% |

### 3. 提高可维护性

- **模块化**: 每个子Agent独立维护
- **可扩展**: 容易添加新的子Agent
- **可复用**: 子Agent可以在不同任务中复用

## 总结

子Agent概述包括：

1. **子Agent的概念**: 什么是子Agent、子Agent vs 主Agent
2. **子Agent的类型**: 代码生成子Agent、代码审查子Agent
3. **子Agent的协作**: 串行协作、并行协作
4. **子Agent的优势**: 提高效率、提高质量、提高可维护性

通过子Agent机制，Claude Code可以更高效地处理复杂的编程任务。

在下一节中，我们将探讨异步子Agent任务。

```
```
```

```
`python

class CodeReviewAgent:
"""代码审查子Agent"""

def __init__(self, context):
self.context = context
self.rules = self._load_review_rules()
self.patterns = self._load_antipatterns()

def review_code(self, code, language='python'):
"""审查代码"""
review = {
'summary': {},
'issues': [],
'suggestions': [],
'metrics': {}
}

 # 执行静态分析
static_analysis = self._static_analysis(code, language)
review['issues'].extend(static_analysis['issues'])

 # 检查代码模式
pattern_analysis = self._check_patterns(code, language)
review['issues'].extend(pattern_analysis['issues'])
review['suggestions'].extend(pattern_analysis['suggestions'])

 # 计算代码指标
metrics = self._calculate_metrics(code, language)
review['metrics'] = metrics

 # 生成总结
review['summary'] = self._generate_summary(review)

return review

def _static_analysis(self, code, language):
"""静态分析"""
issues = []

 # 检查未使用的导入
unused_imports = self._check_unused_imports(code, language)
issues.extend(unused_imports)

 # 检查未使用的变量
unused_variables = self._check_unused_variables(code, language)
issues.extend(unused_variables)

 # 检查代码复杂度
complexity_issues = self._check_complexity(code, language)
issues.extend(complexity_issues)

 # 检查安全问题
security_issues = self._check_security(code, language)
issues.extend(security_issues)

return {'issues': issues}

def _check_unused_imports(self, code, language):
"""检查未使用的导入"""
issues = []

if language == 'python':
import ast
import re

tree = ast.parse(code)

 # 获取所有导入
imports = set()
for node in ast.walk(tree):
if isinstance(node, ast.Import):
for alias in node.names:
imports.add(alias.name.split('.')[0])
elif isinstance(node, ast.ImportFrom):
if node.module:
imports.add(node.module.split('.')[0])

 # 检查是否使用
for imp in imports:
if imp not in code[code.find(imp):]:
issues.append({
'type': 'unused_import',
'severity': 'warning',
'message': f"Unused import: {imp}",
'line': self._find_line(code, imp)
})

return issues

def _check_complexity(self, code, language):
"""检查代码复杂度"""
issues = []

if language == 'python':
import ast

tree = ast.parse(code)

for node in ast.walk(tree):
if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
complexity = self._calculate_cyclomatic_complexity(node)

if complexity > 10:
issues.append({
'type': 'high_complexity',
'severity': 'warning',
'message': f"Function '{node.name}' has high complexity ({complexity})",
'line': node.lineno,
'complexity': complexity
})

return issues

def _calculate_cyclomatic_complexity(self, node):
"""计算圈复杂度"""
complexity = 1

for child in ast.walk(node):
if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor)):
complexity += 1
elif isinstance(child, ast.ExceptHandler):
complexity += 1
elif isinstance(child, ast.BoolOp):
complexity += len(child.values) - 1

return complexity

def _check_security(self, code, language):
"""检查安全问题"""
issues = []

 # 检查硬编码密钥
if 'password' in code.lower() and '=' in code:
lines = code.split('\n')
for i, line in enumerate(lines, 1):
if 'password' in line.lower() and '"' in line:
issues.append({
'type': 'security',
'severity': 'error',
'message': 'Possible hardcoded password detected',
'line': i
})

 # 检查SQL注入风险
if 'execute' in code and '%' in code:
lines = code.split('\n')
for i, line in enumerate(lines, 1):
if 'execute' in line and '%' in line and not 'param' in line.lower():
issues.append({
'type': 'security',
'severity': 'error',
'message': 'Possible SQL injection vulnerability',
'line': i
})

return issues

def _check_patterns(self, code, language):
"""检查代码模式"""
issues = []
suggestions = []

 # 检查长函数
if language == 'python':
import ast

tree = ast.parse(code)

for node in ast.walk(tree):
if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
end_line = node.end_lineno if hasattr(node, 'end_lineno') else node.lineno
length = end_line - node.lineno

if length > 50:
issues.append({
'type': 'long_function',
'severity': 'warning',
'message': f"Function '{node.name}' is too long ({length} lines)",
'line': node.lineno,
'length': length
})
suggestions.append({
'type': 'refactor',
'message': f"Consider breaking down '{node.name}' into smaller functions",
'line': node.lineno
})

return {'issues': issues, 'suggestions': suggestions}

def _calculate_metrics(self, code, language):
"""计算代码指标"""
metrics = {}

lines = code.split('\n')

 # 总行数
metrics['total_lines'] = len(lines)

 # 代码行数（排除空行和注释）
code_lines = [line for line in lines if line.strip() and not line.strip().startswith('#')]
metrics['code_lines'] = len(code_lines)

 # 注释行数
comment_lines = [line for line in lines if line.strip().startswith('#')]
metrics['comment_lines'] = len(comment_lines)

 # 空行数
blank_lines = [line for line in lines if not line.strip()]
metrics['blank_lines'] = len(blank_lines)

 # 注释率
metrics['comment_ratio'] = metrics['comment_lines'] / metrics['code_lines'] if metrics['code_lines'] > 0 else 0

return metrics

def _generate_summary(self, review):
"""生成审查总结"""
summary = {
'total_issues': len(review['issues']),
'critical_issues': len([i for i in review['issues'] if i['severity'] == 'error']),
'warning_issues': len([i for i in review['issues'] if i['severity'] == 'warning']),
'total_suggestions': len(review['suggestions']),
'code_quality': 'good'
}

 # 评估代码质量
if summary['critical_issues'] > 0:
summary['code_quality'] = 'poor'
elif summary['warning_issues'] > 5:
summary['code_quality'] = 'fair'

return summary

```> **子Agent特点**:
> - 专注于代码审查
> - 包含审查规则库
> - 检查代码模式和反模式
> - 计算代码指标

```
## 子Agent的协作

### 1. 串行协作

# 示例：子Agent串行协作
用户请求：
"使用子Agent完成一个完整的开发任务"
Claude Code 生成的协作流程：
````python
`python

class AgentOrchestrator:
"""Agent协调器"""

def __init__(self, context):
self.context = context
self.agents = {
'code_generator': CodeGenerationAgent(context),
'code_reviewer': CodeReviewAgent(context),
'test_generator': TestGenerationAgent(context),
'documenter': DocumentationAgent(context)
}

def execute_task(self, task):
"""执行任务"""
results = {}

 # 步骤1: 生成代码
print("Step 1: Generating code...")
code_result = self.agents['code_generator'].generate_code(task)
results['code'] = code_result

 # 步骤2: 审查代码
print("Step 2: Reviewing code...")
review_result = self.agents['code_reviewer'].review_code(
code_result['code'],
language=task.get('language', 'python')
)
results['review'] = review_result

 # 步骤3: 修复问题
if review_result['summary']['critical_issues'] > 0:
print("Step 3: Fixing critical issues...")
fixed_code = self._fix_issues(
code_result['code'],
review_result['issues']
)
results['fixed_code'] = fixed_code
else:
results['fixed_code'] = code_result['code']

 # 步骤4: 生成测试
print("Step 4: Generating tests...")
test_result = self.agents['test_generator'].generate_tests(
results['fixed_code'],
language=task.get('language', 'python')
)
results['tests'] = test_result

 # 步骤5: 生成文档
print("Step 5: Generating documentation...")
doc_result = self.agents['documenter'].generate_documentation(
results['fixed_code'],
test_result['tests']
)
results['documentation'] = doc_result

return results

def _fix_issues(self, code, issues):
"""修复代码问题"""
fixed_code = code

for issue in issues:
if issue['type'] == 'security':
fixed_code = self._fix_security_issue(fixed_code, issue)
elif issue['type'] == 'high_complexity':
fixed_code = self._refactor_complex_function(fixed_code, issue)

return fixed_code

def _fix_security_issue(self, code, issue):
"""修复安全问题"""
 # 实现安全修复逻辑
return code

def _refactor_complex_function(self, code, issue):
"""重构复杂函数"""
 # 实现重构逻辑
return code

```> **协作流程**:
1. 代码生成子Agent生成代码
2. 代码审查子Agent审查代码
3. 修复发现的问题
4. 测试生成子Agent生成测试
5. 文档生成子Agent生成文档
```
### 2. 并行协作

# 示例：子Agent并行协作
用户请求：
"使用子Agent并行处理多个任务"
Claude Code 生成的并行协作流程：
````python
`python

import concurrent.futures

class ParallelAgentOrchestrator:
"""并行Agent协调器"""

def __init__(self, context):
self.context = context
self.agents = {
'code_generator': CodeGenerationAgent(context),
'code_reviewer': CodeReviewAgent(context),
'test_generator': TestGenerationAgent(context),
'documenter': DocumentationAgent(context)
}

def execute_parallel_tasks(self, tasks):
"""并行执行任务"""
results = {}

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
 # 提交任务
future_to_task = {
executor.submit(self.agents['code_generator'].generate_code, task): task
for task in tasks
}

 # 收集结果
for future in concurrent.futures.as_completed(future_to_task):
task = future_to_task[future]
try:
result = future.result()
results[task['id']] = result
except Exception as e:
results[task['id']] = {'error': str(e)}

return results

def execute_parallel_analysis(self, code):
"""并行分析代码"""
results = {}

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
 # 提交分析任务
futures = {
'static_analysis': executor.submit(
self.agents['code_reviewer']._static_analysis,
code,
'python'
),
'pattern_analysis': executor.submit(
self.agents['code_reviewer']._check_patterns,
code,
'python'
),
'security_analysis': executor.submit(
self.agents['code_reviewer']._check_security,
code,
'python'
),
'metrics_calculation': executor.submit(
self.agents['code_reviewer']._calculate_metrics,
code,
'python'
)
}

 # 收集结果
for name, future in futures.items():
try:
results[name] = future.result()
except Exception as e:
results[name] = {'error': str(e)}

return results

```> **并行协作优势**:
> - 提高任务执行速度
> - 充分利用系统资源
> - 缩短总执行时间

```
## 子Agent的优势

### 1. 提高效率

| 任务类型 | 单Agent | 多子Agent | 效率提升 |
|----------|---------|-----------|----------|
| 代码生成 + 审查 | 10分钟 | 6分钟 | 40% ↑ |
| 多文件处理 | 15分钟 | 5分钟 | 67% ↑ |
| 复杂任务分解 | 20分钟 | 8分钟 | 60% ↑ |

### 2. 提高质量

| 指标 | 单Agent | 多子Agent | 改善 |
|------|---------|-----------|------|
| 代码质量 | 75% | 90% | +20% |
| 错误率 | 15% | 5% | 67% ↓ |
| 测试覆盖率 | 70% | 85% | +21% |

### 3. 提高可维护性

- **模块化**: 每个子Agent独立维护
- **可扩展**: 容易添加新的子Agent
- **可复用**: 子Agent可以在不同任务中复用

## 总结

子Agent概述包括：

1. **子Agent的概念**: 什么是子Agent、子Agent vs 主Agent
2. **子Agent的类型**: 代码生成子Agent、代码审查子Agent
3. **子Agent的协作**: 串行协作、并行协作
4. **子Agent的优势**: 提高效率、提高质量、提高可维护性

通过子Agent机制，Claude Code可以更高效地处理复杂的编程任务。

在下一节中，我们将探讨异步子Agent任务。

```
```
```

---

## 2 异步子Agent任务

**URL**: https://claudecode.tangshuang.net/course/26.2%20%E5%BC%82%E6%AD%A5%E5%AD%90Agent%E4%BB%BB%E5%8A%A1

#### 异步子Agent任务概述#

异步子Agent任务是Claude Code中处理长时间运行任务的重要机制。通过异步执行，子Agent可以在后台执行任务，主Agent可以继续处理其他请求，从而提高整体效率和响应速度。

#### 异步任务的基本概念#

##### 1. 同步 vs 异步#

### 示例：同步 vs 异步

```
python复制````python

def process_task(task):
"""同步处理任务"""
result1 = agent1.execute(task)
result2 = agent2.execute(result1)
result3 = agent3.execute(result2)
return result3

# 执行时间: 10 + 15 + 20 = 45秒

```> 异步执行：
```
python

async def process_task_async(task):
    """异步处理任务"""
    result1 = await agent1.execute_async(task)
    result2 = await agent2.execute_async(result1)
    result3 = await agent3.execute_async(result2)
    return result3

# 执行时间: 20秒（并行执行）

### 2. 异步任务的优势

| 特性 | 同步任务 | 异步任务 |
|------|----------|----------|
| 执行方式 | 顺序执行 | 并行执行 |
| 响应时间 | 长 | 短 |
| 资源利用率 | 低 | 高 |
| 用户体验 | 差 | 好 |
| 复杂度 | 低 | 中 |

## 异步子Agent实现

### 1. 基础异步子Agent

````python
````python

# 示例：基础异步子Agent

用户请求：
"创建一个异步代码生成子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)

class AsyncCodeGenerationAgent:
    """异步代码生成子Agent"""

    def __init__(self, context):
        self.context = context
        self.task_queue = asyncio.Queue()
        self.results = {}
        self.running = False

    async def start(self):
        """启动Agent"""
        self.running = True
        logger.info("AsyncCodeGenerationAgent started")

        # 启动任务处理器
        asyncio.create_task(self._process_tasks())

    async def stop(self):
        """停止Agent"""
        self.running = False
        logger.info("AsyncCodeGenerationAgent stopped")

    async def submit_task(self, task_id: str, task: Dict[str, Any]):
        """提交任务"""
        await self.task_queue.put((task_id, task))
        logger.info(f"Task {task_id} submitted")

    async def get_result(self, task_id: str) -> Dict[str, Any]:
        """获取任务结果"""
        while task_id not in self.results:
            await asyncio.sleep(0.1)

        return self.results[task_id]

    async def _process_tasks(self):
        """处理任务"""
        while self.running:
            try:
                task_id, task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                logger.info(f"Processing task {task_id}")

                # 处理任务
                result = await self._generate_code(task)

                # 保存结果
                self.results[task_id] = result

                logger.info(f"Task {task_id} completed")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing task: {e}")

    async def _generate_code(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """生成代码"""
        # 模拟长时间运行的任务
        await asyncio.sleep(2)

        code = f"""
# Generated code for {task['name']}
def {task['function_name']}():
    pass
"""

        return {
            'code': code,
            'status': 'completed',
            'task_id': task.get('task_id')
        }

# 使用示例
async def main():
    """主函数"""
    agent = AsyncCodeGenerationAgent({})

    # 启动Agent
    await agent.start()

    # 提交任务
    task1 = {'name': 'Task 1', 'function_name': 'func1'}
    task2 = {'name': 'Task 2', 'function_name': 'func2'}
    task3 = {'name': 'Task 3', 'function_name': 'func3'}

    await agent.submit_task('task1', task1)
    await agent.submit_task('task2', task2)
    await agent.submit_task('task3', task3)

    # 获取结果
    result1 = await agent.get_result('task1')
    result2 = await agent.get_result('task2')
    result3 = await agent.get_result('task3')

    print("Task 1 result:", result1['status'])
    print("Task 2 result:", result2['status'])
    print("Task 3 result:", result3['status'])

    # 停止Agent
    await agent.stop()

if __name__ == '__main__':
    asyncio.run(main())

```> **异步子Agent特点**:
> - 使用asyncio实现异步处理
> - 任务队列管理
> - 结果存储和检索
> - 后台任务处理
### 2. 高级异步子Agent
````python
`python

# 示例：高级异步子Agent

用户请求：
"创建一个支持任务优先级和超时的异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import heapq
import logging

logger = logging.getLogger(__name__)

class AsyncPriorityAgent:
    """支持优先级的异步子Agent"""

    def __init__(self, context, max_workers=4):
        self.context = context
        self.task_queue = []
        self.task_lock = asyncio.Lock()
        self.results = {}
        self.running = False
        self.max_workers = max_workers
        self.workers = []
        self.task_stats = {
            'submitted': 0,
            'completed': 0,
            'failed': 0,
            'timeout': 0
        }

    async def start(self):
        """启动Agent"""
        self.running = True
        logger.info(f"AsyncPriorityAgent started with {self.max_workers} workers")

        # 启动工作线程
        for i in range(self.max_workers):
            worker = asyncio.create_task(self._worker(f"worker-{i}"))
            self.workers.append(worker)

    async def stop(self):
        """停止Agent"""
        self.running = False

        # 等待所有工作线程完成
        await asyncio.gather(*self.workers, return_exceptions=True)

        logger.info("AsyncPriorityAgent stopped")

    async def submit_task(
        self,
        task_id: str,
        task: Dict[str, Any],
        priority: int = 0,
        timeout: Optional[float] = None
    ):
        """提交任务"""
        task_data = {
            'task_id': task_id,
            'task': task,
            'priority': priority,
            'timeout': timeout,
            'submitted_at': datetime.utcnow(),
            'status': 'pending'
        }

        async with self.task_lock:
            heapq.heappush(self.task_queue, (-priority, task_data))

        self.task_stats['submitted'] += 1
        logger.info(f"Task {task_id} submitted with priority {priority}")

    async def get_result(self, task_id: str, timeout: float = 30.0) -> Dict[str, Any]:
        """获取任务结果"""
        start_time = datetime.utcnow()

        while True:
            if task_id in self.results:
                return self.results[task_id]

            # 检查超时
            elapsed = (datetime.utcnow() - start_time).total_seconds()
            if elapsed > timeout:
                raise TimeoutError(f"Task {task_id} timeout after {timeout}s")

            await asyncio.sleep(0.1)

    async def _worker(self, worker_name: str):
        """工作线程"""
        logger.info(f"{worker_name} started")

        while self.running:
            try:
                # 获取任务
                task_data = await self._get_task()

                if task_data is None:
                    await asyncio.sleep(0.1)
                    continue

                task_id = task_data['task_id']
                task = task_data['task']
                timeout = task_data.get('timeout')

                logger.info(f"{worker_name} processing task {task_id}")

                # 执行任务
                try:
                    if timeout:
                        result = await asyncio.wait_for(
                            self._execute_task(task),
                            timeout=timeout
                        )
                    else:
                        result = await self._execute_task(task)

                    self.results[task_id] = {
                        'result': result,
                        'status': 'completed',
                        'worker': worker_name,
                        'completed_at': datetime.utcnow()
                    }

                    self.task_stats['completed'] += 1
                    logger.info(f"{worker_name} completed task {task_id}")

                except asyncio.TimeoutError:
                    self.results[task_id] = {
                        'error': 'Task timeout',
                        'status': 'timeout',
                        'worker': worker_name
                    }

                    self.task_stats['timeout'] += 1
                    logger.warning(f"{worker_name} task {task_id} timeout")

                except Exception as e:
                    self.results[task_id] = {
                        'error': str(e),
                        'status': 'failed',
                        'worker': worker_name
                    }

                    self.task_stats['failed'] += 1
                    logger.error(f"{worker_name} task {task_id} failed: {e}")

            except Exception as e:
                logger.error(f"{worker_name} error: {e}")
                await asyncio.sleep(1)

        logger.info(f"{worker_name} stopped")

    async def _get_task(self) -> Optional[Dict[str, Any]]:
        """获取任务"""
        async with self.task_lock:
            if self.task_queue:
                _, task_data = heapq.heappop(self.task_queue)
                task_data['status'] = 'processing'
                return task_data

        return None

    async def _execute_task(self, task: Dict[str, Any]) -> Any:
        """执行任务"""
        task_type = task.get('type', 'default')

        if task_type == 'code_generation':
            return await self._generate_code(task)
        elif task_type == 'code_review':
            return await self._review_code(task)
        elif task_type == 'test_generation':
            return await self._generate_tests(task)
        else:
            return await self._default_task(task)

    async def _generate_code(self, task: Dict[str, Any]) -> str:
        """生成代码"""
        await asyncio.sleep(2)

        return f"""
# Generated code for {task['name']}
```

```
````python

def process_task(task):
"""同步处理任务"""
result1 = agent1.execute(task)
result2 = agent2.execute(result1)
result3 = agent3.execute(result2)
return result3

# 执行时间: 10 + 15 + 20 = 45秒

```> 异步执行：
```
python

async def process_task_async(task):
    """异步处理任务"""
    result1 = await agent1.execute_async(task)
    result2 = await agent2.execute_async(result1)
    result3 = await agent3.execute_async(result2)
    return result3

# 执行时间: 20秒（并行执行）

### 2. 异步任务的优势

| 特性 | 同步任务 | 异步任务 |
|------|----------|----------|
| 执行方式 | 顺序执行 | 并行执行 |
| 响应时间 | 长 | 短 |
| 资源利用率 | 低 | 高 |
| 用户体验 | 差 | 好 |
| 复杂度 | 低 | 中 |

## 异步子Agent实现

### 1. 基础异步子Agent

````python
````python

# 示例：基础异步子Agent

用户请求：
"创建一个异步代码生成子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)

class AsyncCodeGenerationAgent:
    """异步代码生成子Agent"""

    def __init__(self, context):
        self.context = context
        self.task_queue = asyncio.Queue()
        self.results = {}
        self.running = False

    async def start(self):
        """启动Agent"""
        self.running = True
        logger.info("AsyncCodeGenerationAgent started")

        # 启动任务处理器
        asyncio.create_task(self._process_tasks())

    async def stop(self):
        """停止Agent"""
        self.running = False
        logger.info("AsyncCodeGenerationAgent stopped")

    async def submit_task(self, task_id: str, task: Dict[str, Any]):
        """提交任务"""
        await self.task_queue.put((task_id, task))
        logger.info(f"Task {task_id} submitted")

    async def get_result(self, task_id: str) -> Dict[str, Any]:
        """获取任务结果"""
        while task_id not in self.results:
            await asyncio.sleep(0.1)

        return self.results[task_id]

    async def _process_tasks(self):
        """处理任务"""
        while self.running:
            try:
                task_id, task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                logger.info(f"Processing task {task_id}")

                # 处理任务
                result = await self._generate_code(task)

                # 保存结果
                self.results[task_id] = result

                logger.info(f"Task {task_id} completed")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing task: {e}")

    async def _generate_code(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """生成代码"""
        # 模拟长时间运行的任务
        await asyncio.sleep(2)

        code = f"""
# Generated code for {task['name']}
def {task['function_name']}():
    pass
"""

        return {
            'code': code,
            'status': 'completed',
            'task_id': task.get('task_id')
        }

# 使用示例
async def main():
    """主函数"""
    agent = AsyncCodeGenerationAgent({})

    # 启动Agent
    await agent.start()

    # 提交任务
    task1 = {'name': 'Task 1', 'function_name': 'func1'}
    task2 = {'name': 'Task 2', 'function_name': 'func2'}
    task3 = {'name': 'Task 3', 'function_name': 'func3'}

    await agent.submit_task('task1', task1)
    await agent.submit_task('task2', task2)
    await agent.submit_task('task3', task3)

    # 获取结果
    result1 = await agent.get_result('task1')
    result2 = await agent.get_result('task2')
    result3 = await agent.get_result('task3')

    print("Task 1 result:", result1['status'])
    print("Task 2 result:", result2['status'])
    print("Task 3 result:", result3['status'])

    # 停止Agent
    await agent.stop()

if __name__ == '__main__':
    asyncio.run(main())

```> **异步子Agent特点**:
> - 使用asyncio实现异步处理
> - 任务队列管理
> - 结果存储和检索
> - 后台任务处理
### 2. 高级异步子Agent
````python
`python

# 示例：高级异步子Agent

用户请求：
"创建一个支持任务优先级和超时的异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import heapq
import logging

logger = logging.getLogger(__name__)

class AsyncPriorityAgent:
    """支持优先级的异步子Agent"""

    def __init__(self, context, max_workers=4):
        self.context = context
        self.task_queue = []
        self.task_lock = asyncio.Lock()
        self.results = {}
        self.running = False
        self.max_workers = max_workers
        self.workers = []
        self.task_stats = {
            'submitted': 0,
            'completed': 0,
            'failed': 0,
            'timeout': 0
        }

    async def start(self):
        """启动Agent"""
        self.running = True
        logger.info(f"AsyncPriorityAgent started with {self.max_workers} workers")

        # 启动工作线程
        for i in range(self.max_workers):
            worker = asyncio.create_task(self._worker(f"worker-{i}"))
            self.workers.append(worker)

    async def stop(self):
        """停止Agent"""
        self.running = False

        # 等待所有工作线程完成
        await asyncio.gather(*self.workers, return_exceptions=True)

        logger.info("AsyncPriorityAgent stopped")

    async def submit_task(
        self,
        task_id: str,
        task: Dict[str, Any],
        priority: int = 0,
        timeout: Optional[float] = None
    ):
        """提交任务"""
        task_data = {
            'task_id': task_id,
            'task': task,
            'priority': priority,
            'timeout': timeout,
            'submitted_at': datetime.utcnow(),
            'status': 'pending'
        }

        async with self.task_lock:
            heapq.heappush(self.task_queue, (-priority, task_data))

        self.task_stats['submitted'] += 1
        logger.info(f"Task {task_id} submitted with priority {priority}")

    async def get_result(self, task_id: str, timeout: float = 30.0) -> Dict[str, Any]:
        """获取任务结果"""
        start_time = datetime.utcnow()

        while True:
            if task_id in self.results:
                return self.results[task_id]

            # 检查超时
            elapsed = (datetime.utcnow() - start_time).total_seconds()
            if elapsed > timeout:
                raise TimeoutError(f"Task {task_id} timeout after {timeout}s")

            await asyncio.sleep(0.1)

    async def _worker(self, worker_name: str):
        """工作线程"""
        logger.info(f"{worker_name} started")

        while self.running:
            try:
                # 获取任务
                task_data = await self._get_task()

                if task_data is None:
                    await asyncio.sleep(0.1)
                    continue

                task_id = task_data['task_id']
                task = task_data['task']
                timeout = task_data.get('timeout')

                logger.info(f"{worker_name} processing task {task_id}")

                # 执行任务
                try:
                    if timeout:
                        result = await asyncio.wait_for(
                            self._execute_task(task),
                            timeout=timeout
                        )
                    else:
                        result = await self._execute_task(task)

                    self.results[task_id] = {
                        'result': result,
                        'status': 'completed',
                        'worker': worker_name,
                        'completed_at': datetime.utcnow()
                    }

                    self.task_stats['completed'] += 1
                    logger.info(f"{worker_name} completed task {task_id}")

                except asyncio.TimeoutError:
                    self.results[task_id] = {
                        'error': 'Task timeout',
                        'status': 'timeout',
                        'worker': worker_name
                    }

                    self.task_stats['timeout'] += 1
                    logger.warning(f"{worker_name} task {task_id} timeout")

                except Exception as e:
                    self.results[task_id] = {
                        'error': str(e),
                        'status': 'failed',
                        'worker': worker_name
                    }

                    self.task_stats['failed'] += 1
                    logger.error(f"{worker_name} task {task_id} failed: {e}")

            except Exception as e:
                logger.error(f"{worker_name} error: {e}")
                await asyncio.sleep(1)

        logger.info(f"{worker_name} stopped")

    async def _get_task(self) -> Optional[Dict[str, Any]]:
        """获取任务"""
        async with self.task_lock:
            if self.task_queue:
                _, task_data = heapq.heappop(self.task_queue)
                task_data['status'] = 'processing'
                return task_data

        return None

    async def _execute_task(self, task: Dict[str, Any]) -> Any:
        """执行任务"""
        task_type = task.get('type', 'default')

        if task_type == 'code_generation':
            return await self._generate_code(task)
        elif task_type == 'code_review':
            return await self._review_code(task)
        elif task_type == 'test_generation':
            return await self._generate_tests(task)
        else:
            return await self._default_task(task)

    async def _generate_code(self, task: Dict[str, Any]) -> str:
        """生成代码"""
        await asyncio.sleep(2)

        return f"""
# Generated code for {task['name']}
```

def {task['function_name']}():
pass
"""

```
bash复制async def _review_code(self, task: Dict[str, Any]) -> Dict[str, Any]:
    """审查代码"""
    await asyncio.sleep(1.5)

    return {
        'issues': [],
        'suggestions': [],
        'metrics': {}
    }

async def _generate_tests(self, task: Dict[str, Any]) -> str:
    """生成测试"""
    await asyncio.sleep(1)

    return """
```

```
async def _review_code(self, task: Dict[str, Any]) -> Dict[str, Any]:
    """审查代码"""
    await asyncio.sleep(1.5)

    return {
        'issues': [],
        'suggestions': [],
        'metrics': {}
    }

async def _generate_tests(self, task: Dict[str, Any]) -> str:
    """生成测试"""
    await asyncio.sleep(1)

    return """
```

import unittest

class TestGeneratedCode(unittest.TestCase):
pass
"""

```
bash复制async def _default_task(self, task: Dict[str, Any]) -> Any:
    """默认任务"""
    await asyncio.sleep(1)
    return {'result': 'completed'}

def get_stats(self) -> Dict[str, Any]:
    """获取统计信息"""
    return {
        'stats': self.task_stats.copy(),
        'queue_size': len(self.task_queue),
        'active_workers': len(self.workers)
    }
```

```
async def _default_task(self, task: Dict[str, Any]) -> Any:
    """默认任务"""
    await asyncio.sleep(1)
    return {'result': 'completed'}

def get_stats(self) -> Dict[str, Any]:
    """获取统计信息"""
    return {
        'stats': self.task_stats.copy(),
        'queue_size': len(self.task_queue),
        'active_workers': len(self.workers)
    }
```

### 使用示例

async def main():
"""主函数"""
agent = AsyncPriorityAgent({}, max_workers=4)

```
bash复制# 启动Agent
await agent.start()

# 提交不同优先级的任务
await agent.submit_task('task1', {'name': 'Low Priority', 'type': 'code_generation'}, priority=1)
await agent.submit_task('task2', {'name': 'High Priority', 'type': 'code_review'}, priority=10)
await agent.submit_task('task3', {'name': 'Medium Priority', 'type': 'test_generation'}, priority=5)
await agent.submit_task('task4', {'name': 'Timeout Task', 'type': 'code_generation'}, priority=8, timeout=1.0)

# 获取结果
try:
    result1 = await agent.get_result('task1')
    print("Task 1 result:", result1['status'])
except TimeoutError as e:
    print(f"Task 1 error: {e}")

try:
    result2 = await agent.get_result('task2')
    print("Task 2 result:", result2['status'])
except TimeoutError as e:
    print(f"Task 2 error: {e}")

try:
    result3 = await agent.get_result('task3')
    print("Task 3 result:", result3['status'])
except TimeoutError as e:
    print(f"Task 3 error: {e}")

try:
    result4 = await agent.get_result('task4')
    print("Task 4 result:", result4['status'])
except TimeoutError as e:
    print(f"Task 4 error: {e}")

# 获取统计信息
stats = agent.get_stats()
print("\nStatistics:")
print(f"  Submitted: {stats['stats']['submitted']}")
print(f"  Completed: {stats['stats']['completed']}")
print(f"  Failed: {stats['stats']['failed']}")
print(f"  Timeout: {stats['stats']['timeout']}")
print(f"  Queue size: {stats['queue_size']}")

# 停止Agent
await agent.stop()
```

```
# 启动Agent
await agent.start()

# 提交不同优先级的任务
await agent.submit_task('task1', {'name': 'Low Priority', 'type': 'code_generation'}, priority=1)
await agent.submit_task('task2', {'name': 'High Priority', 'type': 'code_review'}, priority=10)
await agent.submit_task('task3', {'name': 'Medium Priority', 'type': 'test_generation'}, priority=5)
await agent.submit_task('task4', {'name': 'Timeout Task', 'type': 'code_generation'}, priority=8, timeout=1.0)

# 获取结果
try:
    result1 = await agent.get_result('task1')
    print("Task 1 result:", result1['status'])
except TimeoutError as e:
    print(f"Task 1 error: {e}")

try:
    result2 = await agent.get_result('task2')
    print("Task 2 result:", result2['status'])
except TimeoutError as e:
    print(f"Task 2 error: {e}")

try:
    result3 = await agent.get_result('task3')
    print("Task 3 result:", result3['status'])
except TimeoutError as e:
    print(f"Task 3 error: {e}")

try:
    result4 = await agent.get_result('task4')
    print("Task 4 result:", result4['status'])
except TimeoutError as e:
    print(f"Task 4 error: {e}")

# 获取统计信息
stats = agent.get_stats()
print("\nStatistics:")
print(f"  Submitted: {stats['stats']['submitted']}")
print(f"  Completed: {stats['stats']['completed']}")
print(f"  Failed: {stats['stats']['failed']}")
print(f"  Timeout: {stats['stats']['timeout']}")
print(f"  Queue size: {stats['queue_size']}")

# 停止Agent
await agent.stop()
```

if name == 'main':
asyncio.run(main())

```
bash复制> - 支持任务优先级
> - 支持任务超时
> - 多工作线程
> - 任务统计
> - 错误处理
## 异步任务模式
### 1. 任务编排模式
````python
`python

# 示例：任务编排

用户请求：
"实现一个任务编排器，协调多个异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)

class TaskOrchestrator:
    """任务编排器"""

    def __init__(self, context):
        self.context = context
        self.agents = {}
        self.task_graph = {}
        self.results = {}

    def register_agent(self, name: str, agent):
        """注册Agent"""
        self.agents[name] = agent
        logger.info(f"Agent {name} registered")

    def define_workflow(self, workflow: Dict[str, Any]):
        """定义工作流"""
        self.task_graph = workflow
        logger.info("Workflow defined")

    async def execute_workflow(self) -> Dict[str, Any]:
        """执行工作流"""
        logger.info("Starting workflow execution")

        # 执行任务
        for task in self.task_graph['tasks']:
            await self._execute_task(task)

        logger.info("Workflow execution completed")

        return self.results

    async def _execute_task(self, task: Dict[str, Any]):
        """执行任务"""
        task_id = task['id']
        task_type = task['type']
        agent_name = task['agent']
        dependencies = task.get('dependencies', [])

        logger.info(f"Executing task {task_id}")

        # 等待依赖任务完成
        for dep_id in dependencies:
            await self._wait_for_task(dep_id)

        # 获取Agent
        agent = self.agents.get(agent_name)
        if not agent:
            raise ValueError(f"Agent {agent_name} not found")

        # 执行任务
        if task_type == 'code_generation':
            result = await agent._generate_code(task['params'])
        elif task_type == 'code_review':
            result = await agent._review_code(task['params'])
        elif task_type == 'test_generation':
            result = await agent._generate_tests(task['params'])
        else:
            result = await agent._default_task(task['params'])

        # 保存结果
        self.results[task_id] = result

        logger.info(f"Task {task_id} completed")

    async def _wait_for_task(self, task_id: str):
        """等待任务完成"""
        while task_id not in self.results:
            await asyncio.sleep(0.1)

# 使用示例
async def main():
    """主函数"""
    orchestrator = TaskOrchestrator({})

    # 注册Agent
    code_agent = AsyncCodeGenerationAgent({})
    review_agent = AsyncCodeReviewAgent({})
    test_agent = AsyncTestGenerationAgent({})

    await code_agent.start()
    await review_agent.start()
    await test_agent.start()

    orchestrator.register_agent('code', code_agent)
    orchestrator.register_agent('review', review_agent)
    orchestrator.register_agent('test', test_agent)

    # 定义工作流
    workflow = {
        'tasks': [
            {
                'id': 'task1',
                'type': 'code_generation',
                'agent': 'code',
                'params': {'name': 'User Service', 'function_name': 'create_user'}
            },
            {
                'id': 'task2',
                'type': 'code_generation',
                'agent': 'code',
                'params': {'name': 'Product Service', 'function_name': 'create_product'}
            },
            {
                'id': 'task3',
                'type': 'code_review',
                'agent': 'review',
                'params': {'code': 'result from task1'},
                'dependencies': ['task1']
            },
            {
                'id': 'task4',
                'type': 'code_review',
                'agent': 'review',
                'params': {'code': 'result from task2'},
                'dependencies': ['task2']
            },
            {
                'id': 'task5',
                'type': 'test_generation',
                'agent': 'test',
                'params': {'code': 'result from task1'},
                'dependencies': ['task1', 'task3']
            },
            {
                'id': 'task6',
                'type': 'test_generation',
                'agent': 'test',
                'params': {'code': 'result from task2'},
                'dependencies': ['task2', 'task4']
            }
        ]
    }

    orchestrator.define_workflow(workflow)

    # 执行工作流
    results = await orchestrator.execute_workflow()

    print("Workflow results:")
    for task_id, result in results.items():
        print(f"  {task_id}: {result.get('status', 'unknown')}")

if __name__ == '__main__':
    asyncio.run(main())

```> **任务编排特点**:
> - 定义任务依赖关系
> - 自动处理任务执行顺序
> - 支持并行执行
> - 结果收集和传递
### 2. 任务分发模式
````python
`python

# 示例：任务分发

用户请求：
"实现一个任务分发器，将任务分发给多个异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, List
import random
import logging

logger = logging.getLogger(__name__)

class TaskDispatcher:
    """任务分发器"""

    def __init__(self, context):
        self.context = context
        self.agents = []
        self.task_queue = asyncio.Queue()
        self.running = False

    def register_agent(self, agent):
        """注册Agent"""
        self.agents.append(agent)
        logger.info(f"Agent registered, total: {len(self.agents)}")

    async def start(self):
        """启动分发器"""
        self.running = True
        logger.info("TaskDispatcher started")

        # 启动分发线程
        asyncio.create_task(self._dispatch_tasks())

    async def stop(self):
        """停止分发器"""
        self.running = False
        logger.info("TaskDispatcher stopped")

    async def submit_task(self, task: Dict[str, Any]):
        """提交任务"""
        await self.task_queue.put(task)
        logger.info(f"Task submitted: {task.get('id', 'unknown')}")

    async def _dispatch_tasks(self):
        """分发任务"""
        while self.running:
            try:
                # 获取任务
                task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                # 选择Agent
                agent = self._select_agent(task)

                if agent:
                    # 提交任务给Agent
                    await agent.submit_task(task['id'], task)
                    logger.info(f"Task {task['id']} dispatched to {agent.__class__.__name__}")
                else:
                    logger.warning(f"No available agent for task {task['id']}")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error dispatching task: {e}")

    def _select_agent(self, task: Dict[str, Any]) -> Any:
        """选择Agent"""
        if not self.agents:
            return None

        # 根据任务类型选择Agent
        task_type = task.get('type', 'default')

        for agent in self.agents:
            if hasattr(agent, 'can_handle') and agent.can_handle(task_type):
                return agent

        # 随机选择一个Agent
        return random.choice(self.agents)

class LoadBalancedDispatcher(TaskDispatcher):
    """负载均衡分发器"""

    def __init__(self, context):
        super().__init__(context)
        self.agent_loads = {}

    def register_agent(self, agent):
        """注册Agent"""
        super().register_agent(agent)
        self.agent_loads[agent] = 0

    async def _dispatch_tasks(self):
        """分发任务（负载均衡）"""
        while self.running:
            try:
                # 获取任务
                task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                # 选择负载最低的Agent
                agent = self._select_least_loaded_agent(task)

                if agent:
                    # 提交任务给Agent
                    await agent.submit_task(task['id'], task)
                    self.agent_loads[agent] += 1
                    logger.info(f"Task {task['id']} dispatched to {agent.__class__.__name__} (load: {self.agent_loads[agent]})")
                else:
                    logger.warning(f"No available agent for task {task['id']}")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error dispatching task: {e}")

    def _select_least_loaded_agent(self, task: Dict[str, Any]) -> Any:
        """选择负载最低的Agent"""
        if not self.agents:
            return None

        # 找到负载最低的Agent
        min_load = float('inf')
        selected_agent = None

        for agent in self.agents:
            if self.agent_loads[agent] < min_load:
                min_load = self.agent_loads[agent]
                selected_agent = agent

        return selected_agent

    def update_agent_load(self, agent, delta: int):
        """更新Agent负载"""
        if agent in self.agent_loads:
            self.agent_loads[agent] += delta
            logger.info(f"Agent {agent.__class__.__name__} load updated to {self.agent_loads[agent]}")

# 使用示例
async def main():
    """主函数"""
    dispatcher = LoadBalancedDispatcher({})

    # 注册Agent
    agent1 = AsyncCodeGenerationAgent({})
    agent2 = AsyncCodeGenerationAgent({})
    agent3 = AsyncCodeGenerationAgent({})

    await agent1.start()
    await agent2.start()
    await agent3.start()

    dispatcher.register_agent(agent1)
    dispatcher.register_agent(agent2)
    dispatcher.register_agent(agent3)

    # 启动分发器
    await dispatcher.start()

    # 提交多个任务
    for i in range(10):
        await dispatcher.submit_task({
            'id': f'task{i}',
            'type': 'code_generation',
            'name': f'Task {i}',
            'function_name': f'func{i}'
        })

    # 等待任务完成
    await asyncio.sleep(5)

    # 停止分发器
    await dispatcher.stop()

    # 停止Agent
    await agent1.stop()
    await agent2.stop()
    await agent3.stop()

if __name__ == '__main__':
    asyncio.run(main())

```> **任务分发特点**:
> - 负载均衡
> - 动态Agent选择
> - 负载监控
> - 任务路由
## 异步任务监控
### 1. 任务状态监控
````python
`python

# 示例：任务状态监控

用户请求：
"实现一个任务状态监控系统"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class TaskMonitor:
    """任务监控器"""

    def __init__(self):
        self.tasks = {}
        self.events = []

    def register_task(self, task_id: str, task_info: Dict[str, Any]):
        """注册任务"""
        self.tasks[task_id] = {
            'id': task_id,
            'status': 'pending',
            'created_at': datetime.utcnow(),
            'updated_at': datetime.utcnow(),
            **task_info
        }

        self._log_event(task_id, 'registered')
        logger.info(f"Task {task_id} registered")

    def update_task_status(self, task_id: str, status: str, **kwargs):
        """更新任务状态"""
        if task_id not in self.tasks:
            logger.warning(f"Task {task_id} not found")
            return

        self.tasks[task_id]['status'] = status
        self.tasks[task_id]['updated_at'] = datetime.utcnow()
        self.tasks[task_id].update(kwargs)

        self._log_event(task_id, f'status_changed_to_{status}')
        logger.info(f"Task {task_id} status updated to {status}")

    def get_task_status(self, task_id: str) -> Dict[str, Any]:
        """获取任务状态"""
        return self.tasks.get(task_id, {})

    def get_all_tasks(self) -> Dict[str, Any]:
        """获取所有任务"""
        return self.tasks

    def get_tasks_by_status(self, status: str) -> Dict[str, Any]:
        """根据状态获取任务"""
        return {
            task_id: task
            for task_id, task in self.tasks.items()
            if task['status'] == status
        }

    def get_task_statistics(self) -> Dict[str, Any]:
        """获取任务统计"""
        stats = {
            'total': len(self.tasks),
            'pending': 0,
            'processing': 0,
            'completed': 0,
            'failed': 0,
            'timeout': 0
        }

        for task in self.tasks.values():
            status = task['status']
            if status in stats:
                stats[status] += 1

        return stats

    def _log_event(self, task_id: str, event: str):
        """记录事件"""
        self.events.append({
            'task_id': task_id,
            'event': event,
            'timestamp': datetime.utcnow()
        })

    def get_task_events(self, task_id: str) -> list:
        """获取任务事件"""
        return [
            event for event in self.events
            if event['task_id'] == task_id
        ]

# 使用示例
async def main():
    """主函数"""
    monitor = TaskMonitor()

    # 注册任务
    monitor.register_task('task1', {'name': 'Task 1', 'type': 'code_generation'})
    monitor.register_task('task2', {'name': 'Task 2', 'type': 'code_review'})
    monitor.register_task('task3', {'name': 'Task 3', 'type': 'test_generation'})

    # 更新任务状态
    monitor.update_task_status('task1', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task1', 'completed', result='success')

    monitor.update_task_status('task2', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task2', 'failed', error='validation error')

    monitor.update_task_status('task3', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task3', 'timeout')

    # 获取任务状态
    print("Task 1 status:", monitor.get_task_status('task1'))
    print("Task 2 status:", monitor.get_task_status('task2'))
    print("Task 3 status:", monitor.get_task_status('task3'))

    # 获取任务统计
    stats = monitor.get_task_statistics()
    print("\nTask Statistics:")
    for key, value in stats.items():
        print(f"  {key}: {value}")

    # 获取任务事件
    print("\nTask 1 events:")
    for event in monitor.get_task_events('task1'):
        print(f"  {event['timestamp']}: {event['event']}")

if __name__ == '__main__':
    asyncio.run(main())
```

```
> - 支持任务优先级
> - 支持任务超时
> - 多工作线程
> - 任务统计
> - 错误处理
## 异步任务模式
### 1. 任务编排模式
````python
`python

# 示例：任务编排

用户请求：
"实现一个任务编排器，协调多个异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)

class TaskOrchestrator:
    """任务编排器"""

    def __init__(self, context):
        self.context = context
        self.agents = {}
        self.task_graph = {}
        self.results = {}

    def register_agent(self, name: str, agent):
        """注册Agent"""
        self.agents[name] = agent
        logger.info(f"Agent {name} registered")

    def define_workflow(self, workflow: Dict[str, Any]):
        """定义工作流"""
        self.task_graph = workflow
        logger.info("Workflow defined")

    async def execute_workflow(self) -> Dict[str, Any]:
        """执行工作流"""
        logger.info("Starting workflow execution")

        # 执行任务
        for task in self.task_graph['tasks']:
            await self._execute_task(task)

        logger.info("Workflow execution completed")

        return self.results

    async def _execute_task(self, task: Dict[str, Any]):
        """执行任务"""
        task_id = task['id']
        task_type = task['type']
        agent_name = task['agent']
        dependencies = task.get('dependencies', [])

        logger.info(f"Executing task {task_id}")

        # 等待依赖任务完成
        for dep_id in dependencies:
            await self._wait_for_task(dep_id)

        # 获取Agent
        agent = self.agents.get(agent_name)
        if not agent:
            raise ValueError(f"Agent {agent_name} not found")

        # 执行任务
        if task_type == 'code_generation':
            result = await agent._generate_code(task['params'])
        elif task_type == 'code_review':
            result = await agent._review_code(task['params'])
        elif task_type == 'test_generation':
            result = await agent._generate_tests(task['params'])
        else:
            result = await agent._default_task(task['params'])

        # 保存结果
        self.results[task_id] = result

        logger.info(f"Task {task_id} completed")

    async def _wait_for_task(self, task_id: str):
        """等待任务完成"""
        while task_id not in self.results:
            await asyncio.sleep(0.1)

# 使用示例
async def main():
    """主函数"""
    orchestrator = TaskOrchestrator({})

    # 注册Agent
    code_agent = AsyncCodeGenerationAgent({})
    review_agent = AsyncCodeReviewAgent({})
    test_agent = AsyncTestGenerationAgent({})

    await code_agent.start()
    await review_agent.start()
    await test_agent.start()

    orchestrator.register_agent('code', code_agent)
    orchestrator.register_agent('review', review_agent)
    orchestrator.register_agent('test', test_agent)

    # 定义工作流
    workflow = {
        'tasks': [
            {
                'id': 'task1',
                'type': 'code_generation',
                'agent': 'code',
                'params': {'name': 'User Service', 'function_name': 'create_user'}
            },
            {
                'id': 'task2',
                'type': 'code_generation',
                'agent': 'code',
                'params': {'name': 'Product Service', 'function_name': 'create_product'}
            },
            {
                'id': 'task3',
                'type': 'code_review',
                'agent': 'review',
                'params': {'code': 'result from task1'},
                'dependencies': ['task1']
            },
            {
                'id': 'task4',
                'type': 'code_review',
                'agent': 'review',
                'params': {'code': 'result from task2'},
                'dependencies': ['task2']
            },
            {
                'id': 'task5',
                'type': 'test_generation',
                'agent': 'test',
                'params': {'code': 'result from task1'},
                'dependencies': ['task1', 'task3']
            },
            {
                'id': 'task6',
                'type': 'test_generation',
                'agent': 'test',
                'params': {'code': 'result from task2'},
                'dependencies': ['task2', 'task4']
            }
        ]
    }

    orchestrator.define_workflow(workflow)

    # 执行工作流
    results = await orchestrator.execute_workflow()

    print("Workflow results:")
    for task_id, result in results.items():
        print(f"  {task_id}: {result.get('status', 'unknown')}")

if __name__ == '__main__':
    asyncio.run(main())

```> **任务编排特点**:
> - 定义任务依赖关系
> - 自动处理任务执行顺序
> - 支持并行执行
> - 结果收集和传递
### 2. 任务分发模式
````python
`python

# 示例：任务分发

用户请求：
"实现一个任务分发器，将任务分发给多个异步子Agent"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any, List
import random
import logging

logger = logging.getLogger(__name__)

class TaskDispatcher:
    """任务分发器"""

    def __init__(self, context):
        self.context = context
        self.agents = []
        self.task_queue = asyncio.Queue()
        self.running = False

    def register_agent(self, agent):
        """注册Agent"""
        self.agents.append(agent)
        logger.info(f"Agent registered, total: {len(self.agents)}")

    async def start(self):
        """启动分发器"""
        self.running = True
        logger.info("TaskDispatcher started")

        # 启动分发线程
        asyncio.create_task(self._dispatch_tasks())

    async def stop(self):
        """停止分发器"""
        self.running = False
        logger.info("TaskDispatcher stopped")

    async def submit_task(self, task: Dict[str, Any]):
        """提交任务"""
        await self.task_queue.put(task)
        logger.info(f"Task submitted: {task.get('id', 'unknown')}")

    async def _dispatch_tasks(self):
        """分发任务"""
        while self.running:
            try:
                # 获取任务
                task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                # 选择Agent
                agent = self._select_agent(task)

                if agent:
                    # 提交任务给Agent
                    await agent.submit_task(task['id'], task)
                    logger.info(f"Task {task['id']} dispatched to {agent.__class__.__name__}")
                else:
                    logger.warning(f"No available agent for task {task['id']}")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error dispatching task: {e}")

    def _select_agent(self, task: Dict[str, Any]) -> Any:
        """选择Agent"""
        if not self.agents:
            return None

        # 根据任务类型选择Agent
        task_type = task.get('type', 'default')

        for agent in self.agents:
            if hasattr(agent, 'can_handle') and agent.can_handle(task_type):
                return agent

        # 随机选择一个Agent
        return random.choice(self.agents)

class LoadBalancedDispatcher(TaskDispatcher):
    """负载均衡分发器"""

    def __init__(self, context):
        super().__init__(context)
        self.agent_loads = {}

    def register_agent(self, agent):
        """注册Agent"""
        super().register_agent(agent)
        self.agent_loads[agent] = 0

    async def _dispatch_tasks(self):
        """分发任务（负载均衡）"""
        while self.running:
            try:
                # 获取任务
                task = await asyncio.wait_for(
                    self.task_queue.get(),
                    timeout=1.0
                )

                # 选择负载最低的Agent
                agent = self._select_least_loaded_agent(task)

                if agent:
                    # 提交任务给Agent
                    await agent.submit_task(task['id'], task)
                    self.agent_loads[agent] += 1
                    logger.info(f"Task {task['id']} dispatched to {agent.__class__.__name__} (load: {self.agent_loads[agent]})")
                else:
                    logger.warning(f"No available agent for task {task['id']}")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error dispatching task: {e}")

    def _select_least_loaded_agent(self, task: Dict[str, Any]) -> Any:
        """选择负载最低的Agent"""
        if not self.agents:
            return None

        # 找到负载最低的Agent
        min_load = float('inf')
        selected_agent = None

        for agent in self.agents:
            if self.agent_loads[agent] < min_load:
                min_load = self.agent_loads[agent]
                selected_agent = agent

        return selected_agent

    def update_agent_load(self, agent, delta: int):
        """更新Agent负载"""
        if agent in self.agent_loads:
            self.agent_loads[agent] += delta
            logger.info(f"Agent {agent.__class__.__name__} load updated to {self.agent_loads[agent]}")

# 使用示例
async def main():
    """主函数"""
    dispatcher = LoadBalancedDispatcher({})

    # 注册Agent
    agent1 = AsyncCodeGenerationAgent({})
    agent2 = AsyncCodeGenerationAgent({})
    agent3 = AsyncCodeGenerationAgent({})

    await agent1.start()
    await agent2.start()
    await agent3.start()

    dispatcher.register_agent(agent1)
    dispatcher.register_agent(agent2)
    dispatcher.register_agent(agent3)

    # 启动分发器
    await dispatcher.start()

    # 提交多个任务
    for i in range(10):
        await dispatcher.submit_task({
            'id': f'task{i}',
            'type': 'code_generation',
            'name': f'Task {i}',
            'function_name': f'func{i}'
        })

    # 等待任务完成
    await asyncio.sleep(5)

    # 停止分发器
    await dispatcher.stop()

    # 停止Agent
    await agent1.stop()
    await agent2.stop()
    await agent3.stop()

if __name__ == '__main__':
    asyncio.run(main())

```> **任务分发特点**:
> - 负载均衡
> - 动态Agent选择
> - 负载监控
> - 任务路由
## 异步任务监控
### 1. 任务状态监控
````python
`python

# 示例：任务状态监控

用户请求：
"实现一个任务状态监控系统"

Claude Code 生成的代码：

```python
```python

import asyncio
from typing import Dict, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class TaskMonitor:
    """任务监控器"""

    def __init__(self):
        self.tasks = {}
        self.events = []

    def register_task(self, task_id: str, task_info: Dict[str, Any]):
        """注册任务"""
        self.tasks[task_id] = {
            'id': task_id,
            'status': 'pending',
            'created_at': datetime.utcnow(),
            'updated_at': datetime.utcnow(),
            **task_info
        }

        self._log_event(task_id, 'registered')
        logger.info(f"Task {task_id} registered")

    def update_task_status(self, task_id: str, status: str, **kwargs):
        """更新任务状态"""
        if task_id not in self.tasks:
            logger.warning(f"Task {task_id} not found")
            return

        self.tasks[task_id]['status'] = status
        self.tasks[task_id]['updated_at'] = datetime.utcnow()
        self.tasks[task_id].update(kwargs)

        self._log_event(task_id, f'status_changed_to_{status}')
        logger.info(f"Task {task_id} status updated to {status}")

    def get_task_status(self, task_id: str) -> Dict[str, Any]:
        """获取任务状态"""
        return self.tasks.get(task_id, {})

    def get_all_tasks(self) -> Dict[str, Any]:
        """获取所有任务"""
        return self.tasks

    def get_tasks_by_status(self, status: str) -> Dict[str, Any]:
        """根据状态获取任务"""
        return {
            task_id: task
            for task_id, task in self.tasks.items()
            if task['status'] == status
        }

    def get_task_statistics(self) -> Dict[str, Any]:
        """获取任务统计"""
        stats = {
            'total': len(self.tasks),
            'pending': 0,
            'processing': 0,
            'completed': 0,
            'failed': 0,
            'timeout': 0
        }

        for task in self.tasks.values():
            status = task['status']
            if status in stats:
                stats[status] += 1

        return stats

    def _log_event(self, task_id: str, event: str):
        """记录事件"""
        self.events.append({
            'task_id': task_id,
            'event': event,
            'timestamp': datetime.utcnow()
        })

    def get_task_events(self, task_id: str) -> list:
        """获取任务事件"""
        return [
            event for event in self.events
            if event['task_id'] == task_id
        ]

# 使用示例
async def main():
    """主函数"""
    monitor = TaskMonitor()

    # 注册任务
    monitor.register_task('task1', {'name': 'Task 1', 'type': 'code_generation'})
    monitor.register_task('task2', {'name': 'Task 2', 'type': 'code_review'})
    monitor.register_task('task3', {'name': 'Task 3', 'type': 'test_generation'})

    # 更新任务状态
    monitor.update_task_status('task1', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task1', 'completed', result='success')

    monitor.update_task_status('task2', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task2', 'failed', error='validation error')

    monitor.update_task_status('task3', 'processing')
    await asyncio.sleep(1)
    monitor.update_task_status('task3', 'timeout')

    # 获取任务状态
    print("Task 1 status:", monitor.get_task_status('task1'))
    print("Task 2 status:", monitor.get_task_status('task2'))
    print("Task 3 status:", monitor.get_task_status('task3'))

    # 获取任务统计
    stats = monitor.get_task_statistics()
    print("\nTask Statistics:")
    for key, value in stats.items():
        print(f"  {key}: {value}")

    # 获取任务事件
    print("\nTask 1 events:")
    for event in monitor.get_task_events('task1'):
        print(f"  {event['timestamp']}: {event['event']}")

if __name__ == '__main__':
    asyncio.run(main())
```

任务监控特点:

- 实时状态跟踪
- 任务统计
- 事件记录
- 状态查询

---

## 3 LSP - 语言服务器协议在Claude Code中的应用

**URL**: https://claudecode.tangshuang.net/course/26.3%20LSP%20-%20%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%8F%E8%AE%AE%E5%9C%A8Claude%20Code%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8

#### 26.3.1 LSP概述#

##### 什么是LSP#

LSP（Language Server Protocol，语言服务器协议）是一种标准化协议，允许代码编辑器或IDE与语言服务器进行通信，以提供代码智能功能。它由Microsoft开发，现已成为行业标准，被广泛应用于各种开发工具中。

在Claude Code中，LSP是一个强大的工具，为AI提供了真正的IDE级别的代码理解能力。通过LSP，Claude Code能够像专业IDE一样理解代码的语义结构，包括函数定义、类继承关系、变量作用域和引用链等。

##### LSP的工作原理#

LSP采用客户端-服务器架构：

True. 客户端：Claude Code编辑器或集成的IDE（如VS Code）
True. 服务器：语言服务器，负责提供代码智能功能
True. 通信协议：基于JSON-RPC的标准化协议，定义了客户端和服务器之间的通信方式

LSP的核心思想是将代码编辑和代码分析分离，编辑器负责UI和基本编辑功能，而语言服务器负责提供高级代码智能功能。

##### Claude Code中LSP的优势#

True. 精确的代码理解：LSP提供了比简单文本搜索更精确的代码理解能力
True. 智能代码导航：支持跳转定义、查找引用等功能
True. 实时错误检查：可以在编辑过程中实时检查代码错误
True. 代码补全建议：提供基于上下文的智能代码补全
True. 减少Token消耗：通过LSP获取精确的代码信息，减少了AI需要处理的Token数量

#### 26.3.2 Claude Code中LSP的功能#

##### 核心功能#

根据Claude Code 2.0.74更新日志，LSP工具提供了以下代码智能功能：

True. Go-to-definition（跳转到定义）：快速跳转到函数、变量或类的定义位置
True. Find references（查找引用）：查找代码中所有引用某个函数、变量或类的位置
True. Hover documentation（悬停文档）：鼠标悬停在代码上时显示详细的文档和类型信息

##### 其他高级功能#

除了上述核心功能外，LSP还为Claude Code提供了以下能力：

True. 代码语义分析：理解代码的结构和关系
True. 类型推断：推断变量和函数的类型
True. 代码重构建议：提供代码重构的建议
True. 代码格式化：自动格式化代码
True. 错误和警告提示：实时显示代码中的错误和警告

#### 26.3.3 Claude Code中LSP的配置#

##### 配置方式#

在Claude Code中，LSP有三种主要配置方式：

True. VS Code集成（推荐）：最简单的配置方式，需要VS Code
True. cclsp社区方案：不需要VS Code的社区解决方案
True. 手动配置.lsp.json：手动创建配置文件

##### VS Code集成配置#

如果您使用VS Code，配置LSP非常简单：

True. 确保您的Claude Code版本 >= 2.0.74
True. 在Claude Code中运行 /config 命令
True. 找到以下配置项并确保其设置正确：

Diff tool = auto：让Claude Code自动检测您使用的IDE
Auto-install IDE extension = true：自动安装IDE扩展
True. Diff tool = auto：让Claude Code自动检测您使用的IDE
True. Auto-install IDE extension = true：自动安装IDE扩展

```
/config
```

- Diff tool = auto：让Claude Code自动检测您使用的IDE
- Auto-install IDE extension = true：自动安装IDE扩展

```
Diff tool = auto
```

```
Auto-install IDE extension = true
```

Claude Code会自动检测VS Code并利用其LSP功能。

##### 手动配置#

如果您不使用VS Code，可以手动创建.lsp.json配置文件：

```
.lsp.json
```

True. 在项目根目录创建.lsp.json文件
True. 配置语言服务器信息：

```
.lsp.json
```

```
json复制{
  "servers": {
    "python": {
      "command": ["pyls", "--verbose"],
      "filetypes": ["python"],
      "rootPatterns": [".git", "setup.py"]
    },
    "javascript": {
      "command": ["typescript-language-server", "--stdio"],
      "filetypes": ["javascript", "javascriptreact"],
      "rootPatterns": ["package.json", ".git"]
    }
  }
}
```

```
{
  "servers": {
    "python": {
      "command": ["pyls", "--verbose"],
      "filetypes": ["python"],
      "rootPatterns": [".git", "setup.py"]
    },
    "javascript": {
      "command": ["typescript-language-server", "--stdio"],
      "filetypes": ["javascript", "javascriptreact"],
      "rootPatterns": ["package.json", ".git"]
    }
  }
}
```

##### 其他相关配置#

True. 终端配置：

运行 /terminal-setup 命令配置终端支持
支持Kitty、Alacritty、Zed和Warp终端
True. 运行 /terminal-setup 命令配置终端支持
True. 支持Kitty、Alacritty、Zed和Warp终端
True. 主题配置：

运行 /theme 命令配置主题
使用 ctrl+t 快捷键切换语法高亮
True. 运行 /theme 命令配置主题
True. 使用 ctrl+t 快捷键切换语法高亮

- 运行 /terminal-setup 命令配置终端支持
- 支持Kitty、Alacritty、Zed和Warp终端

```
/terminal-setup
```

- 运行 /theme 命令配置主题
- 使用 ctrl+t 快捷键切换语法高亮

```
/theme
```

```
ctrl+t
```

#### 26.3.4 Claude Code中LSP的使用#

##### 基本使用#

LSP在Claude Code中是隐性工作的，您不需要手动触发LSP功能。当您与Claude Code交互时，它会自动使用LSP获取代码信息。

##### 实际应用示例#

###### 1. 代码理解

当您请求Claude Code解释一段代码时，它会使用LSP获取精确的代码结构信息：

```
bash复制> 请解释这段代码的工作原理
```

```
> 请解释这段代码的工作原理
```

Claude Code会利用LSP理解代码的结构，包括函数调用关系、变量作用域等，提供更准确的解释。

###### 2. 代码修改

当您请求Claude Code修改代码时，它会使用LSP确保修改的准确性：

```
bash复制> 将这个函数的参数类型改为TypeScript接口
```

```
> 将这个函数的参数类型改为TypeScript接口
```

Claude Code会使用LSP获取当前函数的定义和引用，确保修改不会破坏代码。

###### 3. 代码导航

您可以请求Claude Code跳转到特定的代码位置：

```
bash复制> 跳转到User类的定义
```

```
> 跳转到User类的定义
```

Claude Code会使用LSP的go-to-definition功能，直接跳转到User类的定义位置。

###### 4. 引用查找

您可以请求Claude Code查找代码引用：

```
bash复制> 查找handleClick函数的所有引用
```

```
> 查找handleClick函数的所有引用
```

Claude Code会使用LSP的find-references功能，列出所有引用handleClick函数的位置。

#### 26.3.5 LSP与子Agent的结合使用#

##### 协同工作原理#

LSP和子Agent可以协同工作，提供更强大的代码处理能力：

True. LSP提供代码理解：LSP负责提供精确的代码结构和语义信息
True. 子Agent执行特定任务：子Agent利用LSP提供的信息执行特定的代码处理任务
True. 结果反馈和优化：执行结果可以反馈给LSP，进一步优化代码理解

##### 使用示例#

以下是LSP与子Agent结合使用的示例：

```
bash复制#!/bin/bash
# lsp-subagent-example.sh

# 1. 使用LSP分析代码结构
claude --model opus --allowedTools "SlashCommand" -p "
使用LSP分析项目代码结构，包括：
1. 主要模块和类
2. 函数依赖关系
3. 关键变量和常量

然后根据分析结果创建一个子Agent，用于：
1. 检查代码中的潜在bug
2. 提供代码优化建议
3. 生成单元测试
"

# 2. 执行子Agent任务
claude --agents '{"code-analyzer": {
  "description": "Expert code analyzer using LSP information",
  "prompt": "You are a code analyzer that uses LSP information to find bugs, suggest optimizations, and generate tests.",
  "tools": ["Read", "Write", "Bash", "SlashCommand"]
}}' -p "
使用LSP信息分析代码，执行以下任务：
1. 检查src/main.py中的潜在bug
2. 提供优化建议
3. 为核心功能生成单元测试
"
```

```
#!/bin/bash
# lsp-subagent-example.sh

# 1. 使用LSP分析代码结构
claude --model opus --allowedTools "SlashCommand" -p "
使用LSP分析项目代码结构，包括：
1. 主要模块和类
2. 函数依赖关系
3. 关键变量和常量

然后根据分析结果创建一个子Agent，用于：
1. 检查代码中的潜在bug
2. 提供代码优化建议
3. 生成单元测试
"

# 2. 执行子Agent任务
claude --agents '{"code-analyzer": {
  "description": "Expert code analyzer using LSP information",
  "prompt": "You are a code analyzer that uses LSP information to find bugs, suggest optimizations, and generate tests.",
  "tools": ["Read", "Write", "Bash", "SlashCommand"]
}}' -p "
使用LSP信息分析代码，执行以下任务：
1. 检查src/main.py中的潜在bug
2. 提供优化建议
3. 为核心功能生成单元测试
"
```

##### 最佳实践#

True. 合理配置LSP：根据项目需求配置合适的语言服务器
True. 结合子Agent使用：利用LSP提供的精确代码信息，让子Agent执行更复杂的代码处理任务
True. 监控性能：注意LSP服务器的性能，避免配置过多的语言服务器
True. 定期更新：保持语言服务器和Claude Code版本的更新
True. 使用VS Code集成：如果可能，优先使用VS Code集成，简化配置过程

#### 26.3.6 LSP的性能优化#

##### 减少Token消耗#

LSP的一个重要优势是减少Token消耗。根据测试，启用LSP后，Token消耗可以降低约40%。这是因为：

True. 精确的代码引用：LSP提供精确的代码位置，避免了发送大量冗余代码
True. 结构化的代码信息：LSP提供结构化的代码信息，减少了AI需要处理的文本量
True. 智能的上下文管理：LSP帮助管理代码上下文，只提供相关的代码信息

##### 性能优化建议#

True. 只配置必要的语言服务器：根据项目需求，只配置项目使用的语言服务器
True. 优化语言服务器配置：根据项目大小调整语言服务器的配置参数
True. 使用缓存：利用LSP的缓存机制，减少重复的代码分析
True. 合理使用子Agent：避免在短时间内创建过多的子Agent
True. 监控资源使用：定期检查语言服务器的资源使用情况

#### 26.3.7 常见问题和解决方案#

##### 问题1：LSP功能不工作#

True. 检查Claude Code版本是否 >= 2.0.74
True. 运行 /config 命令检查LSP配置
True. 检查语言服务器是否正确安装
True. 检查项目根目录是否有正确的配置文件

```
/config
```

##### 问题2：LSP服务器崩溃#

True. 检查语言服务器日志
True. 调整语言服务器的配置参数
True. 更新语言服务器版本
True. 减少同时打开的文件数量

##### 问题3：VS Code集成问题#

True. 运行 /terminal-setup 命令重新配置终端
True. 检查VS Code扩展是否正确安装
True. 重启VS Code和Claude Code
True. 检查VS Code版本兼容性

```
/terminal-setup
```

##### 问题4：Token消耗仍然很高#

True. 检查LSP配置是否正确
True. 优化语言服务器性能
True. 调整Claude Code的上下文窗口大小
True. 使用更精确的查询方式

#### 26.3.8 总结#

LSP是Claude Code中的一个重要功能，它为AI提供了真正的IDE级别的代码理解能力。通过LSP，Claude Code能够更精确地理解代码结构，提供更智能的代码导航和分析功能，同时减少Token消耗。

在使用LSP时，建议：

True. 优先使用VS Code集成，简化配置过程
True. 根据项目需求配置合适的语言服务器
True. 结合子Agent使用，执行更复杂的代码处理任务
True. 定期优化LSP配置，提高性能
True. 关注Claude Code的更新，获取新的LSP功能

LSP的引入标志着Claude Code从简单的代码生成工具向完整的AI辅助开发环境的转变，为开发者提供了更强大的AI编程体验。

---

## 4 计划模式（Plan Mode）

**URL**: https://claudecode.tangshuang.net/course/26.4%20%E8%AE%A1%E5%88%92%E6%A8%A1%E5%BC%8F%EF%BC%88Plan%20Mode%EF%BC%89

#### Plan Mode概述#

Plan Mode（计划模式）是Claude Code中的一项高级智能规划功能，依托Anthropic最新的Claude Opus 4.5模型的强大规划能力，通过在执行任何代码修改之前生成详细的执行计划，显著提高了编程任务的可靠性和可预测性。这一功能将传统的"直接执行"模式转变为"计划-审核-执行"的闭环工作流程，为用户提供了可编辑、可审核的任务执行蓝图。

#### Plan Mode的核心概念#

##### 1. 什么是Plan Mode#

Plan Mode是Claude Code的三种作业模式之一（默认模式、计划模式、自动接受模式），具有以下核心特点：

- 先计划后执行：在执行任何代码操作前，系统会先生成结构化的执行计划
- 智能需求澄清：主动询问用户关于任务逻辑边界和实现细节的问题，减少需求误解
- 可编辑计划文档：自动生成plan.md文件，允许用户在执行前调整和优化步骤
- 透明执行流程：让用户清楚了解系统将要执行的每一个操作和预期结果
- 基于最新模型：充分利用Claude Opus 4.5的高级规划和推理能力

```
plan.md
```

##### 2. Plan Mode的工作流程#

```
bash复制┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 用户提出需求 │────▶│ 启用Plan Mode   │────▶│ 智能需求澄清   │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
```

```
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 用户提出需求 │────▶│ 启用Plan Mode   │────▶│ 智能需求澄清   │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
```

│ 任务完成    │◀────│ 执行计划       │◀────│ 生成/修改计划   │
└─────────────┘     └─────────────────┘     └─────────────────┘

```
bash复制
## Plan Mode的使用方法

### 1. 启用Plan Mode

在Claude Code中启用Plan Mode有三种便捷方式：

- **快捷键操作**：使用`Shift + Tab`快捷键快速切换
- **界面按钮**：点击界面左下角的Plan Mode切换按钮（显示"plan"标识）
- **命令行指令**：在命令输入框中输入`/plan`命令

### 2. Plan Mode的使用示例

# 示例：使用Plan Mode创建一个待办事项应用

**用户请求**：
"创建一个简单的待办事项应用，包含添加、删除和标记完成功能"

**Claude Code (Plan Mode) 智能澄清**：
```

```
## Plan Mode的使用方法

### 1. 启用Plan Mode

在Claude Code中启用Plan Mode有三种便捷方式：

- **快捷键操作**：使用`Shift + Tab`快捷键快速切换
- **界面按钮**：点击界面左下角的Plan Mode切换按钮（显示"plan"标识）
- **命令行指令**：在命令输入框中输入`/plan`命令

### 2. Plan Mode的使用示例

# 示例：使用Plan Mode创建一个待办事项应用

**用户请求**：
"创建一个简单的待办事项应用，包含添加、删除和标记完成功能"

**Claude Code (Plan Mode) 智能澄清**：
```

为了给您创建一个符合需求的待办事项应用，我需要了解一些具体细节：

True. 您希望使用什么编程语言？(例如：Python, JavaScript, TypeScript)
True. 是否需要特定的框架？(例如：React, Vue, Flask, Express)
True. 数据存储方式？(本地JSON文件, 数据库, 内存)
True. 用户界面类型？(命令行界面, Web界面, 桌面应用)
True. 是否有其他特定功能需求？(如搜索、分类等)

```
bash复制
**用户回答**：
"使用JavaScript，不需要框架，本地JSON存储，命令行界面"

**Claude Code (Plan Mode) 生成的plan.md**：

~~~markdown
# 待办事项应用实现计划

## 1. 项目结构
- 创建项目根目录: `todo-app`
- 创建主程序文件: `todo.js`
- 创建数据存储文件: `todos.json`
- 创建项目说明文档: `README.md`

## 2. 核心功能实现

### 2.1 数据管理模块
- **loadTodos()**: 从JSON文件读取待办事项数据
- **saveTodos(todos)**: 将待办事项数据保存到JSON文件
- **initTodos()**: 初始化数据结构（如果文件不存在）

### 2.2 待办事项功能模块
- **addTodo(todoText)**: 添加新的待办事项
- **deleteTodo(index)**: 删除指定索引的待办事项
- **toggleTodo(index)**: 切换待办事项的完成状态
- **listTodos()**: 列出所有待办事项（区分已完成和未完成）

### 2.3 用户界面模块
- **showMenu()**: 显示命令行菜单选项
- **handleUserInput()**: 处理用户输入和命令执行
- **run()**: 主程序循环，保持应用运行

## 3. 实现步骤

1. 创建项目目录和基础文件结构
2. 实现数据管理模块（文件读写功能）
3. 实现待办事项核心功能
4. 实现命令行用户界面
5. 编写主程序入口和初始化逻辑
6. 全面测试所有功能
7. 编写项目说明文档

## 4. 预期文件结构
```

```
**用户回答**：
"使用JavaScript，不需要框架，本地JSON存储，命令行界面"

**Claude Code (Plan Mode) 生成的plan.md**：

~~~markdown
# 待办事项应用实现计划

## 1. 项目结构
- 创建项目根目录: `todo-app`
- 创建主程序文件: `todo.js`
- 创建数据存储文件: `todos.json`
- 创建项目说明文档: `README.md`

## 2. 核心功能实现

### 2.1 数据管理模块
- **loadTodos()**: 从JSON文件读取待办事项数据
- **saveTodos(todos)**: 将待办事项数据保存到JSON文件
- **initTodos()**: 初始化数据结构（如果文件不存在）

### 2.2 待办事项功能模块
- **addTodo(todoText)**: 添加新的待办事项
- **deleteTodo(index)**: 删除指定索引的待办事项
- **toggleTodo(index)**: 切换待办事项的完成状态
- **listTodos()**: 列出所有待办事项（区分已完成和未完成）

### 2.3 用户界面模块
- **showMenu()**: 显示命令行菜单选项
- **handleUserInput()**: 处理用户输入和命令执行
- **run()**: 主程序循环，保持应用运行

## 3. 实现步骤

1. 创建项目目录和基础文件结构
2. 实现数据管理模块（文件读写功能）
3. 实现待办事项核心功能
4. 实现命令行用户界面
5. 编写主程序入口和初始化逻辑
6. 全面测试所有功能
7. 编写项目说明文档

## 4. 预期文件结构
```

todo-app/
├── todo.js          # 主程序文件
├── todos.json       # 数据存储文件
└── README.md        # 项目说明文档

```
bash复制
## 5. 预期使用示例

```bash
$ node todo.js
1. 添加待办事项
2. 删除待办事项
3. 标记完成/未完成
4. 查看所有待办
5. 退出
请选择操作: 1
请输入待办事项: 学习Claude Code Plan Mode
待办事项已添加！
```

```
## 5. 预期使用示例

```bash
$ node todo.js
1. 添加待办事项
2. 删除待办事项
3. 标记完成/未完成
4. 查看所有待办
5. 退出
请选择操作: 1
请输入待办事项: 学习Claude Code Plan Mode
待办事项已添加！
```

```
bash复制
### 3. 审核和修改计划

用户可以审核生成的`plan.md`文件，并根据实际需求进行调整和优化。例如，添加新功能、调整实现顺序或修改技术细节：

~~~markdown
# 待办事项应用实现计划（修改后）

## 1. 项目结构
- 创建项目根目录: `todo-app`
- 创建主程序文件: `todo.js`
- 创建数据存储文件: `todos.json`
- 创建项目说明文档: `README.md`

## 2. 核心功能实现

### 2.1 数据管理模块
- **loadTodos()**: 从JSON文件读取待办事项数据
- **saveTodos(todos)**: 将待办事项数据保存到JSON文件
- **initTodos()**: 初始化数据结构

### 2.2 待办事项功能模块
- **addTodo(todoText)**: 添加新的待办事项
- **deleteTodo(index)**: 删除指定索引的待办事项
- **toggleTodo(index)**: 切换待办事项的完成状态
- **listTodos()**: 列出所有待办事项
- **clearCompleted()**: 清空所有已完成的待办事项  # 新增功能

### 2.3 用户界面模块
- **showMenu()**: 显示命令行菜单选项
- **handleUserInput()**: 处理用户输入和命令执行
- **displayTodo(todo, index)**: 格式化显示单个待办事项  # 新增辅助函数
- **run()**: 主程序循环

## 3. 实现步骤

1. 创建项目目录和基础文件结构
2. 实现数据管理模块
3. 实现待办事项核心功能（包括新增的清空功能）
4. 实现命令行用户界面（增强显示效果）
5. 编写主程序入口
6. 测试所有功能（重点测试新增功能）
7. 编写详细的README文档

## 4. 预期文件结构

```
todo-app/
├── todo.js          # 主程序文件
├── todos.json       # 数据存储文件
└── README.md        # 项目说明文档
```

## 5. 预期使用示例

```bash
$ node todo.js
1. 添加待办事项
2. 删除待办事项
3. 标记完成/未完成
4. 查看所有待办
5. 清空已完成的待办事项
6. 退出
请选择操作: 1
请输入待办事项: 学习Plan Mode
待办事项已添加！
```
```

```
### 3. 审核和修改计划

用户可以审核生成的`plan.md`文件，并根据实际需求进行调整和优化。例如，添加新功能、调整实现顺序或修改技术细节：

~~~markdown
# 待办事项应用实现计划（修改后）

## 1. 项目结构
- 创建项目根目录: `todo-app`
- 创建主程序文件: `todo.js`
- 创建数据存储文件: `todos.json`
- 创建项目说明文档: `README.md`

## 2. 核心功能实现

### 2.1 数据管理模块
- **loadTodos()**: 从JSON文件读取待办事项数据
- **saveTodos(todos)**: 将待办事项数据保存到JSON文件
- **initTodos()**: 初始化数据结构

### 2.2 待办事项功能模块
- **addTodo(todoText)**: 添加新的待办事项
- **deleteTodo(index)**: 删除指定索引的待办事项
- **toggleTodo(index)**: 切换待办事项的完成状态
- **listTodos()**: 列出所有待办事项
- **clearCompleted()**: 清空所有已完成的待办事项  # 新增功能

### 2.3 用户界面模块
- **showMenu()**: 显示命令行菜单选项
- **handleUserInput()**: 处理用户输入和命令执行
- **displayTodo(todo, index)**: 格式化显示单个待办事项  # 新增辅助函数
- **run()**: 主程序循环

## 3. 实现步骤

1. 创建项目目录和基础文件结构
2. 实现数据管理模块
3. 实现待办事项核心功能（包括新增的清空功能）
4. 实现命令行用户界面（增强显示效果）
5. 编写主程序入口
6. 测试所有功能（重点测试新增功能）
7. 编写详细的README文档

## 4. 预期文件结构

```
todo-app/
├── todo.js          # 主程序文件
├── todos.json       # 数据存储文件
└── README.md        # 项目说明文档
```

## 5. 预期使用示例

```bash
$ node todo.js
1. 添加待办事项
2. 删除待办事项
3. 标记完成/未完成
4. 查看所有待办
5. 清空已完成的待办事项
6. 退出
请选择操作: 1
请输入待办事项: 学习Plan Mode
待办事项已添加！
```
```

##### 4. 执行计划#

用户确认并优化计划后，Claude Code将按照计划有序执行所有操作，并实时反馈进度：

```
bash复制开始执行待办事项应用开发计划...

1. 创建项目目录结构
✅ 创建目录: todo-app
✅ 创建文件: todo.js
✅ 创建文件: todos.json
✅ 创建文件: README.md

2. 实现数据管理模块
✅ 实现 loadTodos() 函数
✅ 实现 saveTodos(todos) 函数
✅ 实现 initTodos() 函数

3. 实现待办事项功能模块
✅ 实现 addTodo(todoText) 函数
✅ 实现 deleteTodo(index) 函数
✅ 实现 toggleTodo(index) 函数
✅ 实现 listTodos() 函数
✅ 实现 clearCompleted() 函数（新增）

4. 实现用户界面模块
✅ 实现 showMenu() 函数
✅ 实现 handleUserInput() 函数
✅ 实现 displayTodo(todo, index) 函数（新增）
✅ 实现 run() 函数

5. 编写主程序入口
✅ 编写主程序入口代码
✅ 实现应用初始化逻辑

6. 测试所有功能
✅ 测试添加功能
✅ 测试删除功能
✅ 测试标记完成功能
✅ 测试列表功能
✅ 测试清空已完成功能
✅ 测试退出功能

7. 编写README文档
✅ 编写项目说明
✅ 编写安装和使用说明
✅ 编写功能说明
✅ 编写代码结构说明

计划执行完成！待办事项应用已成功创建。
```

```
开始执行待办事项应用开发计划...

1. 创建项目目录结构
✅ 创建目录: todo-app
✅ 创建文件: todo.js
✅ 创建文件: todos.json
✅ 创建文件: README.md

2. 实现数据管理模块
✅ 实现 loadTodos() 函数
✅ 实现 saveTodos(todos) 函数
✅ 实现 initTodos() 函数

3. 实现待办事项功能模块
✅ 实现 addTodo(todoText) 函数
✅ 实现 deleteTodo(index) 函数
✅ 实现 toggleTodo(index) 函数
✅ 实现 listTodos() 函数
✅ 实现 clearCompleted() 函数（新增）

4. 实现用户界面模块
✅ 实现 showMenu() 函数
✅ 实现 handleUserInput() 函数
✅ 实现 displayTodo(todo, index) 函数（新增）
✅ 实现 run() 函数

5. 编写主程序入口
✅ 编写主程序入口代码
✅ 实现应用初始化逻辑

6. 测试所有功能
✅ 测试添加功能
✅ 测试删除功能
✅ 测试标记完成功能
✅ 测试列表功能
✅ 测试清空已完成功能
✅ 测试退出功能

7. 编写README文档
✅ 编写项目说明
✅ 编写安装和使用说明
✅ 编写功能说明
✅ 编写代码结构说明

计划执行完成！待办事项应用已成功创建。
```

#### Plan Mode的优势#

##### 1. 显著提高任务质量#

Plan Mode通过结构化的规划流程，大幅提升了编程任务的整体质量：

##### 2. 增强用户控制能力#

- 完全可见性：用户可以清晰了解系统将要执行的每一个操作和预期结果
- 灵活可编辑性：用户可以根据实际需求调整和优化执行计划
- 严格可审核性：用户可以在执行前全面审核计划的合理性和完整性
- 实时反馈：执行过程中提供清晰的进度和状态反馈

##### 3. 大幅减少错误和风险#

Plan Mode通过前置规划和审核机制，有效降低了编程任务的各类风险：

#### Plan Mode的应用场景#

##### 1. 复杂项目开发#

对于结构复杂、涉及多个模块和技术栈的项目，Plan Mode可以：

- 帮助用户清晰规划项目架构和模块划分
- 有序组织开发步骤和依赖关系
- 确保所有功能点完整实现
- 提高团队协作效率（通过共享和讨论计划）

##### 2. 关键代码修改#

对于需要修改核心代码、敏感数据或生产环境代码的任务，Plan Mode可以：

- 降低误操作和破坏性修改的风险
- 提供详细的修改计划作为回滚参考
- 确保修改符合系统架构和设计原则
- 便于代码审查和质量控制

##### 3. 学习和教学场景#

对于学习编程的用户和教育场景，Plan Mode可以：

- 展示完整的软件开发流程和最佳实践
- 解释每一步执行的逻辑和技术原理
- 帮助培养结构化思维和规划能力
- 提供清晰的学习路径和实践指导

##### 4. 批量数据处理#

对于需要处理大量数据的任务，Plan Mode可以：

- 规划高效的数据处理流程
- 设计并行处理策略提高效率
- 确保数据安全和完整性
- 提供处理进度和结果验证机制

#### Plan Mode与其他功能的结合#

##### 1. 与子Agent功能结合#

Plan Mode可以与Claude Code的子Agent功能无缝结合，为复杂任务生成包含多Agent协作的详细计划：

```
markdown复制# 复杂Web应用开发计划

## 1. 项目概述
开发一个包含前端、后端和数据库的完整Web应用

## 2. 项目结构
- 前端目录: `frontend/` (React + TypeScript)
- 后端目录: `backend/` (Node.js + Express)
- 数据库目录: `database/` (PostgreSQL)

## 3. 子Agent分配与协作

### 3.1 前端开发子Agent
- **负责范围**: 用户界面实现、交互逻辑、响应式设计
- **技术栈**: React 18 + TypeScript + Tailwind CSS
- **交付物**: 完整的前端应用、组件文档

### 3.2 后端开发子Agent
- **负责范围**: API服务、业务逻辑、用户认证
- **技术栈**: Node.js + Express + JWT
- **交付物**: 完整的后端服务、API文档

### 3.3 数据库设计子Agent
- **负责范围**: 数据模型设计、关系映射、查询优化
- **技术栈**: PostgreSQL + Prisma ORM
- **交付物**: 数据库设计文档、迁移脚本

## 4. 协作流程

1. 前端子Agent设计UI原型和组件结构
2. 数据库子Agent设计数据模型和关系
3. 后端子Agent实现API接口
4. 前端子Agent集成API并实现完整交互
5. 进行系统集成测试和调试
6. 性能优化和部署配置

## 5. 时间线规划

- 第1-2天: 需求分析和设计
- 第3-5天: 并行开发（前端、后端、数据库）
- 第6天: 系统集成和测试
- 第7天: 优化和部署
```

```
# 复杂Web应用开发计划

## 1. 项目概述
开发一个包含前端、后端和数据库的完整Web应用

## 2. 项目结构
- 前端目录: `frontend/` (React + TypeScript)
- 后端目录: `backend/` (Node.js + Express)
- 数据库目录: `database/` (PostgreSQL)

## 3. 子Agent分配与协作

### 3.1 前端开发子Agent
- **负责范围**: 用户界面实现、交互逻辑、响应式设计
- **技术栈**: React 18 + TypeScript + Tailwind CSS
- **交付物**: 完整的前端应用、组件文档

### 3.2 后端开发子Agent
- **负责范围**: API服务、业务逻辑、用户认证
- **技术栈**: Node.js + Express + JWT
- **交付物**: 完整的后端服务、API文档

### 3.3 数据库设计子Agent
- **负责范围**: 数据模型设计、关系映射、查询优化
- **技术栈**: PostgreSQL + Prisma ORM
- **交付物**: 数据库设计文档、迁移脚本

## 4. 协作流程

1. 前端子Agent设计UI原型和组件结构
2. 数据库子Agent设计数据模型和关系
3. 后端子Agent实现API接口
4. 前端子Agent集成API并实现完整交互
5. 进行系统集成测试和调试
6. 性能优化和部署配置

## 5. 时间线规划

- 第1-2天: 需求分析和设计
- 第3-5天: 并行开发（前端、后端、数据库）
- 第6天: 系统集成和测试
- 第7天: 优化和部署
```

##### 2. 与异步任务功能结合#

Plan Mode可以为异步任务生成包含并行执行步骤的优化计划：

```
markdown复制# 大规模用户数据处理计划

## 1. 任务概述
处理100万条用户数据，包括清洗、转换和分析

## 2. 执行步骤

### 2.1 数据准备阶段
- 下载原始数据文件: `users_raw.csv`
- 验证文件完整性和格式
- 创建数据备份

### 2.2 并行处理阶段（提高效率）
- **数据清洗任务**: `clean_data.js` (线程1) - 处理缺失值和格式问题
- **数据转换任务**: `transform_data.js` (线程2) - 标准化数据格式
- **数据验证任务**: `validate_data.js` (线程3) - 确保数据一致性

### 2.3 结果整合阶段
- 合并三个线程的处理结果
- 生成详细的数据分析报告
- 保存最终处理后的数据

## 3. 资源配置

- 分配3个CPU核心用于并行处理
- 设置1GB内存限制/线程
- 预计处理时间: 25-30分钟

## 4. 风险控制

- 每个处理步骤都创建中间备份
- 实现错误重试机制
- 设置超时监控和警报
```

```
# 大规模用户数据处理计划

## 1. 任务概述
处理100万条用户数据，包括清洗、转换和分析

## 2. 执行步骤

### 2.1 数据准备阶段
- 下载原始数据文件: `users_raw.csv`
- 验证文件完整性和格式
- 创建数据备份

### 2.2 并行处理阶段（提高效率）
- **数据清洗任务**: `clean_data.js` (线程1) - 处理缺失值和格式问题
- **数据转换任务**: `transform_data.js` (线程2) - 标准化数据格式
- **数据验证任务**: `validate_data.js` (线程3) - 确保数据一致性

### 2.3 结果整合阶段
- 合并三个线程的处理结果
- 生成详细的数据分析报告
- 保存最终处理后的数据

## 3. 资源配置

- 分配3个CPU核心用于并行处理
- 设置1GB内存限制/线程
- 预计处理时间: 25-30分钟

## 4. 风险控制

- 每个处理步骤都创建中间备份
- 实现错误重试机制
- 设置超时监控和警报
```

#### 总结#

Plan Mode是Claude Code的一项革命性功能，它通过以下方式彻底改变了AI辅助编程的体验：

True. 智能规划引擎：利用Claude Opus 4.5的高级推理能力生成结构化执行计划
True. 需求澄清机制：主动询问关键细节，大幅减少需求误解
True. 用户可控性：提供可编辑的计划文档，让用户掌握完全的控制权
True. 透明执行流程：从计划到执行的全过程可见，减少"黑盒操作"的不确定性
True. 多场景适用性：从简单脚本到复杂系统开发，从学习到生产环境都能发挥价值
True. 无缝功能集成：与子Agent、异步任务等高级功能完美结合，支持复杂任务处理

通过Plan Mode，Claude Code将AI辅助编程从"简单执行指令"提升到"智能协作伙伴"的层次，为开发者提供了更加可靠、高效和可控的编程体验。无论是个人开发还是团队协作，Plan Mode都能帮助用户以更高的质量、更低的风险完成编程任务。

在下一节中，我们将探讨Claude Code的另一个高级功能：Interview Mode。

---

## 5 Interview Mode

**URL**: https://claudecode.tangshuang.net/course/26.5%20Interview%20Mode

#### Interview Mode概述#

Interview Mode（交互式询问模式）是Claude Code的一项核心功能，它通过AskUserQuestion工具在自动化工作流中插入人工决策点，允许AI Agent在执行任务过程中主动向用户提问，以获取关键信息、确认决策或澄清需求。

```
AskUserQuestion
```

##### Thariq推荐的基于规范的开发方法#

Claude Code的工程师Thariq在推特中分享了他使用Interview Mode的最佳实践：

my favorite way to use Claude Code to build large features is spec based
start with a minimal spec or prompt and ask Claude to interview you using the AskUserQuestionTool
then make a new session to execute the spec

这种基于规范的开发方法已成为Claude Code用户构建大型功能的首选方式，它通过前置决策过程确保AI准确理解需求，从而提高开发效率和质量。

#### Interview Mode的核心概念#

##### 1. 什么是Interview Mode#

Interview Mode是Claude Code的一种交互范式，具有以下特点：

- 主动询问：AI在执行任务过程中主动向用户提问，而不是被动等待用户输入
- 上下文感知：基于当前任务上下文提出相关问题，确保询问的针对性
- 灵活决策：根据用户的回答动态调整执行路径
- 工作流集成：可作为工作流中的独立节点使用，与其他组件无缝协作
- 多轮对话：支持复杂的多轮交互式决策过程

##### 2. Interview Mode的工作原理#

```
bash复制┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ AI执行任务   │────▶│ 需要用户输入   │────▶│ 生成问题       │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 继续执行任务 │◀────│ 处理用户回答   │◀────│ 用户回答问题   │
└─────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ AI执行任务   │────▶│ 需要用户输入   │────▶│ 生成问题       │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 继续执行任务 │◀────│ 处理用户回答   │◀────│ 用户回答问题   │
└─────────────┘     └─────────────────┘     └─────────────────┘
```

#### Interview Mode的核心工具：AskUserQuestion#

##### 1. AskUserQuestion工具概述#

AskUserQuestion是Claude Code中用于实现Interview Mode的核心工具，它允许AI在执行工作流时向用户提出问题并获取回答。

```
AskUserQuestion
```

- question：要向用户提出的问题（必填）
- options：可选的预定义答案列表（数组格式）
- default：默认答案（如果用户未提供回答）
- required：是否为必填问题（布尔值，默认为false）
- description：问题的详细描述或上下文信息
- multiple：是否允许选择多个答案（布尔值，默认为false）

```
question
```

```
options
```

```
default
```

```
required
```

```
description
```

```
multiple
```

##### 2. AskUserQuestion在工作流中的使用#

在Claude Code工作流中，AskUserQuestion通常与其他节点配合使用，如条件分支（IfElse/Switch）、子代理（AI任务）等：

```
AskUserQuestion
```

```
bash复制┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 启动任务    │────▶│ AskUserQuestion │────▶│ IfElse/Switch   │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               │                      │
                               │                      ▼
                               │               ┌─────────────────┐
                               │               │ 执行分支1       │
                               │               └─────────────────┘
                               │                      │
                               │                      ▼
                               │               ┌─────────────────┐
                               └──────────────▶│ 执行分支2       │
                                               └─────────────────┘
```

```
┌─────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 启动任务    │────▶│ AskUserQuestion │────▶│ IfElse/Switch   │
└─────────────┘     └─────────────────┘     └─────────────────┘
                               │                      │
                               │                      ▼
                               │               ┌─────────────────┐
                               │               │ 执行分支1       │
                               │               └─────────────────┘
                               │                      │
                               │                      ▼
                               │               ┌─────────────────┐
                               └──────────────▶│ 执行分支2       │
                                               └─────────────────┘
```

#### 基于规范的开发流程#

Thariq推荐的基于规范的开发方法包含三个主要阶段：

##### 阶段1：使用Interview Mode构建规范#

从一个最小化的规范或提示开始，让Claude使用AskUserQuestion工具对你进行访谈：

```
AskUserQuestion
```

```
bash复制$ claude "帮我构建一个待办事项应用的规范" --interview

我需要了解一些细节来为您创建待办事项应用的规范：

1. 应用类型：桌面应用、Web应用还是移动应用？
2. 核心功能需求：
   - 用户认证
   - 任务管理（创建、编辑、删除）
   - 任务分类
   - 提醒功能
   - 数据同步
3. 技术栈偏好：
   - 前端框架
   - 后端技术
   - 数据库
4. 设计风格要求：
   - 简约风格
   - 现代风格
   - 自定义风格
```

```
$ claude "帮我构建一个待办事项应用的规范" --interview

我需要了解一些细节来为您创建待办事项应用的规范：

1. 应用类型：桌面应用、Web应用还是移动应用？
2. 核心功能需求：
   - 用户认证
   - 任务管理（创建、编辑、删除）
   - 任务分类
   - 提醒功能
   - 数据同步
3. 技术栈偏好：
   - 前端框架
   - 后端技术
   - 数据库
4. 设计风格要求：
   - 简约风格
   - 现代风格
   - 自定义风格
```

##### 阶段2：生成详细规范文档#

基于访谈结果，Claude会生成一个详细的规范文档：

```
markdown复制# 待办事项应用规范

## 应用概述
Web应用，提供任务管理和提醒功能

## 核心功能
1. 用户认证
   - 注册/登录
   - 密码重置
   - 邮箱验证

2. 任务管理
   - 创建任务（标题、描述、截止日期、优先级）
   - 编辑任务
   - 删除任务
   - 标记完成/未完成

3. 任务分类
   - 创建分类
   - 任务分配到分类
   - 按分类筛选

4. 提醒功能
   - 截止日期提醒
   - 自定义提醒时间

5. 数据同步
   - 实时同步
   - 离线支持

## 技术栈
- 前端：React + TypeScript + Tailwind CSS
- 后端：Node.js + Express
- 数据库：MongoDB
- 认证：JWT

## 设计风格
现代简约风格，支持深色/浅色主题切换
```

```
# 待办事项应用规范

## 应用概述
Web应用，提供任务管理和提醒功能

## 核心功能
1. 用户认证
   - 注册/登录
   - 密码重置
   - 邮箱验证

2. 任务管理
   - 创建任务（标题、描述、截止日期、优先级）
   - 编辑任务
   - 删除任务
   - 标记完成/未完成

3. 任务分类
   - 创建分类
   - 任务分配到分类
   - 按分类筛选

4. 提醒功能
   - 截止日期提醒
   - 自定义提醒时间

5. 数据同步
   - 实时同步
   - 离线支持

## 技术栈
- 前端：React + TypeScript + Tailwind CSS
- 后端：Node.js + Express
- 数据库：MongoDB
- 认证：JWT

## 设计风格
现代简约风格，支持深色/浅色主题切换
```

##### 阶段3：执行规范实现功能#

创建一个新会话，使用生成的规范作为输入，Claude会按照规范实现完整的应用：

```
bash复制$ claude "根据待办事项应用规范实现完整功能"
```

```
$ claude "根据待办事项应用规范实现完整功能"
```

#### Interview Mode的使用方法#

##### 1. 在命令行中使用Interview Mode#

在Claude Code命令行界面中，当AI需要用户输入时会自动进入Interview Mode，主动提出问题：

```
bash复制$ claude "帮我创建一个Web应用"

我需要了解一些细节来为您创建Web应用：

1. 您希望使用什么前端框架？(React, Vue, Angular, 或其他)
2. 您希望使用什么后端技术？(Node.js, Python, Java, 或其他)
3. 您需要数据库支持吗？如果需要，您偏好哪种数据库？
4. 应用需要哪些核心功能？
5. 您有特定的设计风格或布局要求吗？

请提供您的选择，或者直接按Enter接受默认值。
```

```
$ claude "帮我创建一个Web应用"

我需要了解一些细节来为您创建Web应用：

1. 您希望使用什么前端框架？(React, Vue, Angular, 或其他)
2. 您希望使用什么后端技术？(Node.js, Python, Java, 或其他)
3. 您需要数据库支持吗？如果需要，您偏好哪种数据库？
4. 应用需要哪些核心功能？
5. 您有特定的设计风格或布局要求吗？

请提供您的选择，或者直接按Enter接受默认值。
```

##### 2. 在工作流中使用AskUserQuestion节点#

在Claude Code Workflow Studio中，可以通过拖拽AskUserQuestion节点来创建交互式工作流：

```
AskUserQuestion
```

```
yaml复制# 工作流示例：创建项目结构
name: "创建项目结构"
description: "根据用户选择创建不同类型的项目结构"

nodes:
  - id: "start"
    type: "start"
    next: "ask_project_type"

  - id: "ask_project_type"
    type: "AskUserQuestion"
    question: "您希望创建什么类型的项目？"
    options:
      - "前端项目"
      - "后端项目"
      - "全栈项目"
      - "移动应用"
    required: true
    next: "project_type_branch"

  - id: "project_type_branch"
    type: "IfElse"
    condition: "${ask_project_type.result}"
    branches:
      - value: "前端项目"
        next: "create_frontend_project"
      - value: "后端项目"
        next: "create_backend_project"
      - value: "全栈项目"
        next: "create_fullstack_project"
      - value: "移动应用"
        next: "create_mobile_project"

  - id: "create_frontend_project"
    type: "subagent"
    prompt: "创建一个现代前端项目结构，包含React框架和Vite构建工具"
    next: "end"

  - id: "create_backend_project"
    type: "subagent"
    prompt: "创建一个Node.js后端项目结构，包含Express框架和REST API"
    next: "end"

  - id: "create_fullstack_project"
    type: "subagent"
    prompt: "创建一个全栈项目结构，包含React前端和Node.js后端"
    next: "end"

  - id: "create_mobile_project"
    type: "subagent"
    prompt: "创建一个移动应用项目结构，包含React Native框架"
    next: "end"

  - id: "end"
    type: "end"
```

```
# 工作流示例：创建项目结构
name: "创建项目结构"
description: "根据用户选择创建不同类型的项目结构"

nodes:
  - id: "start"
    type: "start"
    next: "ask_project_type"

  - id: "ask_project_type"
    type: "AskUserQuestion"
    question: "您希望创建什么类型的项目？"
    options:
      - "前端项目"
      - "后端项目"
      - "全栈项目"
      - "移动应用"
    required: true
    next: "project_type_branch"

  - id: "project_type_branch"
    type: "IfElse"
    condition: "${ask_project_type.result}"
    branches:
      - value: "前端项目"
        next: "create_frontend_project"
      - value: "后端项目"
        next: "create_backend_project"
      - value: "全栈项目"
        next: "create_fullstack_project"
      - value: "移动应用"
        next: "create_mobile_project"

  - id: "create_frontend_project"
    type: "subagent"
    prompt: "创建一个现代前端项目结构，包含React框架和Vite构建工具"
    next: "end"

  - id: "create_backend_project"
    type: "subagent"
    prompt: "创建一个Node.js后端项目结构，包含Express框架和REST API"
    next: "end"

  - id: "create_fullstack_project"
    type: "subagent"
    prompt: "创建一个全栈项目结构，包含React前端和Node.js后端"
    next: "end"

  - id: "create_mobile_project"
    type: "subagent"
    prompt: "创建一个移动应用项目结构，包含React Native框架"
    next: "end"

  - id: "end"
    type: "end"
```

##### 3. Interview Mode的编程接口#

在Claude Code的编程接口中，可以通过ask_user函数来使用Interview Mode：

```
ask_user
```

```
python复制# 使用Interview Mode的Python示例
from claude_code import ClaudeAgent

agent = ClaudeAgent()

def create_website():
    # AI主动询问网站类型
    website_type = agent.ask_user(
        question="您希望创建什么类型的网站？",
        options=["博客", "电商网站", "企业官网", "个人作品集"],
        required=True
    )
    
    # 根据用户回答调整执行逻辑
    if website_type == "博客":
        create_blog()
    elif website_type == "电商网站":
        create_ecommerce()
    elif website_type == "企业官网":
        create_corporate_site()
    elif website_type == "个人作品集":
        create_portfolio()
    
    # 询问是否需要额外功能（允许多选）
    additional_features = agent.ask_user(
        question="您是否需要添加额外功能？",
        options=["SEO优化", "响应式设计", "社交媒体集成", "支付功能"],
        required=False,
        multiple=True
    )
    
    if additional_features:
        add_features(additional_features)
    
    print("网站创建完成！")

def create_blog():
    print("创建博客网站...")
    # 博客网站创建逻辑

def create_ecommerce():
    print("创建电商网站...")
    # 电商网站创建逻辑

def create_corporate_site():
    print("创建企业官网...")
    # 企业官网创建逻辑

def create_portfolio():
    print("创建个人作品集...")
    # 个人作品集创建逻辑

def add_features(features):
    print(f"添加额外功能: {', '.join(features)}...")
    # 添加功能的逻辑

# 执行任务
create_website()
```

```
# 使用Interview Mode的Python示例
from claude_code import ClaudeAgent

agent = ClaudeAgent()

def create_website():
    # AI主动询问网站类型
    website_type = agent.ask_user(
        question="您希望创建什么类型的网站？",
        options=["博客", "电商网站", "企业官网", "个人作品集"],
        required=True
    )
    
    # 根据用户回答调整执行逻辑
    if website_type == "博客":
        create_blog()
    elif website_type == "电商网站":
        create_ecommerce()
    elif website_type == "企业官网":
        create_corporate_site()
    elif website_type == "个人作品集":
        create_portfolio()
    
    # 询问是否需要额外功能（允许多选）
    additional_features = agent.ask_user(
        question="您是否需要添加额外功能？",
        options=["SEO优化", "响应式设计", "社交媒体集成", "支付功能"],
        required=False,
        multiple=True
    )
    
    if additional_features:
        add_features(additional_features)
    
    print("网站创建完成！")

def create_blog():
    print("创建博客网站...")
    # 博客网站创建逻辑

def create_ecommerce():
    print("创建电商网站...")
    # 电商网站创建逻辑

def create_corporate_site():
    print("创建企业官网...")
    # 企业官网创建逻辑

def create_portfolio():
    print("创建个人作品集...")
    # 个人作品集创建逻辑

def add_features(features):
    print(f"添加额外功能: {', '.join(features)}...")
    # 添加功能的逻辑

# 执行任务
create_website()
```

#### Interview Mode的使用场景#

##### 1. 需求澄清#

当AI需要更详细的需求信息时，可以使用Interview Mode：

```
bash复制我需要了解更多关于您的项目需求：

1. 您的项目预计有多少用户访问量？
   - 少于1000/月
   - 1000-10000/月
   - 10000-100000/月
   - 超过100000/月

2. 您需要支持哪些语言版本？
3. 您有特定的性能要求吗？
```

```
我需要了解更多关于您的项目需求：

1. 您的项目预计有多少用户访问量？
   - 少于1000/月
   - 1000-10000/月
   - 10000-100000/月
   - 超过100000/月

2. 您需要支持哪些语言版本？
3. 您有特定的性能要求吗？
```

##### 2. 决策确认#

当AI需要用户确认关键决策时，可以使用Interview Mode：

```
bash复制我发现项目中存在以下潜在问题：

1. 数据库连接字符串使用了明文密码
2. 代码中存在未使用的依赖
3. 缺乏错误处理机制

请问您希望我如何处理这些问题？
   - 自动修复所有问题
   - 只修复安全相关问题（数据库密码）
   - 只修复性能相关问题（未使用的依赖）
   - 不修复，只提供建议
```

```
我发现项目中存在以下潜在问题：

1. 数据库连接字符串使用了明文密码
2. 代码中存在未使用的依赖
3. 缺乏错误处理机制

请问您希望我如何处理这些问题？
   - 自动修复所有问题
   - 只修复安全相关问题（数据库密码）
   - 只修复性能相关问题（未使用的依赖）
   - 不修复，只提供建议
```

##### 3. 配置选择#

当AI需要用户选择配置选项时，可以使用Interview Mode：

```
bash复制请选择项目的配置选项：

1. 开发环境：
   - Local（本地开发）
   - Docker（容器化开发）
   - Cloud（云开发环境）

2. 代码风格：
   - Standard
   - Prettier
   - ESLint

3. 测试框架：
   - Jest
   - Mocha
   - Cypress
```

```
请选择项目的配置选项：

1. 开发环境：
   - Local（本地开发）
   - Docker（容器化开发）
   - Cloud（云开发环境）

2. 代码风格：
   - Standard
   - Prettier
   - ESLint

3. 测试框架：
   - Jest
   - Mocha
   - Cypress
```

##### 4. 内容确认#

当AI生成内容需要用户确认时，可以使用Interview Mode：

```
markdown复制我为您的项目生成了以下README文件内容：

# My Project

这是一个使用React和Node.js开发的全栈项目，包含以下功能：
- 用户认证
- 数据管理
- API接口

## 安装

```bash
npm install
npm run dev
```

请问您是否满意这个README文件？
   - 满意，使用这个版本
   - 需要修改，我来提供具体修改意见
   - 不满意，重新生成
```

```
我为您的项目生成了以下README文件内容：

# My Project

这是一个使用React和Node.js开发的全栈项目，包含以下功能：
- 用户认证
- 数据管理
- API接口

## 安装

```bash
npm install
npm run dev
```

请问您是否满意这个README文件？
   - 满意，使用这个版本
   - 需要修改，我来提供具体修改意见
   - 不满意，重新生成
```

##### 5. 规范构建#

使用Interview Mode构建详细的项目规范：

```
bash复制我需要了解一些细节来构建您的项目规范：

1. 项目类型：
   - 前端项目
   - 后端项目
   - 全栈项目
   - 移动应用

2. 核心功能需求：
   - 用户认证
   - 数据管理
   - 第三方集成
   - 其他特殊功能

3. 技术栈偏好：
   - 编程语言
   - 框架和库
   - 数据库
   - 部署方式

4. 项目规模：
   - 小型（1-5人月）
   - 中型（5-15人月）
   - 大型（15人月以上）

5. 交付时间要求：
   - 紧急（1-2周）
   - 短期（2-4周）
   - 中期（1-3个月）
   - 长期（3个月以上）
```

```
我需要了解一些细节来构建您的项目规范：

1. 项目类型：
   - 前端项目
   - 后端项目
   - 全栈项目
   - 移动应用

2. 核心功能需求：
   - 用户认证
   - 数据管理
   - 第三方集成
   - 其他特殊功能

3. 技术栈偏好：
   - 编程语言
   - 框架和库
   - 数据库
   - 部署方式

4. 项目规模：
   - 小型（1-5人月）
   - 中型（5-15人月）
   - 大型（15人月以上）

5. 交付时间要求：
   - 紧急（1-2周）
   - 短期（2-4周）
   - 中期（1-3个月）
   - 长期（3个月以上）
```

#### Interview Mode与其他功能的结合#

##### 1. 与Plan Mode结合#

Interview Mode可以与Plan Mode结合使用，在生成执行计划前向用户询问关键信息：

```
bash复制我将为您创建一个完整的项目计划，首先需要了解一些关键信息：

1. 项目类型：前端/后端/全栈/移动应用
2. 技术栈偏好：
3. 项目规模：小型/中型/大型
4. 时间期限：
5. 预算限制：

请提供这些信息，我将生成一个详细的项目计划。
```

```
我将为您创建一个完整的项目计划，首先需要了解一些关键信息：

1. 项目类型：前端/后端/全栈/移动应用
2. 技术栈偏好：
3. 项目规模：小型/中型/大型
4. 时间期限：
5. 预算限制：

请提供这些信息，我将生成一个详细的项目计划。
```

##### 2. 与子Agent结合#

Interview Mode可以与子Agent结合，为子Agent提供必要的输入信息：

```
yaml复制# 工作流示例：多Agent协作
name: "多Agent项目开发"
description: "基于用户需求开发完整项目"

nodes:
  - id: "start"
    type: "start"
    next: "ask_requirements"

  - id: "ask_requirements"
    type: "AskUserQuestion"
    question: "请描述您的项目需求"
    required: true
    next: "plan_agent"

  - id: "plan_agent"
    type: "subagent"
    prompt: "根据用户需求生成详细的项目计划"
    next: "ask_approval"

  - id: "ask_approval"
    type: "AskUserQuestion"
    question: "您是否批准这个项目计划？"
    options: ["批准", "修改", "拒绝"]
    required: true
    next: "approval_branch"

  - id: "approval_branch"
    type: "IfElse"
    condition: "${ask_approval.result}"
    branches:
      - value: "批准"
        next: "execute_agent"
      - value: "修改"
        next: "ask_requirements"
      - value: "拒绝"
        next: "end"

  - id: "execute_agent"
    type: "subagent"
    prompt: "根据批准的计划执行项目开发"
    next: "end"

  - id: "end"
    type: "end"
```

```
# 工作流示例：多Agent协作
name: "多Agent项目开发"
description: "基于用户需求开发完整项目"

nodes:
  - id: "start"
    type: "start"
    next: "ask_requirements"

  - id: "ask_requirements"
    type: "AskUserQuestion"
    question: "请描述您的项目需求"
    required: true
    next: "plan_agent"

  - id: "plan_agent"
    type: "subagent"
    prompt: "根据用户需求生成详细的项目计划"
    next: "ask_approval"

  - id: "ask_approval"
    type: "AskUserQuestion"
    question: "您是否批准这个项目计划？"
    options: ["批准", "修改", "拒绝"]
    required: true
    next: "approval_branch"

  - id: "approval_branch"
    type: "IfElse"
    condition: "${ask_approval.result}"
    branches:
      - value: "批准"
        next: "execute_agent"
      - value: "修改"
        next: "ask_requirements"
      - value: "拒绝"
        next: "end"

  - id: "execute_agent"
    type: "subagent"
    prompt: "根据批准的计划执行项目开发"
    next: "end"

  - id: "end"
    type: "end"
```

##### 3. 与条件分支结合#

Interview Mode可以与条件分支结合，根据用户的回答选择不同的执行路径：

```
python复制# 示例：根据用户选择执行不同的优化策略
def optimize_website():
    # 询问用户的优化目标
    optimization_goal = agent.ask_user(
        question="您的网站优化主要目标是什么？",
        options=["加载速度", "SEO排名", "用户体验", "转化率"]
    )
    
    # 根据回答选择不同的优化策略
    if optimization_goal == "加载速度":
        optimize_load_speed()
    elif optimization_goal == "SEO排名":
        optimize_seo()
    elif optimization_goal == "用户体验":
        optimize_ux()
    elif optimization_goal == "转化率":
        optimize_conversion()
```

```
# 示例：根据用户选择执行不同的优化策略
def optimize_website():
    # 询问用户的优化目标
    optimization_goal = agent.ask_user(
        question="您的网站优化主要目标是什么？",
        options=["加载速度", "SEO排名", "用户体验", "转化率"]
    )
    
    # 根据回答选择不同的优化策略
    if optimization_goal == "加载速度":
        optimize_load_speed()
    elif optimization_goal == "SEO排名":
        optimize_seo()
    elif optimization_goal == "用户体验":
        optimize_ux()
    elif optimization_goal == "转化率":
        optimize_conversion()
```

#### Interview Mode的最佳实践#

##### 1. 清晰的问题表述#

```
python复制# 不好的问题
question = "您想要什么？"

# 好的问题
question = "您希望创建哪种类型的网站？(博客、电商、企业官网或个人作品集)"
```

```
# 不好的问题
question = "您想要什么？"

# 好的问题
question = "您希望创建哪种类型的网站？(博客、电商、企业官网或个人作品集)"
```

##### 2. 提供合理的选项#

```
python复制# 不好的选项
options = ["选项1", "选项2", "选项3"]

# 好的选项
options = ["博客", "电商网站", "企业官网", "个人作品集"]
```

```
# 不好的选项
options = ["选项1", "选项2", "选项3"]

# 好的选项
options = ["博客", "电商网站", "企业官网", "个人作品集"]
```

##### 3. 控制问题数量#

```
python复制# 不好的做法：一次性问太多问题
questions = [
    "您的项目类型是什么？",
    "您使用什么技术栈？",
    "项目规模有多大？",
    "时间期限是什么？",
    "预算限制是什么？",
    "有什么特殊要求？"
]

# 好的做法：分阶段提问
first_question = "您的项目类型是什么？"
# 根据回答再提问相关问题
```

```
# 不好的做法：一次性问太多问题
questions = [
    "您的项目类型是什么？",
    "您使用什么技术栈？",
    "项目规模有多大？",
    "时间期限是什么？",
    "预算限制是什么？",
    "有什么特殊要求？"
]

# 好的做法：分阶段提问
first_question = "您的项目类型是什么？"
# 根据回答再提问相关问题
```

##### 4. 提供默认值#

```
python复制# 提供默认值，提高效率
question = "您希望使用哪种开发环境？"
options = ["Local", "Docker", "Cloud"]
default = "Local"
```

```
# 提供默认值，提高效率
question = "您希望使用哪种开发环境？"
options = ["Local", "Docker", "Cloud"]
default = "Local"
```

##### 5. 基于规范的开发最佳实践#

- 从简单开始：使用最小化的提示启动Interview Mode
- 深入细节：在访谈中逐步深入功能细节
- 验证理解：让AI重复关键需求，确保理解正确
- 文档化规范：将访谈结果整理成正式的规范文档
- 分阶段执行：先构建规范，再执行实现

#### Interview Mode的优势#

##### 1. 提高任务成功率#

##### 2. 增强灵活性#

- 处理开放式任务：能够处理需求不明确的复杂任务
- 适应变化：可以根据用户的实时反馈调整执行路径
- 个性化定制：生成符合用户特定需求的解决方案

##### 3. 提升用户体验#

- 透明化流程：用户清楚了解AI的执行思路和决策过程
- 控制权：用户在关键节点保持决策控制权
- 参与感：用户能够参与到任务执行过程中

#### 实际案例：使用Interview Mode构建待办事项应用#

##### 步骤1：启动Interview Mode构建规范#

```
bash复制$ claude "帮我构建一个待办事项应用的详细规范" --interview
```

```
$ claude "帮我构建一个待办事项应用的详细规范" --interview
```

##### 步骤2：回答AI的问题#

```
bash复制1. 应用类型：Web应用
2. 核心功能：
   - 用户认证
   - 任务管理
   - 任务分类
   - 提醒功能
3. 技术栈：React + Node.js + MongoDB
4. 设计风格：现代简约风格
```

```
1. 应用类型：Web应用
2. 核心功能：
   - 用户认证
   - 任务管理
   - 任务分类
   - 提醒功能
3. 技术栈：React + Node.js + MongoDB
4. 设计风格：现代简约风格
```

##### 步骤3：获取生成的规范#

Claude会根据回答生成详细的规范文档：

```
markdown复制# 待办事项应用规范

## 1. 项目概述
基于React的Web待办事项应用，提供完整的任务管理功能

## 2. 核心功能
### 2.1 用户认证
- 注册/登录
- 密码重置
- JWT认证

### 2.2 任务管理
- 创建任务（标题、描述、截止日期、优先级）
- 编辑任务
- 删除任务
- 标记完成/未完成

### 2.3 任务分类
- 创建/编辑/删除分类
- 任务分配到分类
- 按分类筛选任务

### 2.4 提醒功能
- 截止日期前24小时提醒
- 支持邮件提醒

## 3. 技术栈
- 前端：React 18 + TypeScript + Tailwind CSS
- 后端：Node.js + Express + TypeScript
- 数据库：MongoDB + Mongoose
- 认证：JWT + bcrypt
- 状态管理：React Context API
- 构建工具：Vite

## 4. 项目结构
```
├── client/           # 前端代码
│   ├── src/
│   │   ├── components/  # React组件
│   │   ├── contexts/    # Context API
│   │   ├── hooks/       # 自定义Hooks
│   │   ├── pages/       # 页面组件
│   │   ├── services/    # API服务
│   │   ├── types/       # TypeScript类型
│   │   └── utils/       # 工具函数
│   └── package.json
├── server/           # 后端代码
│   ├── src/
│   │   ├── controllers/ # 控制器
│   │   ├── middleware/  # 中间件
│   │   ├── models/      # 数据模型
│   │   ├── routes/      # 路由
│   │   ├── services/    # 业务逻辑
│   │   └── utils/       # 工具函数
│   └── package.json
└── README.md
```
```

```
# 待办事项应用规范

## 1. 项目概述
基于React的Web待办事项应用，提供完整的任务管理功能

## 2. 核心功能
### 2.1 用户认证
- 注册/登录
- 密码重置
- JWT认证

### 2.2 任务管理
- 创建任务（标题、描述、截止日期、优先级）
- 编辑任务
- 删除任务
- 标记完成/未完成

### 2.3 任务分类
- 创建/编辑/删除分类
- 任务分配到分类
- 按分类筛选任务

### 2.4 提醒功能
- 截止日期前24小时提醒
- 支持邮件提醒

## 3. 技术栈
- 前端：React 18 + TypeScript + Tailwind CSS
- 后端：Node.js + Express + TypeScript
- 数据库：MongoDB + Mongoose
- 认证：JWT + bcrypt
- 状态管理：React Context API
- 构建工具：Vite

## 4. 项目结构
```
├── client/           # 前端代码
│   ├── src/
│   │   ├── components/  # React组件
│   │   ├── contexts/    # Context API
│   │   ├── hooks/       # 自定义Hooks
│   │   ├── pages/       # 页面组件
│   │   ├── services/    # API服务
│   │   ├── types/       # TypeScript类型
│   │   └── utils/       # 工具函数
│   └── package.json
├── server/           # 后端代码
│   ├── src/
│   │   ├── controllers/ # 控制器
│   │   ├── middleware/  # 中间件
│   │   ├── models/      # 数据模型
│   │   ├── routes/      # 路由
│   │   ├── services/    # 业务逻辑
│   │   └── utils/       # 工具函数
│   └── package.json
└── README.md
```
```

##### 步骤4：使用规范实现应用#

```
bash复制$ claude "根据待办事项应用规范实现完整功能"
```

```
$ claude "根据待办事项应用规范实现完整功能"
```

Claude会按照规范创建完整的项目结构和代码实现。

#### 总结#

Interview Mode是Claude Code的一项强大功能，它通过AskUserQuestion工具实现了AI与用户之间的交互式对话。Thariq推荐的基于规范的开发方法进一步释放了Interview Mode的潜力，通过"访谈-规范-执行"的流程，大幅提高了复杂功能的开发效率和质量。

```
AskUserQuestion
```

Interview Mode的核心价值在于：

True. 需求澄清：确保AI准确理解用户需求
True. 决策确认：让用户在关键节点保持控制权
True. 灵活适应：根据用户反馈调整执行路径
True. 规范构建：从模糊需求到详细规范的转化
True. 透明流程：让用户清楚了解AI的执行过程

通过合理使用Interview Mode，开发者可以充分发挥Claude Code的能力，处理更加复杂和多样化的任务，同时确保结果符合自己的预期。Interview Mode与Plan Mode、子Agent等功能相结合，构成了Claude Code强大的Agentic编程能力体系。

---

## 6 自动编程与Stop Hook

**URL**: https://claudecode.tangshuang.net/course/26.6%20%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E4%B8%8EStop%20Hook

#### 自动编程概述#

在2026年，Claude Code的自动编程功能已经成为构建自主、自我修复开发工作流的标准。通过Stop hook（停止钩子）等高级功能，开发者可以实现"Auto Code Forever"（永远自动编码）的工作模式，让Claude Code能够在无人干预的情况下持续运行数小时甚至数天，自主完成从代码生成到测试修复的全流程。

#### Stop Hook核心概念#

##### 1. 什么是Stop Hook#

Stop Hook是Claude Code在每个工作周期结束时自动执行的操作，可以是shell命令或基于LLM的提示。与普通提示不同，Hook是由环境强制执行的保证动作，提供了确定性的控制机制。

###### Stop Hook的类型

- 命令类型Hook：执行shell命令，用于检查错误、运行测试或执行其他自动化任务
- 提示类型Hook：使用"type: prompt"配置，允许LLM评估工作是否真正完成或是否需要触发后续操作

##### 2. Stop Hook的工作原理#

```
bash复制┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Claude完成任务  │────▶│ Stop Hook触发   │────▶│ 执行检查/评估   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 继续执行任务    │◀────│ 反馈结果给Claude │◀────│ 生成反馈/指令   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Claude完成任务  │────▶│ Stop Hook触发   │────▶│ 执行检查/评估   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                               ▲                      │
                               │                      ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 继续执行任务    │◀────│ 反馈结果给Claude │◀────│ 生成反馈/指令   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

#### 实现"Auto Code Forever"的模式#

##### 1. 链式反应循环#

配置Stop Hook运行脚本检查错误（ linting、测试等）。如果发现错误，脚本会以特定状态退出，迫使Claude重新评估并继续修复代码。

```
bash复制# 示例：使用Biome进行代码检查的Stop Hook脚本
#!/bin/bash

# 运行代码检查
npx biome check src

# 如果发现错误，以状态码1退出，提示Claude继续修复
if [ $? -ne 0 ]; then
    echo "发现代码错误，请Claude继续修复"
    exit 1
fi

echo "代码检查通过，任务完成"
exit 0
```

```
# 示例：使用Biome进行代码检查的Stop Hook脚本
#!/bin/bash

# 运行代码检查
npx biome check src

# 如果发现错误，以状态码1退出，提示Claude继续修复
if [ $? -ne 0 ]; then
    echo "发现代码错误，请Claude继续修复"
    exit 1
fi

echo "代码检查通过，任务完成"
exit 0
```

##### 2. 自主Agent框架#

用户在远程VPS服务器（如AWS EC2或Hetzner）上部署Claude Code，并使用--dangerously-skip-permissions标志绕过手动批准提示，使其能够24/7无人工干预运行。

```
--dangerously-skip-permissions
```

```
bash复制# 示例：在远程服务器上启动Claude Code的命令
claude --dangerously-skip-permissions --project-path /home/user/my-project
```

```
# 示例：在远程服务器上启动Claude Code的命令
claude --dangerously-skip-permissions --project-path /home/user/my-project
```

##### 3. Todo驱动开发#

通过维护PROJECT.md或todo.md文件，使用Hook在当前任务结束后立即向Claude提供列表中的下一个任务。

```
markdown复制# todo.md示例

## 待办任务
1. ✅ 实现用户认证功能
2. ⏳ 开发数据模型
3. ⏳ 集成API接口
4. ⏳ 编写测试用例
```

```
# todo.md示例

## 待办任务
1. ✅ 实现用户认证功能
2. ⏳ 开发数据模型
3. ⏳ 集成API接口
4. ⏳ 编写测试用例
```

```
bash复制# 示例：读取下一个任务的Hook脚本
#!/bin/bash

# 查找下一个未完成的任务
next_task=$(grep -n "⏳" todo.md | head -1)

# 如果找到任务，以状态码1退出并提供下一个任务
if [ ! -z "$next_task" ]; then
    echo "当前任务完成，下一个任务：$next_task"
    exit 1
fi

echo "所有任务已完成"
exit 0
```

```
# 示例：读取下一个任务的Hook脚本
#!/bin/bash

# 查找下一个未完成的任务
next_task=$(grep -n "⏳" todo.md | head -1)

# 如果找到任务，以状态码1退出并提供下一个任务
if [ ! -z "$next_task" ]; then
    echo "当前任务完成，下一个任务：$next_task"
    exit 1
fi

echo "所有任务已完成"
exit 0
```

#### 设置与命令#

##### 1. 配置Hook#

在终端中输入/hooks打开交互式配置菜单，或直接编辑配置文件：

```
/hooks
```

```
json复制// claude/settings.json
{
  "hooks": {
    "Stop": {
      "type": "command",
      "command": "./scripts/check-code.sh",
      "match": ".*"
    },
    "PostToolUse": {
      "type": "command",
      "command": "./scripts/format-code.sh",
      "match": ".*\.(js|ts|tsx)$"
    }
  }
}
```

```
// claude/settings.json
{
  "hooks": {
    "Stop": {
      "type": "command",
      "command": "./scripts/check-code.sh",
      "match": ".*"
    },
    "PostToolUse": {
      "type": "command",
      "command": "./scripts/format-code.sh",
      "match": ".*\.(js|ts|tsx)$"
    }
  }
}
```

##### 2. 自动继续命令#

使用以下命令允许Agent在不请求权限的情况下执行shell命令和文件编辑：

```
bash复制claude --dangerously-skip-permissions
```

```
claude --dangerously-skip-permissions
```

##### 3. 中断操作#

- 按Escape键停止当前工作周期
- 按Ctrl+C完全退出会话

#### 流行的自动化工具#

##### 1. claude-mem#

一个插件，用于在无限会话中保留项目上下文，防止AI在长时间运行的任务中"变笨"或失去目标跟踪。

##### 2. CC AutoRenew#

防止会话过期间隙的工具，确保Agent在计划的编码块期间保持活跃。

#### 注意事项与最佳实践#

##### 1. 避免无限循环#

- 谨慎使用调用claude的Hook
- 使用条件或最大迭代次数防止失控成本
- 示例：在脚本中添加计数器

```
bash复制#!/bin/bash

# 检查是否达到最大迭代次数
if [ -f .iteration_count ]; then
    count=$(cat .iteration_count)
    if [ $count -ge 10 ]; then
        echo "已达到最大迭代次数10，停止自动修复"
        exit 0
    fi
    count=$((count+1))
else
    count=1
fi

echo $count > .iteration_count

# 继续执行检查...
```

```
#!/bin/bash

# 检查是否达到最大迭代次数
if [ -f .iteration_count ]; then
    count=$(cat .iteration_count)
    if [ $count -ge 10 ]; then
        echo "已达到最大迭代次数10，停止自动修复"
        exit 0
    fi
    count=$((count+1))
else
    count=1
fi

echo $count > .iteration_count

# 继续执行检查...
```

##### 2. 错误处理#

- 使用非零退出码向Claude发出问题信号
- 状态码2会阻止继续执行

##### 3. 安全考虑#

- --dangerously-skip-permissions标志会绕过所有权限检查，请谨慎使用
- 在生产环境中建议保留手动批准机制
- 定期监控长时间运行的任务

```
--dangerously-skip-permissions
```

#### 自动编程的应用场景#

##### 1. 自主代码修复#

设置Stop Hook自动运行测试和lint检查，当发现错误时自动让Claude修复，直到所有测试通过。

##### 2. 持续集成工作流#

将Claude Code集成到CI/CD管道中，实现从代码提交到部署的全自动化流程。

##### 3. 夜间批量处理#

在非工作时间运行Claude Code处理大量重复任务，如代码重构、文档生成等。

#### 总结#

Claude Code的自动编程功能，特别是Stop Hook机制，为开发者提供了前所未有的自动化能力。通过合理配置和使用这些工具，开发者可以实现"Auto Code Forever"的工作模式，大幅提高开发效率和代码质量。

自动编程与Interview Mode、Plan Mode、子Agent等功能相结合，构成了Claude Code强大的Agentic编程能力体系，使开发者能够处理更加复杂和多样化的任务，同时确保结果符合预期。

---

# 第 28 章

## 1 整体架构

**URL**: https://claudecode.tangshuang.net/course/28.1%20%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84

#### Claude Code 整体架构概述#

Claude Code 是一个基于大语言模型的编程助手，它通过复杂的架构设计实现了代码理解、生成、调试和优化等多种功能。理解其整体架构对于深入掌握其工作原理至关重要。

#### 系统架构层次#

##### 1. 架构分层#

┌─────────────────────────────────────────────────────────┐
│                     用户界面层                            │
│  (CLI、Web UI、IDE插件)                                  │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                     交互层                               │
│  (命令解析、上下文管理、会话状态)                         │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                     核心层                               │
│  (意图识别、任务规划、工具调度)                           │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                     能力层                               │
│  (代码生成、代码理解、代码调试、代码优化)                 │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                     工具层                               │
│  (文件操作、代码执行、搜索、版本控制)                     │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                     基础层                               │
│  (LLM、向量数据库、文件系统、进程管理)                   │
└─────────────────────────────────────────────────────────┘

##### 2. 各层职责#

#### 核心组件#

##### 1. 用户界面组件#

```
python复制python

# 示例：用户界面组件

用户请求：
"展示Claude Code的用户界面组件架构"

Claude Code 生成的代码：

```python
```

```
python

# 示例：用户界面组件

用户请求：
"展示Claude Code的用户界面组件架构"

Claude Code 生成的代码：

```python
```

from typing import Dict, List, Any, Optional
from abc import ABC, abstractmethod
import logging

logger = logging.getLogger(name)

class UserInterface(ABC):
"""用户界面抽象基类"""

```
bash复制@abstractmethod
def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    pass

@abstractmethod
def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    pass

@abstractmethod
def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    pass

@abstractmethod
def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    pass
```

```
@abstractmethod
def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    pass

@abstractmethod
def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    pass

@abstractmethod
def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    pass

@abstractmethod
def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    pass
```

class CLIInterface(UserInterface):
"""命令行界面"""

```
bash复制def __init__(self):
    self.colors = {
        'info': '\033[94m',
        'success': '\033[92m',
```

```
def __init__(self):
    self.colors = {
        'info': '\033[94m',
        'success': '\033[92m',
```

```
bash复制        'warning': '\033[93m',
        'error': '\033[91m',
        'reset': '\033[0m'
    }

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    color = self.colors.get(message_type, self.colors['info'])
    print(f"{color}{message}{self.colors['reset']}")

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    return input(prompt)

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    print(f"\n```{language}")
    print(code)
    print("```\n")

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    bar_length = 50
    filled_length = int(bar_length * progress)
    bar = '█' * filled_length + '-' * (bar_length - filled_length)
    print(f"\r[{bar}] {progress:.1%} {message}", end='', flush=True)
```

```
'warning': '\033[93m',
        'error': '\033[91m',
        'reset': '\033[0m'
    }

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    color = self.colors.get(message_type, self.colors['info'])
    print(f"{color}{message}{self.colors['reset']}")

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    return input(prompt)

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    print(f"\n```{language}")
    print(code)
    print("```\n")

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    bar_length = 50
    filled_length = int(bar_length * progress)
    bar = '█' * filled_length + '-' * (bar_length - filled_length)
    print(f"\r[{bar}] {progress:.1%} {message}", end='', flush=True)
```

class WebInterface(UserInterface):
"""Web界面"""

```
bash复制def __init__(self):
    self.messages: List[Dict[str, Any]] = []

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    self.messages.append({
        'type': message_type,
        'content': message,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    # 在Web界面中，这通常通过异步事件处理
    return ""

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    self.messages.append({
        'type': 'code',
        'content': code,
        'language': language,
        'timestamp': datetime.utcnow().isoformat()
    })

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    self.messages.append({
        'type': 'progress',
        'progress': progress,
        'message': message,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_messages(self) -> List[Dict[str, Any]]:
    """获取所有消息"""
    return self.messages
```

```
def __init__(self):
    self.messages: List[Dict[str, Any]] = []

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    self.messages.append({
        'type': message_type,
        'content': message,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    # 在Web界面中，这通常通过异步事件处理
    return ""

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    self.messages.append({
        'type': 'code',
        'content': code,
        'language': language,
        'timestamp': datetime.utcnow().isoformat()
    })

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    self.messages.append({
        'type': 'progress',
        'progress': progress,
        'message': message,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_messages(self) -> List[Dict[str, Any]]:
    """获取所有消息"""
    return self.messages
```

class IDEPluginInterface(UserInterface):
"""IDE插件界面"""

```
bash复制def __init__(self, ide_name: str):
    self.ide_name = ide_name
    self.notifications: List[Dict[str, Any]] = []

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    self.notifications.append({
        'type': message_type,
        'content': message,
        'ide': self.ide_name,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    # 在IDE插件中，这通常通过输入框
    return ""

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    # 在IDE中，这通常在编辑器中显示
    pass

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    # 在IDE中，这通常在状态栏显示
    pass

def show_inline_suggestion(self, line: int, suggestion: str):
    """显示内联建议"""
    self.notifications.append({
        'type': 'inline_suggestion',
        'line': line,
        'suggestion': suggestion,
        'ide': self.ide_name,
        'timestamp': datetime.utcnow().isoformat()
    })
```

```
def __init__(self, ide_name: str):
    self.ide_name = ide_name
    self.notifications: List[Dict[str, Any]] = []

def display_message(self, message: str, message_type: str = "info"):
    """显示消息"""
    self.notifications.append({
        'type': message_type,
        'content': message,
        'ide': self.ide_name,
        'timestamp': datetime.utcnow().isoformat()
    })

def get_user_input(self, prompt: str) -> str:
    """获取用户输入"""
    # 在IDE插件中，这通常通过输入框
    return ""

def display_code(self, code: str, language: str = "python"):
    """显示代码"""
    # 在IDE中，这通常在编辑器中显示
    pass

def display_progress(self, progress: float, message: str = ""):
    """显示进度"""
    # 在IDE中，这通常在状态栏显示
    pass

def show_inline_suggestion(self, line: int, suggestion: str):
    """显示内联建议"""
    self.notifications.append({
        'type': 'inline_suggestion',
        'line': line,
        'suggestion': suggestion,
        'ide': self.ide_name,
        'timestamp': datetime.utcnow().isoformat()
    })
```

### 使用示例

cli = CLIInterface()
cli.display_message("Hello, Claude Code!", "success")
cli.display_code("print('Hello, World!')", "python")

用户界面组件特点:

- 支持多种界面类型
- 统一的消息显示接口
- 代码高亮显示
- 进度反馈

##### 2. 交互层组件#

```
python复制python

# 示例：交互层组件

用户请求：
"展示Claude Code的交互层组件"

Claude Code 生成的代码：

```python
```

```
python

# 示例：交互层组件

用户请求：
"展示Claude Code的交互层组件"

Claude Code 生成的代码：

```python
```

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(name)

class Session:
"""会话"""

```
bash复制def __init__(self, session_id: str):
    self.id = session_id
    self.messages: List[Dict[str, Any]] = []
    self.context: Dict[str, Any] = {}
    self.state = "active"
    self.created_at = datetime.utcnow()
    self.last_activity = datetime.utcnow()

def add_message(self, role: str, content: str, metadata: Optional[Dict[str, Any]] = None):
    """添加消息"""
    self.messages.append({
        'role': role,
        'content': content,
        'metadata': metadata or {},
        'timestamp': datetime.utcnow()
    })
    self.last_activity = datetime.utcnow()

def update_context(self, key: str, value: Any):
    """更新上下文"""
    self.context[key] = value
    self.last_activity = datetime.utcnow()

def get_context(self, key: str) -> Optional[Any]:
    """获取上下文"""
    return self.context.get(key)

def get_recent_messages(self, limit: int = 10) -> List[Dict[str, Any]]:
    """获取最近消息"""
    return self.messages[-limit:]
```

```
def __init__(self, session_id: str):
    self.id = session_id
    self.messages: List[Dict[str, Any]] = []
    self.context: Dict[str, Any] = {}
    self.state = "active"
    self.created_at = datetime.utcnow()
    self.last_activity = datetime.utcnow()

def add_message(self, role: str, content: str, metadata: Optional[Dict[str, Any]] = None):
    """添加消息"""
    self.messages.append({
        'role': role,
        'content': content,
        'metadata': metadata or {},
        'timestamp': datetime.utcnow()
    })
    self.last_activity = datetime.utcnow()

def update_context(self, key: str, value: Any):
    """更新上下文"""
    self.context[key] = value
    self.last_activity = datetime.utcnow()

def get_context(self, key: str) -> Optional[Any]:
    """获取上下文"""
    return self.context.get(key)

def get_recent_messages(self, limit: int = 10) -> List[Dict[str, Any]]:
    """获取最近消息"""
    return self.messages[-limit:]
```

class ContextManager:
"""上下文管理器"""

```
bash复制def __init__(self, max_context_size: int = 10000):
    self.max_context_size = max_context_size
    self.context_window: List[Dict[str, Any]] = []
    self.permanent_context: Dict[str, Any] = {}

def add_to_context(self, content: str, metadata: Optional[Dict[str, Any]] = None):
    """添加到上下文窗口"""
    self.context_window.append({
        'content': content,
        'metadata': metadata or {},
        'timestamp': datetime.utcnow()
    })

    # 限制上下文窗口大小
    self._trim_context()

def _trim_context(self):
    """修剪上下文"""
    current_size = sum(len(item['content']) for item in self.context_window)

    while current_size > self.max_context_size and self.context_window:
        removed = self.context_window.pop(0)
        current_size -= len(removed['content'])

def get_context(self) -> str:
    """获取上下文"""
    context_parts = []

    for item in self.context_window:
        context_parts.append(item['content'])

    return '\n'.join(context_parts)

def add_permanent_context(self, key: str, value: Any):
    """添加永久上下文"""
    self.permanent_context[key] = value

def get_permanent_context(self, key: str) -> Optional[Any]:
    """获取永久上下文"""
    return self.permanent_context.get(key)

def clear_context(self):
    """清空上下文"""
    self.context_window.clear()
```

```
def __init__(self, max_context_size: int = 10000):
    self.max_context_size = max_context_size
    self.context_window: List[Dict[str, Any]] = []
    self.permanent_context: Dict[str, Any] = {}

def add_to_context(self, content: str, metadata: Optional[Dict[str, Any]] = None):
    """添加到上下文窗口"""
    self.context_window.append({
        'content': content,
        'metadata': metadata or {},
        'timestamp': datetime.utcnow()
    })

    # 限制上下文窗口大小
    self._trim_context()

def _trim_context(self):
    """修剪上下文"""
    current_size = sum(len(item['content']) for item in self.context_window)

    while current_size > self.max_context_size and self.context_window:
        removed = self.context_window.pop(0)
        current_size -= len(removed['content'])

def get_context(self) -> str:
    """获取上下文"""
    context_parts = []

    for item in self.context_window:
        context_parts.append(item['content'])

    return '\n'.join(context_parts)

def add_permanent_context(self, key: str, value: Any):
    """添加永久上下文"""
    self.permanent_context[key] = value

def get_permanent_context(self, key: str) -> Optional[Any]:
    """获取永久上下文"""
    return self.permanent_context.get(key)

def clear_context(self):
    """清空上下文"""
    self.context_window.clear()
```

class CommandParser:
"""命令解析器"""

```
bash复制def __init__(self):
    self.command_patterns = {
        'read_file': r'^read\s+(.+)$',
        'write_file': r'^write\s+(.+)$',
        'execute_code': r'^execute\s+(.+)$',
        'search': r'^search\s+(.+)$',
        'help': r'^help\s*(.*)$'
    }

def parse_command(self, command: str) -> Dict[str, Any]:
    """解析命令"""
    import re

    for command_name, pattern in self.command_patterns.items():
        match = re.match(pattern, command, re.IGNORECASE)
        if match:
            return {
                'command': command_name,
                'arguments': match.groups(),
                'raw_command': command
            }

    return {
        'command': 'unknown',
        'arguments': [],
        'raw_command': command
    }

def register_command(self, command_name: str, pattern: str):
    """注册命令"""
    self.command_patterns[command_name] = pattern
```

```
def __init__(self):
    self.command_patterns = {
        'read_file': r'^read\s+(.+)$',
        'write_file': r'^write\s+(.+)$',
        'execute_code': r'^execute\s+(.+)$',
        'search': r'^search\s+(.+)$',
        'help': r'^help\s*(.*)$'
    }

def parse_command(self, command: str) -> Dict[str, Any]:
    """解析命令"""
    import re

    for command_name, pattern in self.command_patterns.items():
        match = re.match(pattern, command, re.IGNORECASE)
        if match:
            return {
                'command': command_name,
                'arguments': match.groups(),
                'raw_command': command
            }

    return {
        'command': 'unknown',
        'arguments': [],
        'raw_command': command
    }

def register_command(self, command_name: str, pattern: str):
    """注册命令"""
    self.command_patterns[command_name] = pattern
```

class InteractionLayer:
"""交互层"""

```
bash复制def __init__(self, user_interface: UserInterface):
    self.user_interface = user_interface
    self.session = Session("default")
    self.context_manager = ContextManager()
    self.command_parser = CommandParser()

def handle_user_input(self, user_input: str) -> Dict[str, Any]:
    """处理用户输入"""
    # 添加到会话
    self.session.add_message('user', user_input)

    # 添加到上下文
    self.context_manager.add_to_context(user_input)

    # 解析命令
    parsed = self.command_parser.parse_command(user_input)

    return {
        'parsed_command': parsed,
        'context': self.context_manager.get_context(),
        'session_id': self.session.id
    }

def handle_response(self, response: str, metadata: Optional[Dict[str, Any]] = None):
    """处理响应"""
    # 添加到会话
    self.session.add_message('assistant', response, metadata)

    # 添加到上下文
    self.context_manager.add_to_context(response, metadata)

    # 显示响应
    self.user_interface.display_message(response, "info")

def get_session_state(self) -> Dict[str, Any]:
    """获取会话状态"""
    return {
        'session_id': self.session.id,
        'state': self.session.state,
        'message_count': len(self.session.messages),
        'context_size': len(self.context_manager.get_context()),
        'last_activity': self.session.last_activity.isoformat()
    }
```

```
def __init__(self, user_interface: UserInterface):
    self.user_interface = user_interface
    self.session = Session("default")
    self.context_manager = ContextManager()
    self.command_parser = CommandParser()

def handle_user_input(self, user_input: str) -> Dict[str, Any]:
    """处理用户输入"""
    # 添加到会话
    self.session.add_message('user', user_input)

    # 添加到上下文
    self.context_manager.add_to_context(user_input)

    # 解析命令
    parsed = self.command_parser.parse_command(user_input)

    return {
        'parsed_command': parsed,
        'context': self.context_manager.get_context(),
        'session_id': self.session.id
    }

def handle_response(self, response: str, metadata: Optional[Dict[str, Any]] = None):
    """处理响应"""
    # 添加到会话
    self.session.add_message('assistant', response, metadata)

    # 添加到上下文
    self.context_manager.add_to_context(response, metadata)

    # 显示响应
    self.user_interface.display_message(response, "info")

def get_session_state(self) -> Dict[str, Any]:
    """获取会话状态"""
    return {
        'session_id': self.session.id,
        'state': self.session.state,
        'message_count': len(self.session.messages),
        'context_size': len(self.context_manager.get_context()),
        'last_activity': self.session.last_activity.isoformat()
    }
```

### 使用示例

cli = CLIInterface()
interaction_layer = InteractionLayer(cli)

### 处理用户输入

user_input = "read file.txt"
result = interaction_layer.handle_user_input(user_input)

print(f"Parsed command: {result['parsed_command']}")
print(f"Context size: {len(result['context'])}")

### 处理响应

interaction_layer.handle_response("File content: Hello, World!")

### 获取会话状态

state = interaction_layer.get_session_state()
print(f"Session state: {state}")

交互层组件特点:

- 会话管理
- 上下文管理
- 命令解析
- 状态跟踪

#### 数据流#

##### 1. 请求处理流程#

```
bash复制用户输入
↓
命令解析
↓
上下文构建
↓
意图识别
↓
任务规划
↓
工具调用
↓
结果处理
↓
响应生成
↓
用户反馈
```

```
用户输入
↓
命令解析
↓
上下文构建
↓
意图识别
↓
任务规划
↓
工具调用
↓
结果处理
↓
响应生成
↓
用户反馈
```

##### 2. 数据流示例#

### 示例：数据流

用户请求：
"展示Claude Code的数据流"
Claude Code 生成的代码：

```
python复制`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class DataFlow:
"""数据流"""

def __init__(self):
self.pipeline: List[Dict[str, Any]] = []
self.current_step = 0

def add_step(self, step_name: str, processor: callable):
"""添加处理步骤"""
self.pipeline.append({
'name': step_name,
'processor': processor,
'input': None,
'output': None,
'timestamp': None
})

def process(self, initial_input: Any) -> Any:
"""处理数据流"""
current_data = initial_input

for i, step in enumerate(self.pipeline):
logger.info(f"Processing step: {step['name']}")

 # 记录输入
step['input'] = current_data
step['timestamp'] = datetime.utcnow()

 # 执行处理
try:
current_data = step['processor'](current_data)
step['output'] = current_data
step['status'] = 'success'
except Exception as e:
logger.error(f"Error in step {step['name']}: {e}")
step['status'] = 'error'
step['error'] = str(e)
raise

self.current_step = i + 1

return current_data

def get_pipeline_status(self) -> List[Dict[str, Any]]:
"""获取管道状态"""
return [
{
'name': step['name'],
'status': step.get('status', 'pending'),
'timestamp': step.get('timestamp')
}
for step in self.pipeline
]

# 示例处理步骤
def parse_command(input_data: Dict[str, str]) -> Dict[str, Any]:
"""解析命令"""
command = input_data['command']
 # 解析逻辑
return {
'command': command,
'parsed': True,
'type': 'read_file'
}

def build_context(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""构建上下文"""
 # 构建上下文逻辑
return {
 **input_data,
'context': "Built context"
}

def identify_intent(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""识别意图"""
 # 意图识别逻辑
return {
 **input_data,
'intent': 'read_file',
'confidence': 0.95
}

def plan_task(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""规划任务"""
 # 任务规划逻辑
return {
 **input_data,
'task_plan': ['read_file', 'parse_content', 'display_result']
}

def invoke_tool(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""调用工具"""
 # 工具调用逻辑
return {
 **input_data,
'tool_result': "File content read successfully"
}

def process_result(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""处理结果"""
 # 结果处理逻辑
return {
 **input_data,
'processed_result': "Processed: File content read successfully"
}

def generate_response(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""生成响应"""
 # 响应生成逻辑
return {
 **input_data,
'response': "I've read the file. Here's the content: File content read successfully"
}

# 使用示例
data_flow = DataFlow()

# 添加处理步骤
data_flow.add_step('parse_command', parse_command)
data_flow.add_step('build_context', build_context)
data_flow.add_step('identify_intent', identify_intent)
data_flow.add_step('plan_task', plan_task)
data_flow.add_step('invoke_tool', invoke_tool)
data_flow.add_step('process_result', process_result)
data_flow.add_step('generate_response', generate_response)

# 处理数据流
initial_input = {'command': 'read file.txt'}
result = data_flow.process(initial_input)

print(f"Final result: {result['response']}")

# 获取管道状态
status = data_flow.get_pipeline_status()
print(f"Pipeline status: {status}")

```> **数据流特点**:
> - 流水线处理
> - 步骤化执行
> - 状态跟踪
> - 错误处理
```
## 总结

整体架构包括：

1. **架构分层**: 用户界面层、交互层、核心层、能力层、工具层、基础层
2. **核心组件**: 用户界面组件、交互层组件
3. **数据流**: 请求处理流程、数据流示例

通过理解Claude Code的整体架构，可以更好地理解其工作原理和设计思想。

在下一节中，我们将探讨核心模块解析。

```
```

```
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class DataFlow:
"""数据流"""

def __init__(self):
self.pipeline: List[Dict[str, Any]] = []
self.current_step = 0

def add_step(self, step_name: str, processor: callable):
"""添加处理步骤"""
self.pipeline.append({
'name': step_name,
'processor': processor,
'input': None,
'output': None,
'timestamp': None
})

def process(self, initial_input: Any) -> Any:
"""处理数据流"""
current_data = initial_input

for i, step in enumerate(self.pipeline):
logger.info(f"Processing step: {step['name']}")

 # 记录输入
step['input'] = current_data
step['timestamp'] = datetime.utcnow()

 # 执行处理
try:
current_data = step['processor'](current_data)
step['output'] = current_data
step['status'] = 'success'
except Exception as e:
logger.error(f"Error in step {step['name']}: {e}")
step['status'] = 'error'
step['error'] = str(e)
raise

self.current_step = i + 1

return current_data

def get_pipeline_status(self) -> List[Dict[str, Any]]:
"""获取管道状态"""
return [
{
'name': step['name'],
'status': step.get('status', 'pending'),
'timestamp': step.get('timestamp')
}
for step in self.pipeline
]

# 示例处理步骤
def parse_command(input_data: Dict[str, str]) -> Dict[str, Any]:
"""解析命令"""
command = input_data['command']
 # 解析逻辑
return {
'command': command,
'parsed': True,
'type': 'read_file'
}

def build_context(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""构建上下文"""
 # 构建上下文逻辑
return {
 **input_data,
'context': "Built context"
}

def identify_intent(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""识别意图"""
 # 意图识别逻辑
return {
 **input_data,
'intent': 'read_file',
'confidence': 0.95
}

def plan_task(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""规划任务"""
 # 任务规划逻辑
return {
 **input_data,
'task_plan': ['read_file', 'parse_content', 'display_result']
}

def invoke_tool(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""调用工具"""
 # 工具调用逻辑
return {
 **input_data,
'tool_result': "File content read successfully"
}

def process_result(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""处理结果"""
 # 结果处理逻辑
return {
 **input_data,
'processed_result': "Processed: File content read successfully"
}

def generate_response(input_data: Dict[str, Any]) -> Dict[str, Any]:
"""生成响应"""
 # 响应生成逻辑
return {
 **input_data,
'response': "I've read the file. Here's the content: File content read successfully"
}

# 使用示例
data_flow = DataFlow()

# 添加处理步骤
data_flow.add_step('parse_command', parse_command)
data_flow.add_step('build_context', build_context)
data_flow.add_step('identify_intent', identify_intent)
data_flow.add_step('plan_task', plan_task)
data_flow.add_step('invoke_tool', invoke_tool)
data_flow.add_step('process_result', process_result)
data_flow.add_step('generate_response', generate_response)

# 处理数据流
initial_input = {'command': 'read file.txt'}
result = data_flow.process(initial_input)

print(f"Final result: {result['response']}")

# 获取管道状态
status = data_flow.get_pipeline_status()
print(f"Pipeline status: {status}")

```> **数据流特点**:
> - 流水线处理
> - 步骤化执行
> - 状态跟踪
> - 错误处理
```
## 总结

整体架构包括：

1. **架构分层**: 用户界面层、交互层、核心层、能力层、工具层、基础层
2. **核心组件**: 用户界面组件、交互层组件
3. **数据流**: 请求处理流程、数据流示例

通过理解Claude Code的整体架构，可以更好地理解其工作原理和设计思想。

在下一节中，我们将探讨核心模块解析。

```
```

---

## 2 核心组件详解

**URL**: https://claudecode.tangshuang.net/course/28.2%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3

#### 核心组件概述#

Claude Code 的核心组件是其功能实现的基础，包括意图识别、任务规划、工具调度等关键模块。深入理解这些组件对于掌握Claude Code的工作原理至关重要。

#### 意图识别器#

##### 1. 意图识别原理#

### 示例：意图识别器

用户请求：
"实现一个意图识别器"

Claude Code 生成的代码：

```
python复制````python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import re

logger = logging.getLogger(__name__)

class Intent:
"""意图"""

def __init__(self, name: str, description: str, confidence: float = 0.0):
self.name = name
self.description = description
self.confidence = confidence
self.entities: Dict[str, Any] = {}
self.metadata: Dict[str, Any] = {}

class IntentRecognizer:
"""意图识别器"""

def __init__(self):
self.intents: Dict[str, Dict[str, Any]] = {}
self.patterns: Dict[str, List[str]] = {}
self.models: Dict[str, Any] = {}

def register_intent(self, name: str, description: str, patterns: List[str] = None):
"""注册意图"""
self.intents[name] = {
'name': name,
'description': description,
'patterns': patterns or []
}

if patterns:
self.patterns[name] = patterns

logger.info(f"Intent registered: {name}")

def recognize(self, text: str) -> Intent:
"""识别意图"""
scores = {}

 # 基于模式匹配
for intent_name, patterns in self.patterns.items():
score = self._match_patterns(text, patterns)
scores[intent_name] = score

 # 基于关键词匹配
for intent_name, intent_info in self.intents.items():
score = self._match_keywords(text, intent_info)
scores[intent_name] = max(scores.get(intent_name, 0), score)

 # 基于模型预测
if self.models:
model_scores = self._predict_with_model(text)
for intent_name, score in model_scores.items():
scores[intent_name] = max(scores.get(intent_name, 0), score)

 # 选择最高分的意图
if not scores:
return Intent("unknown", "Unknown intent", 0.0)

best_intent_name = max(scores, key=scores.get)
confidence = scores[best_intent_name]

 # 提取实体
entities = self._extract_entities(text, best_intent_name)

intent = Intent(
name=best_intent_name,
description=self.intents[best_intent_name]['description'],
confidence=confidence
)
intent.entities = entities

return intent

def _match_patterns(self, text: str, patterns: List[str]) -> float:
"""匹配模式"""
max_score = 0.0

for pattern in patterns:
try:
if re.search(pattern, text, re.IGNORECASE):
max_score = max(max_score, 0.9)
except re.error:
continue

return max_score

def _match_keywords(self, text: str, intent_info: Dict[str, Any]) -> float:
"""匹配关键词"""
keywords = intent_info.get('keywords', [])
if not keywords:
return 0.0

text_lower = text.lower()
matched = sum(1 for keyword in keywords if keyword.lower() in text_lower)

return matched / len(keywords) if keywords else 0.0

def _predict_with_model(self, text: str) -> Dict[str, float]:
"""使用模型预测"""
 # 这里可以使用机器学习模型进行预测
 # 简化版本：返回空字典
return {}

def _extract_entities(self, text: str, intent_name: str) -> Dict[str, Any]:
"""提取实体"""
entities = {}

 # 根据意图类型提取实体
if intent_name == 'read_file':
file_match = re.search(r'file\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
if file_match:
entities['file_path'] = file_match.group(1)

elif intent_name == 'write_file':
file_match = re.search(r'file\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
content_match = re.search(r'content\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)

if file_match:
entities['file_path'] = file_match.group(1)
if content_match:
entities['content'] = content_match.group(1)

elif intent_name == 'execute_code':
code_match = re.search(r'code\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
language_match = re.search(r'language\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
```

```
````python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import re

logger = logging.getLogger(__name__)

class Intent:
"""意图"""

def __init__(self, name: str, description: str, confidence: float = 0.0):
self.name = name
self.description = description
self.confidence = confidence
self.entities: Dict[str, Any] = {}
self.metadata: Dict[str, Any] = {}

class IntentRecognizer:
"""意图识别器"""

def __init__(self):
self.intents: Dict[str, Dict[str, Any]] = {}
self.patterns: Dict[str, List[str]] = {}
self.models: Dict[str, Any] = {}

def register_intent(self, name: str, description: str, patterns: List[str] = None):
"""注册意图"""
self.intents[name] = {
'name': name,
'description': description,
'patterns': patterns or []
}

if patterns:
self.patterns[name] = patterns

logger.info(f"Intent registered: {name}")

def recognize(self, text: str) -> Intent:
"""识别意图"""
scores = {}

 # 基于模式匹配
for intent_name, patterns in self.patterns.items():
score = self._match_patterns(text, patterns)
scores[intent_name] = score

 # 基于关键词匹配
for intent_name, intent_info in self.intents.items():
score = self._match_keywords(text, intent_info)
scores[intent_name] = max(scores.get(intent_name, 0), score)

 # 基于模型预测
if self.models:
model_scores = self._predict_with_model(text)
for intent_name, score in model_scores.items():
scores[intent_name] = max(scores.get(intent_name, 0), score)

 # 选择最高分的意图
if not scores:
return Intent("unknown", "Unknown intent", 0.0)

best_intent_name = max(scores, key=scores.get)
confidence = scores[best_intent_name]

 # 提取实体
entities = self._extract_entities(text, best_intent_name)

intent = Intent(
name=best_intent_name,
description=self.intents[best_intent_name]['description'],
confidence=confidence
)
intent.entities = entities

return intent

def _match_patterns(self, text: str, patterns: List[str]) -> float:
"""匹配模式"""
max_score = 0.0

for pattern in patterns:
try:
if re.search(pattern, text, re.IGNORECASE):
max_score = max(max_score, 0.9)
except re.error:
continue

return max_score

def _match_keywords(self, text: str, intent_info: Dict[str, Any]) -> float:
"""匹配关键词"""
keywords = intent_info.get('keywords', [])
if not keywords:
return 0.0

text_lower = text.lower()
matched = sum(1 for keyword in keywords if keyword.lower() in text_lower)

return matched / len(keywords) if keywords else 0.0

def _predict_with_model(self, text: str) -> Dict[str, float]:
"""使用模型预测"""
 # 这里可以使用机器学习模型进行预测
 # 简化版本：返回空字典
return {}

def _extract_entities(self, text: str, intent_name: str) -> Dict[str, Any]:
"""提取实体"""
entities = {}

 # 根据意图类型提取实体
if intent_name == 'read_file':
file_match = re.search(r'file\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
if file_match:
entities['file_path'] = file_match.group(1)

elif intent_name == 'write_file':
file_match = re.search(r'file\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
content_match = re.search(r'content\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)

if file_match:
entities['file_path'] = file_match.group(1)
if content_match:
entities['content'] = content_match.group(1)

elif intent_name == 'execute_code':
code_match = re.search(r'code\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
language_match = re.search(r'language\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE)
```

if code_match:
entities['code'] = code_match.group(1)
if language_match:
entities['language'] = language_match.group(1)

return entities

### 使用示例

recognizer = IntentRecognizer()

### 注册意图

recognizer.register_intent(
name='read_file',
description='Read a file',
patterns=[r'read\s+file', r'open\s+file', r'cat\s+file'],
keywords=['read', 'file', 'open', 'cat']
)

recognizer.register_intent(
name='write_file',
description='Write to a file',
patterns=[r'write\s+file', r'save\s+file', r'create\s+file'],
keywords=['write', 'file', 'save', 'create']
)

recognizer.register_intent(
name='execute_code',
description='Execute code',
patterns=[r'execute\s+code', r'run\s+code', r'eval\s+code'],
keywords=['execute', 'code', 'run', 'eval']
)

### 识别意图

text = "Please read the file config.txt"
intent = recognizer.recognize(text)

print(f"Intent: {intent.name}")
print(f"Confidence: {intent.confidence}")
print(f"Entities: {intent.entities}")

```
bash复制> - 支持多种识别方法
> - 模式匹配
> - 关键词匹配
> - 实体提取
```

```
> - 支持多种识别方法
> - 模式匹配
> - 关键词匹配
> - 实体提取
```

#### 任务规划器#

##### 1. 任务规划原理#

### 示例：任务规划器

用户请求：
"实现一个任务规划器"
Claude Code 生成的代码：

```
python复制`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class Task:
"""任务"""

def __init__(self, task_id: str, name: str, description: str, action: str):
self.id = task_id
self.name = name
self.description = description
self.action = action
self.status = "pending"
self.dependencies: List[str] = []
self.created_at = datetime.utcnow()
self.started_at: Optional[datetime] = None
self.completed_at: Optional[datetime] = None
self.result: Optional[Any] = None
self.error: Optional[str] = None

class TaskPlanner:
"""任务规划器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.task_graph: Dict[str, List[str]] = {}
self.execution_plan: List[str] = []

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
self.task_graph[task.id] = task.dependencies
logger.info(f"Task added: {task.id}")

def create_plan(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""创建执行计划"""
 # 根据目标和上下文生成任务
tasks = self._generate_tasks(goal, context)

 # 添加任务
for task in tasks:
self.add_task(task)

 # 生成执行顺序
self.execution_plan = self._topological_sort()

 # 返回按顺序排列的任务
return [self.tasks[task_id] for task_id in self.execution_plan]

def _generate_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成任务"""
tasks = []

 # 根据目标类型生成任务
if 'read' in goal.lower() and 'file' in goal.lower():
tasks = self._generate_file_reading_tasks(goal, context)
elif 'write' in goal.lower() and 'file' in goal.lower():
tasks = self._generate_file_writing_tasks(goal, context)
elif 'execute' in goal.lower() and 'code' in goal.lower():
tasks = self._generate_code_execution_tasks(goal, context)
else:
tasks = self._generate_default_tasks(goal, context)

return tasks

def _generate_file_reading_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成文件读取任务"""
file_path = context.get('file_path', 'default.txt')

tasks = [
Task(
task_id="validate_file_path",
name="Validate File Path",
description=f"Validate file path: {file_path}",
action="validate_file_path"
),
Task(
task_id="read_file",
name="Read File",
description=f"Read file: {file_path}",
action="read_file",
dependencies=["validate_file_path"]
),
Task(
task_id="parse_content",
name="Parse Content",
description="Parse file content",
action="parse_content",
dependencies=["read_file"]
)
]

return tasks

def _generate_file_writing_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成文件写入任务"""
file_path = context.get('file_path', 'output.txt')
content = context.get('content', '')

tasks = [
Task(
task_id="validate_file_path",
name="Validate File Path",
description=f"Validate file path: {file_path}",
action="validate_file_path"
),
Task(
task_id="prepare_content",
name="Prepare Content",
description="Prepare content for writing",
action="prepare_content",
dependencies=["validate_file_path"]
),
Task(
task_id="write_file",
name="Write File",
description=f"Write content to file: {file_path}",
action="write_file",
dependencies=["prepare_content"]
),
Task(
task_id="verify_write",
name="Verify Write",
description="Verify file was written successfully",
action="verify_write",
dependencies=["write_file"]
)
]

return tasks

def _generate_code_execution_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成代码执行任务"""
code = context.get('code', '')
language = context.get('language', 'python')

tasks = [
Task(
task_id="validate_code",
name="Validate Code",
description="Validate code syntax",
action="validate_code"
),
Task(
task_id="setup_environment",
name="Setup Environment",
description=f"Setup {language} execution environment",
action="setup_environment",
dependencies=["validate_code"]
),
Task(
task_id="execute_code",
name="Execute Code",
description="Execute the code",
action="execute_code",
dependencies=["setup_environment"]
),
Task(
task_id="capture_output",
name="Capture Output",
description="Capture execution output",
action="capture_output",
dependencies=["execute_code"]
)
]

return tasks

def _generate_default_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成默认任务"""
tasks = [
Task(
task_id="analyze_goal",
name="Analyze Goal",
description=f"Analyze goal: {goal}",
action="analyze_goal"
),
Task(
task_id="execute_goal",
name="Execute Goal",
description=f"Execute goal: {goal}",
action="execute_goal",
dependencies=["analyze_goal"]
)
]

return tasks

def _topological_sort(self) -> List[str]:
"""拓扑排序"""
visited = set()
result = []

def visit(task_id: str):
if task_id in visited:
return

visited.add(task_id)

 # 先访问依赖
for dep_id in self.task_graph.get(task_id, []):
visit(dep_id)

result.append(task_id)

for task_id in self.tasks:
visit(task_id)

return result

def update_task_status(self, task_id: str, status: str, result: Any = None, error: str = None):
"""更新任务状态"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return

task.status = status

if status == "in_progress":
task.started_at = datetime.utcnow()
elif status == "completed":
task.completed_at = datetime.utcnow()
task.result = result
elif status == "failed":
task.completed_at = datetime.utcnow()
task.error = error

logger.info(f"Task {task_id} status updated to {status}")

def get_plan_status(self) -> Dict[str, Any]:
"""获取计划状态"""
total_tasks = len(self.tasks)
completed_tasks = len([t for t in self.tasks.values() if t.status == "completed"])
failed_tasks = len([t for t in self.tasks.values() if t.status == "failed"])
in_progress_tasks = len([t for t in self.tasks.values() if t.status == "in_progress"])
pending_tasks = len([t for t in self.tasks.values() if t.status == "pending"])

return {
'total_tasks': total_tasks,
'completed_tasks': completed_tasks,
'failed_tasks': failed_tasks,
'in_progress_tasks': in_progress_tasks,
'pending_tasks': pending_tasks,
'progress': completed_tasks / total_tasks if total_tasks > 0 else 0
}

# 使用示例
planner = TaskPlanner()

# 创建计划
goal = "Read the file config.txt"
context = {'file_path': 'config.txt'}
plan = planner.create_plan(goal, context)

print("Execution plan:")
for task in plan:
print(f"  - {task.name}: {task.description}")

# 更新任务状态
planner.update_task_status("validate_file_path", "completed")
planner.update_task_status("read_file", "in_progress")

# 获取计划状态
status = planner.get_plan_status()
print(f"\nPlan status: {status}")

```> **任务规划器特点**:
> - 根据目标生成任务
> - 处理任务依赖
> - 拓扑排序
> - 状态跟踪

```
## 工具调度器

### 1. 工具调度原理

# 示例：工具调度器
用户请求：
"实现一个工具调度器"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

class Tool:
"""工具"""

def __init__(self, tool_id: str, name: str, description: str, function: callable):
self.id = tool_id
self.name = name
self.description = description
self.function = function
self.status = "idle"
self.last_used: Optional[datetime] = None
self.usage_count = 0

class ToolScheduler:
"""工具调度器"""

def __init__(self, max_concurrent: int = 3):
self.tools: Dict[str, Tool] = {}
self.task_queue: asyncio.Queue = asyncio.Queue()
self.running_tasks: Dict[str, asyncio.Task] = {}
self.max_concurrent = max_concurrent
self.running = False

def register_tool(self, tool: Tool):
"""注册工具"""
self.tools[tool.id] = tool
logger.info(f"Tool registered: {tool.id}")

def schedule_task(self, tool_id: str, parameters: Dict[str, Any]) -> str:
"""调度任务"""
task_id = f"task_{datetime.utcnow().timestamp()}"

task = {
'task_id': task_id,
'tool_id': tool_id,
'parameters': parameters,
'status': 'pending',
'created_at': datetime.utcnow()
}

asyncio.create_task(self.task_queue.put(task))
logger.info(f"Task scheduled: {task_id}")

return task_id

async def start(self):
"""启动调度器"""
self.running = True
logger.info("Tool scheduler started")

 # 启动工作线程
for i in range(self.max_concurrent):
asyncio.create_task(self._worker(f"worker-{i}"))

async def stop(self):
"""停止调度器"""
self.running = False

 # 等待所有任务完成
await asyncio.gather(*self.running_tasks.values(), return_exceptions=True)

logger.info("Tool scheduler stopped")

async def _worker(self, worker_name: str):
"""工作线程"""
logger.info(f"{worker_name} started")

while self.running:
try:
 # 获取任务
task = await asyncio.wait_for(
self.task_queue.get(),
timeout=1.0
)

tool_id = task['tool_id']
tool = self.tools.get(tool_id)

if not tool:
logger.warning(f"Tool not found: {tool_id}")
continue

 # 执行任务
await self._execute_task(worker_name, task, tool)

except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"{worker_name} error: {e}")

logger.info(f"{worker_name} stopped")

async def _execute_task(self, worker_name: str, task: Dict[str, Any], tool: Tool):
"""执行任务"""
task_id = task['task_id']

 # 更新工具状态
tool.status = "busy"

try:
 # 执行工具函数
result = await self._run_tool_function(tool, task['parameters'])

 # 更新任务状态
task['status'] = 'completed'
task['result'] = result
task['completed_at'] = datetime.utcnow()

 # 更新工具统计
tool.last_used = datetime.utcnow()
tool.usage_count += 1

logger.info(f"{worker_name} completed task {task_id}")

except Exception as e:
 # 更新任务状态
task['status'] = 'failed'
task['error'] = str(e)
task['completed_at'] = datetime.utcnow()

logger.error(f"{worker_name} failed task {task_id}: {e}")

finally:
 # 更新工具状态
tool.status = "idle"

async def _run_tool_function(self, tool: Tool, parameters: Dict[str, Any]) -> Any:
"""运行工具函数"""
 # 检查函数是否是协程函数
if asyncio.iscoroutinefunction(tool.function):
return await tool.function(**parameters)
else:
 # 在线程池中运行同步函数
loop = asyncio.get_event_loop()
return await loop.run_in_executor(None, tool.function, **parameters)

def get_tool_status(self, tool_id: str) -> Optional[Dict[str, Any]]:
"""获取工具状态"""
tool = self.tools.get(tool_id)
if not tool:
return None

return {
'id': tool.id,
'name': tool.name,
'status': tool.status,
'last_used': tool.last_used.isoformat() if tool.last_used else None,
'usage_count': tool.usage_count
}

def get_all_tool_status(self) -> Dict[str, Dict[str, Any]]:
"""获取所有工具状态"""
return {
tool_id: self.get_tool_status(tool_id)
for tool_id in self.tools
}

# 使用示例
async def main():
"""主函数"""
scheduler = ToolScheduler(max_concurrent=2)

 # 注册工具
def read_file_tool(file_path: str) -> str:
"""读取文件工具"""
with open(file_path, 'r') as f:
return f.read()

def write_file_tool(file_path: str, content: str) -> str:
"""写入文件工具"""
with open(file_path, 'w') as f:
f.write(content)
return f"Written to {file_path}"

scheduler.register_tool(Tool("read_file", "Read File", "Read file content", read_file_tool))
scheduler.register_tool(Tool("write_file", "Write File", "Write content to file", write_file_tool))

 # 启动调度器
await scheduler.start()

 # 调度任务
task1 = scheduler.schedule_task("read_file", {'file_path': 'test.txt'})
task2 = scheduler.schedule_task("write_file", {'file_path': 'output.txt', 'content': 'Hello'})
task3 = scheduler.schedule_task("read_file", {'file_path': 'test.txt'})

 # 等待任务完成
await asyncio.sleep(2)

 # 获取工具状态
status = scheduler.get_all_tool_status()
print(f"Tool status: {status}")

 # 停止调度器
await scheduler.stop()

if __name__ == '__main__':
asyncio.run(main())

```> **工具调度器特点**:
> - 异步任务调度
> - 并发控制
> - 工具状态管理
> - 使用统计
```
## 总结

核心组件详解包括：

1. **意图识别器**: 意图识别原理、实现方法
2. **任务规划器**: 任务规划原理、执行计划生成
3. **工具调度器**: 工具调度原理、异步执行

通过理解这些核心组件，可以更好地掌握Claude Code的工作原理。

在下一节中，我们将探讨数据流与工作流程。

```
```

```
`python

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class Task:
"""任务"""

def __init__(self, task_id: str, name: str, description: str, action: str):
self.id = task_id
self.name = name
self.description = description
self.action = action
self.status = "pending"
self.dependencies: List[str] = []
self.created_at = datetime.utcnow()
self.started_at: Optional[datetime] = None
self.completed_at: Optional[datetime] = None
self.result: Optional[Any] = None
self.error: Optional[str] = None

class TaskPlanner:
"""任务规划器"""

def __init__(self):
self.tasks: Dict[str, Task] = {}
self.task_graph: Dict[str, List[str]] = {}
self.execution_plan: List[str] = []

def add_task(self, task: Task):
"""添加任务"""
self.tasks[task.id] = task
self.task_graph[task.id] = task.dependencies
logger.info(f"Task added: {task.id}")

def create_plan(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""创建执行计划"""
 # 根据目标和上下文生成任务
tasks = self._generate_tasks(goal, context)

 # 添加任务
for task in tasks:
self.add_task(task)

 # 生成执行顺序
self.execution_plan = self._topological_sort()

 # 返回按顺序排列的任务
return [self.tasks[task_id] for task_id in self.execution_plan]

def _generate_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成任务"""
tasks = []

 # 根据目标类型生成任务
if 'read' in goal.lower() and 'file' in goal.lower():
tasks = self._generate_file_reading_tasks(goal, context)
elif 'write' in goal.lower() and 'file' in goal.lower():
tasks = self._generate_file_writing_tasks(goal, context)
elif 'execute' in goal.lower() and 'code' in goal.lower():
tasks = self._generate_code_execution_tasks(goal, context)
else:
tasks = self._generate_default_tasks(goal, context)

return tasks

def _generate_file_reading_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成文件读取任务"""
file_path = context.get('file_path', 'default.txt')

tasks = [
Task(
task_id="validate_file_path",
name="Validate File Path",
description=f"Validate file path: {file_path}",
action="validate_file_path"
),
Task(
task_id="read_file",
name="Read File",
description=f"Read file: {file_path}",
action="read_file",
dependencies=["validate_file_path"]
),
Task(
task_id="parse_content",
name="Parse Content",
description="Parse file content",
action="parse_content",
dependencies=["read_file"]
)
]

return tasks

def _generate_file_writing_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成文件写入任务"""
file_path = context.get('file_path', 'output.txt')
content = context.get('content', '')

tasks = [
Task(
task_id="validate_file_path",
name="Validate File Path",
description=f"Validate file path: {file_path}",
action="validate_file_path"
),
Task(
task_id="prepare_content",
name="Prepare Content",
description="Prepare content for writing",
action="prepare_content",
dependencies=["validate_file_path"]
),
Task(
task_id="write_file",
name="Write File",
description=f"Write content to file: {file_path}",
action="write_file",
dependencies=["prepare_content"]
),
Task(
task_id="verify_write",
name="Verify Write",
description="Verify file was written successfully",
action="verify_write",
dependencies=["write_file"]
)
]

return tasks

def _generate_code_execution_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成代码执行任务"""
code = context.get('code', '')
language = context.get('language', 'python')

tasks = [
Task(
task_id="validate_code",
name="Validate Code",
description="Validate code syntax",
action="validate_code"
),
Task(
task_id="setup_environment",
name="Setup Environment",
description=f"Setup {language} execution environment",
action="setup_environment",
dependencies=["validate_code"]
),
Task(
task_id="execute_code",
name="Execute Code",
description="Execute the code",
action="execute_code",
dependencies=["setup_environment"]
),
Task(
task_id="capture_output",
name="Capture Output",
description="Capture execution output",
action="capture_output",
dependencies=["execute_code"]
)
]

return tasks

def _generate_default_tasks(self, goal: str, context: Dict[str, Any]) -> List[Task]:
"""生成默认任务"""
tasks = [
Task(
task_id="analyze_goal",
name="Analyze Goal",
description=f"Analyze goal: {goal}",
action="analyze_goal"
),
Task(
task_id="execute_goal",
name="Execute Goal",
description=f"Execute goal: {goal}",
action="execute_goal",
dependencies=["analyze_goal"]
)
]

return tasks

def _topological_sort(self) -> List[str]:
"""拓扑排序"""
visited = set()
result = []

def visit(task_id: str):
if task_id in visited:
return

visited.add(task_id)

 # 先访问依赖
for dep_id in self.task_graph.get(task_id, []):
visit(dep_id)

result.append(task_id)

for task_id in self.tasks:
visit(task_id)

return result

def update_task_status(self, task_id: str, status: str, result: Any = None, error: str = None):
"""更新任务状态"""
task = self.tasks.get(task_id)
if not task:
logger.warning(f"Task not found: {task_id}")
return

task.status = status

if status == "in_progress":
task.started_at = datetime.utcnow()
elif status == "completed":
task.completed_at = datetime.utcnow()
task.result = result
elif status == "failed":
task.completed_at = datetime.utcnow()
task.error = error

logger.info(f"Task {task_id} status updated to {status}")

def get_plan_status(self) -> Dict[str, Any]:
"""获取计划状态"""
total_tasks = len(self.tasks)
completed_tasks = len([t for t in self.tasks.values() if t.status == "completed"])
failed_tasks = len([t for t in self.tasks.values() if t.status == "failed"])
in_progress_tasks = len([t for t in self.tasks.values() if t.status == "in_progress"])
pending_tasks = len([t for t in self.tasks.values() if t.status == "pending"])

return {
'total_tasks': total_tasks,
'completed_tasks': completed_tasks,
'failed_tasks': failed_tasks,
'in_progress_tasks': in_progress_tasks,
'pending_tasks': pending_tasks,
'progress': completed_tasks / total_tasks if total_tasks > 0 else 0
}

# 使用示例
planner = TaskPlanner()

# 创建计划
goal = "Read the file config.txt"
context = {'file_path': 'config.txt'}
plan = planner.create_plan(goal, context)

print("Execution plan:")
for task in plan:
print(f"  - {task.name}: {task.description}")

# 更新任务状态
planner.update_task_status("validate_file_path", "completed")
planner.update_task_status("read_file", "in_progress")

# 获取计划状态
status = planner.get_plan_status()
print(f"\nPlan status: {status}")

```> **任务规划器特点**:
> - 根据目标生成任务
> - 处理任务依赖
> - 拓扑排序
> - 状态跟踪

```
## 工具调度器

### 1. 工具调度原理

# 示例：工具调度器
用户请求：
"实现一个工具调度器"
Claude Code 生成的代码：
````python
`python

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

class Tool:
"""工具"""

def __init__(self, tool_id: str, name: str, description: str, function: callable):
self.id = tool_id
self.name = name
self.description = description
self.function = function
self.status = "idle"
self.last_used: Optional[datetime] = None
self.usage_count = 0

class ToolScheduler:
"""工具调度器"""

def __init__(self, max_concurrent: int = 3):
self.tools: Dict[str, Tool] = {}
self.task_queue: asyncio.Queue = asyncio.Queue()
self.running_tasks: Dict[str, asyncio.Task] = {}
self.max_concurrent = max_concurrent
self.running = False

def register_tool(self, tool: Tool):
"""注册工具"""
self.tools[tool.id] = tool
logger.info(f"Tool registered: {tool.id}")

def schedule_task(self, tool_id: str, parameters: Dict[str, Any]) -> str:
"""调度任务"""
task_id = f"task_{datetime.utcnow().timestamp()}"

task = {
'task_id': task_id,
'tool_id': tool_id,
'parameters': parameters,
'status': 'pending',
'created_at': datetime.utcnow()
}

asyncio.create_task(self.task_queue.put(task))
logger.info(f"Task scheduled: {task_id}")

return task_id

async def start(self):
"""启动调度器"""
self.running = True
logger.info("Tool scheduler started")

 # 启动工作线程
for i in range(self.max_concurrent):
asyncio.create_task(self._worker(f"worker-{i}"))

async def stop(self):
"""停止调度器"""
self.running = False

 # 等待所有任务完成
await asyncio.gather(*self.running_tasks.values(), return_exceptions=True)

logger.info("Tool scheduler stopped")

async def _worker(self, worker_name: str):
"""工作线程"""
logger.info(f"{worker_name} started")

while self.running:
try:
 # 获取任务
task = await asyncio.wait_for(
self.task_queue.get(),
timeout=1.0
)

tool_id = task['tool_id']
tool = self.tools.get(tool_id)

if not tool:
logger.warning(f"Tool not found: {tool_id}")
continue

 # 执行任务
await self._execute_task(worker_name, task, tool)

except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"{worker_name} error: {e}")

logger.info(f"{worker_name} stopped")

async def _execute_task(self, worker_name: str, task: Dict[str, Any], tool: Tool):
"""执行任务"""
task_id = task['task_id']

 # 更新工具状态
tool.status = "busy"

try:
 # 执行工具函数
result = await self._run_tool_function(tool, task['parameters'])

 # 更新任务状态
task['status'] = 'completed'
task['result'] = result
task['completed_at'] = datetime.utcnow()

 # 更新工具统计
tool.last_used = datetime.utcnow()
tool.usage_count += 1

logger.info(f"{worker_name} completed task {task_id}")

except Exception as e:
 # 更新任务状态
task['status'] = 'failed'
task['error'] = str(e)
task['completed_at'] = datetime.utcnow()

logger.error(f"{worker_name} failed task {task_id}: {e}")

finally:
 # 更新工具状态
tool.status = "idle"

async def _run_tool_function(self, tool: Tool, parameters: Dict[str, Any]) -> Any:
"""运行工具函数"""
 # 检查函数是否是协程函数
if asyncio.iscoroutinefunction(tool.function):
return await tool.function(**parameters)
else:
 # 在线程池中运行同步函数
loop = asyncio.get_event_loop()
return await loop.run_in_executor(None, tool.function, **parameters)

def get_tool_status(self, tool_id: str) -> Optional[Dict[str, Any]]:
"""获取工具状态"""
tool = self.tools.get(tool_id)
if not tool:
return None

return {
'id': tool.id,
'name': tool.name,
'status': tool.status,
'last_used': tool.last_used.isoformat() if tool.last_used else None,
'usage_count': tool.usage_count
}

def get_all_tool_status(self) -> Dict[str, Dict[str, Any]]:
"""获取所有工具状态"""
return {
tool_id: self.get_tool_status(tool_id)
for tool_id in self.tools
}

# 使用示例
async def main():
"""主函数"""
scheduler = ToolScheduler(max_concurrent=2)

 # 注册工具
def read_file_tool(file_path: str) -> str:
"""读取文件工具"""
with open(file_path, 'r') as f:
return f.read()

def write_file_tool(file_path: str, content: str) -> str:
"""写入文件工具"""
with open(file_path, 'w') as f:
f.write(content)
return f"Written to {file_path}"

scheduler.register_tool(Tool("read_file", "Read File", "Read file content", read_file_tool))
scheduler.register_tool(Tool("write_file", "Write File", "Write content to file", write_file_tool))

 # 启动调度器
await scheduler.start()

 # 调度任务
task1 = scheduler.schedule_task("read_file", {'file_path': 'test.txt'})
task2 = scheduler.schedule_task("write_file", {'file_path': 'output.txt', 'content': 'Hello'})
task3 = scheduler.schedule_task("read_file", {'file_path': 'test.txt'})

 # 等待任务完成
await asyncio.sleep(2)

 # 获取工具状态
status = scheduler.get_all_tool_status()
print(f"Tool status: {status}")

 # 停止调度器
await scheduler.stop()

if __name__ == '__main__':
asyncio.run(main())

```> **工具调度器特点**:
> - 异步任务调度
> - 并发控制
> - 工具状态管理
> - 使用统计
```
## 总结

核心组件详解包括：

1. **意图识别器**: 意图识别原理、实现方法
2. **任务规划器**: 任务规划原理、执行计划生成
3. **工具调度器**: 工具调度原理、异步执行

通过理解这些核心组件，可以更好地掌握Claude Code的工作原理。

在下一节中，我们将探讨数据流与工作流程。

```
```

---

## 3 数据流与工作流程

**URL**: https://claudecode.tangshuang.net/course/28.3%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B

#### 28.3.1 数据流概述#

Claude Code 的数据流是指用户请求从输入到最终结果输出的完整处理过程。理解数据流对于掌握 Claude Code 的工作原理至关重要。

##### 数据流特点#

True. 多阶段处理：数据流经过多个处理阶段，每个阶段都有特定的职责
True. 异步处理：支持异步处理以提高性能
True. 错误处理：完善的错误处理和恢复机制
True. 可观测性：每个处理步骤都可以被监控和追踪

##### 数据流架构#

用户输入
↓
预处理（上下文收集、历史分析）
↓
意图识别
↓
任务规划
↓
工具选择
↓
工具执行
↓
结果处理
↓
后处理（格式化、验证）
↓
用户输出

#### 28.3.2 核心数据流组件#

##### 1. 输入处理器#

```
python复制python

class InputProcessor:
    """输入处理器"""

    def __init__(self):
        self.context_manager = ContextManager()
        self.history_analyzer = HistoryAnalyzer()

    def process(self, user_input: str, session_id: str) -> ProcessedInput:
        """处理用户输入"""

        # 收集上下文
        context = self.context_manager.collect_context(session_id)

        # 分析历史
        history = self.history_analyzer.analyze(session_id)

        # 预处理输入
        processed_input = self._preprocess(user_input)

        # 构建处理后的输入
        result = ProcessedInput(
            original_input=user_input,
            processed_input=processed_input,
            context=context,
            history=history,
            metadata={
                'timestamp': datetime.utcnow(),
                'session_id': session_id
            }
        )

        return result

    def _preprocess(self, input_text: str) -> str:
        """预处理输入文本"""
        # 去除多余空格
        text = ' '.join(input_text.split())

        # 标准化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')

        # 处理特殊字符
        text = self._normalize_special_chars(text)

        return text

    def _normalize_special_chars(self, text: str) -> str:
        """标准化特殊字符"""
        # 统一引号
        text = text.replace('"', '"').replace('"', '"')
        text = text.replace(''', "'").replace(''', "'")

        # 统一破折号
        text = text.replace('–', '-').replace('—', '--')

        return text

```### 2. 意图识别处理器

class IntentProcessor:
"""意图识别处理器"""
def __init__(self):
self.intent_recognizer = IntentRecognizer()
self.entity_extractor = EntityExtractor()
def process(self, processed_input: ProcessedInput) -> IntentResult:
"""处理意图识别"""
# 识别意图
intent = self.intent_recognizer.recognize(
processed_input.processed_input
)
# 提取实体
entities = self.entity_extractor.extract(
processed_input.processed_input,
intent
```

```
python

class InputProcessor:
    """输入处理器"""

    def __init__(self):
        self.context_manager = ContextManager()
        self.history_analyzer = HistoryAnalyzer()

    def process(self, user_input: str, session_id: str) -> ProcessedInput:
        """处理用户输入"""

        # 收集上下文
        context = self.context_manager.collect_context(session_id)

        # 分析历史
        history = self.history_analyzer.analyze(session_id)

        # 预处理输入
        processed_input = self._preprocess(user_input)

        # 构建处理后的输入
        result = ProcessedInput(
            original_input=user_input,
            processed_input=processed_input,
            context=context,
            history=history,
            metadata={
                'timestamp': datetime.utcnow(),
                'session_id': session_id
            }
        )

        return result

    def _preprocess(self, input_text: str) -> str:
        """预处理输入文本"""
        # 去除多余空格
        text = ' '.join(input_text.split())

        # 标准化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')

        # 处理特殊字符
        text = self._normalize_special_chars(text)

        return text

    def _normalize_special_chars(self, text: str) -> str:
        """标准化特殊字符"""
        # 统一引号
        text = text.replace('"', '"').replace('"', '"')
        text = text.replace(''', "'").replace(''', "'")

        # 统一破折号
        text = text.replace('–', '-').replace('—', '--')

        return text

```### 2. 意图识别处理器

class IntentProcessor:
"""意图识别处理器"""
def __init__(self):
self.intent_recognizer = IntentRecognizer()
self.entity_extractor = EntityExtractor()
def process(self, processed_input: ProcessedInput) -> IntentResult:
"""处理意图识别"""
# 识别意图
intent = self.intent_recognizer.recognize(
processed_input.processed_input
)
# 提取实体
entities = self.entity_extractor.extract(
processed_input.processed_input,
intent
```

### 构建结果

result = IntentResult(
intent=intent,
entities=entities,
confidence=intent.confidence,
metadata={
'processing_time': self._measure_time(),
'model_version': self.intent_recognizer.model_version
}
)
return result
def _measure_time(self) -> float:
"""测量处理时间"""
return time.time()

```
bash复制### 3. 任务规划处理器

```python
```python

class TaskPlanningProcessor:
    """任务规划处理器"""

    def __init__(self):
        self.task_planner = TaskPlanner()
        self.dependency_analyzer = DependencyAnalyzer()

    def process(self, intent_result: IntentResult,
                context: Dict[str, Any]) -> PlanningResult:
        """处理任务规划"""

        # 分析依赖关系
        dependencies = self.dependency_analyzer.analyze(
            intent_result,
            context
        )

        # 创建执行计划
        tasks = self.task_planner.create_plan(
            intent_result.intent.name,
            context
        )

        # 构建结果
        result = PlanningResult(
            tasks=tasks,
            dependencies=dependencies,
            execution_order=self.task_planner.execution_plan,
            estimated_time=self._estimate_time(tasks),
            metadata={
                'planning_algorithm': self.task_planner.algorithm,
                'optimization_level': self.task_planner.optimization_level
            }
        )

        return result

    def _estimate_time(self, tasks: List[Task]) -> float:
        """估计执行时间"""
        total_time = 0.0
        for task in tasks:
            total_time += task.estimated_duration
        return total_time

```### 4. 工具执行处理器

class ToolExecutionProcessor:
"""工具执行处理器"""
def __init__(self):
self.tool_scheduler = ToolScheduler()
self.result_aggregator = ResultAggregator()
def process(self, planning_result: PlanningResult) -> ExecutionResult:
"""处理工具执行"""
# 执行任务
execution_results = []
for task in planning_result.tasks:
result = self.tool_scheduler.execute(task)
execution_results.append(result)
# 聚合结果
aggregated_result = self.result_aggregator.aggregate(
execution_results
)
# 构建结果
result = ExecutionResult(
individual_results=execution_results,
aggregated_result=aggregated_result,
total_time=sum(r.execution_time for r in execution_results),
success_rate=sum(1 for r in execution_results if r.success) / len(execution_results),
metadata={
'parallel_execution': self.tool_scheduler.parallel,
'max_concurrency': self.tool_scheduler.max_concurrency
}
)
return result
```

```
### 3. 任务规划处理器

```python
```python

class TaskPlanningProcessor:
    """任务规划处理器"""

    def __init__(self):
        self.task_planner = TaskPlanner()
        self.dependency_analyzer = DependencyAnalyzer()

    def process(self, intent_result: IntentResult,
                context: Dict[str, Any]) -> PlanningResult:
        """处理任务规划"""

        # 分析依赖关系
        dependencies = self.dependency_analyzer.analyze(
            intent_result,
            context
        )

        # 创建执行计划
        tasks = self.task_planner.create_plan(
            intent_result.intent.name,
            context
        )

        # 构建结果
        result = PlanningResult(
            tasks=tasks,
            dependencies=dependencies,
            execution_order=self.task_planner.execution_plan,
            estimated_time=self._estimate_time(tasks),
            metadata={
                'planning_algorithm': self.task_planner.algorithm,
                'optimization_level': self.task_planner.optimization_level
            }
        )

        return result

    def _estimate_time(self, tasks: List[Task]) -> float:
        """估计执行时间"""
        total_time = 0.0
        for task in tasks:
            total_time += task.estimated_duration
        return total_time

```### 4. 工具执行处理器

class ToolExecutionProcessor:
"""工具执行处理器"""
def __init__(self):
self.tool_scheduler = ToolScheduler()
self.result_aggregator = ResultAggregator()
def process(self, planning_result: PlanningResult) -> ExecutionResult:
"""处理工具执行"""
# 执行任务
execution_results = []
for task in planning_result.tasks:
result = self.tool_scheduler.execute(task)
execution_results.append(result)
# 聚合结果
aggregated_result = self.result_aggregator.aggregate(
execution_results
)
# 构建结果
result = ExecutionResult(
individual_results=execution_results,
aggregated_result=aggregated_result,
total_time=sum(r.execution_time for r in execution_results),
success_rate=sum(1 for r in execution_results if r.success) / len(execution_results),
metadata={
'parallel_execution': self.tool_scheduler.parallel,
'max_concurrency': self.tool_scheduler.max_concurrency
}
)
return result
```

##### 5. 输出生成处理器#

```
python复制```python

class OutputGenerationProcessor:
    """输出生成处理器"""

    def __init__(self):
        self.formatter = OutputFormatter()
        self.validator = OutputValidator()

    def process(self, execution_result: ExecutionResult,
                intent_result: IntentResult) -> OutputResult:
        """处理输出生成"""

        # 格式化输出
        formatted_output = self.formatter.format(
            execution_result.aggregated_result,
            intent_result.intent
        )

        # 验证输出
        validation_result = self.validator.validate(
            formatted_output,
            intent_result
        )

        # 构建结果
        result = OutputResult(
            formatted_output=formatted_output,
            validation_result=validation_result,
            format_type=self.formatter.current_format,
            metadata={
                'formatter_version': self.formatter.version,
                'validation_rules': self.validator.rules
            }
        )

        return result

```## 28.3.3 完整数据流实现

class DataPipeline:
"""数据流管道"""
def __init__(self):
self.input_processor = InputProcessor()
self.intent_processor = IntentProcessor()
self.planning_processor = TaskPlanningProcessor()
self.execution_processor = ToolExecutionProcessor()
self.output_processor = OutputGenerationProcessor()
self.observers: List[PipelineObserver] = []
def add_observer(self, observer: PipelineObserver):
"""添加观察者"""
self.observers.append(observer)
def process(self, user_input: str, session_id: str) -> PipelineResult:
"""处理完整数据流"""
pipeline_result = PipelineResult()
try:
# 1. 输入处理
self._notify_observers('input_processing_start')
processed_input = self.input_processor.process(user_input, session_id)
pipeline_result.processed_input = processed_input
self._notify_observers('input_processing_complete', processed_input)
# 2. 意图识别
self._notify_observers('intent_recognition_start')
intent_result = self.intent_processor.process(processed_input)
pipeline_result.intent_result = intent_result
self._notify_observers('intent_recognition_complete', intent_result)
# 3. 任务规划
self._notify_observers('task_planning_start')
planning_result = self.planning_processor.process(
intent_result,
processed_input.context
)
pipeline_result.planning_result = planning_result
self._notify_observers('task_planning_complete', planning_result)
# 4. 工具执行
self._notify_observers('tool_execution_start')
execution_result = self.execution_processor.process(planning_result)
pipeline_result.execution_result = execution_result
self._notify_observers('tool_execution_complete', execution_result)
# 5. 输出生成
self._notify_observers('output_generation_start')
output_result = self.output_processor.process(
execution_result,
intent_result
)
pipeline_result.output_result = output_result
self._notify_observers('output_generation_complete', output_result)
# 标记成功
pipeline_result.success = True
except Exception as e:
pipeline_result.success = False
pipeline_result.error = str(e)
self._notify_observers('pipeline_error', e)
logger.error(f"Pipeline error: {e}")
raise
finally:
pipeline_result.total_time = self._calculate_total_time(pipeline_result)
self._notify_observers('pipeline_complete', pipeline_result)
return pipeline_result
def _notify_observers(self, event: str, data: Any = None):
"""通知观察者"""
for observer in self.observers:
observer.notify(event, data)
def _calculate_total_time(self, result: PipelineResult) -> float:
"""计算总处理时间"""
if not result.output_result:
return 0.0
return (
result.processed_input.metadata['timestamp'] -
result.output_result.metadata['timestamp']
).total_seconds()
```

```
```python

class OutputGenerationProcessor:
    """输出生成处理器"""

    def __init__(self):
        self.formatter = OutputFormatter()
        self.validator = OutputValidator()

    def process(self, execution_result: ExecutionResult,
                intent_result: IntentResult) -> OutputResult:
        """处理输出生成"""

        # 格式化输出
        formatted_output = self.formatter.format(
            execution_result.aggregated_result,
            intent_result.intent
        )

        # 验证输出
        validation_result = self.validator.validate(
            formatted_output,
            intent_result
        )

        # 构建结果
        result = OutputResult(
            formatted_output=formatted_output,
            validation_result=validation_result,
            format_type=self.formatter.current_format,
            metadata={
                'formatter_version': self.formatter.version,
                'validation_rules': self.validator.rules
            }
        )

        return result

```## 28.3.3 完整数据流实现

class DataPipeline:
"""数据流管道"""
def __init__(self):
self.input_processor = InputProcessor()
self.intent_processor = IntentProcessor()
self.planning_processor = TaskPlanningProcessor()
self.execution_processor = ToolExecutionProcessor()
self.output_processor = OutputGenerationProcessor()
self.observers: List[PipelineObserver] = []
def add_observer(self, observer: PipelineObserver):
"""添加观察者"""
self.observers.append(observer)
def process(self, user_input: str, session_id: str) -> PipelineResult:
"""处理完整数据流"""
pipeline_result = PipelineResult()
try:
# 1. 输入处理
self._notify_observers('input_processing_start')
processed_input = self.input_processor.process(user_input, session_id)
pipeline_result.processed_input = processed_input
self._notify_observers('input_processing_complete', processed_input)
# 2. 意图识别
self._notify_observers('intent_recognition_start')
intent_result = self.intent_processor.process(processed_input)
pipeline_result.intent_result = intent_result
self._notify_observers('intent_recognition_complete', intent_result)
# 3. 任务规划
self._notify_observers('task_planning_start')
planning_result = self.planning_processor.process(
intent_result,
processed_input.context
)
pipeline_result.planning_result = planning_result
self._notify_observers('task_planning_complete', planning_result)
# 4. 工具执行
self._notify_observers('tool_execution_start')
execution_result = self.execution_processor.process(planning_result)
pipeline_result.execution_result = execution_result
self._notify_observers('tool_execution_complete', execution_result)
# 5. 输出生成
self._notify_observers('output_generation_start')
output_result = self.output_processor.process(
execution_result,
intent_result
)
pipeline_result.output_result = output_result
self._notify_observers('output_generation_complete', output_result)
# 标记成功
pipeline_result.success = True
except Exception as e:
pipeline_result.success = False
pipeline_result.error = str(e)
self._notify_observers('pipeline_error', e)
logger.error(f"Pipeline error: {e}")
raise
finally:
pipeline_result.total_time = self._calculate_total_time(pipeline_result)
self._notify_observers('pipeline_complete', pipeline_result)
return pipeline_result
def _notify_observers(self, event: str, data: Any = None):
"""通知观察者"""
for observer in self.observers:
observer.notify(event, data)
def _calculate_total_time(self, result: PipelineResult) -> float:
"""计算总处理时间"""
if not result.output_result:
return 0.0
return (
result.processed_input.metadata['timestamp'] -
result.output_result.metadata['timestamp']
).total_seconds()
```

#### 28.3.4 工作流程设计#

##### 1. 顺序工作流程#

```
python复制```python

class SequentialWorkflow:
    """顺序工作流程"""

    def __init__(self):
        self.steps: List[WorkflowStep] = []

    def add_step(self, step: WorkflowStep):
        """添加步骤"""
        self.steps.append(step)

    def execute(self, context: Dict[str, Any]) -> WorkflowResult:
        """执行工作流程"""

        result = WorkflowResult()
        current_context = context.copy()

        for i, step in enumerate(self.steps):
            try:
                # 执行步骤
                step_result = step.execute(current_context)

                # 更新上下文
                current_context.update(step_result.output)

                # 记录结果
                result.add_step_result(step.name, step_result)

            except Exception as e:
                logger.error(f"Error in step {step.name}: {e}")
                result.success = False
                result.error = str(e)
                result.failed_step = i
                break

        if result.success is None:
            result.success = True

        result.final_context = current_context

        return result

```### 2. 并行工作流程

class ParallelWorkflow:
"""并行工作流程"""
def __init__(self, max_workers: int = 4):
self.steps: List[WorkflowStep] = []
self.max_workers = max_workers
def add_step(self, step: WorkflowStep):
"""添加步骤"""
self.steps.append(step)
async def execute(self, context: Dict[str, Any]) -> WorkflowResult:
"""执行并行工作流程"""
result = WorkflowResult()
# 创建异步任务
tasks = []
for step in self.steps:
task = asyncio.create_task(
self._execute_step(step, context.copy())
)
tasks.append(task)
# 等待所有任务完成
step_results = await asyncio.gather(*tasks, return_exceptions=True)
# 处理结果
for i, step_result in enumerate(step_results):
if isinstance(step_result, Exception):
logger.error(f"Error in step {self.steps[i].name}: {step_result}")
result.success = False
result.add_step_result(
self.steps[i].name,
StepResult(success=False, error=str(step_result))
)
else:
result.add_step_result(self.steps[i].name, step_result)
result.success = all(r.success for r in result.step_results.values())
return result
async def _execute_step(self, step: WorkflowStep,
context: Dict[str, Any]) -> StepResult:
"""执行单个步骤"""
return await step.execute_async(context)
```

```
```python

class SequentialWorkflow:
    """顺序工作流程"""

    def __init__(self):
        self.steps: List[WorkflowStep] = []

    def add_step(self, step: WorkflowStep):
        """添加步骤"""
        self.steps.append(step)

    def execute(self, context: Dict[str, Any]) -> WorkflowResult:
        """执行工作流程"""

        result = WorkflowResult()
        current_context = context.copy()

        for i, step in enumerate(self.steps):
            try:
                # 执行步骤
                step_result = step.execute(current_context)

                # 更新上下文
                current_context.update(step_result.output)

                # 记录结果
                result.add_step_result(step.name, step_result)

            except Exception as e:
                logger.error(f"Error in step {step.name}: {e}")
                result.success = False
                result.error = str(e)
                result.failed_step = i
                break

        if result.success is None:
            result.success = True

        result.final_context = current_context

        return result

```### 2. 并行工作流程

class ParallelWorkflow:
"""并行工作流程"""
def __init__(self, max_workers: int = 4):
self.steps: List[WorkflowStep] = []
self.max_workers = max_workers
def add_step(self, step: WorkflowStep):
"""添加步骤"""
self.steps.append(step)
async def execute(self, context: Dict[str, Any]) -> WorkflowResult:
"""执行并行工作流程"""
result = WorkflowResult()
# 创建异步任务
tasks = []
for step in self.steps:
task = asyncio.create_task(
self._execute_step(step, context.copy())
)
tasks.append(task)
# 等待所有任务完成
step_results = await asyncio.gather(*tasks, return_exceptions=True)
# 处理结果
for i, step_result in enumerate(step_results):
if isinstance(step_result, Exception):
logger.error(f"Error in step {self.steps[i].name}: {step_result}")
result.success = False
result.add_step_result(
self.steps[i].name,
StepResult(success=False, error=str(step_result))
)
else:
result.add_step_result(self.steps[i].name, step_result)
result.success = all(r.success for r in result.step_results.values())
return result
async def _execute_step(self, step: WorkflowStep,
context: Dict[str, Any]) -> StepResult:
"""执行单个步骤"""
return await step.execute_async(context)
```

##### 3. 条件工作流程#

```
python复制```python

class ConditionalWorkflow:
    """条件工作流程"""

    def __init__(self):
        self.branches: Dict[str, List[WorkflowStep]] = {}
        self.default_branch: List[WorkflowStep] = []

    def add_branch(self, condition: str, steps: List[WorkflowStep]):
        """添加分支"""
        self.branches[condition] = steps

    def set_default_branch(self, steps: List[WorkflowStep]):
        """设置默认分支"""
        self.default_branch = steps

    def execute(self, context: Dict[str, Any],
               condition_evaluator: callable) -> WorkflowResult:
        """执行条件工作流程"""

        result = WorkflowResult()

        # 评估条件
        selected_branch = None
        for condition, steps in self.branches.items():
            if condition_evaluator(condition, context):
                selected_branch = steps
                result.selected_branch = condition
                break

        # 使用默认分支
        if selected_branch is None:
            selected_branch = self.default_branch
            result.selected_branch = 'default'

        # 执行选定的分支
        current_context = context.copy()
        for step in selected_branch:
            try:
                step_result = step.execute(current_context)
                current_context.update(step_result.output)
                result.add_step_result(step.name, step_result)
            except Exception as e:
                logger.error(f"Error in step {step.name}: {e}")
                result.success = False
                result.error = str(e)
                break

        if result.success is None:
            result.success = True

        result.final_context = current_context

        return result

```## 28.3.5 数据流监控与调试

### 1. 数据流监控器

class DataFlowMonitor:
"""数据流监控器"""
def __init__(self):
self.metrics: Dict[str, List[float]] = {}
self.events: List[Dict[str, Any]] = []
def record_metric(self, name: str, value: float):
"""记录指标"""
if name not in self.metrics:
self.metrics[name] = []
self.metrics[name].append(value)
def record_event(self, event_type: str, data: Dict[str, Any]):
"""记录事件"""
event = {
'type': event_type,
'timestamp': datetime.utcnow(),
'data': data
}
self.events.append(event)
def get_metrics_summary(self) -> Dict[str, Dict[str, float]]:
"""获取指标摘要"""
summary = {}
for name, values in self.metrics.items():
summary[name] = {
'count': len(values),
'mean': sum(values) / len(values),
'min': min(values),
'max': max(values)
}
return summary
def get_events(self, event_type: str = None) -> List[Dict[str, Any]]:
"""获取事件"""
if event_type:
return [e for e in self.events if e['type'] == event_type]
return self.events
```

```
```python

class ConditionalWorkflow:
    """条件工作流程"""

    def __init__(self):
        self.branches: Dict[str, List[WorkflowStep]] = {}
        self.default_branch: List[WorkflowStep] = []

    def add_branch(self, condition: str, steps: List[WorkflowStep]):
        """添加分支"""
        self.branches[condition] = steps

    def set_default_branch(self, steps: List[WorkflowStep]):
        """设置默认分支"""
        self.default_branch = steps

    def execute(self, context: Dict[str, Any],
               condition_evaluator: callable) -> WorkflowResult:
        """执行条件工作流程"""

        result = WorkflowResult()

        # 评估条件
        selected_branch = None
        for condition, steps in self.branches.items():
            if condition_evaluator(condition, context):
                selected_branch = steps
                result.selected_branch = condition
                break

        # 使用默认分支
        if selected_branch is None:
            selected_branch = self.default_branch
            result.selected_branch = 'default'

        # 执行选定的分支
        current_context = context.copy()
        for step in selected_branch:
            try:
                step_result = step.execute(current_context)
                current_context.update(step_result.output)
                result.add_step_result(step.name, step_result)
            except Exception as e:
                logger.error(f"Error in step {step.name}: {e}")
                result.success = False
                result.error = str(e)
                break

        if result.success is None:
            result.success = True

        result.final_context = current_context

        return result

```## 28.3.5 数据流监控与调试

### 1. 数据流监控器

class DataFlowMonitor:
"""数据流监控器"""
def __init__(self):
self.metrics: Dict[str, List[float]] = {}
self.events: List[Dict[str, Any]] = []
def record_metric(self, name: str, value: float):
"""记录指标"""
if name not in self.metrics:
self.metrics[name] = []
self.metrics[name].append(value)
def record_event(self, event_type: str, data: Dict[str, Any]):
"""记录事件"""
event = {
'type': event_type,
'timestamp': datetime.utcnow(),
'data': data
}
self.events.append(event)
def get_metrics_summary(self) -> Dict[str, Dict[str, float]]:
"""获取指标摘要"""
summary = {}
for name, values in self.metrics.items():
summary[name] = {
'count': len(values),
'mean': sum(values) / len(values),
'min': min(values),
'max': max(values)
}
return summary
def get_events(self, event_type: str = None) -> List[Dict[str, Any]]:
"""获取事件"""
if event_type:
return [e for e in self.events if e['type'] == event_type]
return self.events
```

##### 2. 数据流调试器#

```
python复制```python

class DataFlowDebugger:
    """数据流调试器"""

    def __init__(self):
        self.breakpoints: List[str] = []
        self.trace: List[Dict[str, Any]] = []
        self.enabled = False

    def enable(self):
        """启用调试"""
        self.enabled = True

    def disable(self):
        """禁用调试"""
        self.enabled = False

    def add_breakpoint(self, step_name: str):
        """添加断点"""
        self.breakpoints.append(step_name)

    def trace_step(self, step_name: str, input_data: Any,
                  output_data: Any):
        """追踪步骤"""
        if not self.enabled:
            return

        trace_entry = {
            'step': step_name,
            'timestamp': datetime.utcnow(),
            'input': self._serialize(input_data),
            'output': self._serialize(output_data)
        }
        self.trace.append(trace_entry)

        # 检查断点
        if step_name in self.breakpoints:
            self._pause_at_breakpoint(step_name, trace_entry)

    def _pause_at_breakpoint(self, step_name: str, trace_entry: Dict):
        """在断点处暂停"""
        logger.info(f"Breakpoint hit at: {step_name}")
        logger.info(f"Input: {trace_entry['input']}")
        logger.info(f"Output: {trace_entry['output']}")

    def _serialize(self, data: Any) -> Any:
        """序列化数据"""
        if isinstance(data, (str, int, float, bool, type(None))):
            return data
        elif isinstance(data, (list, tuple)):
            return [self._serialize(item) for item in data]
        elif isinstance(data, dict):
            return {k: self._serialize(v) for k, v in data.items()}
        else:
            return str(data)
```

```
```python

class DataFlowDebugger:
    """数据流调试器"""

    def __init__(self):
        self.breakpoints: List[str] = []
        self.trace: List[Dict[str, Any]] = []
        self.enabled = False

    def enable(self):
        """启用调试"""
        self.enabled = True

    def disable(self):
        """禁用调试"""
        self.enabled = False

    def add_breakpoint(self, step_name: str):
        """添加断点"""
        self.breakpoints.append(step_name)

    def trace_step(self, step_name: str, input_data: Any,
                  output_data: Any):
        """追踪步骤"""
        if not self.enabled:
            return

        trace_entry = {
            'step': step_name,
            'timestamp': datetime.utcnow(),
            'input': self._serialize(input_data),
            'output': self._serialize(output_data)
        }
        self.trace.append(trace_entry)

        # 检查断点
        if step_name in self.breakpoints:
            self._pause_at_breakpoint(step_name, trace_entry)

    def _pause_at_breakpoint(self, step_name: str, trace_entry: Dict):
        """在断点处暂停"""
        logger.info(f"Breakpoint hit at: {step_name}")
        logger.info(f"Input: {trace_entry['input']}")
        logger.info(f"Output: {trace_entry['output']}")

    def _serialize(self, data: Any) -> Any:
        """序列化数据"""
        if isinstance(data, (str, int, float, bool, type(None))):
            return data
        elif isinstance(data, (list, tuple)):
            return [self._serialize(item) for item in data]
        elif isinstance(data, dict):
            return {k: self._serialize(v) for k, v in data.items()}
        else:
            return str(data)
```

#### 28.3.6 最佳实践#

##### 1. 数据流设计原则#

True. 单一职责：每个处理器只负责一个特定的任务
True. 可组合性：处理器可以灵活组合以构建不同的数据流
True. 可观测性：每个处理步骤都应该可以被监控和追踪
True. 错误处理：完善的错误处理和恢复机制
True. 性能优化：支持异步处理和并行执行

##### 2. 工作流程设计原则#

True. 清晰性：工作流程的逻辑应该清晰易懂
True. 可维护性：易于修改和扩展
True. 可测试性：每个步骤都应该可以独立测试
True. 灵活性：支持不同的执行模式（顺序、并行、条件）
True. 可重用性：工作流程组件应该可以在不同场景中重用

##### 3. 监控与调试建议#

True. 关键指标：监控处理时间、成功率、错误率等关键指标
True. 事件追踪：记录重要事件以便后续分析
True. 断点调试：在关键步骤设置断点进行调试
True. 性能分析：识别性能瓶颈并进行优化
True. 日志记录：详细的日志记录有助于问题诊断

通过合理设计数据流和工作流程，可以构建高效、可靠、可维护的 Claude Code 系统。

---

## 4 扩展性设计

**URL**: https://claudecode.tangshuang.net/course/28.4%20%E6%89%A9%E5%B1%95%E6%80%A7%E8%AE%BE%E8%AE%A1

#### 28.4.1 扩展性概述#

Claude Code 的扩展性设计是其能够适应不同使用场景和需求的关键。良好的扩展性设计使得系统可以：

True. 轻松添加新功能：通过插件机制添加新能力
True. 支持多种集成方式：与不同的开发工具和环境集成
True. 适应不同规模：从小型项目到大型企业级应用
True. 保持向后兼容：新版本不影响现有功能
True. 支持自定义配置：根据具体需求进行定制

#### 28.4.2 插件系统架构#

##### 1. 插件接口设计#

class PluginInterface(ABC):
"""插件接口"""

@property
@abstractmethod
def name(self) -> str:
"""插件名称"""
pass

@property
@abstractmethod
def version(self) -> str:

"""插件版本"""
pass

@property
@abstractmethod
def description(self) -> str:
"""插件描述"""
pass

@abstractmethod
def initialize(self, context: PluginContext):
"""初始化插件"""
pass

@abstractmethod
def execute(self, request: PluginRequest) -> PluginResponse:
"""执行插件功能"""
pass

@abstractmethod
def cleanup(self):
"""清理插件资源"""
pass

def get_capabilities(self) -> List[str]:
"""获取插件能力"""
return []

def validate_config(self, config: Dict[str, Any]) -> bool:
"""验证配置"""
return True

##### 2. 插件管理器#

```
bash复制python

class PluginManager:
    """插件管理器"""

    def __init__(self):
        self.plugins: Dict[str, PluginInterface] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}
        self.plugin_dependencies: Dict[str, List[str]] = {}
        self.load_order: List[str] = []

    def register_plugin(self, plugin: PluginInterface,
                       config: Dict[str, Any] = None):
        """注册插件"""
        plugin_name = plugin.name

        # 检查是否已注册
        if plugin_name in self.plugins:
            logger.warning(f"Plugin already registered: {plugin_name}")
            return

        # 验证配置
        if config and not plugin.validate_config(config):
            raise ValueError(f"Invalid config for plugin: {plugin_name}")

        # 存储插件
        self.plugins[plugin_name] = plugin
        self.plugin_configs[plugin_name] = config or {}

        logger.info(f"Plugin registered: {plugin_name} v{plugin.version}")

    def load_plugin(self, plugin_path: str, config: Dict[str, Any] = None):
        """加载插件"""
        # 动态导入插件模块
        spec = importlib.util.spec_from_file_location("plugin", plugin_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # 获取插件类
        plugin_class = getattr(module, 'Plugin')

        # 实例化插件
        plugin = plugin_class()

        # 注册插件
        self.register_plugin(plugin, config)

    def initialize_plugins(self):
        """初始化所有插件"""
        # 解析依赖关系
        self._resolve_dependencies()

        # 按顺序初始化插件
        for plugin_name in self.load_order:
            plugin = self.plugins[plugin_name]
            config = self.plugin_configs[plugin_name]

            context = PluginContext(
                plugin_manager=self,
                config=config
            )

            try:
                plugin.initialize(context)
                logger.info(f"Plugin initialized: {plugin_name}")
            except Exception as e:
                logger.error(f"Failed to initialize plugin {plugin_name}: {e}")
                raise

    def execute_plugin(self, plugin_name: str,
                       request: PluginRequest) -> PluginResponse:
        """执行插件"""
        plugin = self.plugins.get(plugin_name)

        if not plugin:
            raise ValueError(f"Plugin not found: {plugin_name}")

        try:
            response = plugin.execute(request)
            return response
        except Exception as e:
            logger.error(f"Error executing plugin {plugin_name}: {e}")
            raise

    def cleanup_plugins(self):
        """清理所有插件"""
        for plugin_name in reversed(self.load_order):
            plugin = self.plugins[plugin_name]
            try:
                plugin.cleanup()
                logger.info(f"Plugin cleaned up: {plugin_name}")
            except Exception as e:
                logger.error(f"Error cleaning up plugin {plugin_name}: {e}")

    def _resolve_dependencies(self):
        """解析插件依赖关系"""
        # 构建依赖图
        graph = {}
        for plugin_name, deps in self.plugin_dependencies.items():
            graph[plugin_name] = deps

        # 拓扑排序
        self.load_order = self._topological_sort(graph)

    def _topological_sort(self, graph: Dict[str, List[str]]) -> List[str]:
        """拓扑排序"""
        visited = set()
        result = []

        def visit(node):
            if node in visited:
                return

            visited.add(node)

            for dep in graph.get(node, []):
                visit(dep)

            result.append(node)

        for node in graph:
            visit(node)

        return result

### 3. 插件上下文

class PluginContext:
"""插件上下文"""
def __init__(self, plugin_manager: PluginManager,
config: Dict[str, Any]):
self.plugin_manager = plugin_manager
self.config = config
self.shared_data: Dict[str, Any] = {}
self.event_bus: EventBus = EventBus()
def get_config(self, key: str, default: Any = None) -> Any:
"""获取配置"""
return self.config.get(key, default)
def set_shared_data(self, key: str, value: Any):
"""设置共享数据"""
self.shared_data[key] = value
def get_shared_data(self, key: str, default: Any = None) -> Any:
"""获取共享数据"""
return self.shared_data.get(key, default)
def emit_event(self, event_name: str, data: Dict[str, Any]):
"""发送事件"""
self.event_bus.emit(event_name, data)
def on_event(self, event_name: str, handler: callable):
"""监听事件"""
self.event_bus.on(event_name, handler)
```

```
python

class PluginManager:
    """插件管理器"""

    def __init__(self):
        self.plugins: Dict[str, PluginInterface] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}
        self.plugin_dependencies: Dict[str, List[str]] = {}
        self.load_order: List[str] = []

    def register_plugin(self, plugin: PluginInterface,
                       config: Dict[str, Any] = None):
        """注册插件"""
        plugin_name = plugin.name

        # 检查是否已注册
        if plugin_name in self.plugins:
            logger.warning(f"Plugin already registered: {plugin_name}")
            return

        # 验证配置
        if config and not plugin.validate_config(config):
            raise ValueError(f"Invalid config for plugin: {plugin_name}")

        # 存储插件
        self.plugins[plugin_name] = plugin
        self.plugin_configs[plugin_name] = config or {}

        logger.info(f"Plugin registered: {plugin_name} v{plugin.version}")

    def load_plugin(self, plugin_path: str, config: Dict[str, Any] = None):
        """加载插件"""
        # 动态导入插件模块
        spec = importlib.util.spec_from_file_location("plugin", plugin_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # 获取插件类
        plugin_class = getattr(module, 'Plugin')

        # 实例化插件
        plugin = plugin_class()

        # 注册插件
        self.register_plugin(plugin, config)

    def initialize_plugins(self):
        """初始化所有插件"""
        # 解析依赖关系
        self._resolve_dependencies()

        # 按顺序初始化插件
        for plugin_name in self.load_order:
            plugin = self.plugins[plugin_name]
            config = self.plugin_configs[plugin_name]

            context = PluginContext(
                plugin_manager=self,
                config=config
            )

            try:
                plugin.initialize(context)
                logger.info(f"Plugin initialized: {plugin_name}")
            except Exception as e:
                logger.error(f"Failed to initialize plugin {plugin_name}: {e}")
                raise

    def execute_plugin(self, plugin_name: str,
                       request: PluginRequest) -> PluginResponse:
        """执行插件"""
        plugin = self.plugins.get(plugin_name)

        if not plugin:
            raise ValueError(f"Plugin not found: {plugin_name}")

        try:
            response = plugin.execute(request)
            return response
        except Exception as e:
            logger.error(f"Error executing plugin {plugin_name}: {e}")
            raise

    def cleanup_plugins(self):
        """清理所有插件"""
        for plugin_name in reversed(self.load_order):
            plugin = self.plugins[plugin_name]
            try:
                plugin.cleanup()
                logger.info(f"Plugin cleaned up: {plugin_name}")
            except Exception as e:
                logger.error(f"Error cleaning up plugin {plugin_name}: {e}")

    def _resolve_dependencies(self):
        """解析插件依赖关系"""
        # 构建依赖图
        graph = {}
        for plugin_name, deps in self.plugin_dependencies.items():
            graph[plugin_name] = deps

        # 拓扑排序
        self.load_order = self._topological_sort(graph)

    def _topological_sort(self, graph: Dict[str, List[str]]) -> List[str]:
        """拓扑排序"""
        visited = set()
        result = []

        def visit(node):
            if node in visited:
                return

            visited.add(node)

            for dep in graph.get(node, []):
                visit(dep)

            result.append(node)

        for node in graph:
            visit(node)

        return result

### 3. 插件上下文

class PluginContext:
"""插件上下文"""
def __init__(self, plugin_manager: PluginManager,
config: Dict[str, Any]):
self.plugin_manager = plugin_manager
self.config = config
self.shared_data: Dict[str, Any] = {}
self.event_bus: EventBus = EventBus()
def get_config(self, key: str, default: Any = None) -> Any:
"""获取配置"""
return self.config.get(key, default)
def set_shared_data(self, key: str, value: Any):
"""设置共享数据"""
self.shared_data[key] = value
def get_shared_data(self, key: str, default: Any = None) -> Any:
"""获取共享数据"""
return self.shared_data.get(key, default)
def emit_event(self, event_name: str, data: Dict[str, Any]):
"""发送事件"""
self.event_bus.emit(event_name, data)
def on_event(self, event_name: str, handler: callable):
"""监听事件"""
self.event_bus.on(event_name, handler)
```

#### 28.4.3 工具扩展机制#

##### 1. 工具注册#

```
bash复制python

class ToolRegistry:
    """工具注册表"""

    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        self.tool_categories: Dict[str, List[str]] = {}

    def register_tool(self, tool: Tool, category: str = None):
        """注册工具"""
        tool_id = tool.id

        if tool_id in self.tools:
            logger.warning(f"Tool already registered: {tool_id}")
            return

        self.tools[tool_id] = tool

        if category:
            if category not in self.tool_categories:
                self.tool_categories[category] = []
            self.tool_categories[category].append(tool_id)

        logger.info(f"Tool registered: {tool_id}")

    def get_tool(self, tool_id: str) -> Tool:
        """获取工具"""
        return self.tools.get(tool_id)

    def get_tools_by_category(self, category: str) -> List[Tool]:
        """按类别获取工具"""
        tool_ids = self.tool_categories.get(category, [])
        return [self.tools[tid] for tid in tool_ids]

    def list_tools(self) -> List[str]:
        """列出所有工具"""
        return list(self.tools.keys())

### 2. 自定义工具

class CustomTool(Tool):
"""自定义工具"""
def __init__(self, tool_id: str, name: str,
description: str, handler: callable):
super().__init__(tool_id, name, description)
self.handler = handler
def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行工具"""
try:
result = self.handler(parameters)
return ToolResult(
success=True,
data=result,
message="Execution successful"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message="Execution failed"
)
# 使用示例
def custom_handler(params: Dict[str, Any]) -> Any:
"""自定义处理函数"""
# 实现自定义逻辑
return {"result": "custom result"}
custom_tool = CustomTool(
tool_id="custom_tool",
name="Custom Tool",
description="A custom tool for specific tasks",
handler=custom_handler
)
registry = ToolRegistry()
registry.register_tool(custom_tool, category="custom")
```

```
python

class ToolRegistry:
    """工具注册表"""

    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        self.tool_categories: Dict[str, List[str]] = {}

    def register_tool(self, tool: Tool, category: str = None):
        """注册工具"""
        tool_id = tool.id

        if tool_id in self.tools:
            logger.warning(f"Tool already registered: {tool_id}")
            return

        self.tools[tool_id] = tool

        if category:
            if category not in self.tool_categories:
                self.tool_categories[category] = []
            self.tool_categories[category].append(tool_id)

        logger.info(f"Tool registered: {tool_id}")

    def get_tool(self, tool_id: str) -> Tool:
        """获取工具"""
        return self.tools.get(tool_id)

    def get_tools_by_category(self, category: str) -> List[Tool]:
        """按类别获取工具"""
        tool_ids = self.tool_categories.get(category, [])
        return [self.tools[tid] for tid in tool_ids]

    def list_tools(self) -> List[str]:
        """列出所有工具"""
        return list(self.tools.keys())

### 2. 自定义工具

class CustomTool(Tool):
"""自定义工具"""
def __init__(self, tool_id: str, name: str,
description: str, handler: callable):
super().__init__(tool_id, name, description)
self.handler = handler
def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行工具"""
try:
result = self.handler(parameters)
return ToolResult(
success=True,
data=result,
message="Execution successful"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message="Execution failed"
)
# 使用示例
def custom_handler(params: Dict[str, Any]) -> Any:
"""自定义处理函数"""
# 实现自定义逻辑
return {"result": "custom result"}
custom_tool = CustomTool(
tool_id="custom_tool",
name="Custom Tool",
description="A custom tool for specific tasks",
handler=custom_handler
)
registry = ToolRegistry()
registry.register_tool(custom_tool, category="custom")
```

#### 28.4.4 集成扩展#

##### 1. IDE 集成接口#

```
bash复制python

class IDEIntegration(ABC):
    """IDE 集成接口"""

    @abstractmethod
    def get_current_file(self) -> str:
        """获取当前文件"""
        pass

    @abstractmethod
    def get_selection(self) -> str:
        """获取选中的文本"""
        pass

    @abstractmethod
    def open_file(self, file_path: str, line: int = None):
        """打开文件"""
        pass

    @abstractmethod
    def insert_text(self, text: str, position: int = None):
        """插入文本"""
        pass

    @abstractmethod
    def show_notification(self, message: str, level: str = "info"):
        """显示通知"""
        pass

### 2. VS Code 集成

class VSCodeIntegration(IDEIntegration):
"""VS Code 集成"""
def __init__(self):
self.extension_api = None
def connect(self, extension_api):
"""连接到 VS Code 扩展 API"""
self.extension_api = extension_api
def get_current_file(self) -> str:
"""获取当前文件"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
return self.extension_api.window.activeTextEditor.document.uri.fsPath
def get_selection(self) -> str:
"""获取选中的文本"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
editor = self.extension_api.window.activeTextEditor
selection = editor.selection
return editor.document.getText(selection)
def open_file(self, file_path: str, line: int = None):
"""打开文件"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
uri = self.extension_api.Uri.file(file_path)
self.extension_api.commands.executeCommand(
'vscode.open',
uri,
{
'selection': self.extension_api.Range(
self.extension_api.Position(line or 0, 0),
self.extension_api.Position(line or 0, 0)
)
}
)
def insert_text(self, text: str, position: int = None):
"""插入文本"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
editor = self.extension_api.window.activeTextEditor
edit_position = editor.selection.active
editor.edit(lambda editBuilder: editBuilder.insert(edit_position, text))
def show_notification(self, message: str, level: str = "info"):
"""显示通知"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
self.extension_api.window.showInformationMessage(message)
```

```
python

class IDEIntegration(ABC):
    """IDE 集成接口"""

    @abstractmethod
    def get_current_file(self) -> str:
        """获取当前文件"""
        pass

    @abstractmethod
    def get_selection(self) -> str:
        """获取选中的文本"""
        pass

    @abstractmethod
    def open_file(self, file_path: str, line: int = None):
        """打开文件"""
        pass

    @abstractmethod
    def insert_text(self, text: str, position: int = None):
        """插入文本"""
        pass

    @abstractmethod
    def show_notification(self, message: str, level: str = "info"):
        """显示通知"""
        pass

### 2. VS Code 集成

class VSCodeIntegration(IDEIntegration):
"""VS Code 集成"""
def __init__(self):
self.extension_api = None
def connect(self, extension_api):
"""连接到 VS Code 扩展 API"""
self.extension_api = extension_api
def get_current_file(self) -> str:
"""获取当前文件"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
return self.extension_api.window.activeTextEditor.document.uri.fsPath
def get_selection(self) -> str:
"""获取选中的文本"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
editor = self.extension_api.window.activeTextEditor
selection = editor.selection
return editor.document.getText(selection)
def open_file(self, file_path: str, line: int = None):
"""打开文件"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
uri = self.extension_api.Uri.file(file_path)
self.extension_api.commands.executeCommand(
'vscode.open',
uri,
{
'selection': self.extension_api.Range(
self.extension_api.Position(line or 0, 0),
self.extension_api.Position(line or 0, 0)
)
}
)
def insert_text(self, text: str, position: int = None):
"""插入文本"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
editor = self.extension_api.window.activeTextEditor
edit_position = editor.selection.active
editor.edit(lambda editBuilder: editBuilder.insert(edit_position, text))
def show_notification(self, message: str, level: str = "info"):
"""显示通知"""
if not self.extension_api:
raise RuntimeError("Not connected to VS Code")
self.extension_api.window.showInformationMessage(message)
```

#### 28.4.5 配置扩展#

##### 1. 配置系统#

```
bash复制python

class ConfigurationSystem:
    """配置系统"""

    def __init__(self):
        self.configs: Dict[str, Any] = {}
        self.config_sources: List[ConfigSource] = []
        self.validators: Dict[str, List[callable]] = {}

    def add_source(self, source: ConfigSource):
        """添加配置源"""
        self.config_sources.append(source)

    def add_validator(self, key: str, validator: callable):
        """添加验证器"""
        if key not in self.validators:
            self.validators[key] = []
        self.validators[key].append(validator)

    def load(self):
        """加载配置"""
        for source in self.config_sources:
            config = source.load()
            self._merge_config(config)

    def get(self, key: str, default: Any = None) -> Any:
        """获取配置"""
        value = self._get_nested_value(key)

        if value is None:
            return default

        # 验证值
        validators = self.validators.get(key, [])
        for validator in validators:
            if not validator(value):
                raise ValueError(f"Invalid value for key: {key}")

        return value

    def set(self, key: str, value: Any):
        """设置配置"""
        self._set_nested_value(key, value)

    def _merge_config(self, config: Dict[str, Any]):
        """合并配置"""
        for key, value in config.items():
            if key in self.configs and isinstance(self.configs[key], dict) and isinstance(value, dict):
                self.configs[key].update(value)
            else:
                self.configs[key] = value

    def _get_nested_value(self, key: str) -> Any:
        """获取嵌套值"""
        keys = key.split('.')
        value = self.configs

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return None

        return value

    def _set_nested_value(self, key: str, value: Any):
        """设置嵌套值"""
        keys = key.split('.')
        config = self.configs

        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]

        config[keys[-1]] = value

### 2. 配置源

class ConfigSource(ABC):
"""配置源"""
@abstractmethod
def load(self) -> Dict[str, Any]:
"""加载配置"""
pass
class FileConfigSource(ConfigSource):
"""文件配置源"""
def __init__(self, file_path: str):
self.file_path = file_path
def load(self) -> Dict[str, Any]:
"""从文件加载配置"""
with open(self.file_path, 'r') as f:
return json.load(f)
class EnvironmentConfigSource(ConfigSource):
"""环境变量配置源"""
def __init__(self, prefix: str = "CLAUDE_"):
self.prefix = prefix
def load(self) -> Dict[str, Any]:
"""从环境变量加载配置"""
config = {}
for key, value in os.environ.items():
if key.startswith(self.prefix):
config_key = key[len(self.prefix):].lower()
config[config_key] = value
return config
```

```
python

class ConfigurationSystem:
    """配置系统"""

    def __init__(self):
        self.configs: Dict[str, Any] = {}
        self.config_sources: List[ConfigSource] = []
        self.validators: Dict[str, List[callable]] = {}

    def add_source(self, source: ConfigSource):
        """添加配置源"""
        self.config_sources.append(source)

    def add_validator(self, key: str, validator: callable):
        """添加验证器"""
        if key not in self.validators:
            self.validators[key] = []
        self.validators[key].append(validator)

    def load(self):
        """加载配置"""
        for source in self.config_sources:
            config = source.load()
            self._merge_config(config)

    def get(self, key: str, default: Any = None) -> Any:
        """获取配置"""
        value = self._get_nested_value(key)

        if value is None:
            return default

        # 验证值
        validators = self.validators.get(key, [])
        for validator in validators:
            if not validator(value):
                raise ValueError(f"Invalid value for key: {key}")

        return value

    def set(self, key: str, value: Any):
        """设置配置"""
        self._set_nested_value(key, value)

    def _merge_config(self, config: Dict[str, Any]):
        """合并配置"""
        for key, value in config.items():
            if key in self.configs and isinstance(self.configs[key], dict) and isinstance(value, dict):
                self.configs[key].update(value)
            else:
                self.configs[key] = value

    def _get_nested_value(self, key: str) -> Any:
        """获取嵌套值"""
        keys = key.split('.')
        value = self.configs

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return None

        return value

    def _set_nested_value(self, key: str, value: Any):
        """设置嵌套值"""
        keys = key.split('.')
        config = self.configs

        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]

        config[keys[-1]] = value

### 2. 配置源

class ConfigSource(ABC):
"""配置源"""
@abstractmethod
def load(self) -> Dict[str, Any]:
"""加载配置"""
pass
class FileConfigSource(ConfigSource):
"""文件配置源"""
def __init__(self, file_path: str):
self.file_path = file_path
def load(self) -> Dict[str, Any]:
"""从文件加载配置"""
with open(self.file_path, 'r') as f:
return json.load(f)
class EnvironmentConfigSource(ConfigSource):
"""环境变量配置源"""
def __init__(self, prefix: str = "CLAUDE_"):
self.prefix = prefix
def load(self) -> Dict[str, Any]:
"""从环境变量加载配置"""
config = {}
for key, value in os.environ.items():
if key.startswith(self.prefix):
config_key = key[len(self.prefix):].lower()
config[config_key] = value
return config
```

---

## 5 性能优化

**URL**: https://claudecode.tangshuang.net/course/28.5%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96

#### 28.5.1 性能优化概述#

Claude Code 的性能优化涉及多个层面，包括：

True. 响应速度：减少用户请求的响应时间
True. 资源利用：优化 CPU、内存、磁盘等资源的使用
True. 并发处理：提高并发请求的处理能力
True. 缓存策略：有效利用缓存减少重复计算
True. 算法优化：选择和实现高效的算法

#### 28.5.2 缓存优化#

##### 1. 多级缓存架构#

class MultiLevelCache:
"""多级缓存"""

def init(self):
self.l1_cache: Dict[str, Any] = {}  # 内存缓存
self.l2_cache: Dict[str, Any] = {}   # 本地缓存
self.l3_cache: Optional[CacheClient] = None  # 分布式缓存

self.l1_size = 1000
self.l1_hits = 0
self.l1_misses = 0

self.l2_size = 10000
self.l2_hits = 0
self.l2_misses = 0

def set_l3_cache(self, cache_client: CacheClient):
"""设置三级缓存"""
self.l3_cache = cache_client

def get(self, key: str) -> Optional[Any]:
"""获取缓存值"""

### L1 缓存

if key in self.l1_cache:
self.l1_hits += 1
return self.l1_cache[key]
self.l1_misses += 1

### L2 缓存

if key in self.l2_cache:
self.l2_hits += 1
value = self.l2_cache[key]

### 提升到 L1

self._promote_to_l1(key, value)
return value
self.l2_misses += 1

### L3 缓存

if self.l3_cache:
value = self.l3_cache.get(key)
if value is not None:

### 提升到 L2 和 L1

self._promote_to_l2(key, value)
self._promote_to_l1(key, value)
return value

return None

def set(self, key: str, value: Any, ttl: int = 3600):
"""设置缓存值"""

### L1 缓存

self._set_l1(key, value)

### L2 缓存

self._set_l2(key, value, ttl)

### L3 缓存

if self.l3_cache:
self.l3_cache.set(key, value, ttl)

def _set_l1(self, key: str, value: Any):
"""设置 L1 缓存"""
if len(self.l1_cache) >= self.l1_size:

### LRU 淘汰

self._evict_lru(self.l1_cache)
self.l1_cache[key] = value

def _set_l2(self, key: str, value: Any, ttl: int):
"""设置 L2 缓存"""
if len(self.l2_cache) >= self.l2_size:

### LRU 淘汰

self._evict_lru(self.l2_cache)
self.l2_cache[key] = {
'value': value,
'expires': time.time() + ttl
}

def _promote_to_l1(self, key: str, value: Any):
"""提升到 L1 缓存"""
self._set_l1(key, value)

def _promote_to_l2(self, key: str, value: Any):
"""提升到 L2 缓存"""
self._set_l2(key, value, 3600)

def _evict_lru(self, cache: Dict[str, Any]):
"""淘汰 LRU 条目"""
if not cache:
return

### 简单实现：删除第一个条目

oldest_key = next(iter(cache))
del cache[oldest_key]

def get_stats(self) -> Dict[str, Any]:
"""获取缓存统计"""
l1_hit_rate = self.l1_hits / (self.l1_hits + self.l1_misses) if (self.l1_hits + self.l1_misses) > 0 else 0
l2_hit_rate = self.l2_hits / (self.l2_hits + self.l2_misses) if (self.l2_hits + self.l2_misses) > 0 else 0

return {
'l1': {
'size': len(self.l1_cache),
'hits': self.l1_hits,
'misses': self.l1_misses,
'hit_rate': l1_hit_rate
},
'l2': {
'size': len(self.l2_cache),
'hits': self.l2_hits,
'misses': self.l2_misses,
'hit_rate': l2_hit_rate
}
}

##### 2. 智能缓存策略#

```
bash复制python

class SmartCache:
    """智能缓存"""

    def __init__(self):
        self.cache: Dict[str, CacheEntry] = {}
        self.access_patterns: Dict[str, AccessPattern] = {}
        self.max_size = 10000

    def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        entry = self.cache.get(key)

        if entry is None:
            return None

        # 检查是否过期
        if entry.is_expired():
            del self.cache[key]
            return None

        # 更新访问模式
        self._update_access_pattern(key)

        return entry.value

    def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存值"""
        # 预测 TTL
        if ttl is None:
            ttl = self._predict_ttl(key)

        entry = CacheEntry(
            key=key,
            value=value,
            ttl=ttl,
            created_at=time.time()
        )

        # 检查缓存大小
        if len(self.cache) >= self.max_size:
            self._evict()

        self.cache[key] = entry

    def _update_access_pattern(self, key: str):
        """更新访问模式"""
        if key not in self.access_patterns:
            self.access_patterns[key] = AccessPattern(key)

        pattern = self.access_patterns[key]
        pattern.record_access()

    def _predict_ttl(self, key: str) -> int:
        """预测 TTL"""
        pattern = self.access_patterns.get(key)

        if pattern is None:
            return 3600  # 默认 1 小时

        # 基于访问频率预测
        frequency = pattern.get_frequency()

        if frequency > 10:  # 高频访问
            return 7200  # 2 小时
        elif frequency > 5:  # 中频访问
            return 3600  # 1 小时
        else:  # 低频访问
            return 1800  # 30 分钟

    def _evict(self):
        """淘汰缓存条目"""
        # 基于访问模式进行淘汰
        scores = {}
        for key, pattern in self.access_patterns.items():
            score = pattern.get_score()
            scores[key] = score

        # 淘汰分数最低的条目
        if scores:
            worst_key = min(scores, key=scores.get)
            if worst_key in self.cache:
                del self.cache[worst_key]
            if worst_key in self.access_patterns:
                del self.access_patterns[worst_key]

class CacheEntry:
    """缓存条目"""

    def __init__(self, key: str, value: Any, ttl: int, created_at: float):
        self.key = key
        self.value = value
        self.ttl = ttl
        self.created_at = created_at

    def is_expired(self) -> bool:
        """检查是否过期"""
        if self.ttl is None:
            return False
        return time.time() > self.created_at + self.ttl

class AccessPattern:
    """访问模式"""

    def __init__(self, key: str):
        self.key = key
        self.access_times: List[float] = []
        self.max_history = 100

    def record_access(self):
        """记录访问"""
        self.access_times.append(time.time())

        # 限制历史记录大小
        if len(self.access_times) > self.max_history:
            self.access_times = self.access_times[-self.max_history:]

    def get_frequency(self) -> float:
        """获取访问频率"""
        if len(self.access_times) < 2:
            return 0

        time_span = self.access_times[-1] - self.access_times[0]
        if time_span == 0:
            return len(self.access_times)

        return len(self.access_times) / time_span

    def get_score(self) -> float:
        """获取分数（用于淘汰决策）"""
        frequency = self.get_frequency()
        recency = self._get_recency()

        # 综合频率和最近性
        return frequency * 0.7 + recency * 0.3

    def _get_recency(self) -> float:
        """获取最近性"""
        if not self.access_times:
            return 0

        last_access = self.access_times[-1]
        time_since_last = time.time() - last_access

        # 越近访问，分数越高
        return 1.0 / (1.0 + time_since_last)

## 28.5.3 并发优化

### 1. 异步任务处理

class AsyncTaskProcessor:
"""异步任务处理器"""
def __init__(self, max_workers: int = 4):
self.task_queue: asyncio.Queue = asyncio.Queue()
self.max_workers = max_workers
self.workers: List[asyncio.Task] = []
self.running = False
async def start(self):
"""启动处理器"""
self.running = True
# 创建工作协程
for i in range(self.max_workers):
worker = asyncio.create_task(self._worker(f"worker-{i}"))
self.workers.append(worker)
async def stop(self):
"""停止处理器"""
self.running = False
# 等待所有工作协程完成
await asyncio.gather(*self.workers, return_exceptions=True)
async def submit_task(self, task: AsyncTask):
"""提交任务"""
await self.task_queue.put(task)
async def _worker(self, worker_name: str):
"""工作协程"""
logger.info(f"{worker_name} started")
while self.running:
try:
# 获取任务
task = await asyncio.wait_for(
self.task_queue.get(),
timeout=1.0
)
# 执行任务
await self._execute_task(worker_name, task)
except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"{worker_name} error: {e}")
logger.info(f"{worker_name} stopped")
async def _execute_task(self, worker_name: str, task: AsyncTask):
"""执行任务"""
task.status = "running"
task.started_at = time.time()
try:
result = await task.execute()
task.result = result
task.status = "completed"
except Exception as e:
task.error = str(e)
task.status = "failed"
finally:
task.completed_at = time.time()
task.duration = task.completed_at - task.started_at
```

```
python

class SmartCache:
    """智能缓存"""

    def __init__(self):
        self.cache: Dict[str, CacheEntry] = {}
        self.access_patterns: Dict[str, AccessPattern] = {}
        self.max_size = 10000

    def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        entry = self.cache.get(key)

        if entry is None:
            return None

        # 检查是否过期
        if entry.is_expired():
            del self.cache[key]
            return None

        # 更新访问模式
        self._update_access_pattern(key)

        return entry.value

    def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存值"""
        # 预测 TTL
        if ttl is None:
            ttl = self._predict_ttl(key)

        entry = CacheEntry(
            key=key,
            value=value,
            ttl=ttl,
            created_at=time.time()
        )

        # 检查缓存大小
        if len(self.cache) >= self.max_size:
            self._evict()

        self.cache[key] = entry

    def _update_access_pattern(self, key: str):
        """更新访问模式"""
        if key not in self.access_patterns:
            self.access_patterns[key] = AccessPattern(key)

        pattern = self.access_patterns[key]
        pattern.record_access()

    def _predict_ttl(self, key: str) -> int:
        """预测 TTL"""
        pattern = self.access_patterns.get(key)

        if pattern is None:
            return 3600  # 默认 1 小时

        # 基于访问频率预测
        frequency = pattern.get_frequency()

        if frequency > 10:  # 高频访问
            return 7200  # 2 小时
        elif frequency > 5:  # 中频访问
            return 3600  # 1 小时
        else:  # 低频访问
            return 1800  # 30 分钟

    def _evict(self):
        """淘汰缓存条目"""
        # 基于访问模式进行淘汰
        scores = {}
        for key, pattern in self.access_patterns.items():
            score = pattern.get_score()
            scores[key] = score

        # 淘汰分数最低的条目
        if scores:
            worst_key = min(scores, key=scores.get)
            if worst_key in self.cache:
                del self.cache[worst_key]
            if worst_key in self.access_patterns:
                del self.access_patterns[worst_key]

class CacheEntry:
    """缓存条目"""

    def __init__(self, key: str, value: Any, ttl: int, created_at: float):
        self.key = key
        self.value = value
        self.ttl = ttl
        self.created_at = created_at

    def is_expired(self) -> bool:
        """检查是否过期"""
        if self.ttl is None:
            return False
        return time.time() > self.created_at + self.ttl

class AccessPattern:
    """访问模式"""

    def __init__(self, key: str):
        self.key = key
        self.access_times: List[float] = []
        self.max_history = 100

    def record_access(self):
        """记录访问"""
        self.access_times.append(time.time())

        # 限制历史记录大小
        if len(self.access_times) > self.max_history:
            self.access_times = self.access_times[-self.max_history:]

    def get_frequency(self) -> float:
        """获取访问频率"""
        if len(self.access_times) < 2:
            return 0

        time_span = self.access_times[-1] - self.access_times[0]
        if time_span == 0:
            return len(self.access_times)

        return len(self.access_times) / time_span

    def get_score(self) -> float:
        """获取分数（用于淘汰决策）"""
        frequency = self.get_frequency()
        recency = self._get_recency()

        # 综合频率和最近性
        return frequency * 0.7 + recency * 0.3

    def _get_recency(self) -> float:
        """获取最近性"""
        if not self.access_times:
            return 0

        last_access = self.access_times[-1]
        time_since_last = time.time() - last_access

        # 越近访问，分数越高
        return 1.0 / (1.0 + time_since_last)

## 28.5.3 并发优化

### 1. 异步任务处理

class AsyncTaskProcessor:
"""异步任务处理器"""
def __init__(self, max_workers: int = 4):
self.task_queue: asyncio.Queue = asyncio.Queue()
self.max_workers = max_workers
self.workers: List[asyncio.Task] = []
self.running = False
async def start(self):
"""启动处理器"""
self.running = True
# 创建工作协程
for i in range(self.max_workers):
worker = asyncio.create_task(self._worker(f"worker-{i}"))
self.workers.append(worker)
async def stop(self):
"""停止处理器"""
self.running = False
# 等待所有工作协程完成
await asyncio.gather(*self.workers, return_exceptions=True)
async def submit_task(self, task: AsyncTask):
"""提交任务"""
await self.task_queue.put(task)
async def _worker(self, worker_name: str):
"""工作协程"""
logger.info(f"{worker_name} started")
while self.running:
try:
# 获取任务
task = await asyncio.wait_for(
self.task_queue.get(),
timeout=1.0
)
# 执行任务
await self._execute_task(worker_name, task)
except asyncio.TimeoutError:
continue
except Exception as e:
logger.error(f"{worker_name} error: {e}")
logger.info(f"{worker_name} stopped")
async def _execute_task(self, worker_name: str, task: AsyncTask):
"""执行任务"""
task.status = "running"
task.started_at = time.time()
try:
result = await task.execute()
task.result = result
task.status = "completed"
except Exception as e:
task.error = str(e)
task.status = "failed"
finally:
task.completed_at = time.time()
task.duration = task.completed_at - task.started_at
```

##### 2. 任务池管理#

```
bash复制python

class TaskPool:
    """任务池"""

    def __init__(self, max_size: int = 100):
        self.max_size = max_size
        self.tasks: Dict[str, AsyncTask] = {}
        self.task_queue: asyncio.Queue = asyncio.Queue()
        self.completed_tasks: List[str] = []

    async def add_task(self, task: AsyncTask) -> str:
        """添加任务"""
        task_id = task.id

        # 检查任务池大小
        if len(self.tasks) >= self.max_size:
            # 等待有任务完成
            await self._wait_for_completion()

        self.tasks[task_id] = task
        await self.task_queue.put(task)

        return task_id

    async def get_task_result(self, task_id: str, timeout: float = None) -> Any:
        """获取任务结果"""
        task = self.tasks.get(task_id)

        if not task:
            raise ValueError(f"Task not found: {task_id}")

        # 等待任务完成
        if task.status != "completed":
            await self._wait_for_task(task, timeout)

        if task.status == "failed":
            raise Exception(task.error)

        return task.result

    async def _wait_for_completion(self):
        """等待任务完成"""
        while len(self.tasks) >= self.max_size:
            # 检查是否有完成的任务
            completed = [tid for tid, task in self.tasks.items()
                        if task.status in ["completed", "failed"]]

            if completed:
                # 清理完成的任务
                for tid in completed:
                    del self.tasks[tid]
                    self.completed_tasks.append(tid)
                break

            await asyncio.sleep(0.1)

    async def _wait_for_task(self, task: AsyncTask, timeout: float):
        """等待任务完成"""
        start_time = time.time()

        while task.status not in ["completed", "failed"]:
            if timeout and (time.time() - start_time) > timeout:
                raise TimeoutError(f"Task timeout: {task.id}")

            await asyncio.sleep(0.1)

## 28.5.4 算法优化

### 1. 字符串匹配优化

class StringMatcher:
"""字符串匹配器"""
def __init__(self):
self.patterns: Dict[str, List[str]] = {}
self.trie: Trie = Trie()
def add_pattern(self, category: str, pattern: str):
"""添加模式"""
if category not in self.patterns:
self.patterns[category] = []
self.patterns[category].append(pattern)
self.trie.insert(pattern)
def match(self, text: str) -> List[MatchResult]:
"""匹配文本"""
results = []
# 使用 Trie 进行快速匹配
matches = self.trie.search(text)
for match in matches:
result = MatchResult(
pattern=match.pattern,
start=match.start,
end=match.end,
text=text[match.start:match.end]
)
results.append(result)
return results
class TrieNode:
"""Trie 节点"""
def __init__(self):
self.children: Dict[str, TrieNode] = {}
self.is_end = False
self.pattern: Optional[str] = None
class Trie:
"""Trie 树"""
def __init__(self):
self.root = TrieNode()
def insert(self, pattern: str):
"""插入模式"""
node = self.root
for char in pattern:
if char not in node.children:
node.children[char] = TrieNode()
node = node.children[char]
node.is_end = True
node.pattern = pattern
def search(self, text: str) -> List[Dict[str, Any]]:
"""搜索文本"""
matches = []
for i in range(len(text)):
node = self.root
j = i
while j < len(text) and text[j] in node.children:
node = node.children[text[j]]
j += 1
if node.is_end:
matches.append({
'pattern': node.pattern,
'start': i,
'end': j
})
return matches
```

```
python

class TaskPool:
    """任务池"""

    def __init__(self, max_size: int = 100):
        self.max_size = max_size
        self.tasks: Dict[str, AsyncTask] = {}
        self.task_queue: asyncio.Queue = asyncio.Queue()
        self.completed_tasks: List[str] = []

    async def add_task(self, task: AsyncTask) -> str:
        """添加任务"""
        task_id = task.id

        # 检查任务池大小
        if len(self.tasks) >= self.max_size:
            # 等待有任务完成
            await self._wait_for_completion()

        self.tasks[task_id] = task
        await self.task_queue.put(task)

        return task_id

    async def get_task_result(self, task_id: str, timeout: float = None) -> Any:
        """获取任务结果"""
        task = self.tasks.get(task_id)

        if not task:
            raise ValueError(f"Task not found: {task_id}")

        # 等待任务完成
        if task.status != "completed":
            await self._wait_for_task(task, timeout)

        if task.status == "failed":
            raise Exception(task.error)

        return task.result

    async def _wait_for_completion(self):
        """等待任务完成"""
        while len(self.tasks) >= self.max_size:
            # 检查是否有完成的任务
            completed = [tid for tid, task in self.tasks.items()
                        if task.status in ["completed", "failed"]]

            if completed:
                # 清理完成的任务
                for tid in completed:
                    del self.tasks[tid]
                    self.completed_tasks.append(tid)
                break

            await asyncio.sleep(0.1)

    async def _wait_for_task(self, task: AsyncTask, timeout: float):
        """等待任务完成"""
        start_time = time.time()

        while task.status not in ["completed", "failed"]:
            if timeout and (time.time() - start_time) > timeout:
                raise TimeoutError(f"Task timeout: {task.id}")

            await asyncio.sleep(0.1)

## 28.5.4 算法优化

### 1. 字符串匹配优化

class StringMatcher:
"""字符串匹配器"""
def __init__(self):
self.patterns: Dict[str, List[str]] = {}
self.trie: Trie = Trie()
def add_pattern(self, category: str, pattern: str):
"""添加模式"""
if category not in self.patterns:
self.patterns[category] = []
self.patterns[category].append(pattern)
self.trie.insert(pattern)
def match(self, text: str) -> List[MatchResult]:
"""匹配文本"""
results = []
# 使用 Trie 进行快速匹配
matches = self.trie.search(text)
for match in matches:
result = MatchResult(
pattern=match.pattern,
start=match.start,
end=match.end,
text=text[match.start:match.end]
)
results.append(result)
return results
class TrieNode:
"""Trie 节点"""
def __init__(self):
self.children: Dict[str, TrieNode] = {}
self.is_end = False
self.pattern: Optional[str] = None
class Trie:
"""Trie 树"""
def __init__(self):
self.root = TrieNode()
def insert(self, pattern: str):
"""插入模式"""
node = self.root
for char in pattern:
if char not in node.children:
node.children[char] = TrieNode()
node = node.children[char]
node.is_end = True
node.pattern = pattern
def search(self, text: str) -> List[Dict[str, Any]]:
"""搜索文本"""
matches = []
for i in range(len(text)):
node = self.root
j = i
while j < len(text) and text[j] in node.children:
node = node.children[text[j]]
j += 1
if node.is_end:
matches.append({
'pattern': node.pattern,
'start': i,
'end': j
})
return matches
```

##### 2. 向量搜索优化#

```
bash复制python

class VectorSearcher:
    """向量搜索器"""

    def __init__(self, dimension: int):
        self.dimension = dimension
        self.vectors: Dict[str, np.ndarray] = {}
        self.index: Optional[faiss.Index] = None

    def add_vector(self, vector_id: str, vector: np.ndarray):
        """添加向量"""
        if len(vector) != self.dimension:
            raise ValueError("Vector dimension mismatch")

        self.vectors[vector_id] = vector

    def build_index(self):
        """构建索引"""
        if not self.vectors:
            return

        # 创建 FAISS 索引
        self.index = faiss.IndexFlatL2(self.dimension)

        # 添加向量
        vectors = np.array(list(self.vectors.values()))
        self.index.add(vectors)

    def search(self, query: np.ndarray, k: int = 10) -> List[SearchResult]:
        """搜索相似向量"""
        if not self.index:
            self.build_index()

        # 搜索
        distances, indices = self.index.search(
            query.reshape(1, -1),
            k
        )

        # 构建结果
        results = []
        vector_ids = list(self.vectors.keys())

        for i, idx in enumerate(indices[0]):
            if idx >= 0 and idx < len(vector_ids):
                result = SearchResult(
                    vector_id=vector_ids[idx],
                    distance=float(distances[0][i]),
                    similarity=1.0 / (1.0 + float(distances[0][i]))
                )
                results.append(result)

        return results

## 28.5.5 资源优化

### 1. 内存管理

class MemoryManager:
"""内存管理器"""
def __init__(self, max_memory: int = 1024 * 1024 * 1024):  # 1GB
self.max_memory = max_memory
self.used_memory = 0
self.allocations: Dict[str, MemoryAllocation] = {}
def allocate(self, allocation_id: str, size: int) -> bool:
"""分配内存"""
if self.used_memory + size > self.max_memory:
# 尝试释放一些内存
if not self._free_memory(size):
return False
allocation = MemoryAllocation(
id=allocation_id,
size=size,
allocated_at=time.time()
)
self.allocations[allocation_id] = allocation
self.used_memory += size
return True
def deallocate(self, allocation_id: str):
"""释放内存"""
allocation = self.allocations.get(allocation_id)
if allocation:
self.used_memory -= allocation.size
del self.allocations[allocation_id]
def _free_memory(self, required_size: int) -> bool:
"""释放内存"""
# 按使用时间排序
sorted_allocations = sorted(
self.allocations.values(),
key=lambda x: x.allocated_at
)
freed = 0
for allocation in sorted_allocations:
self.deallocate(allocation.id)
freed += allocation.size
if freed >= required_size:
return True
return False
def get_stats(self) -> Dict[str, Any]:
"""获取统计信息"""
return {
'max_memory': self.max_memory,
'used_memory': self.used_memory,
'free_memory': self.max_memory - self.used_memory,
'utilization': self.used_memory / self.max_memory,
'num_allocations': len(self.allocations)
}
```

```
python

class VectorSearcher:
    """向量搜索器"""

    def __init__(self, dimension: int):
        self.dimension = dimension
        self.vectors: Dict[str, np.ndarray] = {}
        self.index: Optional[faiss.Index] = None

    def add_vector(self, vector_id: str, vector: np.ndarray):
        """添加向量"""
        if len(vector) != self.dimension:
            raise ValueError("Vector dimension mismatch")

        self.vectors[vector_id] = vector

    def build_index(self):
        """构建索引"""
        if not self.vectors:
            return

        # 创建 FAISS 索引
        self.index = faiss.IndexFlatL2(self.dimension)

        # 添加向量
        vectors = np.array(list(self.vectors.values()))
        self.index.add(vectors)

    def search(self, query: np.ndarray, k: int = 10) -> List[SearchResult]:
        """搜索相似向量"""
        if not self.index:
            self.build_index()

        # 搜索
        distances, indices = self.index.search(
            query.reshape(1, -1),
            k
        )

        # 构建结果
        results = []
        vector_ids = list(self.vectors.keys())

        for i, idx in enumerate(indices[0]):
            if idx >= 0 and idx < len(vector_ids):
                result = SearchResult(
                    vector_id=vector_ids[idx],
                    distance=float(distances[0][i]),
                    similarity=1.0 / (1.0 + float(distances[0][i]))
                )
                results.append(result)

        return results

## 28.5.5 资源优化

### 1. 内存管理

class MemoryManager:
"""内存管理器"""
def __init__(self, max_memory: int = 1024 * 1024 * 1024):  # 1GB
self.max_memory = max_memory
self.used_memory = 0
self.allocations: Dict[str, MemoryAllocation] = {}
def allocate(self, allocation_id: str, size: int) -> bool:
"""分配内存"""
if self.used_memory + size > self.max_memory:
# 尝试释放一些内存
if not self._free_memory(size):
return False
allocation = MemoryAllocation(
id=allocation_id,
size=size,
allocated_at=time.time()
)
self.allocations[allocation_id] = allocation
self.used_memory += size
return True
def deallocate(self, allocation_id: str):
"""释放内存"""
allocation = self.allocations.get(allocation_id)
if allocation:
self.used_memory -= allocation.size
del self.allocations[allocation_id]
def _free_memory(self, required_size: int) -> bool:
"""释放内存"""
# 按使用时间排序
sorted_allocations = sorted(
self.allocations.values(),
key=lambda x: x.allocated_at
)
freed = 0
for allocation in sorted_allocations:
self.deallocate(allocation.id)
freed += allocation.size
if freed >= required_size:
return True
return False
def get_stats(self) -> Dict[str, Any]:
"""获取统计信息"""
return {
'max_memory': self.max_memory,
'used_memory': self.used_memory,
'free_memory': self.max_memory - self.used_memory,
'utilization': self.used_memory / self.max_memory,
'num_allocations': len(self.allocations)
}
```

##### 2. 连接池管理#

```
bash复制python

class ConnectionPool:
    """连接池"""

    def __init__(self, factory: callable, max_size: int = 10):
        self.factory = factory
        self.max_size = max_size
        self.pool: List[Any] = []
        self.in_use: Set[Any] = set()

    def acquire(self, timeout: float = 30.0) -> Any:
        """获取连接"""
        start_time = time.time()

        while True:
            # 检查是否有可用连接
            if self.pool:
                connection = self.pool.pop()
                self.in_use.add(connection)
                return connection

            # 检查是否可以创建新连接
            if len(self.in_use) < self.max_size:
                connection = self.factory()
                self.in_use.add(connection)
                return connection

            # 等待连接释放
            if time.time() - start_time > timeout:
                raise TimeoutError("Failed to acquire connection")

            time.sleep(0.1)

    def release(self, connection: Any):
        """释放连接"""
        if connection in self.in_use:
            self.in_use.remove(connection)
            self.pool.append(connection)

    def close_all(self):
        """关闭所有连接"""
        for connection in self.pool:
            try:
                connection.close()
            except Exception as e:
                logger.error(f"Error closing connection: {e}")

        for connection in self.in_use:
            try:
                connection.close()
            except Exception as e:
                logger.error(f"Error closing connection: {e}")

        self.pool.clear()
        self.in_use.clear()

## 28.5.6 性能监控

### 1. 性能指标收集

class PerformanceMonitor:
"""性能监控器"""
def __init__(self):
self.metrics: Dict[str, List[float]] = {}
self.counters: Dict[str, int] = {}
self.timers: Dict[str, float] = {}
def record_metric(self, name: str, value: float):
"""记录指标"""
if name not in self.metrics:
self.metrics[name] = []
self.metrics[name].append(value)
def increment_counter(self, name: str, value: int = 1):
"""增加计数器"""
self.counters[name] = self.counters.get(name, 0) + value
def start_timer(self, name: str):
"""启动计时器"""
self.timers[name] = time.time()
def stop_timer(self, name: str) -> float:
"""停止计时器"""
if name not in self.timers:
raise ValueError(f"Timer not found: {name}")
duration = time.time() - self.timers[name]
del self.timers[name]
self.record_metric(f"{name}_duration", duration)
return duration
def get_summary(self) -> Dict[str, Any]:
"""获取摘要"""
summary = {
'metrics': {},
'counters': self.counters.copy()
}
for name, values in self.metrics.items():
summary['metrics'][name] = {
'count': len(values),
'mean': sum(values) / len(values),
'min': min(values),
'max': max(values),
'p50': np.percentile(values, 50),
'p95': np.percentile(values, 95),
'p99': np.percentile(values, 99)
}
return summary
```

```
python

class ConnectionPool:
    """连接池"""

    def __init__(self, factory: callable, max_size: int = 10):
        self.factory = factory
        self.max_size = max_size
        self.pool: List[Any] = []
        self.in_use: Set[Any] = set()

    def acquire(self, timeout: float = 30.0) -> Any:
        """获取连接"""
        start_time = time.time()

        while True:
            # 检查是否有可用连接
            if self.pool:
                connection = self.pool.pop()
                self.in_use.add(connection)
                return connection

            # 检查是否可以创建新连接
            if len(self.in_use) < self.max_size:
                connection = self.factory()
                self.in_use.add(connection)
                return connection

            # 等待连接释放
            if time.time() - start_time > timeout:
                raise TimeoutError("Failed to acquire connection")

            time.sleep(0.1)

    def release(self, connection: Any):
        """释放连接"""
        if connection in self.in_use:
            self.in_use.remove(connection)
            self.pool.append(connection)

    def close_all(self):
        """关闭所有连接"""
        for connection in self.pool:
            try:
                connection.close()
            except Exception as e:
                logger.error(f"Error closing connection: {e}")

        for connection in self.in_use:
            try:
                connection.close()
            except Exception as e:
                logger.error(f"Error closing connection: {e}")

        self.pool.clear()
        self.in_use.clear()

## 28.5.6 性能监控

### 1. 性能指标收集

class PerformanceMonitor:
"""性能监控器"""
def __init__(self):
self.metrics: Dict[str, List[float]] = {}
self.counters: Dict[str, int] = {}
self.timers: Dict[str, float] = {}
def record_metric(self, name: str, value: float):
"""记录指标"""
if name not in self.metrics:
self.metrics[name] = []
self.metrics[name].append(value)
def increment_counter(self, name: str, value: int = 1):
"""增加计数器"""
self.counters[name] = self.counters.get(name, 0) + value
def start_timer(self, name: str):
"""启动计时器"""
self.timers[name] = time.time()
def stop_timer(self, name: str) -> float:
"""停止计时器"""
if name not in self.timers:
raise ValueError(f"Timer not found: {name}")
duration = time.time() - self.timers[name]
del self.timers[name]
self.record_metric(f"{name}_duration", duration)
return duration
def get_summary(self) -> Dict[str, Any]:
"""获取摘要"""
summary = {
'metrics': {},
'counters': self.counters.copy()
}
for name, values in self.metrics.items():
summary['metrics'][name] = {
'count': len(values),
'mean': sum(values) / len(values),
'min': min(values),
'max': max(values),
'p50': np.percentile(values, 50),
'p95': np.percentile(values, 95),
'p99': np.percentile(values, 99)
}
return summary
```

##### 2. 性能分析器#

```
bash复制python

class PerformanceProfiler:
    """性能分析器"""

    def __init__(self):
        self.call_stack: List[ProfileEntry] = []
        self.entries: List[ProfileEntry] = []

    def enter(self, function_name: str):
        """进入函数"""
        entry = ProfileEntry(
            function_name=function_name,
            start_time=time.time(),
            parent=self.call_stack[-1] if self.call_stack else None
        )

        self.call_stack.append(entry)
        self.entries.append(entry)

    def exit(self):
        """退出函数"""
        if not self.call_stack:
            return

        entry = self.call_stack.pop()
        entry.end_time = time.time()
        entry.duration = entry.end_time - entry.start_time

    def get_report(self) -> str:
        """获取报告"""
        # 按函数名分组
        function_stats: Dict[str, Dict[str, Any]] = {}

        for entry in self.entries:
            if entry.function_name not in function_stats:
                function_stats[entry.function_name] = {
                    'count': 0,
                    'total_duration': 0.0,
                    'min_duration': float('inf'),
                    'max_duration': 0.0
                }

            stats = function_stats[entry.function_name]
            stats['count'] += 1
            stats['total_duration'] += entry.duration
            stats['min_duration'] = min(stats['min_duration'], entry.duration)
            stats['max_duration'] = max(stats['max_duration'], entry.duration)

        # 生成报告
        report = []
        report.append("Performance Profile Report")
        report.append("=" * 50)
        report.append("")

        for function_name, stats in sorted(
            function_stats.items(),
            key=lambda x: x[1]['total_duration'],
            reverse=True
        ):
            report.append(f"Function: {function_name}")
            report.append(f"  Calls: {stats['count']}")
            report.append(f"  Total Time: {stats['total_duration']:.4f}s")
            report.append(f"  Avg Time: {stats['total_duration'] / stats['count']:.4f}s")
            report.append(f"  Min Time: {stats['min_duration']:.4f}s")
            report.append(f"  Max Time: {stats['max_duration']:.4f}s")
            report.append("")

        return "\n".join(report)

class ProfileEntry:
    """性能分析条目"""

    def __init__(self, function_name: str, start_time: float,
                 parent: Optional['ProfileEntry']):
        self.function_name = function_name
        self.start_time = start_time
        self.end_time = None
        self.duration = None
        self.parent = parent
```

```
python

class PerformanceProfiler:
    """性能分析器"""

    def __init__(self):
        self.call_stack: List[ProfileEntry] = []
        self.entries: List[ProfileEntry] = []

    def enter(self, function_name: str):
        """进入函数"""
        entry = ProfileEntry(
            function_name=function_name,
            start_time=time.time(),
            parent=self.call_stack[-1] if self.call_stack else None
        )

        self.call_stack.append(entry)
        self.entries.append(entry)

    def exit(self):
        """退出函数"""
        if not self.call_stack:
            return

        entry = self.call_stack.pop()
        entry.end_time = time.time()
        entry.duration = entry.end_time - entry.start_time

    def get_report(self) -> str:
        """获取报告"""
        # 按函数名分组
        function_stats: Dict[str, Dict[str, Any]] = {}

        for entry in self.entries:
            if entry.function_name not in function_stats:
                function_stats[entry.function_name] = {
                    'count': 0,
                    'total_duration': 0.0,
                    'min_duration': float('inf'),
                    'max_duration': 0.0
                }

            stats = function_stats[entry.function_name]
            stats['count'] += 1
            stats['total_duration'] += entry.duration
            stats['min_duration'] = min(stats['min_duration'], entry.duration)
            stats['max_duration'] = max(stats['max_duration'], entry.duration)

        # 生成报告
        report = []
        report.append("Performance Profile Report")
        report.append("=" * 50)
        report.append("")

        for function_name, stats in sorted(
            function_stats.items(),
            key=lambda x: x[1]['total_duration'],
            reverse=True
        ):
            report.append(f"Function: {function_name}")
            report.append(f"  Calls: {stats['count']}")
            report.append(f"  Total Time: {stats['total_duration']:.4f}s")
            report.append(f"  Avg Time: {stats['total_duration'] / stats['count']:.4f}s")
            report.append(f"  Min Time: {stats['min_duration']:.4f}s")
            report.append(f"  Max Time: {stats['max_duration']:.4f}s")
            report.append("")

        return "\n".join(report)

class ProfileEntry:
    """性能分析条目"""

    def __init__(self, function_name: str, start_time: float,
                 parent: Optional['ProfileEntry']):
        self.function_name = function_name
        self.start_time = start_time
        self.end_time = None
        self.duration = None
        self.parent = parent
```

#### 28.5.7 性能优化最佳实践#

##### 1. 优化原则#

True. 测量优先：先测量再优化，避免过早优化
True. 热点优化：专注于性能瓶颈和热点代码
True. 渐进优化：逐步优化，每次优化后验证效果
True. 权衡考虑：在性能、可读性、可维护性之间权衡
True. 持续监控：建立持续的性能监控机制

##### 2. 优化策略#

True. 缓存优先：有效利用缓存减少重复计算
True. 异步处理：使用异步处理提高并发能力
True. 算法优化：选择合适的算法和数据结构
True. 资源管理：合理管理内存、连接等资源
True. 批量处理：批量处理减少开销

##### 3. 监控建议#

True. 关键指标：监控响应时间、吞吐量、资源使用率
True. 告警机制：设置合理的告警阈值
True. 趋势分析：分析性能趋势，提前发现问题
True. 定期审查：定期审查性能指标和优化效果
True. 文档记录：记录优化过程和经验教训

通过系统的性能优化，Claude Code 可以提供更快速、更高效的编程辅助体验。

---

# 第 29 章

## 1 编程 Agent 概述

**URL**: https://claudecode.tangshuang.net/course/29.1%20%E7%BC%96%E7%A8%8B%20Agent%20%E6%A6%82%E8%BF%B0

#### 29.1.1 什么是编程 Agent#

编程 Agent 是一种能够自主理解、生成、分析和优化代码的智能系统。它结合了大语言模型、工具调用、任务规划等核心技术，能够像人类程序员一样进行软件开发工作。

##### 编程 Agent 的核心特征#

True. 自主性：能够自主理解需求并制定解决方案
True. 交互性：能够与用户进行自然语言交互
True. 工具使用：能够调用各种开发工具和 API
True. 学习能力：能够从交互中学习和改进
True. 协作性：能够与其他 Agent 或人类开发者协作

##### 编程 Agent 与传统工具的区别#

#### 29.1.2 编程 Agent 的应用场景#

##### 1. 代码生成#

### 用户请求

"创建一个 Python 类来实现二叉搜索树，包含插入、删除和搜索功能"

### Agent 生成的代码

class BinarySearchTree:
def init(self):
self.root = None

def insert(self, value):
if not self.root:
self.root = TreeNode(value)
else:
self._insert_recursive(self.root, value)

def _insert_recursive(self, node, value):
if value < node.value:
if node.left is None:
node.left = TreeNode(value)
else:
self._insert_recursive(node.left, value)
else:
if node.right is None:
node.right = TreeNode(value)
else:
self._insert_recursive(node.right, value)

def search(self, value):
return self._search_recursive(self.root, value)

def _search_recursive(self, node, value):
if node is None:
return False
if value == node.value:
return True
elif value < node.value:
return self._search_recursive(node.left, value)
else:
return self._search_recursive(node.right, value)

def delete(self, value):
self.root = self._delete_recursive(self.root, value)

def _delete_recursive(self, node, value):
if node is None:
return node

if value < node.value:
node.left = self._delete_recursive(node.left, value)
elif value > node.value:
node.right = self._delete_recursive(node.right, value)
else:
if node.left is None:
return node.right
elif node.right is None:
return node.left

min_larger = self._find_min(node.right)
node.value = min_larger.value
node.right = self._delete_recursive(node.right, min_larger.value)

return node

def _find_min(self, node):
current = node
while current.left is not None:
current = current.left
return current

class TreeNode:
def init(self, value):
self.value = value
self.left = None
self.right = None

##### 2. 代码理解#

```
bash复制python

# 用户请求
"解释这段代码的功能和潜在问题"

# Agent 的分析
"""
这段代码实现了一个快速排序算法：

功能：

潜在问题：

改进建议：

"""

### 3. 代码调试

# 用户请求
"我的代码运行时出现 IndexError，帮我找出问题"
# Agent 的诊断
"""
问题定位：
- 错误发生在第 15 行：`result[i] = data[i + 1]`
- 当 i 等于 len(data) - 1 时，i + 1 会越界
根本原因：
- 循环范围应该是 `range(len(data) - 1)` 而不是 `range(len(data))`
修复方案：
````python
`python

# 修改前
for i in range(len(data)):
result[i] = data[i + 1]

# 修改后
for i in range(len(data) - 1):
result[i] = data[i + 1]

```> """
```

```
python

# 用户请求
"解释这段代码的功能和潜在问题"

# Agent 的分析
"""
这段代码实现了一个快速排序算法：

功能：

潜在问题：

改进建议：

"""

### 3. 代码调试

# 用户请求
"我的代码运行时出现 IndexError，帮我找出问题"
# Agent 的诊断
"""
问题定位：
- 错误发生在第 15 行：`result[i] = data[i + 1]`
- 当 i 等于 len(data) - 1 时，i + 1 会越界
根本原因：
- 循环范围应该是 `range(len(data) - 1)` 而不是 `range(len(data))`
修复方案：
````python
`python

# 修改前
for i in range(len(data)):
result[i] = data[i + 1]

# 修改后
for i in range(len(data) - 1):
result[i] = data[i + 1]

```> """
```

##### 4. 代码优化#

### 用户请求

"优化这段代码的性能"

### Agent 的优化建议

"""
原始代码的时间复杂度：O(n²)
优化策略：

True. 使用集合代替列表进行查找，将查找复杂度从 O(n) 降到 O(1)
True. 使用列表推导式简化代码
True. 预先计算常用值
优化后的代码：

```
python复制`python

def find_duplicates_optimized(data):
seen = set()
duplicates = set()

for item in data:
if item in seen:
duplicates.add(item)
else:
seen.add(item)

return list(duplicates)

```> 优化效果：
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)
> - 性能提升：约 10-100 倍（取决于数据规模）
"""
```
## 29.1.3 编程 Agent 的架构

### 整体架构

┌─────────────────────────────────────────┐
│           用户界面层                     │
│  (CLI、Web UI、IDE 插件)                │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           交互管理层                     │
│  (会话管理、上下文维护、对话历史)         │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           理解与规划层                   │
│  (意图识别、任务分解、计划生成)           │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           执行与工具层                    │
│  (代码生成、文件操作、测试执行)           │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           基础能力层                     │
│  (LLM、向量存储、知识库)                 │
└─────────────────────────────────────────┘

```
### 核心组件
```python
python

class CodingAgent:
    """编程 Agent"""

    def __init__(self, config: AgentConfig):
        self.config = config

        # 核心组件
        self.llm_client = LLMClient(config.llm_config)
        self.tool_manager = ToolManager()
        self.memory_system = MemorySystem(config.memory_config)
        self.planner = TaskPlanner()

        # 会话管理
        self.session_manager = SessionManager()

        # 能力模块
        self.code_generator = CodeGenerator(self.llm_client)
        self.code_analyzer = CodeAnalyzer(self.llm_client)
        self.code_optimizer = CodeOptimizer(self.llm_client)
        self.debugger = Debugger(self.tool_manager)

        # 初始化工具
        self._initialize_tools()

    def _initialize_tools(self):
        """初始化工具"""
        # 文件操作工具
        self.tool_manager.register_tool(FileReadTool())
        self.tool_manager.register_tool(FileWriteTool())
        self.tool_manager.register_tool(FileSearchTool())

        # 代码执行工具
        self.tool_manager.register_tool(CodeExecuteTool())
        self.tool_manager.register_tool(TestRunnerTool())

        # 版本控制工具
        self.tool_manager.register_tool(GitTool())

        # 其他工具
        self.tool_manager.register_tool(SearchTool())
        self.tool_manager.register_tool(DocumentationTool())

    async def process_request(self, request: UserRequest) -> AgentResponse:
        """处理用户请求"""

        # 1. 理解请求
        intent = await self._understand_intent(request)

        # 2. 制定计划
        plan = await self._create_plan(intent, request.context)

        # 3. 执行计划
        results = await self._execute_plan(plan)

        # 4. 生成响应
        response = await self._generate_response(results, intent)

        # 5. 更新记忆
        await self._update_memory(request, response)

        return response

    async def _understand_intent(self, request: UserRequest) -> Intent:
        """理解用户意图"""
        prompt = f"""
        分析用户请求的意图：

        用户请求：{request.text}
        上下文：{request.context}

        请识别：
        1. 主要意图（代码生成、代码理解、调试、优化等）
        2. 相关的编程语言
        3. 需要的工具
        4. 具体的任务要求
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_intent(response)

    async def _create_plan(self, intent: Intent,
                          context: Dict[str, Any]) -> ExecutionPlan:
        """创建执行计划"""
        plan = ExecutionPlan()

        # 根据意图生成任务
        tasks = await self.planner.plan(intent, context)

        for task in tasks:
            plan.add_task(task)

        return plan

    async def _execute_plan(self, plan: ExecutionPlan) -> List[TaskResult]:
        """执行计划"""
        results = []

        for task in plan.tasks:
            try:
                result = await self._execute_task(task)
                results.append(result)
            except Exception as e:
                logger.error(f"Task execution failed: {e}")
                results.append(TaskResult(
                    task_id=task.id,
                    success=False,
                    error=str(e)
                ))

        return results

    async def _execute_task(self, task: Task) -> TaskResult:
        """执行单个任务"""
        # 根据任务类型选择执行器
        if task.type == "code_generation":
            return await self.code_generator.generate(task)
        elif task.type == "code_analysis":
            return await self.code_analyzer.analyze(task)
        elif task.type == "code_optimization":
            return await self.code_optimizer.optimize(task)
        elif task.type == "debugging":
            return await self.debugger.debug(task)
        else:
            # 使用工具执行
            tool = self.tool_manager.get_tool(task.tool_id)
            return await tool.execute(task.parameters)

    async def _generate_response(self, results: List[TaskResult],
                                intent: Intent) -> AgentResponse:
        """生成响应"""
        prompt = f"""
        基于执行结果生成响应：

        意图：{intent.description}
        执行结果：{results}

        请生成清晰、有用的响应，包括：
        1. 主要结果
        2. 相关代码（如果适用）
        3. 说明和建议
        """

        response_text = await self.llm_client.complete(prompt)

        return AgentResponse(
            text=response_text,
            results=results,
            metadata={
                'intent': intent.name,
                'timestamp': datetime.utcnow()
            }
        )

    async def _update_memory(self, request: UserRequest,
                            response: AgentResponse):
        """更新记忆"""
        # 存储交互历史
        self.memory_system.store_interaction(
            request=request,
            response=response
        )

        # 存储有用的知识
        await self._extract_and_store_knowledge(request, response)

```

## 29.1.4 编程 Agent 的能力层次

### 基础能力

1. **代码生成**：根据需求生成代码
2. **代码理解**：理解现有代码的功能
3. **简单调试**：识别和修复简单错误
4. **文档生成**：为代码生成文档

### 进阶能力

1. **复杂系统设计**：设计大型软件架构
2. **性能优化**：优化代码性能
3. **安全分析**：识别安全漏洞
4. **重构建议**：提供代码重构建议

### 高级能力

1. **自主学习**：从项目中学习最佳实践
2. **跨语言理解**：理解多种编程语言
3. **团队协作**：与多个开发者协作
4. **持续改进**：持续优化自身能力

## 29.1.5 构建编程 Agent 的挑战

### 技术挑战

1. **上下文理解**：准确理解复杂的上下文信息
2. **工具集成**：与各种开发工具无缝集成
3. **错误处理**：优雅地处理各种错误情况
4. **性能优化**：在保证质量的同时提高响应速度

### 实践挑战

1. **用户期望管理**：管理用户对 Agent 能力的期望
2. **安全性**：确保 Agent 的操作是安全的
3. **可解释性**：让用户理解 Agent 的决策过程
4. **持续学习**：从用户反馈中持续改进

通过理解编程 Agent 的基本概念和架构，我们可以为构建自己的编程 Agent 奠定坚实的基础。
```
```
```

```
`python

def find_duplicates_optimized(data):
seen = set()
duplicates = set()

for item in data:
if item in seen:
duplicates.add(item)
else:
seen.add(item)

return list(duplicates)

```> 优化效果：
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)
> - 性能提升：约 10-100 倍（取决于数据规模）
"""
```
## 29.1.3 编程 Agent 的架构

### 整体架构

┌─────────────────────────────────────────┐
│           用户界面层                     │
│  (CLI、Web UI、IDE 插件)                │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           交互管理层                     │
│  (会话管理、上下文维护、对话历史)         │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           理解与规划层                   │
│  (意图识别、任务分解、计划生成)           │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           执行与工具层                    │
│  (代码生成、文件操作、测试执行)           │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           基础能力层                     │
│  (LLM、向量存储、知识库)                 │
└─────────────────────────────────────────┘

```
### 核心组件
```python
python

class CodingAgent:
    """编程 Agent"""

    def __init__(self, config: AgentConfig):
        self.config = config

        # 核心组件
        self.llm_client = LLMClient(config.llm_config)
        self.tool_manager = ToolManager()
        self.memory_system = MemorySystem(config.memory_config)
        self.planner = TaskPlanner()

        # 会话管理
        self.session_manager = SessionManager()

        # 能力模块
        self.code_generator = CodeGenerator(self.llm_client)
        self.code_analyzer = CodeAnalyzer(self.llm_client)
        self.code_optimizer = CodeOptimizer(self.llm_client)
        self.debugger = Debugger(self.tool_manager)

        # 初始化工具
        self._initialize_tools()

    def _initialize_tools(self):
        """初始化工具"""
        # 文件操作工具
        self.tool_manager.register_tool(FileReadTool())
        self.tool_manager.register_tool(FileWriteTool())
        self.tool_manager.register_tool(FileSearchTool())

        # 代码执行工具
        self.tool_manager.register_tool(CodeExecuteTool())
        self.tool_manager.register_tool(TestRunnerTool())

        # 版本控制工具
        self.tool_manager.register_tool(GitTool())

        # 其他工具
        self.tool_manager.register_tool(SearchTool())
        self.tool_manager.register_tool(DocumentationTool())

    async def process_request(self, request: UserRequest) -> AgentResponse:
        """处理用户请求"""

        # 1. 理解请求
        intent = await self._understand_intent(request)

        # 2. 制定计划
        plan = await self._create_plan(intent, request.context)

        # 3. 执行计划
        results = await self._execute_plan(plan)

        # 4. 生成响应
        response = await self._generate_response(results, intent)

        # 5. 更新记忆
        await self._update_memory(request, response)

        return response

    async def _understand_intent(self, request: UserRequest) -> Intent:
        """理解用户意图"""
        prompt = f"""
        分析用户请求的意图：

        用户请求：{request.text}
        上下文：{request.context}

        请识别：
        1. 主要意图（代码生成、代码理解、调试、优化等）
        2. 相关的编程语言
        3. 需要的工具
        4. 具体的任务要求
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_intent(response)

    async def _create_plan(self, intent: Intent,
                          context: Dict[str, Any]) -> ExecutionPlan:
        """创建执行计划"""
        plan = ExecutionPlan()

        # 根据意图生成任务
        tasks = await self.planner.plan(intent, context)

        for task in tasks:
            plan.add_task(task)

        return plan

    async def _execute_plan(self, plan: ExecutionPlan) -> List[TaskResult]:
        """执行计划"""
        results = []

        for task in plan.tasks:
            try:
                result = await self._execute_task(task)
                results.append(result)
            except Exception as e:
                logger.error(f"Task execution failed: {e}")
                results.append(TaskResult(
                    task_id=task.id,
                    success=False,
                    error=str(e)
                ))

        return results

    async def _execute_task(self, task: Task) -> TaskResult:
        """执行单个任务"""
        # 根据任务类型选择执行器
        if task.type == "code_generation":
            return await self.code_generator.generate(task)
        elif task.type == "code_analysis":
            return await self.code_analyzer.analyze(task)
        elif task.type == "code_optimization":
            return await self.code_optimizer.optimize(task)
        elif task.type == "debugging":
            return await self.debugger.debug(task)
        else:
            # 使用工具执行
            tool = self.tool_manager.get_tool(task.tool_id)
            return await tool.execute(task.parameters)

    async def _generate_response(self, results: List[TaskResult],
                                intent: Intent) -> AgentResponse:
        """生成响应"""
        prompt = f"""
        基于执行结果生成响应：

        意图：{intent.description}
        执行结果：{results}

        请生成清晰、有用的响应，包括：
        1. 主要结果
        2. 相关代码（如果适用）
        3. 说明和建议
        """

        response_text = await self.llm_client.complete(prompt)

        return AgentResponse(
            text=response_text,
            results=results,
            metadata={
                'intent': intent.name,
                'timestamp': datetime.utcnow()
            }
        )

    async def _update_memory(self, request: UserRequest,
                            response: AgentResponse):
        """更新记忆"""
        # 存储交互历史
        self.memory_system.store_interaction(
            request=request,
            response=response
        )

        # 存储有用的知识
        await self._extract_and_store_knowledge(request, response)

```

## 29.1.4 编程 Agent 的能力层次

### 基础能力

1. **代码生成**：根据需求生成代码
2. **代码理解**：理解现有代码的功能
3. **简单调试**：识别和修复简单错误
4. **文档生成**：为代码生成文档

### 进阶能力

1. **复杂系统设计**：设计大型软件架构
2. **性能优化**：优化代码性能
3. **安全分析**：识别安全漏洞
4. **重构建议**：提供代码重构建议

### 高级能力

1. **自主学习**：从项目中学习最佳实践
2. **跨语言理解**：理解多种编程语言
3. **团队协作**：与多个开发者协作
4. **持续改进**：持续优化自身能力

## 29.1.5 构建编程 Agent 的挑战

### 技术挑战

1. **上下文理解**：准确理解复杂的上下文信息
2. **工具集成**：与各种开发工具无缝集成
3. **错误处理**：优雅地处理各种错误情况
4. **性能优化**：在保证质量的同时提高响应速度

### 实践挑战

1. **用户期望管理**：管理用户对 Agent 能力的期望
2. **安全性**：确保 Agent 的操作是安全的
3. **可解释性**：让用户理解 Agent 的决策过程
4. **持续学习**：从用户反馈中持续改进

通过理解编程 Agent 的基本概念和架构，我们可以为构建自己的编程 Agent 奠定坚实的基础。
```
```
```

---

## 2 核心组件实现

**URL**: https://claudecode.tangshuang.net/course/29.2%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0

#### 29.2.1 LLM 客户端#

LLM 客户端是编程 Agent 与大语言模型交互的核心组件，负责处理 API 调用、响应解析、错误处理等。

##### 基础实现#

class LLMClient:
"""LLM 客户端"""

def init(self, config: LLMConfig):
self.config = config
self.api_key = config.api_key
self.base_url = config.base_url
self.model = config.model
self.max_tokens = config.max_tokens
self.temperature = config.temperature

### 会话管理

self.session = requests.Session()
self.session.headers.update({
'Authorization': f'Bearer {self.api_key}',
'Content-Type': 'application/json'
})

### 缓存

self.cache = LRUCache(maxsize=1000)

### 统计

self.stats = {
'total_requests': 0,
'cache_hits': 0,
'errors': 0
}

async def complete(self, prompt: str,
context: List[Dict] = None,
**kwargs) -> str:
"""完成文本生成"""

### 检查缓存

cache_key = self._generate_cache_key(prompt, context, kwargs)
cached_response = self.cache.get(cache_key)
if cached_response:
self.stats['cache_hits'] += 1
return cached_response

### 构建请求

messages = self._build_messages(prompt, context)

### 合并参数

params = {
'model': kwargs.get('model', self.model),
'messages': messages,
'max_tokens': kwargs.get('max_tokens', self.max_tokens),
'temperature': kwargs.get('temperature', self.temperature),
**kwargs
}

### 发送请求

try:
response = await self._send_request(params)
self.stats['total_requests'] += 1

### 解析响应

result = self._parse_response(response)

### 缓存结果

self.cache.set(cache_key, result)

return result

except Exception as e:
self.stats['errors'] += 1
logger.error(f"LLM request failed: {e}")
raise

async def _send_request(self, params: Dict) -> Dict:
"""发送请求"""
url = f"{self.base_url}/chat/completions"

### 使用异步请求

async with aiohttp.ClientSession() as session:
async with session.post(url, json=params) as response:
if response.status != 200:
error_text = await response.text()
raise Exception(f"API error: {response.status} - {error_text}")

return await response.json()

def _build_messages(self, prompt: str,
context: List[Dict] = None) -> List[Dict]:
"""构建消息列表"""
messages = []

### 添加系统提示

if self.config.system_prompt:
messages.append({
'role': 'system',
'content': self.config.system_prompt
})

### 添加上下文

if context:
messages.extend(context)

### 添加用户提示

messages.append({
'role': 'user',
'content': prompt
})

return messages

def _parse_response(self, response: Dict) -> str:
"""解析响应"""
try:
return response['choices'][0]['message']['content']
except (KeyError, IndexError) as e:
raise Exception(f"Invalid response format: {e}")

def _generate_cache_key(self, prompt: str,
context: List[Dict],
kwargs: Dict) -> str:
"""生成缓存键"""
key_data = {
'prompt': prompt,
'context': context,
'kwargs': kwargs
}
return hashlib.md5(
json.dumps(key_data, sort_keys=True).encode()
).hexdigest()

def get_stats(self) -> Dict[str, Any]:
"""获取统计信息"""
return self.stats.copy()

##### 流式响应支持#

```
bash复制python

class StreamingLLMClient(LLMClient):
    """支持流式响应的 LLM 客户端"""

    async def complete_stream(self, prompt: str,
                            context: List[Dict] = None,
                            **kwargs) -> AsyncIterator[str]:
        """流式完成文本生成"""

        # 构建请求
        messages = self._build_messages(prompt, context)

        params = {
            'model': kwargs.get('model', self.model),
            'messages': messages,
            'max_tokens': kwargs.get('max_tokens', self.max_tokens),
            'temperature': kwargs.get('temperature', self.temperature),
            'stream': True,
            **kwargs
        }

        # 发送流式请求
        url = f"{self.base_url}/chat/completions"

        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=params) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise Exception(f"API error: {response.status} - {error_text}")

                # 处理流式响应
                async for line in response.content:
                    line = line.decode('utf-8').strip()

                    if not line or line == 'data: [DONE]':
                        continue

                    if line.startswith('data: '):
                        data = json.loads(line[6:])
                        try:
                            content = data['choices'][0]['delta']['content']
                            if content:
                                yield content
                        except (KeyError, IndexError):
                            continue

## 29.2.2 工具管理器

工具管理器负责注册、管理和执行各种工具，是编程 Agent 与外部系统交互的桥梁。

### 工具接口

class Tool(ABC):
"""工具基类"""
def __init__(self, tool_id: str, name: str, description: str):
self.id = tool_id
self.name = name
self.description = description
@abstractmethod
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行工具"""
pass
@abstractmethod
def get_schema(self) -> Dict[str, Any]:
"""获取工具的参数模式"""
pass
def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
"""验证参数"""
schema = self.get_schema()
return self._validate_against_schema(parameters, schema)
def _validate_against_schema(self, parameters: Dict,
schema: Dict) -> bool:
"""根据模式验证参数"""
required = schema.get('required', [])
properties = schema.get('properties', {})
# 检查必需参数
for param in required:
if param not in parameters:
return False
# 检查参数类型
for key, value in parameters.items():
if key in properties:
expected_type = properties[key].get('type')
if not self._check_type(value, expected_type):
return False
return True
def _check_type(self, value: Any, expected_type: str) -> bool:
"""检查类型"""
type_map = {
'string': str,
'number': (int, float),
'integer': int,
'boolean': bool,
'array': list,
'object': dict
}
expected_python_type = type_map.get(expected_type)
if expected_python_type is None:
return True
return isinstance(value, expected_python_type)
```

```
python

class StreamingLLMClient(LLMClient):
    """支持流式响应的 LLM 客户端"""

    async def complete_stream(self, prompt: str,
                            context: List[Dict] = None,
                            **kwargs) -> AsyncIterator[str]:
        """流式完成文本生成"""

        # 构建请求
        messages = self._build_messages(prompt, context)

        params = {
            'model': kwargs.get('model', self.model),
            'messages': messages,
            'max_tokens': kwargs.get('max_tokens', self.max_tokens),
            'temperature': kwargs.get('temperature', self.temperature),
            'stream': True,
            **kwargs
        }

        # 发送流式请求
        url = f"{self.base_url}/chat/completions"

        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=params) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise Exception(f"API error: {response.status} - {error_text}")

                # 处理流式响应
                async for line in response.content:
                    line = line.decode('utf-8').strip()

                    if not line or line == 'data: [DONE]':
                        continue

                    if line.startswith('data: '):
                        data = json.loads(line[6:])
                        try:
                            content = data['choices'][0]['delta']['content']
                            if content:
                                yield content
                        except (KeyError, IndexError):
                            continue

## 29.2.2 工具管理器

工具管理器负责注册、管理和执行各种工具，是编程 Agent 与外部系统交互的桥梁。

### 工具接口

class Tool(ABC):
"""工具基类"""
def __init__(self, tool_id: str, name: str, description: str):
self.id = tool_id
self.name = name
self.description = description
@abstractmethod
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行工具"""
pass
@abstractmethod
def get_schema(self) -> Dict[str, Any]:
"""获取工具的参数模式"""
pass
def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
"""验证参数"""
schema = self.get_schema()
return self._validate_against_schema(parameters, schema)
def _validate_against_schema(self, parameters: Dict,
schema: Dict) -> bool:
"""根据模式验证参数"""
required = schema.get('required', [])
properties = schema.get('properties', {})
# 检查必需参数
for param in required:
if param not in parameters:
return False
# 检查参数类型
for key, value in parameters.items():
if key in properties:
expected_type = properties[key].get('type')
if not self._check_type(value, expected_type):
return False
return True
def _check_type(self, value: Any, expected_type: str) -> bool:
"""检查类型"""
type_map = {
'string': str,
'number': (int, float),
'integer': int,
'boolean': bool,
'array': list,
'object': dict
}
expected_python_type = type_map.get(expected_type)
if expected_python_type is None:
return True
return isinstance(value, expected_python_type)
```

##### 工具管理器实现#

```
bash复制python

class ToolManager:
    """工具管理器"""

    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        self.tool_categories: Dict[str, List[str]] = {}
        self.execution_history: List[ToolExecution] = []

    def register_tool(self, tool: Tool, category: str = None):
        """注册工具"""
        tool_id = tool.id

        if tool_id in self.tools:
            logger.warning(f"Tool already registered: {tool_id}")
            return

        self.tools[tool_id] = tool

        if category:
            if category not in self.tool_categories:
                self.tool_categories[category] = []
            self.tool_categories[category].append(tool_id)

        logger.info(f"Tool registered: {tool_id}")

    async def execute_tool(self, tool_id: str,
                           parameters: Dict[str, Any]) -> ToolResult:
        """执行工具"""
        tool = self.tools.get(tool_id)

        if not tool:
            raise ValueError(f"Tool not found: {tool_id}")

        # 验证参数
        if not tool.validate_parameters(parameters):
            raise ValueError("Invalid parameters")

        # 记录执行开始
        execution = ToolExecution(
            tool_id=tool_id,
            parameters=parameters,
            started_at=datetime.utcnow()
        )

        try:
            # 执行工具
            result = await tool.execute(parameters)

            # 记录执行结果
            execution.completed_at = datetime.utcnow()
            execution.success = True
            execution.result = result

            self.execution_history.append(execution)

            return result

        except Exception as e:
            # 记录执行失败
            execution.completed_at = datetime.utcnow()
            execution.success = False
            execution.error = str(e)

            self.execution_history.append(execution)

            logger.error(f"Tool execution failed: {e}")
            raise

    def get_tool(self, tool_id: str) -> Tool:
        """获取工具"""
        return self.tools.get(tool_id)

    def list_tools(self, category: str = None) -> List[Tool]:
        """列出工具"""
        if category:
            tool_ids = self.tool_categories.get(category, [])
            return [self.tools[tid] for tid in tool_ids]
        return list(self.tools.values())

    def get_tool_schema(self, tool_id: str) -> Dict[str, Any]:
        """获取工具模式"""
        tool = self.get_tool(tool_id)
        if tool:
            return tool.get_schema()
        return None

    def get_execution_history(self, tool_id: str = None,
                            limit: int = 100) -> List[ToolExecution]:
        """获取执行历史"""
        history = self.execution_history

        if tool_id:
            history = [e for e in history if e.tool_id == tool_id]

        return history[-limit:]

### 示例工具实现

class FileReadTool(Tool):
"""文件读取工具"""
def __init__(self):
super().__init__(
tool_id="file_read",
name="File Read",
description="Read the contents of a file"
)
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行文件读取"""
file_path = parameters['file_path']
try:
with open(file_path, 'r', encoding='utf-8') as f:
content = f.read()
return ToolResult(
success=True,
data={
'content': content,
'file_path': file_path
},
message=f"Successfully read file: {file_path}"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message=f"Failed to read file: {file_path}"
)
def get_schema(self) -> Dict[str, Any]:
"""获取参数模式"""
return {
'type': 'object',
'properties': {
'file_path': {
'type': 'string',
'description': 'Path to the file to read'
}
},
'required': ['file_path']
}
class CodeExecuteTool(Tool):
"""代码执行工具"""
def __init__(self):
super().__init__(
tool_id="code_execute",
name="Code Execute",
description="Execute code and return the output"
)
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行代码"""
code = parameters['code']
language = parameters.get('language', 'python')
try:
if language == 'python':
result = await self._execute_python(code)
else:
raise ValueError(f"Unsupported language: {language}")
return ToolResult(
success=True,
data={
'output': result['output'],
'error': result.get('error')
},
message="Code executed successfully"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message="Code execution failed"
)
async def _execute_python(self, code: str) -> Dict[str, Any]:
"""执行 Python 代码"""
# 使用 subprocess 执行
process = await asyncio.create_subprocess_exec(
'python3',
'-c',
code,
stdout=asyncio.subprocess.PIPE,
stderr=asyncio.subprocess.PIPE
)
stdout, stderr = await process.communicate()
return {
'output': stdout.decode('utf-8'),
'error': stderr.decode('utf-8') if stderr else None
}
def get_schema(self) -> Dict[str, Any]:
"""获取参数模式"""
return {
'type': 'object',
'properties': {
'code': {
'type': 'string',
'description': 'Code to execute'
},
'language': {
'type': 'string',
'description': 'Programming language',
'default': 'python'
}
},
'required': ['code']
}
```

```
python

class ToolManager:
    """工具管理器"""

    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        self.tool_categories: Dict[str, List[str]] = {}
        self.execution_history: List[ToolExecution] = []

    def register_tool(self, tool: Tool, category: str = None):
        """注册工具"""
        tool_id = tool.id

        if tool_id in self.tools:
            logger.warning(f"Tool already registered: {tool_id}")
            return

        self.tools[tool_id] = tool

        if category:
            if category not in self.tool_categories:
                self.tool_categories[category] = []
            self.tool_categories[category].append(tool_id)

        logger.info(f"Tool registered: {tool_id}")

    async def execute_tool(self, tool_id: str,
                           parameters: Dict[str, Any]) -> ToolResult:
        """执行工具"""
        tool = self.tools.get(tool_id)

        if not tool:
            raise ValueError(f"Tool not found: {tool_id}")

        # 验证参数
        if not tool.validate_parameters(parameters):
            raise ValueError("Invalid parameters")

        # 记录执行开始
        execution = ToolExecution(
            tool_id=tool_id,
            parameters=parameters,
            started_at=datetime.utcnow()
        )

        try:
            # 执行工具
            result = await tool.execute(parameters)

            # 记录执行结果
            execution.completed_at = datetime.utcnow()
            execution.success = True
            execution.result = result

            self.execution_history.append(execution)

            return result

        except Exception as e:
            # 记录执行失败
            execution.completed_at = datetime.utcnow()
            execution.success = False
            execution.error = str(e)

            self.execution_history.append(execution)

            logger.error(f"Tool execution failed: {e}")
            raise

    def get_tool(self, tool_id: str) -> Tool:
        """获取工具"""
        return self.tools.get(tool_id)

    def list_tools(self, category: str = None) -> List[Tool]:
        """列出工具"""
        if category:
            tool_ids = self.tool_categories.get(category, [])
            return [self.tools[tid] for tid in tool_ids]
        return list(self.tools.values())

    def get_tool_schema(self, tool_id: str) -> Dict[str, Any]:
        """获取工具模式"""
        tool = self.get_tool(tool_id)
        if tool:
            return tool.get_schema()
        return None

    def get_execution_history(self, tool_id: str = None,
                            limit: int = 100) -> List[ToolExecution]:
        """获取执行历史"""
        history = self.execution_history

        if tool_id:
            history = [e for e in history if e.tool_id == tool_id]

        return history[-limit:]

### 示例工具实现

class FileReadTool(Tool):
"""文件读取工具"""
def __init__(self):
super().__init__(
tool_id="file_read",
name="File Read",
description="Read the contents of a file"
)
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行文件读取"""
file_path = parameters['file_path']
try:
with open(file_path, 'r', encoding='utf-8') as f:
content = f.read()
return ToolResult(
success=True,
data={
'content': content,
'file_path': file_path
},
message=f"Successfully read file: {file_path}"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message=f"Failed to read file: {file_path}"
)
def get_schema(self) -> Dict[str, Any]:
"""获取参数模式"""
return {
'type': 'object',
'properties': {
'file_path': {
'type': 'string',
'description': 'Path to the file to read'
}
},
'required': ['file_path']
}
class CodeExecuteTool(Tool):
"""代码执行工具"""
def __init__(self):
super().__init__(
tool_id="code_execute",
name="Code Execute",
description="Execute code and return the output"
)
async def execute(self, parameters: Dict[str, Any]) -> ToolResult:
"""执行代码"""
code = parameters['code']
language = parameters.get('language', 'python')
try:
if language == 'python':
result = await self._execute_python(code)
else:
raise ValueError(f"Unsupported language: {language}")
return ToolResult(
success=True,
data={
'output': result['output'],
'error': result.get('error')
},
message="Code executed successfully"
)
except Exception as e:
return ToolResult(
success=False,
error=str(e),
message="Code execution failed"
)
async def _execute_python(self, code: str) -> Dict[str, Any]:
"""执行 Python 代码"""
# 使用 subprocess 执行
process = await asyncio.create_subprocess_exec(
'python3',
'-c',
code,
stdout=asyncio.subprocess.PIPE,
stderr=asyncio.subprocess.PIPE
)
stdout, stderr = await process.communicate()
return {
'output': stdout.decode('utf-8'),
'error': stderr.decode('utf-8') if stderr else None
}
def get_schema(self) -> Dict[str, Any]:
"""获取参数模式"""
return {
'type': 'object',
'properties': {
'code': {
'type': 'string',
'description': 'Code to execute'
},
'language': {
'type': 'string',
'description': 'Programming language',
'default': 'python'
}
},
'required': ['code']
}
```

#### 29.2.3 记忆系统#

记忆系统负责存储和管理 Agent 的知识、经验和交互历史。

##### 记忆系统架构#

```
bash复制python

class MemorySystem:
    """记忆系统"""

    def __init__(self, config: MemoryConfig):
        self.config = config

        # 短期记忆（会话级）
        self.short_term_memory: Dict[str, SessionMemory] = {}

        # 长期记忆（持久化）
        self.long_term_memory = LongTermMemory(config.storage_config)

        # 向量存储（语义检索）
        self.vector_store = VectorStore(config.vector_config)

        # 知识图谱
        self.knowledge_graph = KnowledgeGraph(config.graph_config)

    async def store_interaction(self, request: UserRequest,
                                response: AgentResponse):
        """存储交互"""
        session_id = request.session_id

        # 获取或创建会话记忆
        if session_id not in self.short_term_memory:
            self.short_term_memory[session_id] = SessionMemory(
                session_id=session_id
            )

        session_memory = self.short_term_memory[session_id]

        # 存储交互
        interaction = Interaction(
            request=request,
            response=response,
            timestamp=datetime.utcnow()
        )

        session_memory.add_interaction(interaction)

        # 提取并存储知识
        await self._extract_and_store_knowledge(interaction)

    async def retrieve_context(self, session_id: str,
                              query: str = None) -> Context:
        """检索上下文"""
        context = Context()

        # 获取会话记忆
        session_memory = self.short_term_memory.get(session_id)
        if session_memory:
            context.interactions = session_memory.get_recent_interactions(
                limit=10
            )

        # 语义检索相关记忆
        if query:
            relevant_memories = await self.vector_store.search(
                query,
                top_k=5
            )
            context.relevant_memories = relevant_memories

        return context

    async def _extract_and_store_knowledge(self,
                                           interaction: Interaction):
        """提取并存储知识"""
        # 提取关键信息
        knowledge = await self._extract_knowledge(interaction)

        # 存储到向量存储
        for item in knowledge:
            await self.vector_store.add(
                id=item.id,
                text=item.text,
                metadata=item.metadata
            )

            # 更新知识图谱
            await self.knowledge_graph.add_node(
                id=item.id,
                type=item.type,
                properties=item.metadata
            )

    async def _extract_knowledge(self,
                                interaction: Interaction) -> List[KnowledgeItem]:
        """提取知识"""
        # 使用 LLM 提取知识
        prompt = f"""
        从以下交互中提取关键知识：

        用户请求：{interaction.request.text}
        Agent 响应：{interaction.response.text}

        请提取：

        """

        response = await self.llm_client.complete(prompt)

        # 解析提取的知识
        return self._parse_knowledge(response)

### 向量存储实现

class VectorStore:
"""向量存储"""
def __init__(self, config: VectorStoreConfig):
self.config = config
self.embedding_client = EmbeddingClient(config.embedding_config)
self.index = None
self.documents: Dict[str, Document] = {}
async def add(self, id: str, text: str, metadata: Dict = None):
"""添加文档"""
# 生成嵌入向量
embedding = await self.embedding_client.embed(text)
# 创建文档
document = Document(
id=id,
text=text,
embedding=embedding,
metadata=metadata or {}
)
self.documents[id] = document
# 更新索引
self._update_index()
async def search(self, query: str, top_k: int = 10) -> List[Document]:
"""搜索文档"""
# 生成查询向量
query_embedding = await self.embedding_client.embed(query)
# 搜索相似文档
if not self.index:
return []
distances, indices = self.index.search(
np.array([query_embedding]),
top_k
)
# 返回结果
results = []
doc_ids = list(self.documents.keys())
for i, idx in enumerate(indices[0]):
if idx >= 0 and idx < len(doc_ids):
doc_id = doc_ids[idx]
document = self.documents[doc_id]
document.similarity = 1.0 / (1.0 + distances[0][i])
results.append(document)
return results
def _update_index(self):
"""更新索引"""
if not self.documents:
return
# 构建向量矩阵
embeddings = np.array([
doc.embedding for doc in self.documents.values()
])
# 创建 FAISS 索引
dimension = embeddings.shape[1]
self.index = faiss.IndexFlatL2(dimension)
self.index.add(embeddings)
```

```
python

class MemorySystem:
    """记忆系统"""

    def __init__(self, config: MemoryConfig):
        self.config = config

        # 短期记忆（会话级）
        self.short_term_memory: Dict[str, SessionMemory] = {}

        # 长期记忆（持久化）
        self.long_term_memory = LongTermMemory(config.storage_config)

        # 向量存储（语义检索）
        self.vector_store = VectorStore(config.vector_config)

        # 知识图谱
        self.knowledge_graph = KnowledgeGraph(config.graph_config)

    async def store_interaction(self, request: UserRequest,
                                response: AgentResponse):
        """存储交互"""
        session_id = request.session_id

        # 获取或创建会话记忆
        if session_id not in self.short_term_memory:
            self.short_term_memory[session_id] = SessionMemory(
                session_id=session_id
            )

        session_memory = self.short_term_memory[session_id]

        # 存储交互
        interaction = Interaction(
            request=request,
            response=response,
            timestamp=datetime.utcnow()
        )

        session_memory.add_interaction(interaction)

        # 提取并存储知识
        await self._extract_and_store_knowledge(interaction)

    async def retrieve_context(self, session_id: str,
                              query: str = None) -> Context:
        """检索上下文"""
        context = Context()

        # 获取会话记忆
        session_memory = self.short_term_memory.get(session_id)
        if session_memory:
            context.interactions = session_memory.get_recent_interactions(
                limit=10
            )

        # 语义检索相关记忆
        if query:
            relevant_memories = await self.vector_store.search(
                query,
                top_k=5
            )
            context.relevant_memories = relevant_memories

        return context

    async def _extract_and_store_knowledge(self,
                                           interaction: Interaction):
        """提取并存储知识"""
        # 提取关键信息
        knowledge = await self._extract_knowledge(interaction)

        # 存储到向量存储
        for item in knowledge:
            await self.vector_store.add(
                id=item.id,
                text=item.text,
                metadata=item.metadata
            )

            # 更新知识图谱
            await self.knowledge_graph.add_node(
                id=item.id,
                type=item.type,
                properties=item.metadata
            )

    async def _extract_knowledge(self,
                                interaction: Interaction) -> List[KnowledgeItem]:
        """提取知识"""
        # 使用 LLM 提取知识
        prompt = f"""
        从以下交互中提取关键知识：

        用户请求：{interaction.request.text}
        Agent 响应：{interaction.response.text}

        请提取：

        """

        response = await self.llm_client.complete(prompt)

        # 解析提取的知识
        return self._parse_knowledge(response)

### 向量存储实现

class VectorStore:
"""向量存储"""
def __init__(self, config: VectorStoreConfig):
self.config = config
self.embedding_client = EmbeddingClient(config.embedding_config)
self.index = None
self.documents: Dict[str, Document] = {}
async def add(self, id: str, text: str, metadata: Dict = None):
"""添加文档"""
# 生成嵌入向量
embedding = await self.embedding_client.embed(text)
# 创建文档
document = Document(
id=id,
text=text,
embedding=embedding,
metadata=metadata or {}
)
self.documents[id] = document
# 更新索引
self._update_index()
async def search(self, query: str, top_k: int = 10) -> List[Document]:
"""搜索文档"""
# 生成查询向量
query_embedding = await self.embedding_client.embed(query)
# 搜索相似文档
if not self.index:
return []
distances, indices = self.index.search(
np.array([query_embedding]),
top_k
)
# 返回结果
results = []
doc_ids = list(self.documents.keys())
for i, idx in enumerate(indices[0]):
if idx >= 0 and idx < len(doc_ids):
doc_id = doc_ids[idx]
document = self.documents[doc_id]
document.similarity = 1.0 / (1.0 + distances[0][i])
results.append(document)
return results
def _update_index(self):
"""更新索引"""
if not self.documents:
return
# 构建向量矩阵
embeddings = np.array([
doc.embedding for doc in self.documents.values()
])
# 创建 FAISS 索引
dimension = embeddings.shape[1]
self.index = faiss.IndexFlatL2(dimension)
self.index.add(embeddings)
```

#### 29.2.4 任务规划器#

任务规划器负责将用户请求分解为可执行的任务序列。

```
bash复制python

class TaskPlanner:
    """任务规划器"""

    def __init__(self):
        self.task_templates: Dict[str, TaskTemplate] = {}
        self.planning_strategies: Dict[str, PlanningStrategy] = {}

        # 注册默认策略
        self._register_default_strategies()

    async def plan(self, intent: Intent,
                  context: Dict[str, Any]) -> List[Task]:
        """规划任务"""

        # 选择规划策略
        strategy = self._select_strategy(intent, context)

        # 生成任务
        tasks = await strategy.generate_tasks(intent, context)

        # 优化任务顺序
        tasks = self._optimize_task_order(tasks)

        return tasks

    def _select_strategy(self, intent: Intent,
                        context: Dict) -> PlanningStrategy:
        """选择规划策略"""
        # 根据意图类型选择策略
        if intent.name == "code_generation":
            return self.planning_strategies.get("code_generation")
        elif intent.name == "code_analysis":
            return self.planning_strategies.get("code_analysis")
        elif intent.name == "debugging":
            return self.planning_strategies.get("debugging")
        else:
            return self.planning_strategies.get("default")

    def _optimize_task_order(self, tasks: List[Task]) -> List[Task]:
        """优化任务顺序"""
        # 构建依赖图
        dependency_graph = self._build_dependency_graph(tasks)

        # 拓扑排序
        return self._topological_sort(dependency_graph)

    def _build_dependency_graph(self,
                                tasks: List[Task]) -> Dict[str, List[str]]:
        """构建依赖图"""
        graph = {}
        for task in tasks:
            graph[task.id] = task.dependencies
        return graph

    def _topological_sort(self,
                         graph: Dict[str, List[str]]) -> List[Task]:
        """拓扑排序"""
        visited = set()
        result = []

        def visit(task_id: str):
            if task_id in visited:
                return

            visited.add(task_id)

            # 先访问依赖
            for dep_id in graph.get(task_id, []):
                visit(dep_id)

            result.append(task_id)

        for task_id in graph:
            visit(task_id)

        # 返回按顺序排列的任务
        task_map = {task.id: task for task in self.tasks}
        return [task_map[tid] for tid in result]

    def _register_default_strategies(self):
        """注册默认策略"""
        self.planning_strategies["code_generation"] = CodeGenerationStrategy()
        self.planning_strategies["code_analysis"] = CodeAnalysisStrategy()
        self.planning_strategies["debugging"] = DebuggingStrategy()
        self.planning_strategies["default"] = DefaultStrategy()
```

```
python

class TaskPlanner:
    """任务规划器"""

    def __init__(self):
        self.task_templates: Dict[str, TaskTemplate] = {}
        self.planning_strategies: Dict[str, PlanningStrategy] = {}

        # 注册默认策略
        self._register_default_strategies()

    async def plan(self, intent: Intent,
                  context: Dict[str, Any]) -> List[Task]:
        """规划任务"""

        # 选择规划策略
        strategy = self._select_strategy(intent, context)

        # 生成任务
        tasks = await strategy.generate_tasks(intent, context)

        # 优化任务顺序
        tasks = self._optimize_task_order(tasks)

        return tasks

    def _select_strategy(self, intent: Intent,
                        context: Dict) -> PlanningStrategy:
        """选择规划策略"""
        # 根据意图类型选择策略
        if intent.name == "code_generation":
            return self.planning_strategies.get("code_generation")
        elif intent.name == "code_analysis":
            return self.planning_strategies.get("code_analysis")
        elif intent.name == "debugging":
            return self.planning_strategies.get("debugging")
        else:
            return self.planning_strategies.get("default")

    def _optimize_task_order(self, tasks: List[Task]) -> List[Task]:
        """优化任务顺序"""
        # 构建依赖图
        dependency_graph = self._build_dependency_graph(tasks)

        # 拓扑排序
        return self._topological_sort(dependency_graph)

    def _build_dependency_graph(self,
                                tasks: List[Task]) -> Dict[str, List[str]]:
        """构建依赖图"""
        graph = {}
        for task in tasks:
            graph[task.id] = task.dependencies
        return graph

    def _topological_sort(self,
                         graph: Dict[str, List[str]]) -> List[Task]:
        """拓扑排序"""
        visited = set()
        result = []

        def visit(task_id: str):
            if task_id in visited:
                return

            visited.add(task_id)

            # 先访问依赖
            for dep_id in graph.get(task_id, []):
                visit(dep_id)

            result.append(task_id)

        for task_id in graph:
            visit(task_id)

        # 返回按顺序排列的任务
        task_map = {task.id: task for task in self.tasks}
        return [task_map[tid] for tid in result]

    def _register_default_strategies(self):
        """注册默认策略"""
        self.planning_strategies["code_generation"] = CodeGenerationStrategy()
        self.planning_strategies["code_analysis"] = CodeAnalysisStrategy()
        self.planning_strategies["debugging"] = DebuggingStrategy()
        self.planning_strategies["default"] = DefaultStrategy()
```

通过实现这些核心组件，我们可以构建一个功能完整的编程 Agent 基础框架。

---

## 3 代码生成模块

**URL**: https://claudecode.tangshuang.net/course/29.3%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97

#### 29.3.1 代码生成概述#

代码生成模块是编程 Agent 的核心能力之一，它能够根据自然语言描述生成高质量的代码。代码生成涉及需求理解、架构设计、代码实现等多个环节。

##### 代码生成流程#

用户需求
↓
需求分析与理解
↓
架构设计
↓
代码实现
↓
代码验证
↓
优化与改进
↓
最终代码

#### 29.3.2 需求分析#

##### 需求提取器#

```
python复制python

class RequirementExtractor:
    """需求提取器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def extract(self, user_request: str) -> Requirement:
        """提取需求"""
        prompt = f"""
        分析用户需求，提取关键信息：

        用户需求：{user_request}

        请提取以下信息：
        1. 功能需求（需要实现什么功能）
        2. 技术栈（使用的编程语言、框架等）
        3. 约束条件（性能、安全、兼容性等）
        4. 输入输出（预期的输入和输出）
        5. 特殊要求（代码风格、注释要求等）

        以 JSON 格式返回结果。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_requirement(response)

    def _parse_requirement(self, response: str) -> Requirement:
        """解析需求"""
        try:
            data = json.loads(response)
            return Requirement(
                functional_requirements=data.get('functional_requirements', []),
                tech_stack=data.get('tech_stack', {}),
                constraints=data.get('constraints', {}),
                inputs=data.get('inputs', []),
                outputs=data.get('outputs', []),
                special_requirements=data.get('special_requirements', {})
            )
        except json.JSONDecodeError:
            raise ValueError("Invalid requirement format")

```### 需求验证器

class RequirementValidator:
"""需求验证器"""
def validate(self, requirement: Requirement) -> ValidationResult:
"""验证需求"""
issues = []
# 检查功能需求
if not requirement.functional_requirements:
issues.append("No functional requirements specified")
```

```
python

class RequirementExtractor:
    """需求提取器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def extract(self, user_request: str) -> Requirement:
        """提取需求"""
        prompt = f"""
        分析用户需求，提取关键信息：

        用户需求：{user_request}

        请提取以下信息：
        1. 功能需求（需要实现什么功能）
        2. 技术栈（使用的编程语言、框架等）
        3. 约束条件（性能、安全、兼容性等）
        4. 输入输出（预期的输入和输出）
        5. 特殊要求（代码风格、注释要求等）

        以 JSON 格式返回结果。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_requirement(response)

    def _parse_requirement(self, response: str) -> Requirement:
        """解析需求"""
        try:
            data = json.loads(response)
            return Requirement(
                functional_requirements=data.get('functional_requirements', []),
                tech_stack=data.get('tech_stack', {}),
                constraints=data.get('constraints', {}),
                inputs=data.get('inputs', []),
                outputs=data.get('outputs', []),
                special_requirements=data.get('special_requirements', {})
            )
        except json.JSONDecodeError:
            raise ValueError("Invalid requirement format")

```### 需求验证器

class RequirementValidator:
"""需求验证器"""
def validate(self, requirement: Requirement) -> ValidationResult:
"""验证需求"""
issues = []
# 检查功能需求
if not requirement.functional_requirements:
issues.append("No functional requirements specified")
```

### 检查技术栈

if not requirement.tech_stack:
issues.append("No tech stack specified")

### 检查约束条件

if 'performance' in requirement.constraints:
perf = requirement.constraints['performance']
if not isinstance(perf, dict) or 'max_time' not in perf:
issues.append("Invalid performance constraint")
return ValidationResult(
valid=len(issues) == 0,
issues=issues
)

```
bash复制## 29.3.3 架构设计

### 架构设计器

```python
```python

class ArchitectureDesigner:
    """架构设计器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client
        self.design_patterns = self._load_design_patterns()

    async def design(self, requirement: Requirement) -> Architecture:
        """设计架构"""
        prompt = f"""
        根据需求设计软件架构：

        功能需求：{requirement.functional_requirements}
        技术栈：{requirement.tech_stack}
        约束条件：{requirement.constraints}

        请设计：
        1. 系统架构（模块划分、层次结构）
        2. 类设计（类、接口、继承关系）
        3. 数据结构（数据模型、存储方案）
        4. 接口设计（API、函数签名）
        5. 设计模式（适用的设计模式）

        以 JSON 格式返回架构设计。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_architecture(response)

    def _parse_architecture(self, response: str) -> Architecture:
        """解析架构"""
        try:
            data = json.loads(response)
            return Architecture(
                system_architecture=data.get('system_architecture', {}),
                class_design=data.get('class_design', []),
                data_structures=data.get('data_structures', []),
                interfaces=data.get('interfaces', []),
                design_patterns=data.get('design_patterns', [])
            )
        except json.JSONDecodeError:
            raise ValueError("Invalid architecture format")

    def _load_design_patterns(self) -> Dict[str, DesignPattern]:
        """加载设计模式"""
        return {
            'singleton': DesignPattern(
                name='Singleton',
                description='确保一个类只有一个实例',
               适用场景='需要全局唯一访问点'
            ),
            'factory': DesignPattern(
                name='Factory',
                description='创建对象的接口',
                适用场景='需要灵活创建对象'
            ),
            'observer': DesignPattern(
                name='Observer',
                description='定义对象间的一对多依赖',
                适用场景='需要事件通知机制'
            )
        }

```### 架构评估器

class ArchitectureEvaluator:
"""架构评估器"""
def evaluate(self, architecture: Architecture,
requirement: Requirement) -> EvaluationResult:
"""评估架构"""
scores = {}
# 评估模块化
scores['modularity'] = self._evaluate_modularity(architecture)
# 评估可扩展性
scores['extensibility'] = self._evaluate_extensibility(architecture)
# 评估性能
scores['performance'] = self._evaluate_performance(
architecture,
requirement
)
# 评估可维护性
scores['maintainability'] = self._evaluate_maintainability(architecture)
# 计算总分
total_score = sum(scores.values()) / len(scores)
return EvaluationResult(
total_score=total_score,
scores=scores,
recommendations=self._generate_recommendations(scores)
)
def _evaluate_modularity(self, architecture: Architecture) -> float:
"""评估模块化"""
# 检查模块划分
modules = architecture.system_architecture.get('modules', [])
if not modules:
return 0.0
# 模块越多，模块化程度越高
score = min(len(modules) / 10.0, 1.0)
return score
def _evaluate_extensibility(self, architecture: Architecture) -> float:
"""评估可扩展性"""
# 检查设计模式使用
patterns = architecture.design_patterns
if not patterns:
return 0.5
# 使用设计模式提高可扩展性
score = 0.5 + min(len(patterns) / 5.0, 0.5)
return score
def _evaluate_performance(self, architecture: Architecture,
requirement: Requirement) -> float:
"""评估性能"""
# 检查性能约束
constraints = requirement.constraints.get('performance', {})
if not constraints:
return 0.8  # 默认分数
# 评估架构是否满足性能要求
score = 0.8  # 基础分数
# 检查缓存策略
if 'caching' in architecture.system_architecture:
score += 0.1
# 检查并发处理
if 'concurrency' in architecture.system_architecture:
score += 0.1
return min(score, 1.0)
def _evaluate_maintainability(self, architecture: Architecture) -> float:
"""评估可维护性"""
# 检查类设计
classes = architecture.class_design
if not classes:
return 0.5
# 评估类的复杂度
avg_methods = sum(
len(c.get('methods', [])) for c in classes
) / len(classes)
# 方法数量适中，可维护性高
if 5 <= avg_methods <= 15:
score = 1.0
elif avg_methods < 5:
score = 0.8
else:
score = 0.6
return score
def _generate_recommendations(self,
scores: Dict[str, float]) -> List[str]:
"""生成建议"""
recommendations = []
if scores['modularity'] < 0.7:
recommendations.append(
"建议增加模块划分，提高模块化程度"
)
if scores['extensibility'] < 0.7:
recommendations.append(
"建议使用更多设计模式，提高可扩展性"
)
if scores['maintainability'] < 0.7:
recommendations.append(
"建议简化类设计，降低复杂度"
)
return recommendations
```

```
## 29.3.3 架构设计

### 架构设计器

```python
```python

class ArchitectureDesigner:
    """架构设计器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client
        self.design_patterns = self._load_design_patterns()

    async def design(self, requirement: Requirement) -> Architecture:
        """设计架构"""
        prompt = f"""
        根据需求设计软件架构：

        功能需求：{requirement.functional_requirements}
        技术栈：{requirement.tech_stack}
        约束条件：{requirement.constraints}

        请设计：
        1. 系统架构（模块划分、层次结构）
        2. 类设计（类、接口、继承关系）
        3. 数据结构（数据模型、存储方案）
        4. 接口设计（API、函数签名）
        5. 设计模式（适用的设计模式）

        以 JSON 格式返回架构设计。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_architecture(response)

    def _parse_architecture(self, response: str) -> Architecture:
        """解析架构"""
        try:
            data = json.loads(response)
            return Architecture(
                system_architecture=data.get('system_architecture', {}),
                class_design=data.get('class_design', []),
                data_structures=data.get('data_structures', []),
                interfaces=data.get('interfaces', []),
                design_patterns=data.get('design_patterns', [])
            )
        except json.JSONDecodeError:
            raise ValueError("Invalid architecture format")

    def _load_design_patterns(self) -> Dict[str, DesignPattern]:
        """加载设计模式"""
        return {
            'singleton': DesignPattern(
                name='Singleton',
                description='确保一个类只有一个实例',
               适用场景='需要全局唯一访问点'
            ),
            'factory': DesignPattern(
                name='Factory',
                description='创建对象的接口',
                适用场景='需要灵活创建对象'
            ),
            'observer': DesignPattern(
                name='Observer',
                description='定义对象间的一对多依赖',
                适用场景='需要事件通知机制'
            )
        }

```### 架构评估器

class ArchitectureEvaluator:
"""架构评估器"""
def evaluate(self, architecture: Architecture,
requirement: Requirement) -> EvaluationResult:
"""评估架构"""
scores = {}
# 评估模块化
scores['modularity'] = self._evaluate_modularity(architecture)
# 评估可扩展性
scores['extensibility'] = self._evaluate_extensibility(architecture)
# 评估性能
scores['performance'] = self._evaluate_performance(
architecture,
requirement
)
# 评估可维护性
scores['maintainability'] = self._evaluate_maintainability(architecture)
# 计算总分
total_score = sum(scores.values()) / len(scores)
return EvaluationResult(
total_score=total_score,
scores=scores,
recommendations=self._generate_recommendations(scores)
)
def _evaluate_modularity(self, architecture: Architecture) -> float:
"""评估模块化"""
# 检查模块划分
modules = architecture.system_architecture.get('modules', [])
if not modules:
return 0.0
# 模块越多，模块化程度越高
score = min(len(modules) / 10.0, 1.0)
return score
def _evaluate_extensibility(self, architecture: Architecture) -> float:
"""评估可扩展性"""
# 检查设计模式使用
patterns = architecture.design_patterns
if not patterns:
return 0.5
# 使用设计模式提高可扩展性
score = 0.5 + min(len(patterns) / 5.0, 0.5)
return score
def _evaluate_performance(self, architecture: Architecture,
requirement: Requirement) -> float:
"""评估性能"""
# 检查性能约束
constraints = requirement.constraints.get('performance', {})
if not constraints:
return 0.8  # 默认分数
# 评估架构是否满足性能要求
score = 0.8  # 基础分数
# 检查缓存策略
if 'caching' in architecture.system_architecture:
score += 0.1
# 检查并发处理
if 'concurrency' in architecture.system_architecture:
score += 0.1
return min(score, 1.0)
def _evaluate_maintainability(self, architecture: Architecture) -> float:
"""评估可维护性"""
# 检查类设计
classes = architecture.class_design
if not classes:
return 0.5
# 评估类的复杂度
avg_methods = sum(
len(c.get('methods', [])) for c in classes
) / len(classes)
# 方法数量适中，可维护性高
if 5 <= avg_methods <= 15:
score = 1.0
elif avg_methods < 5:
score = 0.8
else:
score = 0.6
return score
def _generate_recommendations(self,
scores: Dict[str, float]) -> List[str]:
"""生成建议"""
recommendations = []
if scores['modularity'] < 0.7:
recommendations.append(
"建议增加模块划分，提高模块化程度"
)
if scores['extensibility'] < 0.7:
recommendations.append(
"建议使用更多设计模式，提高可扩展性"
)
if scores['maintainability'] < 0.7:
recommendations.append(
"建议简化类设计，降低复杂度"
)
return recommendations
```

#### 29.3.4 代码实现#

##### 代码生成器#

```
python复制```python

class CodeGenerator:
    """代码生成器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client
        self.code_templates = self._load_code_templates()

    async def generate(self, architecture: Architecture,
                      requirement: Requirement) -> GeneratedCode:
        """生成代码"""

        # 生成类代码
        class_codes = []
        for class_design in architecture.class_design:
            code = await self._generate_class_code(
                class_design,
                requirement
            )
            class_codes.append(code)

        # 生成接口代码
        interface_codes = []
        for interface in architecture.interfaces:
            code = await self._generate_interface_code(
                interface,
                requirement
            )
            interface_codes.append(code)

        # 生成主程序代码
        main_code = await self._generate_main_code(
            architecture,
            requirement
        )

        # 组合所有代码
        full_code = self._combine_codes(
            class_codes,
            interface_codes,
            main_code
        )

        return GeneratedCode(
            full_code=full_code,
            class_codes=class_codes,
            interface_codes=interface_codes,
            main_code=main_code
        )

    async def _generate_class_code(self, class_design: Dict,
                                  requirement: Requirement) -> str:
        """生成类代码"""
        prompt = f"""
        根据类设计生成代码：

        类名：{class_design.get('name')}
        方法：{class_design.get('methods', [])}
        属性：{class_design.get('attributes', [])}
        父类：{class_design.get('parent', 'None')}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成完整的类代码，包括：
        1. 类定义
        2. 所有方法的实现
        3. 必要的注释
        4. 错误处理
        """

        return await self.llm_client.complete(prompt)

    async def _generate_interface_code(self, interface: Dict,
                                       requirement: Requirement) -> str:
        """生成接口代码"""
        prompt = f"""
        根据接口设计生成代码：

        接口名：{interface.get('name')}
        方法：{interface.get('methods', [])}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成完整的接口代码。
        """

        return await self.llm_client.complete(prompt)

    async def _generate_main_code(self, architecture: Architecture,
                                  requirement: Requirement) -> str:
        """生成主程序代码"""
        prompt = f"""
        根据架构和需求生成主程序代码：

        功能需求：{requirement.functional_requirements}
        类：{[c.get('name') for c in architecture.class_design]}
        接口：{[i.get('name') for i in architecture.interfaces]}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成主程序代码，包括：
        1. 初始化代码
        2. 主要业务逻辑
        3. 示例用法
        """

        return await self.llm_client.complete(prompt)

    def _combine_codes(self, class_codes: List[str],
                      interface_codes: List[str],
                      main_code: str) -> str:
        """组合代码"""
        combined = []

        # 添加导入
        combined.append("# Generated Code")
        combined.append("")

        # 添加接口
        if interface_codes:
            combined.append("# Interfaces")
            for code in interface_codes:
                combined.append(code)
                combined.append("")

        # 添加类
        if class_codes:
            combined.append("# Classes")
            for code in class_codes:
                combined.append(code)
                combined.append("")

        # 添加主程序
        combined.append("# Main Program")
        combined.append(main_code)

        return "\n".join(combined)

```### 代码优化器

class CodeOptimizer:
"""代码优化器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def optimize(self, code: str,
requirement: Requirement) -> OptimizedCode:
"""优化代码"""
# 分析代码问题
issues = await self._analyze_issues(code)
# 生成优化建议
suggestions = await self._generate_suggestions(
code,
issues,
requirement
)
# 应用优化
optimized_code = await self._apply_optimizations(
code,
suggestions
)
return OptimizedCode(
original_code=code,
optimized_code=optimized_code,
issues=issues,
suggestions=suggestions
)
async def _analyze_issues(self, code: str) -> List[CodeIssue]:
"""分析代码问题"""
prompt = f"""
分析以下代码的问题：
{code}
请识别：
1. 性能问题
2. 安全问题
3. 代码风格问题
4. 潜在的 bug
5. 可维护性问题
以 JSON 格式返回问题列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_issues(response)
async def _generate_suggestions(self, code: str,
issues: List[CodeIssue],
requirement: Requirement) -> List[Suggestion]:
"""生成优化建议"""
prompt = f"""
基于代码问题生成优化建议：
代码：{code}
问题：{issues}
约束条件：{requirement.constraints}
请生成具体的优化建议，包括：
1. 问题描述
2. 优化方案
3. 预期效果
以 JSON 格式返回建议列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_suggestions(response)
async def _apply_optimizations(self, code: str,
suggestions: List[Suggestion]) -> str:
"""应用优化"""
optimized_code = code
for suggestion in suggestions:
if suggestion.applicable:
optimized_code = await self._apply_suggestion(
optimized_code,
suggestion
)
return optimized_code
async def _apply_suggestion(self, code: str,
suggestion: Suggestion) -> str:
"""应用单个建议"""
prompt = f"""
应用以下优化建议到代码：
原始代码：{code}
优化建议：{suggestion.description}
优化方案：{suggestion.solution}
请返回优化后的代码。
"""
return await self.llm_client.complete(prompt)
```

```
```python

class CodeGenerator:
    """代码生成器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client
        self.code_templates = self._load_code_templates()

    async def generate(self, architecture: Architecture,
                      requirement: Requirement) -> GeneratedCode:
        """生成代码"""

        # 生成类代码
        class_codes = []
        for class_design in architecture.class_design:
            code = await self._generate_class_code(
                class_design,
                requirement
            )
            class_codes.append(code)

        # 生成接口代码
        interface_codes = []
        for interface in architecture.interfaces:
            code = await self._generate_interface_code(
                interface,
                requirement
            )
            interface_codes.append(code)

        # 生成主程序代码
        main_code = await self._generate_main_code(
            architecture,
            requirement
        )

        # 组合所有代码
        full_code = self._combine_codes(
            class_codes,
            interface_codes,
            main_code
        )

        return GeneratedCode(
            full_code=full_code,
            class_codes=class_codes,
            interface_codes=interface_codes,
            main_code=main_code
        )

    async def _generate_class_code(self, class_design: Dict,
                                  requirement: Requirement) -> str:
        """生成类代码"""
        prompt = f"""
        根据类设计生成代码：

        类名：{class_design.get('name')}
        方法：{class_design.get('methods', [])}
        属性：{class_design.get('attributes', [])}
        父类：{class_design.get('parent', 'None')}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成完整的类代码，包括：
        1. 类定义
        2. 所有方法的实现
        3. 必要的注释
        4. 错误处理
        """

        return await self.llm_client.complete(prompt)

    async def _generate_interface_code(self, interface: Dict,
                                       requirement: Requirement) -> str:
        """生成接口代码"""
        prompt = f"""
        根据接口设计生成代码：

        接口名：{interface.get('name')}
        方法：{interface.get('methods', [])}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成完整的接口代码。
        """

        return await self.llm_client.complete(prompt)

    async def _generate_main_code(self, architecture: Architecture,
                                  requirement: Requirement) -> str:
        """生成主程序代码"""
        prompt = f"""
        根据架构和需求生成主程序代码：

        功能需求：{requirement.functional_requirements}
        类：{[c.get('name') for c in architecture.class_design]}
        接口：{[i.get('name') for i in architecture.interfaces]}
        编程语言：{requirement.tech_stack.get('language', 'Python')}

        请生成主程序代码，包括：
        1. 初始化代码
        2. 主要业务逻辑
        3. 示例用法
        """

        return await self.llm_client.complete(prompt)

    def _combine_codes(self, class_codes: List[str],
                      interface_codes: List[str],
                      main_code: str) -> str:
        """组合代码"""
        combined = []

        # 添加导入
        combined.append("# Generated Code")
        combined.append("")

        # 添加接口
        if interface_codes:
            combined.append("# Interfaces")
            for code in interface_codes:
                combined.append(code)
                combined.append("")

        # 添加类
        if class_codes:
            combined.append("# Classes")
            for code in class_codes:
                combined.append(code)
                combined.append("")

        # 添加主程序
        combined.append("# Main Program")
        combined.append(main_code)

        return "\n".join(combined)

```### 代码优化器

class CodeOptimizer:
"""代码优化器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def optimize(self, code: str,
requirement: Requirement) -> OptimizedCode:
"""优化代码"""
# 分析代码问题
issues = await self._analyze_issues(code)
# 生成优化建议
suggestions = await self._generate_suggestions(
code,
issues,
requirement
)
# 应用优化
optimized_code = await self._apply_optimizations(
code,
suggestions
)
return OptimizedCode(
original_code=code,
optimized_code=optimized_code,
issues=issues,
suggestions=suggestions
)
async def _analyze_issues(self, code: str) -> List[CodeIssue]:
"""分析代码问题"""
prompt = f"""
分析以下代码的问题：
{code}
请识别：
1. 性能问题
2. 安全问题
3. 代码风格问题
4. 潜在的 bug
5. 可维护性问题
以 JSON 格式返回问题列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_issues(response)
async def _generate_suggestions(self, code: str,
issues: List[CodeIssue],
requirement: Requirement) -> List[Suggestion]:
"""生成优化建议"""
prompt = f"""
基于代码问题生成优化建议：
代码：{code}
问题：{issues}
约束条件：{requirement.constraints}
请生成具体的优化建议，包括：
1. 问题描述
2. 优化方案
3. 预期效果
以 JSON 格式返回建议列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_suggestions(response)
async def _apply_optimizations(self, code: str,
suggestions: List[Suggestion]) -> str:
"""应用优化"""
optimized_code = code
for suggestion in suggestions:
if suggestion.applicable:
optimized_code = await self._apply_suggestion(
optimized_code,
suggestion
)
return optimized_code
async def _apply_suggestion(self, code: str,
suggestion: Suggestion) -> str:
"""应用单个建议"""
prompt = f"""
应用以下优化建议到代码：
原始代码：{code}
优化建议：{suggestion.description}
优化方案：{suggestion.solution}
请返回优化后的代码。
"""
return await self.llm_client.complete(prompt)
```

#### 29.3.5 代码验证#

##### 代码验证器#

```
python复制```python

class CodeValidator:
    """代码验证器"""

    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager

    async def validate(self, code: str,
                      requirement: Requirement) -> ValidationResult:
        """验证代码"""

        results = []

        # 语法检查
        syntax_result = await self._check_syntax(code, requirement)
        results.append(syntax_result)

        # 类型检查
        type_result = await self._check_types(code, requirement)
        results.append(type_result)

        # 逻辑检查
        logic_result = await self._check_logic(code, requirement)
        results.append(logic_result)

        # 性能检查
        performance_result = await self._check_performance(
            code,
            requirement
        )
        results.append(performance_result)

        # 综合结果
        all_passed = all(r.passed for r in results)

        return ValidationResult(
            passed=all_passed,
            results=results,
            issues=self._collect_issues(results)
        )

    async def _check_syntax(self, code: str,
                           requirement: Requirement) -> CheckResult:
        """检查语法"""
        language = requirement.tech_stack.get('language', 'python')

        try:
            if language == 'python':
                result = await self._check_python_syntax(code)
            else:
                result = CheckResult(
                    check_type='syntax',
                    passed=True,
                    message=f"Syntax check for {language} not implemented"
                )

            return result

        except Exception as e:
            return CheckResult(
                check_type='syntax',
                passed=False,
                message=f"Syntax error: {str(e)}"
            )

    async def _check_python_syntax(self, code: str) -> CheckResult:
        """检查 Python 语法"""
        try:
            compile(code, '<string>', 'exec')
            return CheckResult(
                check_type='syntax',
                passed=True,
                message="Syntax is valid"
            )
        except SyntaxError as e:
            return CheckResult(
                check_type='syntax',
                passed=False,
                message=f"Syntax error at line {e.lineno}: {e.msg}"
            )

    async def _check_types(self, code: str,
                          requirement: Requirement) -> CheckResult:
        """检查类型"""
        # 使用类型检查工具
        tool = self.tool_manager.get_tool('type_checker')

        if not tool:
            return CheckResult(
                check_type='type',
                passed=True,
                message="Type checker not available"
            )

        try:
            result = await tool.execute({'code': code})

            if result.success:
                return CheckResult(
                    check_type='type',
                    passed=True,
                    message="Type check passed"
                )
            else:
                return CheckResult(
                    check_type='type',
                    passed=False,
                    message=f"Type check failed: {result.error}"
                )
        except Exception as e:
            return CheckResult(
                check_type='type',
                passed=False,
                message=f"Type check error: {str(e)}"
            )

    async def _check_logic(self, code: str,
                          requirement: Requirement) -> CheckResult:
        """检查逻辑"""
        # 分析代码逻辑
        issues = []

        # 检查空指针
        if 'None' in code and 'if' not in code:
            issues.append("Potential None reference without check")

        # 检查资源泄漏
        if 'open(' in code and 'close(' not in code:
            issues.append("Potential resource leak (file not closed)")

        if issues:
            return CheckResult(
                check_type='logic',
                passed=False,
                message=f"Logic issues: {', '.join(issues)}"
            )
        else:
            return CheckResult(
                check_type='logic',
                passed=True,
                message="Logic check passed"
            )

    async def _check_performance(self, code: str,
                                requirement: Requirement) -> CheckResult:
        """检查性能"""
        issues = []

        # 检查嵌套循环
        if code.count('for ') > 2:
            issues.append("Deep nested loops may cause performance issues")

        # 检查大列表操作
        if 'list(' in code and 'range(' in code:
            issues.append("Consider using generator expressions for large ranges")

        if issues:
            return CheckResult(
                check_type='performance',
                passed=False,
                message=f"Performance issues: {', '.join(issues)}"
            )
        else:
            return CheckResult(
                check_type='performance',
                passed=True,
                message="Performance check passed"
            )

    def _collect_issues(self,
                       results: List[CheckResult]) -> List[str]:
        """收集所有问题"""
        issues = []

        for result in results:
            if not result.passed:
                issues.append(result.message)

        return issues
```

```
```python

class CodeValidator:
    """代码验证器"""

    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager

    async def validate(self, code: str,
                      requirement: Requirement) -> ValidationResult:
        """验证代码"""

        results = []

        # 语法检查
        syntax_result = await self._check_syntax(code, requirement)
        results.append(syntax_result)

        # 类型检查
        type_result = await self._check_types(code, requirement)
        results.append(type_result)

        # 逻辑检查
        logic_result = await self._check_logic(code, requirement)
        results.append(logic_result)

        # 性能检查
        performance_result = await self._check_performance(
            code,
            requirement
        )
        results.append(performance_result)

        # 综合结果
        all_passed = all(r.passed for r in results)

        return ValidationResult(
            passed=all_passed,
            results=results,
            issues=self._collect_issues(results)
        )

    async def _check_syntax(self, code: str,
                           requirement: Requirement) -> CheckResult:
        """检查语法"""
        language = requirement.tech_stack.get('language', 'python')

        try:
            if language == 'python':
                result = await self._check_python_syntax(code)
            else:
                result = CheckResult(
                    check_type='syntax',
                    passed=True,
                    message=f"Syntax check for {language} not implemented"
                )

            return result

        except Exception as e:
            return CheckResult(
                check_type='syntax',
                passed=False,
                message=f"Syntax error: {str(e)}"
            )

    async def _check_python_syntax(self, code: str) -> CheckResult:
        """检查 Python 语法"""
        try:
            compile(code, '<string>', 'exec')
            return CheckResult(
                check_type='syntax',
                passed=True,
                message="Syntax is valid"
            )
        except SyntaxError as e:
            return CheckResult(
                check_type='syntax',
                passed=False,
                message=f"Syntax error at line {e.lineno}: {e.msg}"
            )

    async def _check_types(self, code: str,
                          requirement: Requirement) -> CheckResult:
        """检查类型"""
        # 使用类型检查工具
        tool = self.tool_manager.get_tool('type_checker')

        if not tool:
            return CheckResult(
                check_type='type',
                passed=True,
                message="Type checker not available"
            )

        try:
            result = await tool.execute({'code': code})

            if result.success:
                return CheckResult(
                    check_type='type',
                    passed=True,
                    message="Type check passed"
                )
            else:
                return CheckResult(
                    check_type='type',
                    passed=False,
                    message=f"Type check failed: {result.error}"
                )
        except Exception as e:
            return CheckResult(
                check_type='type',
                passed=False,
                message=f"Type check error: {str(e)}"
            )

    async def _check_logic(self, code: str,
                          requirement: Requirement) -> CheckResult:
        """检查逻辑"""
        # 分析代码逻辑
        issues = []

        # 检查空指针
        if 'None' in code and 'if' not in code:
            issues.append("Potential None reference without check")

        # 检查资源泄漏
        if 'open(' in code and 'close(' not in code:
            issues.append("Potential resource leak (file not closed)")

        if issues:
            return CheckResult(
                check_type='logic',
                passed=False,
                message=f"Logic issues: {', '.join(issues)}"
            )
        else:
            return CheckResult(
                check_type='logic',
                passed=True,
                message="Logic check passed"
            )

    async def _check_performance(self, code: str,
                                requirement: Requirement) -> CheckResult:
        """检查性能"""
        issues = []

        # 检查嵌套循环
        if code.count('for ') > 2:
            issues.append("Deep nested loops may cause performance issues")

        # 检查大列表操作
        if 'list(' in code and 'range(' in code:
            issues.append("Consider using generator expressions for large ranges")

        if issues:
            return CheckResult(
                check_type='performance',
                passed=False,
                message=f"Performance issues: {', '.join(issues)}"
            )
        else:
            return CheckResult(
                check_type='performance',
                passed=True,
                message="Performance check passed"
            )

    def _collect_issues(self,
                       results: List[CheckResult]) -> List[str]:
        """收集所有问题"""
        issues = []

        for result in results:
            if not result.passed:
                issues.append(result.message)

        return issues
```

通过实现这些组件，我们可以构建一个完整的代码生成模块，能够从需求分析到代码验证的全流程自动化。

---

## 4 代码理解模块

**URL**: https://claudecode.tangshuang.net/course/29.4%20%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97

#### 29.4.1 代码理解概述#

代码理解模块是编程 Agent 的另一个核心能力，它能够分析、解释和理解现有代码的功能、结构和设计。代码理解涉及代码解析、语义分析、依赖分析等多个环节。

##### 代码理解流程#

输入代码
↓
代码解析
↓
结构分析
↓
语义分析
↓
依赖分析
↓
功能推断
↓
生成解释

#### 29.4.2 代码解析#

##### 代码解析器#

```
python复制python

class CodeParser:
    """代码解析器"""

    def __init__(self):
        self.parsers = {
            'python': PythonParser(),
            'javascript': JavaScriptParser(),
            'java': JavaParser(),
            'cpp': CppParser()
        }

    def parse(self, code: str, language: str) -> ParsedCode:
        """解析代码"""
        parser = self.parsers.get(language.lower())

        if not parser:
            raise ValueError(f"Unsupported language: {language}")

        return parser.parse(code)

class PythonParser:
    """Python 解析器"""

    def parse(self, code: str) -> ParsedCode:
        """解析 Python 代码"""
        try:
            tree = ast.parse(code)

            parsed_code = ParsedCode(
                language='python',
                original_code=code,
                ast=tree
            )

            # 提取类
            parsed_code.classes = self._extract_classes(tree)

            # 提取函数
            parsed_code.functions = self._extract_functions(tree)

            # 提取导入
            parsed_code.imports = self._extract_imports(tree)

            # 提取全局变量
            parsed_code.global_variables = self._extract_global_variables(tree)

            return parsed_code

        except SyntaxError as e:
            raise ValueError(f"Invalid Python code: {e}")

    def _extract_classes(self, tree: ast.AST) -> List[ClassInfo]:
        """提取类信息"""
        classes = []

        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_info = ClassInfo(
                    name=node.name,
                    bases=[self._get_name(base) for base in node.bases],
                    methods=[self._extract_method(m) for m in node.body
                            if isinstance(m, ast.FunctionDef)],
                    attributes=[self._extract_attribute(a) for a in node.body
                              if isinstance(a, ast.Assign)],
```

```
python

class CodeParser:
    """代码解析器"""

    def __init__(self):
        self.parsers = {
            'python': PythonParser(),
            'javascript': JavaScriptParser(),
            'java': JavaParser(),
            'cpp': CppParser()
        }

    def parse(self, code: str, language: str) -> ParsedCode:
        """解析代码"""
        parser = self.parsers.get(language.lower())

        if not parser:
            raise ValueError(f"Unsupported language: {language}")

        return parser.parse(code)

class PythonParser:
    """Python 解析器"""

    def parse(self, code: str) -> ParsedCode:
        """解析 Python 代码"""
        try:
            tree = ast.parse(code)

            parsed_code = ParsedCode(
                language='python',
                original_code=code,
                ast=tree
            )

            # 提取类
            parsed_code.classes = self._extract_classes(tree)

            # 提取函数
            parsed_code.functions = self._extract_functions(tree)

            # 提取导入
            parsed_code.imports = self._extract_imports(tree)

            # 提取全局变量
            parsed_code.global_variables = self._extract_global_variables(tree)

            return parsed_code

        except SyntaxError as e:
            raise ValueError(f"Invalid Python code: {e}")

    def _extract_classes(self, tree: ast.AST) -> List[ClassInfo]:
        """提取类信息"""
        classes = []

        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_info = ClassInfo(
                    name=node.name,
                    bases=[self._get_name(base) for base in node.bases],
                    methods=[self._extract_method(m) for m in node.body
                            if isinstance(m, ast.FunctionDef)],
                    attributes=[self._extract_attribute(a) for a in node.body
                              if isinstance(a, ast.Assign)],
```

```
bash复制                docstring=ast.get_docstring(node)
            )
            classes.append(class_info)

    return classes

def _extract_functions(self, tree: ast.AST) -> List[FunctionInfo]:
    """提取函数信息"""
    functions = []

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            # 跳过类中的方法
            if not any(isinstance(parent, ast.ClassDef)
                      for parent in ast.walk(tree)
                      if node in ast.iter_child_nodes(parent)):
                function_info = FunctionInfo(
                    name=node.name,
                    arguments=[arg.arg for arg in node.args.args],
                    return_type=self._get_return_type(node),
                    docstring=ast.get_docstring(node),
                    decorators=[self._get_name(d) for d in node.decorator_list]
                )
                functions.append(function_info)

    return functions

def _extract_imports(self, tree: ast.AST) -> List[ImportInfo]:
    """提取导入信息"""
    imports = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                import_info = ImportInfo(
                    module=alias.name,
                    alias=alias.asname,
                    type='import'
                )
                imports.append(import_info)
        elif isinstance(node, ast.ImportFrom):
            for alias in node.names:
                import_info = ImportInfo(
                    module=node.module,
                    name=alias.name,
                    alias=alias.asname,
                    type='from'
                )
                imports.append(import_info)

    return imports

def _extract_global_variables(self, tree: ast.AST) -> List[VariableInfo]:
    """提取全局变量"""
    variables = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Assign):
            # 只提取模块级别的变量
            if isinstance(node, ast.Module):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        var_info = VariableInfo(
                            name=target.id,
                            type=self._infer_type(node.value),
                            value=self._get_value(node.value)
                        )
                        variables.append(var_info)

    return variables

def _extract_method(self, node: ast.FunctionDef) -> MethodInfo:
    """提取方法信息"""
    return MethodInfo(
        name=node.name,
        arguments=[arg.arg for arg in node.args.args],
        return_type=self._get_return_type(node),
        docstring=ast.get_docstring(node),
        is_static=any(isinstance(d, ast.Name) and d.id == 'staticmethod'
                      for d in node.decorator_list),
        is_classmethod=any(isinstance(d, ast.Name) and d.id == 'classmethod'
                          for d in node.decorator_list)
    )

def _extract_attribute(self, node: ast.Assign) -> AttributeInfo:
    """提取属性信息"""
    target = node.targets[0]
    if isinstance(target, ast.Name):
        return AttributeInfo(
            name=target.id,
            type=self._infer_type(node.value),
            value=self._get_value(node.value)
        )
    return None

def _get_name(self, node: ast.AST) -> str:
    """获取节点名称"""
    if isinstance(node, ast.Name):
        return node.id
    elif isinstance(node, ast.Attribute):
        return f"{self._get_name(node.value)}.{node.attr}"
    return str(node)

def _get_return_type(self, node: ast.FunctionDef) -> str:
    """获取返回类型"""
    if node.returns:
        return self._get_name(node.returns)
    return "None"

def _infer_type(self, node: ast.AST) -> str:
    """推断类型"""
    if isinstance(node, ast.Constant):
        return type(node.value).__name__
    elif isinstance(node, ast.List):
        return "list"
    elif isinstance(node, ast.Dict):
        return "dict"
    elif isinstance(node, ast.Call):
        return self._get_name(node.func)
    return "Any"

def _get_value(self, node: ast.AST) -> Any:
    """获取值"""
    if isinstance(node, ast.Constant):
        return node.value
    return None
```

```
docstring=ast.get_docstring(node)
            )
            classes.append(class_info)

    return classes

def _extract_functions(self, tree: ast.AST) -> List[FunctionInfo]:
    """提取函数信息"""
    functions = []

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            # 跳过类中的方法
            if not any(isinstance(parent, ast.ClassDef)
                      for parent in ast.walk(tree)
                      if node in ast.iter_child_nodes(parent)):
                function_info = FunctionInfo(
                    name=node.name,
                    arguments=[arg.arg for arg in node.args.args],
                    return_type=self._get_return_type(node),
                    docstring=ast.get_docstring(node),
                    decorators=[self._get_name(d) for d in node.decorator_list]
                )
                functions.append(function_info)

    return functions

def _extract_imports(self, tree: ast.AST) -> List[ImportInfo]:
    """提取导入信息"""
    imports = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                import_info = ImportInfo(
                    module=alias.name,
                    alias=alias.asname,
                    type='import'
                )
                imports.append(import_info)
        elif isinstance(node, ast.ImportFrom):
            for alias in node.names:
                import_info = ImportInfo(
                    module=node.module,
                    name=alias.name,
                    alias=alias.asname,
                    type='from'
                )
                imports.append(import_info)

    return imports

def _extract_global_variables(self, tree: ast.AST) -> List[VariableInfo]:
    """提取全局变量"""
    variables = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Assign):
            # 只提取模块级别的变量
            if isinstance(node, ast.Module):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        var_info = VariableInfo(
                            name=target.id,
                            type=self._infer_type(node.value),
                            value=self._get_value(node.value)
                        )
                        variables.append(var_info)

    return variables

def _extract_method(self, node: ast.FunctionDef) -> MethodInfo:
    """提取方法信息"""
    return MethodInfo(
        name=node.name,
        arguments=[arg.arg for arg in node.args.args],
        return_type=self._get_return_type(node),
        docstring=ast.get_docstring(node),
        is_static=any(isinstance(d, ast.Name) and d.id == 'staticmethod'
                      for d in node.decorator_list),
        is_classmethod=any(isinstance(d, ast.Name) and d.id == 'classmethod'
                          for d in node.decorator_list)
    )

def _extract_attribute(self, node: ast.Assign) -> AttributeInfo:
    """提取属性信息"""
    target = node.targets[0]
    if isinstance(target, ast.Name):
        return AttributeInfo(
            name=target.id,
            type=self._infer_type(node.value),
            value=self._get_value(node.value)
        )
    return None

def _get_name(self, node: ast.AST) -> str:
    """获取节点名称"""
    if isinstance(node, ast.Name):
        return node.id
    elif isinstance(node, ast.Attribute):
        return f"{self._get_name(node.value)}.{node.attr}"
    return str(node)

def _get_return_type(self, node: ast.FunctionDef) -> str:
    """获取返回类型"""
    if node.returns:
        return self._get_name(node.returns)
    return "None"

def _infer_type(self, node: ast.AST) -> str:
    """推断类型"""
    if isinstance(node, ast.Constant):
        return type(node.value).__name__
    elif isinstance(node, ast.List):
        return "list"
    elif isinstance(node, ast.Dict):
        return "dict"
    elif isinstance(node, ast.Call):
        return self._get_name(node.func)
    return "Any"

def _get_value(self, node: ast.AST) -> Any:
    """获取值"""
    if isinstance(node, ast.Constant):
        return node.value
    return None
```

```
bash复制
### 结构分析器

class StructureAnalyzer:
"""结构分析器"""
def analyze(self, parsed_code: ParsedCode) -> StructureAnalysis:
"""分析代码结构"""
analysis = StructureAnalysis()
# 分析类的层次结构
analysis.class_hierarchy = self._analyze_class_hierarchy(
parsed_code.classes
)
# 分析函数调用关系
analysis.call_graph = self._analyze_call_graph(parsed_code)
# 分析模块依赖
analysis.dependencies = self._analyze_dependencies(parsed_code)
# 分析代码复杂度
analysis.complexity = self._analyze_complexity(parsed_code)
return analysis
def _analyze_class_hierarchy(self,
classes: List[ClassInfo]) -> Dict[str, List[str]]:
"""分析类层次结构"""
hierarchy = {}
for cls in classes:
hierarchy[cls.name] = cls.bases
return hierarchy
def _analyze_call_graph(self,
parsed_code: ParsedCode) -> Dict[str, List[str]]:
"""分析函数调用关系"""
call_graph = {}
# 分析函数调用
for func in parsed_code.functions:
calls = self._extract_function_calls(func, parsed_code)
call_graph[func.name] = calls
# 分析方法调用
for cls in parsed_code.classes:
for method in cls.methods:
calls = self._extract_method_calls(method, cls, parsed_code)
call_graph[f"{cls.name}.{method.name}"] = calls
return call_graph
def _extract_function_calls(self, func: FunctionInfo,
parsed_code: ParsedCode) -> List[str]:
"""提取函数调用"""
calls = []
# 这里需要更复杂的 AST 分析
# 简化实现：从函数体中提取调用
return calls
def _extract_method_calls(self, method: MethodInfo,
cls: ClassInfo,
parsed_code: ParsedCode) -> List[str]:
"""提取方法调用"""
calls = []
# 这里需要更复杂的 AST 分析
# 简化实现：从方法体中提取调用
return calls
def _analyze_dependencies(self,
parsed_code: ParsedCode) -> List[Dependency]:
"""分析依赖关系"""
dependencies = []
# 分析导入依赖
for imp in parsed_code.imports:
dependency = Dependency(
type='import',
source=parsed_code.language,
target=imp.module,
strength='external'
)
dependencies.append(dependency)
# 分析类继承依赖
for cls in parsed_code.classes:
for base in cls.bases:
dependency = Dependency(
type='inheritance',
source=cls.name,
target=base,
strength='strong'
)
dependencies.append(dependency)
return dependencies
def _analyze_complexity(self,
parsed_code: ParsedCode) -> ComplexityMetrics:
"""分析代码复杂度"""
metrics = ComplexityMetrics()
# 计算圈复杂度
metrics.cyclomatic_complexity = self._calculate_cyclomatic_complexity(
parsed_code
)
# 计算认知复杂度
metrics.cognitive_complexity = self._calculate_cognitive_complexity(
parsed_code
)
# 计算维护性指数
metrics.maintainability_index = self._calculate_maintainability_index(
parsed_code
)
return metrics
def _calculate_cyclomatic_complexity(self,
parsed_code: ParsedCode) -> float:
"""计算圈复杂度"""
complexity = 1  # 基础复杂度
# 遍历 AST，计算决策点
for node in ast.walk(parsed_code.ast):
if isinstance(node, (ast.If, ast.While, ast.For, ast.ExceptHandler)):
complexity += 1
elif isinstance(node, ast.BoolOp):
complexity += len(node.values) - 1
return complexity
def _calculate_cognitive_complexity(self,
parsed_code: ParsedCode) -> float:
"""计算认知复杂度"""
# 简化实现
return self._calculate_cyclomatic_complexity(parsed_code) * 1.5
def _calculate_maintainability_index(self,
parsed_code: ParsedCode) -> float:
"""计算维护性指数"""
# 简化实现
loc = len(parsed_code.original_code.split('\n'))
complexity = self._calculate_cyclomatic_complexity(parsed_code)
# MI = 171 - 5.2 * ln(V) - 0.23 * G - 16.2 * ln(L)
# V = 圈复杂度, G = 代码行数, L = 代码行数
mi = 171 - 5.2 * math.log(complexity) - 0.23 * loc - 16.2 * math.log(loc)
return max(0, min(100, mi))
```

```
### 结构分析器

class StructureAnalyzer:
"""结构分析器"""
def analyze(self, parsed_code: ParsedCode) -> StructureAnalysis:
"""分析代码结构"""
analysis = StructureAnalysis()
# 分析类的层次结构
analysis.class_hierarchy = self._analyze_class_hierarchy(
parsed_code.classes
)
# 分析函数调用关系
analysis.call_graph = self._analyze_call_graph(parsed_code)
# 分析模块依赖
analysis.dependencies = self._analyze_dependencies(parsed_code)
# 分析代码复杂度
analysis.complexity = self._analyze_complexity(parsed_code)
return analysis
def _analyze_class_hierarchy(self,
classes: List[ClassInfo]) -> Dict[str, List[str]]:
"""分析类层次结构"""
hierarchy = {}
for cls in classes:
hierarchy[cls.name] = cls.bases
return hierarchy
def _analyze_call_graph(self,
parsed_code: ParsedCode) -> Dict[str, List[str]]:
"""分析函数调用关系"""
call_graph = {}
# 分析函数调用
for func in parsed_code.functions:
calls = self._extract_function_calls(func, parsed_code)
call_graph[func.name] = calls
# 分析方法调用
for cls in parsed_code.classes:
for method in cls.methods:
calls = self._extract_method_calls(method, cls, parsed_code)
call_graph[f"{cls.name}.{method.name}"] = calls
return call_graph
def _extract_function_calls(self, func: FunctionInfo,
parsed_code: ParsedCode) -> List[str]:
"""提取函数调用"""
calls = []
# 这里需要更复杂的 AST 分析
# 简化实现：从函数体中提取调用
return calls
def _extract_method_calls(self, method: MethodInfo,
cls: ClassInfo,
parsed_code: ParsedCode) -> List[str]:
"""提取方法调用"""
calls = []
# 这里需要更复杂的 AST 分析
# 简化实现：从方法体中提取调用
return calls
def _analyze_dependencies(self,
parsed_code: ParsedCode) -> List[Dependency]:
"""分析依赖关系"""
dependencies = []
# 分析导入依赖
for imp in parsed_code.imports:
dependency = Dependency(
type='import',
source=parsed_code.language,
target=imp.module,
strength='external'
)
dependencies.append(dependency)
# 分析类继承依赖
for cls in parsed_code.classes:
for base in cls.bases:
dependency = Dependency(
type='inheritance',
source=cls.name,
target=base,
strength='strong'
)
dependencies.append(dependency)
return dependencies
def _analyze_complexity(self,
parsed_code: ParsedCode) -> ComplexityMetrics:
"""分析代码复杂度"""
metrics = ComplexityMetrics()
# 计算圈复杂度
metrics.cyclomatic_complexity = self._calculate_cyclomatic_complexity(
parsed_code
)
# 计算认知复杂度
metrics.cognitive_complexity = self._calculate_cognitive_complexity(
parsed_code
)
# 计算维护性指数
metrics.maintainability_index = self._calculate_maintainability_index(
parsed_code
)
return metrics
def _calculate_cyclomatic_complexity(self,
parsed_code: ParsedCode) -> float:
"""计算圈复杂度"""
complexity = 1  # 基础复杂度
# 遍历 AST，计算决策点
for node in ast.walk(parsed_code.ast):
if isinstance(node, (ast.If, ast.While, ast.For, ast.ExceptHandler)):
complexity += 1
elif isinstance(node, ast.BoolOp):
complexity += len(node.values) - 1
return complexity
def _calculate_cognitive_complexity(self,
parsed_code: ParsedCode) -> float:
"""计算认知复杂度"""
# 简化实现
return self._calculate_cyclomatic_complexity(parsed_code) * 1.5
def _calculate_maintainability_index(self,
parsed_code: ParsedCode) -> float:
"""计算维护性指数"""
# 简化实现
loc = len(parsed_code.original_code.split('\n'))
complexity = self._calculate_cyclomatic_complexity(parsed_code)
# MI = 171 - 5.2 * ln(V) - 0.23 * G - 16.2 * ln(L)
# V = 圈复杂度, G = 代码行数, L = 代码行数
mi = 171 - 5.2 * math.log(complexity) - 0.23 * loc - 16.2 * math.log(loc)
return max(0, min(100, mi))
```

#### 29.4.4 语义分析#

##### 语义分析器#

```
python复制```python

class SemanticAnalyzer:
    """语义分析器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def analyze(self, parsed_code: ParsedCode,
                     structure: StructureAnalysis) -> SemanticAnalysis:
        """分析代码语义"""
        analysis = SemanticAnalysis()

        # 分析代码意图
        analysis.purpose = await self._analyze_purpose(parsed_code)

        # 分析算法
        analysis.algorithms = await self._analyze_algorithms(parsed_code)

        # 分析设计模式
        analysis.design_patterns = await self._analyze_design_patterns(
            parsed_code,
            structure
        )

        # 分析数据流
        analysis.data_flow = await self._analyze_data_flow(parsed_code)

        return analysis

    async def _analyze_purpose(self,
                              parsed_code: ParsedCode) -> str:
        """分析代码目的"""
        prompt = f"""
        分析以下代码的主要目的和功能：

        {parsed_code.original_code}

        请用简洁的语言描述这段代码的主要功能。
        """

        return await self.llm_client.complete(prompt)

    async def _analyze_algorithms(self,
                                 parsed_code: ParsedCode) -> List[AlgorithmInfo]:
        """分析算法"""
        prompt = f"""
        识别以下代码中使用的算法：

        {parsed_code.original_code}

        请识别：
        1. 使用的主要算法（排序、搜索、图算法等）
        2. 算法的时间复杂度
        3. 算法的空间复杂度

        以 JSON 格式返回结果。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_algorithms(response)

    async def _analyze_design_patterns(self,
                                      parsed_code: ParsedCode,
                                      structure: StructureAnalysis) -> List[str]:
        """分析设计模式"""
        prompt = f"""
        识别以下代码中使用的设计模式：

        类：{parsed_code.classes}
        函数：{parsed_code.functions}
        类层次结构：{structure.class_hierarchy}

        请识别使用的设计模式。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_design_patterns(response)

    async def _analyze_data_flow(self,
                                parsed_code: ParsedCode) -> DataFlowAnalysis:
        """分析数据流"""
        analysis = DataFlowAnalysis()

        # 分析输入
        analysis.inputs = self._identify_inputs(parsed_code)

        # 分析输出
        analysis.outputs = self._identify_outputs(parsed_code)

        # 分析转换
        analysis.transformations = self._identify_transformations(parsed_code)

        return analysis

    def _identify_inputs(self, parsed_code: ParsedCode) -> List[str]:
        """识别输入"""
        inputs = []

        # 函数参数
        for func in parsed_code.functions:
            inputs.extend(func.arguments)

        # 方法参数
        for cls in parsed_code.classes:
            for method in cls.methods:
                inputs.extend(method.arguments)

        return list(set(inputs))

    def _identify_outputs(self, parsed_code: ParsedCode) -> List[str]:
        """识别输出"""
        outputs = []

        # 函数返回值
        for func in parsed_code.functions:
            if func.return_type != "None":
                outputs.append(f"{func.name}() -> {func.return_type}")

        # 方法返回值
        for cls in parsed_code.classes:
            for method in cls.methods:
                if method.return_type != "None":
                    outputs.append(f"{cls.name}.{method.name}() -> {method.return_type}")

        return outputs

    def _identify_transformations(self,
                                 parsed_code: ParsedCode) -> List[str]:
        """识别数据转换"""
        transformations = []

        # 这里需要更复杂的分析
        # 简化实现：基于函数名推断

        for func in parsed_code.functions:
            if any(keyword in func.name.lower()
                  for keyword in ['transform', 'convert', 'process', 'compute']):
                transformations.append(func.name)

        return transformations

```## 29.4.5 代码解释生成

### 解释生成器

class ExplanationGenerator:
"""解释生成器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def generate_explanation(self,
parsed_code: ParsedCode,
structure: StructureAnalysis,
semantic: SemanticAnalysis) -> CodeExplanation:
"""生成代码解释"""
explanation = CodeExplanation()
# 生成总体概述
explanation.overview = await self._generate_overview(
parsed_code,
semantic
)
# 生成类解释
explanation.class_explanations = await self._generate_class_explanations(
parsed_code.classes,
structure
)
# 生成函数解释
explanation.function_explanations = await self._generate_function_explanations(
parsed_code.functions,
structure
)
# 生成算法解释
explanation.algorithm_explanations = await self._generate_algorithm_explanations(
semantic.algorithms
)
# 生成使用示例
explanation.usage_examples = await self._generate_usage_examples(
parsed_code
)
return explanation
async def _generate_overview(self,
parsed_code: ParsedCode,
semantic: SemanticAnalysis) -> str:
"""生成总体概述"""
prompt = f"""
为以下代码生成总体概述：
代码目的：{semantic.purpose}
类：{[c.name for c in parsed_code.classes]}
函数：{[f.name for f in parsed_code.functions]}
请生成一个清晰的总体概述，包括：
1. 代码的主要功能
2. 主要组件
3. 整体架构
"""
return await self.llm_client.complete(prompt)
async def _generate_class_explanations(self,
classes: List[ClassInfo],
structure: StructureAnalysis) -> Dict[str, str]:
"""生成类解释"""
explanations = {}
for cls in classes:
prompt = f"""
为以下类生成详细解释：
类名：{cls.name}
父类：{cls.bases}
方法：{[m.name for m in cls.methods]}
属性：{[a.name for a in cls.attributes if a]}
文档字符串：{cls.docstring}
请生成详细的类解释，包括：
1. 类的职责
2. 主要方法的功能
3. 使用场景
"""
explanation = await self.llm_client.complete(prompt)
explanations[cls.name] = explanation
return explanations
async def _generate_function_explanations(self,
functions: List[FunctionInfo],
structure: StructureAnalysis) -> Dict[str, str]:
"""生成函数解释"""
explanations = {}
for func in functions:
prompt = f"""
为以下函数生成详细解释：
函数名：{func.name}
参数：{func.arguments}
返回类型：{func.return_type}
文档字符串：{func.docstring}
请生成详细的函数解释，包括：
1. 函数的功能
2. 参数说明
3. 返回值说明
4. 使用示例
"""
explanation = await self.llm_client.complete(prompt)
explanations[func.name] = explanation
return explanations
async def _generate_algorithm_explanations(self,
algorithms: List[AlgorithmInfo]) -> Dict[str, str]:
"""生成算法解释"""
explanations = {}
for algo in algorithms:
prompt = f"""
为以下算法生成详细解释：
算法名称：{algo.name}
时间复杂度：{algo.time_complexity}
空间复杂度：{algo.space_complexity}
请生成详细的算法解释，包括：
1. 算法原理
2. 实现细节
3. 优缺点分析
4. 适用场景
"""
explanation = await self.llm_client.complete(prompt)
explanations[algo.name] = explanation
return explanations
async def _generate_usage_examples(self,
parsed_code: ParsedCode) -> List[str]:
"""生成使用示例"""
examples = []
# 为每个类生成示例
for cls in parsed_code.classes:
prompt = f"""
为以下类生成使用示例：
类名：{cls.name}
方法：{[m.name for m in cls.methods]}
请生成 2-3 个实用的使用示例。
"""
example = await self.llm_client.complete(prompt)
examples.append(example)
# 为主要函数生成示例
for func in parsed_code.functions[:3]:  # 只生成前 3 个函数的示例
prompt = f"""
为以下函数生成使用示例：
函数名：{func.name}
参数：{func.arguments}
请生成 1-2 个实用的使用示例。
"""
example = await self.llm_client.complete(prompt)
examples.append(example)
return examples
```

```
```python

class SemanticAnalyzer:
    """语义分析器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def analyze(self, parsed_code: ParsedCode,
                     structure: StructureAnalysis) -> SemanticAnalysis:
        """分析代码语义"""
        analysis = SemanticAnalysis()

        # 分析代码意图
        analysis.purpose = await self._analyze_purpose(parsed_code)

        # 分析算法
        analysis.algorithms = await self._analyze_algorithms(parsed_code)

        # 分析设计模式
        analysis.design_patterns = await self._analyze_design_patterns(
            parsed_code,
            structure
        )

        # 分析数据流
        analysis.data_flow = await self._analyze_data_flow(parsed_code)

        return analysis

    async def _analyze_purpose(self,
                              parsed_code: ParsedCode) -> str:
        """分析代码目的"""
        prompt = f"""
        分析以下代码的主要目的和功能：

        {parsed_code.original_code}

        请用简洁的语言描述这段代码的主要功能。
        """

        return await self.llm_client.complete(prompt)

    async def _analyze_algorithms(self,
                                 parsed_code: ParsedCode) -> List[AlgorithmInfo]:
        """分析算法"""
        prompt = f"""
        识别以下代码中使用的算法：

        {parsed_code.original_code}

        请识别：
        1. 使用的主要算法（排序、搜索、图算法等）
        2. 算法的时间复杂度
        3. 算法的空间复杂度

        以 JSON 格式返回结果。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_algorithms(response)

    async def _analyze_design_patterns(self,
                                      parsed_code: ParsedCode,
                                      structure: StructureAnalysis) -> List[str]:
        """分析设计模式"""
        prompt = f"""
        识别以下代码中使用的设计模式：

        类：{parsed_code.classes}
        函数：{parsed_code.functions}
        类层次结构：{structure.class_hierarchy}

        请识别使用的设计模式。
        """

        response = await self.llm_client.complete(prompt)
        return self._parse_design_patterns(response)

    async def _analyze_data_flow(self,
                                parsed_code: ParsedCode) -> DataFlowAnalysis:
        """分析数据流"""
        analysis = DataFlowAnalysis()

        # 分析输入
        analysis.inputs = self._identify_inputs(parsed_code)

        # 分析输出
        analysis.outputs = self._identify_outputs(parsed_code)

        # 分析转换
        analysis.transformations = self._identify_transformations(parsed_code)

        return analysis

    def _identify_inputs(self, parsed_code: ParsedCode) -> List[str]:
        """识别输入"""
        inputs = []

        # 函数参数
        for func in parsed_code.functions:
            inputs.extend(func.arguments)

        # 方法参数
        for cls in parsed_code.classes:
            for method in cls.methods:
                inputs.extend(method.arguments)

        return list(set(inputs))

    def _identify_outputs(self, parsed_code: ParsedCode) -> List[str]:
        """识别输出"""
        outputs = []

        # 函数返回值
        for func in parsed_code.functions:
            if func.return_type != "None":
                outputs.append(f"{func.name}() -> {func.return_type}")

        # 方法返回值
        for cls in parsed_code.classes:
            for method in cls.methods:
                if method.return_type != "None":
                    outputs.append(f"{cls.name}.{method.name}() -> {method.return_type}")

        return outputs

    def _identify_transformations(self,
                                 parsed_code: ParsedCode) -> List[str]:
        """识别数据转换"""
        transformations = []

        # 这里需要更复杂的分析
        # 简化实现：基于函数名推断

        for func in parsed_code.functions:
            if any(keyword in func.name.lower()
                  for keyword in ['transform', 'convert', 'process', 'compute']):
                transformations.append(func.name)

        return transformations

```## 29.4.5 代码解释生成

### 解释生成器

class ExplanationGenerator:
"""解释生成器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def generate_explanation(self,
parsed_code: ParsedCode,
structure: StructureAnalysis,
semantic: SemanticAnalysis) -> CodeExplanation:
"""生成代码解释"""
explanation = CodeExplanation()
# 生成总体概述
explanation.overview = await self._generate_overview(
parsed_code,
semantic
)
# 生成类解释
explanation.class_explanations = await self._generate_class_explanations(
parsed_code.classes,
structure
)
# 生成函数解释
explanation.function_explanations = await self._generate_function_explanations(
parsed_code.functions,
structure
)
# 生成算法解释
explanation.algorithm_explanations = await self._generate_algorithm_explanations(
semantic.algorithms
)
# 生成使用示例
explanation.usage_examples = await self._generate_usage_examples(
parsed_code
)
return explanation
async def _generate_overview(self,
parsed_code: ParsedCode,
semantic: SemanticAnalysis) -> str:
"""生成总体概述"""
prompt = f"""
为以下代码生成总体概述：
代码目的：{semantic.purpose}
类：{[c.name for c in parsed_code.classes]}
函数：{[f.name for f in parsed_code.functions]}
请生成一个清晰的总体概述，包括：
1. 代码的主要功能
2. 主要组件
3. 整体架构
"""
return await self.llm_client.complete(prompt)
async def _generate_class_explanations(self,
classes: List[ClassInfo],
structure: StructureAnalysis) -> Dict[str, str]:
"""生成类解释"""
explanations = {}
for cls in classes:
prompt = f"""
为以下类生成详细解释：
类名：{cls.name}
父类：{cls.bases}
方法：{[m.name for m in cls.methods]}
属性：{[a.name for a in cls.attributes if a]}
文档字符串：{cls.docstring}
请生成详细的类解释，包括：
1. 类的职责
2. 主要方法的功能
3. 使用场景
"""
explanation = await self.llm_client.complete(prompt)
explanations[cls.name] = explanation
return explanations
async def _generate_function_explanations(self,
functions: List[FunctionInfo],
structure: StructureAnalysis) -> Dict[str, str]:
"""生成函数解释"""
explanations = {}
for func in functions:
prompt = f"""
为以下函数生成详细解释：
函数名：{func.name}
参数：{func.arguments}
返回类型：{func.return_type}
文档字符串：{func.docstring}
请生成详细的函数解释，包括：
1. 函数的功能
2. 参数说明
3. 返回值说明
4. 使用示例
"""
explanation = await self.llm_client.complete(prompt)
explanations[func.name] = explanation
return explanations
async def _generate_algorithm_explanations(self,
algorithms: List[AlgorithmInfo]) -> Dict[str, str]:
"""生成算法解释"""
explanations = {}
for algo in algorithms:
prompt = f"""
为以下算法生成详细解释：
算法名称：{algo.name}
时间复杂度：{algo.time_complexity}
空间复杂度：{algo.space_complexity}
请生成详细的算法解释，包括：
1. 算法原理
2. 实现细节
3. 优缺点分析
4. 适用场景
"""
explanation = await self.llm_client.complete(prompt)
explanations[algo.name] = explanation
return explanations
async def _generate_usage_examples(self,
parsed_code: ParsedCode) -> List[str]:
"""生成使用示例"""
examples = []
# 为每个类生成示例
for cls in parsed_code.classes:
prompt = f"""
为以下类生成使用示例：
类名：{cls.name}
方法：{[m.name for m in cls.methods]}
请生成 2-3 个实用的使用示例。
"""
example = await self.llm_client.complete(prompt)
examples.append(example)
# 为主要函数生成示例
for func in parsed_code.functions[:3]:  # 只生成前 3 个函数的示例
prompt = f"""
为以下函数生成使用示例：
函数名：{func.name}
参数：{func.arguments}
请生成 1-2 个实用的使用示例。
"""
example = await self.llm_client.complete(prompt)
examples.append(example)
return examples
```

---

## 5 调试与优化模块

**URL**: https://claudecode.tangshuang.net/course/29.5%20%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9D%97

#### 29.5.1 调试模块概述#

调试模块是编程 Agent 的重要能力，它能够自动识别、定位和修复代码中的错误。调试涉及错误检测、根因分析、修复建议等多个环节。

##### 调试流程#

错误报告
↓
错误检测
↓
错误定位
↓
根因分析
↓
修复建议
↓
修复验证
↓
问题解决

#### 29.5.2 错误检测#

##### 错误检测器#

```
python复制python

class ErrorDetector:
    """错误检测器"""

    def __init__(self):
        self.detectors = {
            'syntax': SyntaxErrorDetector(),
            'runtime': RuntimeErrorDetector(),
            'logic': LogicErrorDetector(),
            'performance': PerformanceErrorDetector(),
            'security': SecurityErrorDetector()
        }

    async def detect(self, code: str,
                     execution_result: ExecutionResult = None) -> List[DetectedError]:
        """检测错误"""
        errors = []

        # 运行各种检测器
        for detector_name, detector in self.detectors.items():
            try:
                detected = await detector.detect(code, execution_result)
                errors.extend(detected)
            except Exception as e:
                logger.error(f"Error in {detector_name} detector: {e}")

        # 去重
        errors = self._deduplicate_errors(errors)

        # 排序（按严重程度）
        errors.sort(key=lambda e: e.severity, reverse=True)

        return errors

    def _deduplicate_errors(self,
                            errors: List[DetectedError]) -> List[DetectedError]:
        """去重错误"""
        seen = set()
        unique_errors = []

        for error in errors:
            key = (error.type, error.location, error.message)
            if key not in seen:
                seen.add(key)
                unique_errors.append(error)

        return unique_errors

class SyntaxErrorDetector:
    """语法错误检测器"""

    async def detect(self, code: str,
```

```
python

class ErrorDetector:
    """错误检测器"""

    def __init__(self):
        self.detectors = {
            'syntax': SyntaxErrorDetector(),
            'runtime': RuntimeErrorDetector(),
            'logic': LogicErrorDetector(),
            'performance': PerformanceErrorDetector(),
            'security': SecurityErrorDetector()
        }

    async def detect(self, code: str,
                     execution_result: ExecutionResult = None) -> List[DetectedError]:
        """检测错误"""
        errors = []

        # 运行各种检测器
        for detector_name, detector in self.detectors.items():
            try:
                detected = await detector.detect(code, execution_result)
                errors.extend(detected)
            except Exception as e:
                logger.error(f"Error in {detector_name} detector: {e}")

        # 去重
        errors = self._deduplicate_errors(errors)

        # 排序（按严重程度）
        errors.sort(key=lambda e: e.severity, reverse=True)

        return errors

    def _deduplicate_errors(self,
                            errors: List[DetectedError]) -> List[DetectedError]:
        """去重错误"""
        seen = set()
        unique_errors = []

        for error in errors:
            key = (error.type, error.location, error.message)
            if key not in seen:
                seen.add(key)
                unique_errors.append(error)

        return unique_errors

class SyntaxErrorDetector:
    """语法错误检测器"""

    async def detect(self, code: str,
```

```
bash复制                 execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测语法错误"""
    errors = []

    try:
        # 尝试编译代码
        compile(code, '<string>', 'exec')
    except SyntaxError as e:
        error = DetectedError(
            type='syntax',
            severity='high',
            location=f"Line {e.lineno}, Column {e.offset}",
            message=e.msg,
            code_snippet=self._get_code_snippet(code, e.lineno),
            suggestion=self._get_syntax_suggestion(e)
        )
        errors.append(error)

    return errors

def _get_code_snippet(self, code: str, line_no: int) -> str:
    """获取代码片段"""
    lines = code.split('\n')
    if 1 <= line_no <= len(lines):
        return lines[line_no - 1]
    return ""

def _get_syntax_suggestion(self, error: SyntaxError) -> str:
    """获取语法错误建议"""
    suggestions = {
        'invalid syntax': "检查语法是否正确，确保括号、引号等匹配",
        'unexpected EOF': "检查代码是否完整，确保所有括号都已闭合",
        'unterminated string literal': "检查字符串是否正确闭合",
        'expected an indented block': "检查缩进是否正确",
        'unindent does not match any outer indentation level': "检查缩进层级是否一致"
    }

    return suggestions.get(error.msg, "请检查语法错误")
```

```
execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测语法错误"""
    errors = []

    try:
        # 尝试编译代码
        compile(code, '<string>', 'exec')
    except SyntaxError as e:
        error = DetectedError(
            type='syntax',
            severity='high',
            location=f"Line {e.lineno}, Column {e.offset}",
            message=e.msg,
            code_snippet=self._get_code_snippet(code, e.lineno),
            suggestion=self._get_syntax_suggestion(e)
        )
        errors.append(error)

    return errors

def _get_code_snippet(self, code: str, line_no: int) -> str:
    """获取代码片段"""
    lines = code.split('\n')
    if 1 <= line_no <= len(lines):
        return lines[line_no - 1]
    return ""

def _get_syntax_suggestion(self, error: SyntaxError) -> str:
    """获取语法错误建议"""
    suggestions = {
        'invalid syntax': "检查语法是否正确，确保括号、引号等匹配",
        'unexpected EOF': "检查代码是否完整，确保所有括号都已闭合",
        'unterminated string literal': "检查字符串是否正确闭合",
        'expected an indented block': "检查缩进是否正确",
        'unindent does not match any outer indentation level': "检查缩进层级是否一致"
    }

    return suggestions.get(error.msg, "请检查语法错误")
```

class RuntimeErrorDetector:
"""运行时错误检测器"""

```
bash复制async def detect(self, code: str,
                 execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测运行时错误"""
    errors = []

    if not execution_result or not execution_result.error:
        return errors

    # 分析错误信息
    error_info = self._parse_error(execution_result.error)

    error = DetectedError(
        type='runtime',
        severity='high',
        location=error_info.get('location', 'Unknown'),
        message=error_info.get('message', 'Unknown error'),
        code_snippet=error_info.get('code_snippet', ''),
        traceback=error_info.get('traceback', ''),
        suggestion=self._get_runtime_suggestion(error_info)
    )
    errors.append(error)

    return errors

def _parse_error(self, error: str) -> Dict[str, str]:
    """解析错误信息"""
    error_info = {
        'message': error,
        'location': 'Unknown',
        'traceback': '',
        'code_snippet': ''
    }

    # 解析 traceback
    if 'Traceback' in error:
        lines = error.split('\n')
        for line in lines:
            if 'File' in line and 'line' in line:
                # 提取文件和行号
                parts = line.split(',')
                if len(parts) >= 2:
                    error_info['location'] = parts[1].strip()
            elif line.strip() and not line.startswith(' ') and 'Error' in line:
                error_info['message'] = line.strip()

    return error_info

def _get_runtime_suggestion(self, error_info: Dict) -> str:
    """获取运行时错误建议"""
    message = error_info.get('message', '').lower()

    suggestions = {
        'nameerror': "检查变量名是否正确，确保在使用前已定义",
        'typeerror': "检查数据类型是否匹配，确保操作适用于该类型",
        'valueerror': "检查值是否在有效范围内",
        'indexerror': "检查索引是否在有效范围内",
        'keyerror': "检查字典键是否存在",
        'attributeerror': "检查对象是否具有该属性或方法",
        'zerodivisionerror': "检查除数是否为零"
    }

    for error_type, suggestion in suggestions.items():
        if error_type in message:
            return suggestion

    return "请检查错误信息和代码逻辑"
```

```
async def detect(self, code: str,
                 execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测运行时错误"""
    errors = []

    if not execution_result or not execution_result.error:
        return errors

    # 分析错误信息
    error_info = self._parse_error(execution_result.error)

    error = DetectedError(
        type='runtime',
        severity='high',
        location=error_info.get('location', 'Unknown'),
        message=error_info.get('message', 'Unknown error'),
        code_snippet=error_info.get('code_snippet', ''),
        traceback=error_info.get('traceback', ''),
        suggestion=self._get_runtime_suggestion(error_info)
    )
    errors.append(error)

    return errors

def _parse_error(self, error: str) -> Dict[str, str]:
    """解析错误信息"""
    error_info = {
        'message': error,
        'location': 'Unknown',
        'traceback': '',
        'code_snippet': ''
    }

    # 解析 traceback
    if 'Traceback' in error:
        lines = error.split('\n')
        for line in lines:
            if 'File' in line and 'line' in line:
                # 提取文件和行号
                parts = line.split(',')
                if len(parts) >= 2:
                    error_info['location'] = parts[1].strip()
            elif line.strip() and not line.startswith(' ') and 'Error' in line:
                error_info['message'] = line.strip()

    return error_info

def _get_runtime_suggestion(self, error_info: Dict) -> str:
    """获取运行时错误建议"""
    message = error_info.get('message', '').lower()

    suggestions = {
        'nameerror': "检查变量名是否正确，确保在使用前已定义",
        'typeerror': "检查数据类型是否匹配，确保操作适用于该类型",
        'valueerror': "检查值是否在有效范围内",
        'indexerror': "检查索引是否在有效范围内",
        'keyerror': "检查字典键是否存在",
        'attributeerror': "检查对象是否具有该属性或方法",
        'zerodivisionerror': "检查除数是否为零"
    }

    for error_type, suggestion in suggestions.items():
        if error_type in message:
            return suggestion

    return "请检查错误信息和代码逻辑"
```

class LogicErrorDetector:
"""逻辑错误检测器"""

```
bash复制def __init__(self, llm_client: LLMClient):
    self.llm_client = llm_client

async def detect(self, code: str,
                 execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测逻辑错误"""
    errors = []

    # 使用 LLM 分析代码逻辑
    prompt = f"""
    分析以下代码中的潜在逻辑错误：

    {code}

    请识别：
    1. 无限循环
    2. 空指针引用
    3. 边界条件错误
    4. 逻辑矛盾
    5. 死代码

    以 JSON 格式返回检测到的错误列表。
    """

    response = await self.llm_client.complete(prompt)
    detected_errors = self._parse_logic_errors(response)

    for error in detected_errors:
        detected_error = DetectedError(
            type='logic',
            severity='medium',
            location=error.get('location', 'Unknown'),
            message=error.get('message', 'Logic error'),
            code_snippet=error.get('code_snippet', ''),
            suggestion=error.get('suggestion', 'Review the logic')
        )
        errors.append(detected_error)

    return errors

def _parse_logic_errors(self, response: str) -> List[Dict]:
    """解析逻辑错误"""
    try:
        return json.loads(response)
    except json.JSONDecodeError:
        return []
```

```
def __init__(self, llm_client: LLMClient):
    self.llm_client = llm_client

async def detect(self, code: str,
                 execution_result: ExecutionResult = None) -> List[DetectedError]:
    """检测逻辑错误"""
    errors = []

    # 使用 LLM 分析代码逻辑
    prompt = f"""
    分析以下代码中的潜在逻辑错误：

    {code}

    请识别：
    1. 无限循环
    2. 空指针引用
    3. 边界条件错误
    4. 逻辑矛盾
    5. 死代码

    以 JSON 格式返回检测到的错误列表。
    """

    response = await self.llm_client.complete(prompt)
    detected_errors = self._parse_logic_errors(response)

    for error in detected_errors:
        detected_error = DetectedError(
            type='logic',
            severity='medium',
            location=error.get('location', 'Unknown'),
            message=error.get('message', 'Logic error'),
            code_snippet=error.get('code_snippet', ''),
            suggestion=error.get('suggestion', 'Review the logic')
        )
        errors.append(detected_error)

    return errors

def _parse_logic_errors(self, response: str) -> List[Dict]:
    """解析逻辑错误"""
    try:
        return json.loads(response)
    except json.JSONDecodeError:
        return []
```

```
bash复制
### 根因分析器

class RootCauseAnalyzer:
"""根因分析器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def analyze(self, error: DetectedError,
code: str,
context: Dict = None) -> RootCauseAnalysis:
"""分析根因"""
analysis = RootCauseAnalysis(error=error)
# 收集相关信息
relevant_code = self._collect_relevant_code(error, code)
# 分析根本原因
analysis.root_cause = await self._identify_root_cause(
error,
relevant_code,
context
)
# 分析影响范围
analysis.impact = await self._analyze_impact(
error,
relevant_code
)
# 分析修复难度
analysis.difficulty = await self._estimate_difficulty(
error,
analysis.root_cause
)
return analysis
def _collect_relevant_code(self, error: DetectedError,
code: str) -> str:
"""收集相关代码"""
lines = code.split('\n')
# 提取错误位置周围的代码
if error.location:
try:
line_no = int(error.location.split(',')[0].split()[-1])
start = max(0, line_no - 5)
end = min(len(lines), line_no + 5)
return '\n'.join(lines[start:end])
except (ValueError, IndexError):
pass
return code
async def _identify_root_cause(self, error: DetectedError,
relevant_code: str,
context: Dict) -> str:
"""识别根本原因"""
prompt = f"""
分析错误的根本原因：
错误类型：{error.type}
错误信息：{error.message}
错误位置：{error.location}
相关代码：
{relevant_code}
上下文：{context}
请分析并说明：
1. 错误的根本原因
2. 为什么会发生这个错误
3. 代码中的具体问题
"""
return await self.llm_client.complete(prompt)
async def _analyze_impact(self, error: DetectedError,
relevant_code: str) -> ImpactAnalysis:
"""分析影响范围"""
prompt = f"""
分析错误的影响范围：
错误：{error.message}
相关代码：
{relevant_code}
请分析：
1. 错误影响哪些功能
2. 影响的严重程度
3. 是否会影响其他代码
4. 是否会影响数据完整性
"""
response = await self.llm_client.complete(prompt)
return self._parse_impact(response)
async def _estimate_difficulty(self, error: DetectedError,
root_cause: str) -> str:
"""估计修复难度"""
prompt = f"""
估计修复错误的难度：
错误：{error.message}
根本原因：{root_cause}
请评估修复难度（简单/中等/困难）并说明理由。
"""
return await self.llm_client.complete(prompt)
```

```
### 根因分析器

class RootCauseAnalyzer:
"""根因分析器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def analyze(self, error: DetectedError,
code: str,
context: Dict = None) -> RootCauseAnalysis:
"""分析根因"""
analysis = RootCauseAnalysis(error=error)
# 收集相关信息
relevant_code = self._collect_relevant_code(error, code)
# 分析根本原因
analysis.root_cause = await self._identify_root_cause(
error,
relevant_code,
context
)
# 分析影响范围
analysis.impact = await self._analyze_impact(
error,
relevant_code
)
# 分析修复难度
analysis.difficulty = await self._estimate_difficulty(
error,
analysis.root_cause
)
return analysis
def _collect_relevant_code(self, error: DetectedError,
code: str) -> str:
"""收集相关代码"""
lines = code.split('\n')
# 提取错误位置周围的代码
if error.location:
try:
line_no = int(error.location.split(',')[0].split()[-1])
start = max(0, line_no - 5)
end = min(len(lines), line_no + 5)
return '\n'.join(lines[start:end])
except (ValueError, IndexError):
pass
return code
async def _identify_root_cause(self, error: DetectedError,
relevant_code: str,
context: Dict) -> str:
"""识别根本原因"""
prompt = f"""
分析错误的根本原因：
错误类型：{error.type}
错误信息：{error.message}
错误位置：{error.location}
相关代码：
{relevant_code}
上下文：{context}
请分析并说明：
1. 错误的根本原因
2. 为什么会发生这个错误
3. 代码中的具体问题
"""
return await self.llm_client.complete(prompt)
async def _analyze_impact(self, error: DetectedError,
relevant_code: str) -> ImpactAnalysis:
"""分析影响范围"""
prompt = f"""
分析错误的影响范围：
错误：{error.message}
相关代码：
{relevant_code}
请分析：
1. 错误影响哪些功能
2. 影响的严重程度
3. 是否会影响其他代码
4. 是否会影响数据完整性
"""
response = await self.llm_client.complete(prompt)
return self._parse_impact(response)
async def _estimate_difficulty(self, error: DetectedError,
root_cause: str) -> str:
"""估计修复难度"""
prompt = f"""
估计修复错误的难度：
错误：{error.message}
根本原因：{root_cause}
请评估修复难度（简单/中等/困难）并说明理由。
"""
return await self.llm_client.complete(prompt)
```

#### 29.5.4 修复建议#

##### 修复建议生成器#

```
python复制```python

class FixSuggestionGenerator:
    """修复建议生成器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def generate_suggestions(self,
                                   analysis: RootCauseAnalysis,
                                   code: str) -> List[FixSuggestion]:
        """生成修复建议"""
        suggestions = []

        # 生成多个修复方案
        prompt = f"""
        为以下错误生成修复建议：

        错误：{analysis.error.message}
        根本原因：{analysis.root_cause}
        原始代码：
        {code}

        请生成 2-3 个不同的修复方案，每个方案包括：
        1. 修复方法
        2. 修改后的代码
        3. 优缺点分析
        4. 适用场景

        以 JSON 格式返回修复方案列表。
        """

        response = await self.llm_client.complete(prompt)
        fix_suggestions = self._parse_fix_suggestions(response)

        for suggestion in fix_suggestions:
            fix_suggestion = FixSuggestion(
                method=suggestion.get('method', ''),
                fixed_code=suggestion.get('fixed_code', ''),
                advantages=suggestion.get('advantages', []),
                disadvantages=suggestion.get('disadvantages', []),
                applicable_scenarios=suggestion.get('applicable_scenarios', ''),
                confidence=suggestion.get('confidence', 0.5)
            )
            suggestions.append(fix_suggestion)

        # 按置信度排序
        suggestions.sort(key=lambda s: s.confidence, reverse=True)

        return suggestions

```## 29.5.5 性能优化

### 性能分析器

class PerformanceAnalyzer:
"""性能分析器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def analyze(self, code: str,
execution_result: ExecutionResult = None) -> PerformanceAnalysis:
"""分析性能"""
analysis = PerformanceAnalysis()
# 分析时间复杂度
analysis.time_complexity = await self._analyze_time_complexity(code)
# 分析空间复杂度
analysis.space_complexity = await self._analyze_space_complexity(code)
# 识别性能瓶颈
analysis.bottlenecks = await self._identify_bottlenecks(code)
# 生成优化建议
analysis.optimization_suggestions = await self._generate_optimization_suggestions(
code,
analysis
)
return analysis
async def _analyze_time_complexity(self, code: str) -> str:
"""分析时间复杂度"""
prompt = f"""
分析以下代码的时间复杂度：
{code}
请分析并说明：
1. 整体时间复杂度
2. 关键部分的复杂度
3. 影响复杂度的主要因素
"""
return await self.llm_client.complete(prompt)
async def _analyze_space_complexity(self, code: str) -> str:
"""分析空间复杂度"""
prompt = f"""
分析以下代码的空间复杂度：
{code}
请分析并说明：
1. 整体空间复杂度
2. 内存使用情况
3. 可能的内存泄漏
"""
return await self.llm_client.complete(prompt)
async def _identify_bottlenecks(self, code: str) -> List[PerformanceBottleneck]:
"""识别性能瓶颈"""
prompt = f"""
识别以下代码中的性能瓶颈：
{code}
请识别：
1. 循环嵌套
2. 重复计算
3. 不必要的内存分配
4. 低效的数据结构使用
5. I/O 操作
以 JSON 格式返回瓶颈列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_bottlenecks(response)
async def _generate_optimization_suggestions(self,
code: str,
analysis: PerformanceAnalysis) -> List[OptimizationSuggestion]:
"""生成优化建议"""
suggestions = []
for bottleneck in analysis.bottlenecks:
prompt = f"""
为以下性能瓶颈生成优化建议：
瓶颈类型：{bottleneck.type}
瓶颈位置：{bottleneck.location}
瓶颈描述：{bottleneck.description}
请生成具体的优化建议，包括：
1. 优化方法
2. 优化后的代码
3. 预期性能提升
"""
response = await self.llm_client.complete(prompt)
suggestion = OptimizationSuggestion(
bottleneck_type=bottleneck.type,
method=self._extract_method(response),
optimized_code=self._extract_code(response),
expected_improvement=self._extract_improvement(response)
)
suggestions.append(suggestion)
return suggestions
```

```
```python

class FixSuggestionGenerator:
    """修复建议生成器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def generate_suggestions(self,
                                   analysis: RootCauseAnalysis,
                                   code: str) -> List[FixSuggestion]:
        """生成修复建议"""
        suggestions = []

        # 生成多个修复方案
        prompt = f"""
        为以下错误生成修复建议：

        错误：{analysis.error.message}
        根本原因：{analysis.root_cause}
        原始代码：
        {code}

        请生成 2-3 个不同的修复方案，每个方案包括：
        1. 修复方法
        2. 修改后的代码
        3. 优缺点分析
        4. 适用场景

        以 JSON 格式返回修复方案列表。
        """

        response = await self.llm_client.complete(prompt)
        fix_suggestions = self._parse_fix_suggestions(response)

        for suggestion in fix_suggestions:
            fix_suggestion = FixSuggestion(
                method=suggestion.get('method', ''),
                fixed_code=suggestion.get('fixed_code', ''),
                advantages=suggestion.get('advantages', []),
                disadvantages=suggestion.get('disadvantages', []),
                applicable_scenarios=suggestion.get('applicable_scenarios', ''),
                confidence=suggestion.get('confidence', 0.5)
            )
            suggestions.append(fix_suggestion)

        # 按置信度排序
        suggestions.sort(key=lambda s: s.confidence, reverse=True)

        return suggestions

```## 29.5.5 性能优化

### 性能分析器

class PerformanceAnalyzer:
"""性能分析器"""
def __init__(self, llm_client: LLMClient):
self.llm_client = llm_client
async def analyze(self, code: str,
execution_result: ExecutionResult = None) -> PerformanceAnalysis:
"""分析性能"""
analysis = PerformanceAnalysis()
# 分析时间复杂度
analysis.time_complexity = await self._analyze_time_complexity(code)
# 分析空间复杂度
analysis.space_complexity = await self._analyze_space_complexity(code)
# 识别性能瓶颈
analysis.bottlenecks = await self._identify_bottlenecks(code)
# 生成优化建议
analysis.optimization_suggestions = await self._generate_optimization_suggestions(
code,
analysis
)
return analysis
async def _analyze_time_complexity(self, code: str) -> str:
"""分析时间复杂度"""
prompt = f"""
分析以下代码的时间复杂度：
{code}
请分析并说明：
1. 整体时间复杂度
2. 关键部分的复杂度
3. 影响复杂度的主要因素
"""
return await self.llm_client.complete(prompt)
async def _analyze_space_complexity(self, code: str) -> str:
"""分析空间复杂度"""
prompt = f"""
分析以下代码的空间复杂度：
{code}
请分析并说明：
1. 整体空间复杂度
2. 内存使用情况
3. 可能的内存泄漏
"""
return await self.llm_client.complete(prompt)
async def _identify_bottlenecks(self, code: str) -> List[PerformanceBottleneck]:
"""识别性能瓶颈"""
prompt = f"""
识别以下代码中的性能瓶颈：
{code}
请识别：
1. 循环嵌套
2. 重复计算
3. 不必要的内存分配
4. 低效的数据结构使用
5. I/O 操作
以 JSON 格式返回瓶颈列表。
"""
response = await self.llm_client.complete(prompt)
return self._parse_bottlenecks(response)
async def _generate_optimization_suggestions(self,
code: str,
analysis: PerformanceAnalysis) -> List[OptimizationSuggestion]:
"""生成优化建议"""
suggestions = []
for bottleneck in analysis.bottlenecks:
prompt = f"""
为以下性能瓶颈生成优化建议：
瓶颈类型：{bottleneck.type}
瓶颈位置：{bottleneck.location}
瓶颈描述：{bottleneck.description}
请生成具体的优化建议，包括：
1. 优化方法
2. 优化后的代码
3. 预期性能提升
"""
response = await self.llm_client.complete(prompt)
suggestion = OptimizationSuggestion(
bottleneck_type=bottleneck.type,
method=self._extract_method(response),
optimized_code=self._extract_code(response),
expected_improvement=self._extract_improvement(response)
)
suggestions.append(suggestion)
return suggestions
```

##### 代码优化器#

```
python复制```python

class CodeOptimizer:
    """代码优化器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def optimize(self, code: str,
                      suggestions: List[OptimizationSuggestion]) -> OptimizedCode:
        """优化代码"""
        optimized_code = code

        for suggestion in suggestions:
            # 应用优化
            optimized_code = await self._apply_optimization(
                optimized_code,
                suggestion
            )

        return OptimizedCode(
            original_code=code,
            optimized_code=optimized_code,
            applied_suggestions=suggestions
        )

    async def _apply_optimization(self, code: str,
                                 suggestion: OptimizationSuggestion) -> str:
        """应用单个优化"""
        prompt = f"""
        应用以下优化到代码：

        原始代码：
        {code}

        优化方法：{suggestion.method}
        优化后的代码示例：
        {suggestion.optimized_code}

        请返回应用优化后的完整代码。
        """

        return await self.llm_client.complete(prompt)

```## 29.5.6 调试工作流

### 调试工作流管理器

class DebuggingWorkflow:
"""调试工作流"""
def __init__(self, llm_client: LLMClient,
tool_manager: ToolManager):
self.llm_client = llm_client
self.tool_manager = tool_manager
# 初始化组件
self.error_detector = ErrorDetector()
self.root_cause_analyzer = RootCauseAnalyzer(llm_client)
self.fix_suggestion_generator = FixSuggestionGenerator(llm_client)
self.performance_analyzer = PerformanceAnalyzer(llm_client)
self.code_optimizer = CodeOptimizer(llm_client)
async def debug(self, code: str,
execution_result: ExecutionResult = None) -> DebuggingResult:
"""执行调试工作流"""
result = DebuggingResult(original_code=code)
# 1. 检测错误
result.errors = await self.error_detector.detect(code, execution_result)
if not result.errors:
result.status = "no_errors"
return result
# 2. 分析每个错误
for error in result.errors:
# 根因分析
analysis = await self.root_cause_analyzer.analyze(error, code)
result.root_cause_analyses.append(analysis)
# 生成修复建议
suggestions = await self.fix_suggestion_generator.generate_suggestions(
analysis,
code
)
result.fix_suggestions.extend(suggestions)
# 3. 性能分析
result.performance_analysis = await self.performance_analyzer.analyze(code)
# 4. 生成优化建议
if result.performance_analysis.optimization_suggestions:
result.optimization_suggestions = result.performance_analysis.optimization_suggestions
result.status = "completed"
return result
async def apply_fix(self, code: str,
suggestion: FixSuggestion) -> FixedCode:
"""应用修复"""
fixed_code = FixedCode(
original_code=code,
fixed_code=suggestion.fixed_code,
applied_suggestion=suggestion
)
# 验证修复
validation_result = await self._validate_fix(fixed_code)
fixed_code.validation_result = validation_result
return fixed_code
async def _validate_fix(self, fixed_code: FixedCode) -> ValidationResult:
"""验证修复"""
# 检查语法
try:
compile(fixed_code.fixed_code, '<string>', 'exec')
syntax_valid = True
except SyntaxError:
syntax_valid = False
# 运行测试（如果有）
test_result = await self._run_tests(fixed_code.fixed_code)
return ValidationResult(
syntax_valid=syntax_valid,
tests_passed=test_result.passed,
test_output=test_result.output
)
async def _run_tests(self, code: str) -> TestResult:
"""运行测试"""
# 简化实现：执行代码并检查错误
try:
exec(code)
return TestResult(passed=True, output="Execution successful")
except Exception as e:
return TestResult(passed=False, output=str(e))
```

```
```python

class CodeOptimizer:
    """代码优化器"""

    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    async def optimize(self, code: str,
                      suggestions: List[OptimizationSuggestion]) -> OptimizedCode:
        """优化代码"""
        optimized_code = code

        for suggestion in suggestions:
            # 应用优化
            optimized_code = await self._apply_optimization(
                optimized_code,
                suggestion
            )

        return OptimizedCode(
            original_code=code,
            optimized_code=optimized_code,
            applied_suggestions=suggestions
        )

    async def _apply_optimization(self, code: str,
                                 suggestion: OptimizationSuggestion) -> str:
        """应用单个优化"""
        prompt = f"""
        应用以下优化到代码：

        原始代码：
        {code}

        优化方法：{suggestion.method}
        优化后的代码示例：
        {suggestion.optimized_code}

        请返回应用优化后的完整代码。
        """

        return await self.llm_client.complete(prompt)

```## 29.5.6 调试工作流

### 调试工作流管理器

class DebuggingWorkflow:
"""调试工作流"""
def __init__(self, llm_client: LLMClient,
tool_manager: ToolManager):
self.llm_client = llm_client
self.tool_manager = tool_manager
# 初始化组件
self.error_detector = ErrorDetector()
self.root_cause_analyzer = RootCauseAnalyzer(llm_client)
self.fix_suggestion_generator = FixSuggestionGenerator(llm_client)
self.performance_analyzer = PerformanceAnalyzer(llm_client)
self.code_optimizer = CodeOptimizer(llm_client)
async def debug(self, code: str,
execution_result: ExecutionResult = None) -> DebuggingResult:
"""执行调试工作流"""
result = DebuggingResult(original_code=code)
# 1. 检测错误
result.errors = await self.error_detector.detect(code, execution_result)
if not result.errors:
result.status = "no_errors"
return result
# 2. 分析每个错误
for error in result.errors:
# 根因分析
analysis = await self.root_cause_analyzer.analyze(error, code)
result.root_cause_analyses.append(analysis)
# 生成修复建议
suggestions = await self.fix_suggestion_generator.generate_suggestions(
analysis,
code
)
result.fix_suggestions.extend(suggestions)
# 3. 性能分析
result.performance_analysis = await self.performance_analyzer.analyze(code)
# 4. 生成优化建议
if result.performance_analysis.optimization_suggestions:
result.optimization_suggestions = result.performance_analysis.optimization_suggestions
result.status = "completed"
return result
async def apply_fix(self, code: str,
suggestion: FixSuggestion) -> FixedCode:
"""应用修复"""
fixed_code = FixedCode(
original_code=code,
fixed_code=suggestion.fixed_code,
applied_suggestion=suggestion
)
# 验证修复
validation_result = await self._validate_fix(fixed_code)
fixed_code.validation_result = validation_result
return fixed_code
async def _validate_fix(self, fixed_code: FixedCode) -> ValidationResult:
"""验证修复"""
# 检查语法
try:
compile(fixed_code.fixed_code, '<string>', 'exec')
syntax_valid = True
except SyntaxError:
syntax_valid = False
# 运行测试（如果有）
test_result = await self._run_tests(fixed_code.fixed_code)
return ValidationResult(
syntax_valid=syntax_valid,
tests_passed=test_result.passed,
test_output=test_result.output
)
async def _run_tests(self, code: str) -> TestResult:
"""运行测试"""
# 简化实现：执行代码并检查错误
try:
exec(code)
return TestResult(passed=True, output="Execution successful")
except Exception as e:
return TestResult(passed=False, output=str(e))
```

---

## 6 集成与部署

**URL**: https://claudecode.tangshuang.net/course/29.6%20%E9%9B%86%E6%88%90%E4%B8%8E%E9%83%A8%E7%BD%B2

#### 29.6.1 系统集成#

##### 整体集成架构#

class IntegratedCodingAgent:
"""集成的编程 Agent"""

def init(self, config: AgentConfig):
self.config = config

### 初始化核心组件

self.llm_client = LLMClient(config.llm_config)
self.tool_manager = ToolManager()
self.memory_system = MemorySystem(config.memory_config)

### 初始化能力模块

self.code_generator = CodeGenerator(self.llm_client)
self.code_understander = CodeUnderstander(self.llm_client)
self.debugger = DebuggingWorkflow(self.llm_client, self.tool_manager)

### 初始化交互管理

self.session_manager = SessionManager()
self.context_manager = ContextManager()

### 初始化工具

self._initialize_tools()

### 初始化插件系统

self.plugin_manager = PluginManager()

### 初始化监控

self.monitor = PerformanceMonitor()

def _initialize_tools(self):
"""初始化工具"""

### 文件操作工具

self.tool_manager.register_tool(FileReadTool())
self.tool_manager.register_tool(FileWriteTool())
self.tool_manager.register_tool(FileSearchTool())

### 代码执行工具

self.tool_manager.register_tool(CodeExecuteTool())
self.tool_manager.register_tool(TestRunnerTool())

### 版本控制工具

self.tool_manager.register_tool(GitTool())

### 搜索工具

self.tool_manager.register_tool(SearchTool())

### 文档工具

self.tool_manager.register_tool(DocumentationTool())

async def process_request(self, request: UserRequest) -> AgentResponse:
"""处理用户请求"""

### 开始监控

self.monitor.start_timer('request_processing')

### 1. 获取或创建会话

session = self.session_manager.get_or_create_session(
request.session_id
)

### 2. 构建上下文

context = await self.context_manager.build_context(
request,
session
)

### 3. 理解意图

intent = await self._understand_intent(request, context)

### 4. 根据意图选择处理流程

if intent.type == 'code_generation':
response = await self._handle_code_generation(
request,
context,
intent
)
elif intent.type == 'code_understanding':
response = await self._handle_code_understanding(
request,
context,
intent
)
elif intent.type == 'debugging':
response = await self._handle_debugging(
request,
context,
intent
)
else:
response = await self._handle_general_request(

request,
context,
intent
)

### 5. 更新会话

session.add_interaction(request, response)

### 6. 存储到记忆系统

await self.memory_system.store_interaction(request, response)

return response

except Exception as e:
logger.error(f"Error processing request: {e}")
return AgentResponse(
text=f"An error occurred: {str(e)}",
success=False,
error=str(e)
)
finally:

### 停止监控

duration = self.monitor.stop_timer('request_processing')
self.monitor.record_metric('request_duration', duration)

async def _understand_intent(self, request: UserRequest,
context: Context) -> Intent:
"""理解用户意图"""
prompt = f"""
分析用户请求的意图：

用户请求：{request.text}
上下文：{context}

True. 意图类型（代码生成、代码理解、调试、优化等）
True. 具体任务
True. 相关的编程语言
True. 需要的工具

以 JSON 格式返回。
"""

response = await self.llm_client.complete(prompt)
return self._parse_intent(response)

async def _handle_code_generation(self, request: UserRequest,
context: Context,
intent: Intent) -> AgentResponse:
"""处理代码生成请求"""

### 提取需求

requirement = await self.code_generator.extract_requirement(
request.text
)

### 设计架构

architecture = await self.code_generator.design_architecture(
requirement
)

### 生成代码

generated_code = await self.code_generator.generate_code(
architecture,
requirement
)

### 验证代码

validation_result = await self.code_generator.validate_code(
generated_code,
requirement
)

### 生成响应

response_text = await self._generate_code_generation_response(
requirement,
architecture,
generated_code,
validation_result
)

return AgentResponse(
text=response_text,
success=validation_result.passed,
data={
'requirement': requirement,
'architecture': architecture,
'code': generated_code,
'validation': validation_result
}
)

async def _handle_code_understanding(self, request: UserRequest,
context: Context,
intent: Intent) -> AgentResponse:
"""处理代码理解请求"""

### 解析代码

parsed_code = await self.code_understander.parse_code(
request.code
)

### 分析结构

structure = await self.code_understander.analyze_structure(
parsed_code
)

### 分析语义

semantic = await self.code_understander.analyze_semantic(
parsed_code,
structure
)

### 生成解释

explanation = await self.code_understander.generate_explanation(
parsed_code,
structure,
semantic
)

### 生成响应

response_text = await self._generate_code_understanding_response(
parsed_code,
structure,
semantic,
explanation
)

return AgentResponse(
text=response_text,
success=True,
data={
'parsed_code': parsed_code,
'structure': structure,
'semantic': semantic,
'explanation': explanation
}
)

async def _handle_debugging(self, request: UserRequest,
context: Context,
intent: Intent) -> AgentResponse:
"""处理调试请求"""

### 执行调试工作流

debugging_result = await self.debugger.debug(
request.code,
request.execution_result
)

### 生成响应

response_text = await self._generate_debugging_response(
debugging_result
)

return AgentResponse(
text=response_text,
success=True,
data={
'debugging_result': debugging_result
}
)

async def _handle_general_request(self, request: UserRequest,
context: Context,
intent: Intent) -> AgentResponse:
"""处理一般请求"""

### 使用 LLM 直接处理

prompt = f"""
处理用户请求：

用户请求：{request.text}
上下文：{context}

请提供有帮助的响应。
"""

response_text = await self.llm_client.complete(prompt)

return AgentResponse(
text=response_text,
success=True
)

#### 29.6.2 API 服务#

##### REST API 实现#

```
bash复制python

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI(title="Coding Agent API")

# 初始化 Agent
agent = IntegratedCodingAgent(config=load_config())

class CodeGenerationRequest(BaseModel):
    prompt: str
    language: str = "python"
    session_id: str = None

class CodeUnderstandingRequest(BaseModel):
    code: str
    language: str = "python"
    session_id: str = None

class DebuggingRequest(BaseModel):
    code: str
    error_message: str = None
    session_id: str = None

@app.post("/api/v1/generate")
async def generate_code(request: CodeGenerationRequest):
    """生成代码"""
    try:
        user_request = UserRequest(
            text=request.prompt,
            session_id=request.session_id or str(uuid.uuid4()),
            type='code_generation'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/understand")
async def understand_code(request: CodeUnderstandingRequest):
    """理解代码"""
    try:
        user_request = UserRequest(
            text="Explain this code",
            code=request.code,
            session_id=request.session_id or str(uuid.uuid4()),
            type='code_understanding'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/debug")
async def debug_code(request: DebuggingRequest):
    """调试代码"""
    try:
        execution_result = ExecutionResult(
            error=request.error_message
        ) if request.error_message else None

        user_request = UserRequest(
            text="Debug this code",
            code=request.code,
            execution_result=execution_result,
            session_id=request.session_id or str(uuid.uuid4()),
            type='debugging'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/health")
async def health_check():
    """健康检查"""
    return {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }

@app.get("/api/v1/stats")
async def get_stats():
    """获取统计信息"""
    return {
        'performance': agent.monitor.get_stats(),
        'sessions': agent.session_manager.get_stats(),
        'memory': agent.memory_system.get_stats()
    }

## 29.6.3 CLI 工具

### 命令行接口

import click
@click.group()
def cli():
"""Coding Agent CLI"""
pass
@cli.command()
@click.argument('prompt')
@click.option('--language', default='python', help='Programming language')
@click.option('--output', '-o', help='Output file')
def generate(prompt, language, output):
"""Generate code from prompt"""
async def generate_code():
agent = IntegratedCodingAgent(config=load_config())
request = UserRequest(
text=prompt,
type='code_generation'
)
response = await agent.process_request(request)
if response.success and response.data:
code = response.data.get('code', {}).get('full_code', '')
if output:
with open(output, 'w') as f:
f.write(code)
click.echo(f"Code generated and saved to {output}")
else:
click.echo(code)
else:
click.echo(f"Error: {response.text}")
asyncio.run(generate_code())
@cli.command()
@click.argument('file', type=click.Path(exists=True))
def understand(file):
"""Understand code"""
async def understand_code():
agent = IntegratedCodingAgent(config=load_config())
with open(file, 'r') as f:
code = f.read()
request = UserRequest(
text="Explain this code",
code=code,
type='code_understanding'
)
response = await agent.process_request(request)
if response.success:
click.echo(response.text)
else:
click.echo(f"Error: {response.text}")
asyncio.run(understand_code())
@cli.command()
@click.argument('file', type=click.Path(exists=True))
@click.option('--error', help='Error message')
def debug(file, error):
"""Debug code"""
async def debug_code():
agent = IntegratedCodingAgent(config=load_config())
with open(file, 'r') as f:
code = f.read()
execution_result = ExecutionResult(error=error) if error else None
request = UserRequest(
text="Debug this code",
code=code,
execution_result=execution_result,
type='debugging'
)
response = await agent.process_request(request)
if response.success:
click.echo(response.text)
else:
click.echo(f"Error: {response.text}")
asyncio.run(debug_code())
@cli.command()
def interactive():
"""Interactive mode"""
async def interactive_mode():
agent = IntegratedCodingAgent(config=load_config())
session_id = str(uuid.uuid4())
click.echo("Coding Agent Interactive Mode")
click.echo("Type 'exit' to quit")
click.echo()
while True:
user_input = click.prompt("You")
if user_input.lower() == 'exit':
break
request = UserRequest(
text=user_input,
session_id=session_id
)
response = await agent.process_request(request)
click.echo(f"Agent: {response.text}")
click.echo()
asyncio.run(interactive_mode())
if __name__ == '__main__':
cli()
```

```
python

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI(title="Coding Agent API")

# 初始化 Agent
agent = IntegratedCodingAgent(config=load_config())

class CodeGenerationRequest(BaseModel):
    prompt: str
    language: str = "python"
    session_id: str = None

class CodeUnderstandingRequest(BaseModel):
    code: str
    language: str = "python"
    session_id: str = None

class DebuggingRequest(BaseModel):
    code: str
    error_message: str = None
    session_id: str = None

@app.post("/api/v1/generate")
async def generate_code(request: CodeGenerationRequest):
    """生成代码"""
    try:
        user_request = UserRequest(
            text=request.prompt,
            session_id=request.session_id or str(uuid.uuid4()),
            type='code_generation'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/understand")
async def understand_code(request: CodeUnderstandingRequest):
    """理解代码"""
    try:
        user_request = UserRequest(
            text="Explain this code",
            code=request.code,
            session_id=request.session_id or str(uuid.uuid4()),
            type='code_understanding'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/debug")
async def debug_code(request: DebuggingRequest):
    """调试代码"""
    try:
        execution_result = ExecutionResult(
            error=request.error_message
        ) if request.error_message else None

        user_request = UserRequest(
            text="Debug this code",
            code=request.code,
            execution_result=execution_result,
            session_id=request.session_id or str(uuid.uuid4()),
            type='debugging'
        )

        response = await agent.process_request(user_request)

        return {
            'success': response.success,
            'response': response.text,
            'data': response.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/health")
async def health_check():
    """健康检查"""
    return {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }

@app.get("/api/v1/stats")
async def get_stats():
    """获取统计信息"""
    return {
        'performance': agent.monitor.get_stats(),
        'sessions': agent.session_manager.get_stats(),
        'memory': agent.memory_system.get_stats()
    }

## 29.6.3 CLI 工具

### 命令行接口

import click
@click.group()
def cli():
"""Coding Agent CLI"""
pass
@cli.command()
@click.argument('prompt')
@click.option('--language', default='python', help='Programming language')
@click.option('--output', '-o', help='Output file')
def generate(prompt, language, output):
"""Generate code from prompt"""
async def generate_code():
agent = IntegratedCodingAgent(config=load_config())
request = UserRequest(
text=prompt,
type='code_generation'
)
response = await agent.process_request(request)
if response.success and response.data:
code = response.data.get('code', {}).get('full_code', '')
if output:
with open(output, 'w') as f:
f.write(code)
click.echo(f"Code generated and saved to {output}")
else:
click.echo(code)
else:
click.echo(f"Error: {response.text}")
asyncio.run(generate_code())
@cli.command()
@click.argument('file', type=click.Path(exists=True))
def understand(file):
"""Understand code"""
async def understand_code():
agent = IntegratedCodingAgent(config=load_config())
with open(file, 'r') as f:
code = f.read()
request = UserRequest(
text="Explain this code",
code=code,
type='code_understanding'
)
response = await agent.process_request(request)
if response.success:
click.echo(response.text)
else:
click.echo(f"Error: {response.text}")
asyncio.run(understand_code())
@cli.command()
@click.argument('file', type=click.Path(exists=True))
@click.option('--error', help='Error message')
def debug(file, error):
"""Debug code"""
async def debug_code():
agent = IntegratedCodingAgent(config=load_config())
with open(file, 'r') as f:
code = f.read()
execution_result = ExecutionResult(error=error) if error else None
request = UserRequest(
text="Debug this code",
code=code,
execution_result=execution_result,
type='debugging'
)
response = await agent.process_request(request)
if response.success:
click.echo(response.text)
else:
click.echo(f"Error: {response.text}")
asyncio.run(debug_code())
@cli.command()
def interactive():
"""Interactive mode"""
async def interactive_mode():
agent = IntegratedCodingAgent(config=load_config())
session_id = str(uuid.uuid4())
click.echo("Coding Agent Interactive Mode")
click.echo("Type 'exit' to quit")
click.echo()
while True:
user_input = click.prompt("You")
if user_input.lower() == 'exit':
break
request = UserRequest(
text=user_input,
session_id=session_id
)
response = await agent.process_request(request)
click.echo(f"Agent: {response.text}")
click.echo()
asyncio.run(interactive_mode())
if __name__ == '__main__':
cli()
```

#### 29.6.4 部署方案#

##### Docker 部署#

```
bash复制dockerfile

# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动服务
CMD ["uvicorn", "api:app", "--host", "0.0.0.0", "--port", "8000"]

# docker-compose.yml
version: '3.8'
services:
agent:
build: .
ports:
- "8000:8000"
environment:
- LLM_API_KEY=${LLM_API_KEY}
- LLM_BASE_URL=${LLM_BASE_URL}
volumes:
- ./data:/app/data
restart: unless-stopped
redis:
image: redis:alpine
ports:
- "6379:6379"
restart: unless-stopped
postgres:
image: postgres:15-alpine
environment:
- POSTGRES_DB=coding_agent
- POSTGRES_USER=agent
- POSTGRES_PASSWORD=password
ports:
- "5432:5432"
volumes:
- postgres_data:/var/lib/postgresql/data
restart: unless-stopped
volumes:
postgres_data:
```

```
dockerfile

# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动服务
CMD ["uvicorn", "api:app", "--host", "0.0.0.0", "--port", "8000"]

# docker-compose.yml
version: '3.8'
services:
agent:
build: .
ports:
- "8000:8000"
environment:
- LLM_API_KEY=${LLM_API_KEY}
- LLM_BASE_URL=${LLM_BASE_URL}
volumes:
- ./data:/app/data
restart: unless-stopped
redis:
image: redis:alpine
ports:
- "6379:6379"
restart: unless-stopped
postgres:
image: postgres:15-alpine
environment:
- POSTGRES_DB=coding_agent
- POSTGRES_USER=agent
- POSTGRES_PASSWORD=password
ports:
- "5432:5432"
volumes:
- postgres_data:/var/lib/postgresql/data
restart: unless-stopped
volumes:
postgres_data:
```

##### Kubernetes 部署#

```
bash复制yaml

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coding-agent
spec:
  replicas: 3
  selector:
    matchLabels:
      app: coding-agent
  template:
    metadata:
      labels:
        app: coding-agent
    spec:
      containers:
      - name: agent
        image: coding-agent:latest
        ports:
        - containerPort: 8000
        env:
        - name: LLM_API_KEY
          valueFrom:
            secretKeyRef:
              name: agent-secrets
              key: llm-api-key
        - name: LLM_BASE_URL
          valueFrom:
            configMapKeyRef:
              name: agent-config
              key: llm-base-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: coding-agent-service
spec:
  selector:
    app: coding-agent
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: LoadBalancer

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-config
data:
  llm-base-url: "https://api.anthropic.com"

---
apiVersion: v1
kind: Secret
metadata:
  name: agent-secrets
type: Opaque
data:
  llm-api-key: <base64-encoded-key>

## 29.6.5 监控与日志

### 监控配置

from prometheus_client import Counter, Histogram, Gauge
# 定义指标
request_counter = Counter(
'agent_requests_total',
'Total number of requests',
['type', 'status']
)
request_duration = Histogram(
'agent_request_duration_seconds',
'Request duration',
['type']
)
active_sessions = Gauge(
'agent_active_sessions',
'Number of active sessions'
)
cache_hits = Counter(
'agent_cache_hits_total',
'Total cache hits'
)
cache_misses = Counter(
'agent_cache_misses_total',
'Total cache misses'
)
# 在 Agent 中集成监控
class MonitoredAgent(IntegratedCodingAgent):
"""带监控的 Agent"""
async def process_request(self, request: UserRequest) -> AgentResponse:
# 记录请求开始
request_counter.labels(
type=request.type,
status='processing'
).inc()
with request_duration.labels(type=request.type).time():
try:
response = await super().process_request(request)
# 记录成功
request_counter.labels(
type=request.type,
status='success' if response.success else 'error'
).inc()
return response
except Exception as e:
# 记录错误
request_counter.labels(
type=request.type,
status='error'
).inc()
raise
```

```
yaml

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coding-agent
spec:
  replicas: 3
  selector:
    matchLabels:
      app: coding-agent
  template:
    metadata:
      labels:
        app: coding-agent
    spec:
      containers:
      - name: agent
        image: coding-agent:latest
        ports:
        - containerPort: 8000
        env:
        - name: LLM_API_KEY
          valueFrom:
            secretKeyRef:
              name: agent-secrets
              key: llm-api-key
        - name: LLM_BASE_URL
          valueFrom:
            configMapKeyRef:
              name: agent-config
              key: llm-base-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: coding-agent-service
spec:
  selector:
    app: coding-agent
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: LoadBalancer

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-config
data:
  llm-base-url: "https://api.anthropic.com"

---
apiVersion: v1
kind: Secret
metadata:
  name: agent-secrets
type: Opaque
data:
  llm-api-key: <base64-encoded-key>

## 29.6.5 监控与日志

### 监控配置

from prometheus_client import Counter, Histogram, Gauge
# 定义指标
request_counter = Counter(
'agent_requests_total',
'Total number of requests',
['type', 'status']
)
request_duration = Histogram(
'agent_request_duration_seconds',
'Request duration',
['type']
)
active_sessions = Gauge(
'agent_active_sessions',
'Number of active sessions'
)
cache_hits = Counter(
'agent_cache_hits_total',
'Total cache hits'
)
cache_misses = Counter(
'agent_cache_misses_total',
'Total cache misses'
)
# 在 Agent 中集成监控
class MonitoredAgent(IntegratedCodingAgent):
"""带监控的 Agent"""
async def process_request(self, request: UserRequest) -> AgentResponse:
# 记录请求开始
request_counter.labels(
type=request.type,
status='processing'
).inc()
with request_duration.labels(type=request.type).time():
try:
response = await super().process_request(request)
# 记录成功
request_counter.labels(
type=request.type,
status='success' if response.success else 'error'
).inc()
return response
except Exception as e:
# 记录错误
request_counter.labels(
type=request.type,
status='error'
).inc()
raise
```

##### 日志配置#

```
bash复制python

import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """配置日志"""
    logger = logging.getLogger('coding_agent')
    logger.setLevel(logging.INFO)

    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_format)
    logger.addHandler(console_handler)

    # 文件处理器
    file_handler = RotatingFileHandler(
        'agent.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.DEBUG)
    file_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
    )
    file_handler.setFormatter(file_format)
    logger.addHandler(file_handler)

    return logger

# 在 Agent 中使用
logger = setup_logging()

class LoggingAgent(IntegratedCodingAgent):
    """带日志的 Agent"""

    async def process_request(self, request: UserRequest) -> AgentResponse:
        logger.info(f"Processing request: {request.type}")

        try:
            response = await super().process_request(request)

            if response.success:
                logger.info(f"Request completed successfully")
            else:
                logger.warning(f"Request completed with errors: {response.error}")

            return response
        except Exception as e:
            logger.error(f"Request failed: {e}", exc_info=True)
            raise
```

```
python

import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """配置日志"""
    logger = logging.getLogger('coding_agent')
    logger.setLevel(logging.INFO)

    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_format)
    logger.addHandler(console_handler)

    # 文件处理器
    file_handler = RotatingFileHandler(
        'agent.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.DEBUG)
    file_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
    )
    file_handler.setFormatter(file_format)
    logger.addHandler(file_handler)

    return logger

# 在 Agent 中使用
logger = setup_logging()

class LoggingAgent(IntegratedCodingAgent):
    """带日志的 Agent"""

    async def process_request(self, request: UserRequest) -> AgentResponse:
        logger.info(f"Processing request: {request.type}")

        try:
            response = await super().process_request(request)

            if response.success:
                logger.info(f"Request completed successfully")
            else:
                logger.warning(f"Request completed with errors: {response.error}")

            return response
        except Exception as e:
            logger.error(f"Request failed: {e}", exc_info=True)
            raise
```

#### 29.6.6 最佳实践#

##### 1. 安全性#

- 使用环境变量存储敏感信息
- 实现请求认证和授权
- 限制代码执行权限
- 输入验证和清理

##### 2. 可扩展性#

- 使用异步处理提高并发
- 实现缓存机制减少重复计算
- 支持水平扩展
- 使用消息队列处理异步任务

##### 3. 可靠性#

- 实现重试机制
- 使用断路器模式
- 健康检查和自动恢复
- 数据持久化和备份

##### 4. 可观测性#

- 完善的日志记录
- 性能监控和告警
- 分布式追踪
- 指标收集和分析

通过合理的集成和部署，我们可以将编程 Agent 部署到生产环境，为用户提供稳定、高效的编程辅助服务。

---

# 第 30 章

## 1 部署架构概述

**URL**: https://claudecode.tangshuang.net/course/30.1%20%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0

#### 30.1.1 企业级部署需求#

企业级 Claude Code 部署需要满足高性能、高可用、安全合规等多方面的需求。与个人使用不同，企业级部署需要考虑团队协作、数据安全、权限管理等因素。

##### 30.1.1.1 部署目标#

- 高性能：支持大规模并发请求
- 高可用：保证系统稳定运行
- 安全：保障数据和代码安全
- 合规：符合行业法规和标准
- 可扩展：支持业务快速发展

##### 30.1.1.2 部署挑战#

True. 性能挑战：处理大规模代码请求
True. 安全挑战：保护企业代码和数据
True. 合规挑战：满足行业法规要求
True. 集成挑战：与现有开发工具链集成
True. 管理挑战：团队协作和权限管理

#### 30.1.2 部署架构设计#

##### 30.1.2.1 分层架构#

```
bash复制Deployment Architecture(
  frontend=Frontend Layer(),
  backend=Backend Layer(),
  model=Model Layer(),
  storage=Storage Layer(),
  security=Security Layer()
)
```

```
Deployment Architecture(
  frontend=Frontend Layer(),
  backend=Backend Layer(),
  model=Model Layer(),
  storage=Storage Layer(),
  security=Security Layer()
)
```

##### 30.1.2.2 微服务架构#

```
bash复制Microservices Architecture(
  api_gateway=API Gateway(),
  code_service=Code Service(),
  model_service=Model Service(),
  auth_service=Auth Service(),
  storage_service=Storage Service()
)
```

```
Microservices Architecture(
  api_gateway=API Gateway(),
  code_service=Code Service(),
  model_service=Model Service(),
  auth_service=Auth Service(),
  storage_service=Storage Service()
)
```

##### 30.1.2.3 容器化部署#

```
bash复制Containerized Deployment(
  docker=Docker(),
  kubernetes=Kubernetes(),
  orchestration=Orchestration()
)
```

```
Containerized Deployment(
  docker=Docker(),
  kubernetes=Kubernetes(),
  orchestration=Orchestration()
)
```

#### 30.1.3 部署模式#

##### 30.1.3.1 公有云部署#

```
bash复制Public Cloud Deployment(
  cloud_provider=AWS/Azure/GCP,
  deployment_model=IaaS/PaaS/SaaS
)
```

```
Public Cloud Deployment(
  cloud_provider=AWS/Azure/GCP,
  deployment_model=IaaS/PaaS/SaaS
)
```

##### 30.1.3.2 私有云部署#

```
bash复制Private Cloud Deployment(
  infrastructure=On-premises Data Center,
  virtualization=VMware/KVM,
  management=OpenStack/VMware vSphere
)
```

```
Private Cloud Deployment(
  infrastructure=On-premises Data Center,
  virtualization=VMware/KVM,
  management=OpenStack/VMware vSphere
)
```

##### 30.1.3.3 混合云部署#

```
bash复制Hybrid Cloud Deployment(
  public_cloud=AWS/Azure/GCP,
  private_cloud=On-premises Data Center,
  integration=Cloud Integration
)
```

```
Hybrid Cloud Deployment(
  public_cloud=AWS/Azure/GCP,
  private_cloud=On-premises Data Center,
  integration=Cloud Integration
)
```

#### 30.1.4 部署流程#

##### 30.1.4.1 需求分析#

```
markdown复制# 需求分析文档

## 业务需求

## 技术需求

## 安全需求

## 合规需求
```

```
# 需求分析文档

## 业务需求

## 技术需求

## 安全需求

## 合规需求
```

##### 30.1.4.2 架构设计#

```
markdown复制# 架构设计文档

## 系统架构

## 网络架构

## 安全架构

## 存储架构
```

```
# 架构设计文档

## 系统架构

## 网络架构

## 安全架构

## 存储架构
```

##### 30.1.4.3 环境搭建#

```
bash复制# 环境搭建脚本
#!/bin/bash

# 安装 Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# 安装 Kubernetes
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
mv kubectl /usr/local/bin/
```

```
# 环境搭建脚本
#!/bin/bash

# 安装 Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# 安装 Kubernetes
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
mv kubectl /usr/local/bin/
```

##### 30.1.4.4 系统部署#

```
bash复制# 系统部署脚本
#!/bin/bash

# 部署 API Gateway
docker run -d --name api-gateway api-gateway:latest

# 部署 Code Service
docker run -d --name code-service code-service:latest

# 部署 Model Service
docker run -d --name model-service model-service:latest
```

```
# 系统部署脚本
#!/bin/bash

# 部署 API Gateway
docker run -d --name api-gateway api-gateway:latest

# 部署 Code Service
docker run -d --name code-service code-service:latest

# 部署 Model Service
docker run -d --name model-service model-service:latest
```

##### 30.1.4.5 测试验证#

```
bash复制# 测试验证脚本
#!/bin/bash

# 测试 API Gateway
curl http://api-gateway/health

# 测试 Code Service
curl http://code-service/health

# 测试 Model Service
curl http://model-service/health
```

```
# 测试验证脚本
#!/bin/bash

# 测试 API Gateway
curl http://api-gateway/health

# 测试 Code Service
curl http://code-service/health

# 测试 Model Service
curl http://model-service/health
```

#### 30.1.5 部署工具链#

##### 30.1.5.1 基础设施即代码#

```
hcl复制# Terraform 配置
resource "aws_instance" "claude_code" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "Claude Code"
  }
}
```

```
# Terraform 配置
resource "aws_instance" "claude_code" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "Claude Code"
  }
}
```

##### 30.1.5.2 配置管理#

```
yaml复制# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install Docker
      apt:
        name: docker.io
        state: present

    - name: Start Docker
      service:
        name: docker
        state: started
```

```
# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install Docker
      apt:
        name: docker.io
        state: present

    - name: Start Docker
      service:
        name: docker
        state: started
```

##### 30.1.5.3 持续集成/持续部署#

```
yaml复制# GitHub Actions 配置
name: Deploy Claude Code

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Deploy to production
      run: |
        docker build -t claude-code .
        docker run -d claude-code
```

```
# GitHub Actions 配置
name: Deploy Claude Code

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Deploy to production
      run: |
        docker build -t claude-code .
        docker run -d claude-code
```

#### 30.1.6 部署最佳实践#

##### 30.1.6.1 自动化部署#

```
bash复制# 自动化部署脚本
#!/bin/bash

# 拉取最新代码
git pull origin main

# 构建 Docker 镜像
docker build -t claude-code .

# 停止旧容器
docker stop claude-code

# 删除旧容器
docker rm claude-code

# 启动新容器
docker run -d --name claude-code claude-code:latest
```

```
# 自动化部署脚本
#!/bin/bash

# 拉取最新代码
git pull origin main

# 构建 Docker 镜像
docker build -t claude-code .

# 停止旧容器
docker stop claude-code

# 删除旧容器
docker rm claude-code

# 启动新容器
docker run -d --name claude-code claude-code:latest
```

##### 30.1.6.2 蓝绿部署#

```
bash复制# 蓝绿部署脚本
#!/bin/bash

# 部署新版本到蓝环境
docker run -d --name claude-code-blue claude-code:latest

# 测试蓝环境
curl http://claude-code-blue/health

# 切换流量到蓝环境
nginx -s reload

# 停止绿环境容器
docker stop claude-code-green
```

```
# 蓝绿部署脚本
#!/bin/bash

# 部署新版本到蓝环境
docker run -d --name claude-code-blue claude-code:latest

# 测试蓝环境
curl http://claude-code-blue/health

# 切换流量到蓝环境
nginx -s reload

# 停止绿环境容器
docker stop claude-code-green
```

##### 30.1.6.3 滚动部署#

```
bash复制# 滚动部署脚本
#!/bin/bash

# 部署新版本
docker service update --image claude-code:latest claude-code-service

# 监控部署进度
docker service ps claude-code-service
```

```
# 滚动部署脚本
#!/bin/bash

# 部署新版本
docker service update --image claude-code:latest claude-code-service

# 监控部署进度
docker service ps claude-code-service
```

#### 30.1.7 部署案例分析#

##### 30.1.7.1 金融行业部署#

```
bash复制Financial Industry Deployment(
  security=High Security,
  compliance=PCI DSS,
  performance=High Performance,
  availability=99.99%
)
```

```
Financial Industry Deployment(
  security=High Security,
  compliance=PCI DSS,
  performance=High Performance,
  availability=99.99%
)
```

##### 30.1.7.2 制造业部署#

```
bash复制Manufacturing Industry Deployment(
  integration=ERP/PLM,
  security=Industrial Security,
  performance=Real-time,
  availability=99.9%
)
```

```
Manufacturing Industry Deployment(
  integration=ERP/PLM,
  security=Industrial Security,
  performance=Real-time,
  availability=99.9%
)
```

##### 30.1.7.3 医疗行业部署#

```
bash复制Healthcare Industry Deployment(
  compliance=HIPAA,
  security=Patient Data Security,
  performance=Fast Response,
  availability=99.99%
)
```

```
Healthcare Industry Deployment(
  compliance=HIPAA,
  security=Patient Data Security,
  performance=Fast Response,
  availability=99.99%
)
```

#### 30.1.8 部署评估#

##### 30.1.8.1 性能评估#

```
python复制class PerformanceEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, deployment):
        # 评估性能指标
        metrics = {
            'response_time': self.measure_response_time(deployment),
            'throughput': self.measure_throughput(deployment),
            'concurrency': self.measure_concurrency(deployment)
        }
        return metrics
```

```
class PerformanceEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, deployment):
        # 评估性能指标
        metrics = {
            'response_time': self.measure_response_time(deployment),
            'throughput': self.measure_throughput(deployment),
            'concurrency': self.measure_concurrency(deployment)
        }
        return metrics
```

##### 30.1.8.2 安全评估#

```
python复制class SecurityEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, deployment):
        # 评估安全指标
        metrics = {
            'vulnerabilities': self.scan_vulnerabilities(deployment),
            'compliance': self.check_compliance(deployment),
            'incidents': self.check_incidents(deployment)
        }
        return metrics
```

```
class SecurityEvaluator:
    def __init__(self):
        pass
    
    def evaluate(self, deployment):
        # 评估安全指标
        metrics = {
            'vulnerabilities': self.scan_vulnerabilities(deployment),
            'compliance': self.check_compliance(deployment),
            'incidents': self.check_incidents(deployment)
        }
        return metrics
```

#### 30.1.9 部署优化#

##### 30.1.9.1 性能优化#

```
python复制class PerformanceOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, deployment):
        # 优化性能
        deployment = self.optimize_resources(deployment)
        deployment = self.optimize_network(deployment)
        deployment = self.optimize_storage(deployment)
        return deployment
```

```
class PerformanceOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, deployment):
        # 优化性能
        deployment = self.optimize_resources(deployment)
        deployment = self.optimize_network(deployment)
        deployment = self.optimize_storage(deployment)
        return deployment
```

##### 30.1.9.2 成本优化#

```
python复制class CostOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, deployment):
        # 优化成本
        deployment = self.optimize_resource_usage(deployment)
        deployment = self.optimize_pricing(deployment)
        deployment = self.optimize_licensing(deployment)
        return deployment
```

```
class CostOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, deployment):
        # 优化成本
        deployment = self.optimize_resource_usage(deployment)
        deployment = self.optimize_pricing(deployment)
        deployment = self.optimize_licensing(deployment)
        return deployment
```

#### 30.1.10 总结#

企业级 Claude Code 部署是一个复杂的系统工程，需要考虑性能、安全、合规、集成等多方面的因素。通过合理的架构设计、部署模式选择和工具链使用，可以实现高效、安全、可靠的企业级 Claude Code 部署。

部署架构的设计需要根据企业的实际需求和情况进行调整，不同行业和规模的企业可能需要不同的部署方案。同时，部署后的评估和优化也是持续的过程，需要不断监控和改进。

未来，随着云计算、容器化、微服务等技术的发展，企业级 Claude Code 部署将变得更加灵活、高效和安全。

---

## 2 公有云部署

**URL**: https://claudecode.tangshuang.net/course/30.2%20%E5%85%AC%E6%9C%89%E4%BA%91%E9%83%A8%E7%BD%B2

#### 30.2.1 公有云部署概述#

公有云部署是将 Claude Code 部署在公有云平台上，利用云平台的基础设施和服务来运行和管理 Claude Code。公有云部署具有快速部署、弹性扩展、成本效益高等特点。

##### 30.2.1.1 公有云优势#

- 快速部署：几分钟内即可部署完成
- 弹性扩展：根据需求自动扩展资源
- 成本效益：按需付费，降低初始投资
- 高可用性：云平台提供高可用基础设施
- 安全可靠：云平台提供安全保障

##### 30.2.1.2 公有云挑战#

- 数据安全：数据存储在公有云中
- 合规风险：需要符合行业法规要求
- 网络延迟：依赖云平台网络
- 锁定风险：可能被云平台锁定

#### 30.2.2 公有云平台选择#

##### 30.2.2.1 AWS 部署#

```
bash复制AWS Deployment(
  compute=EC2/Fargate/Lambda,
  storage=S3/EBS/RDS,
  networking=VPC/ELB/Route 53,
  security=IAM/Shield/GuardDuty
)
```

```
AWS Deployment(
  compute=EC2/Fargate/Lambda,
  storage=S3/EBS/RDS,
  networking=VPC/ELB/Route 53,
  security=IAM/Shield/GuardDuty
)
```

##### 30.2.2.2 Azure 部署#

```
bash复制Azure Deployment(
  compute=VM/Container Apps/Function Apps,
  storage=Blob Storage/File Storage/SQL Database,
  networking=VNet/Load Balancer/DNS,
  security=Azure AD/Security Center/Defender
)
```

```
Azure Deployment(
  compute=VM/Container Apps/Function Apps,
  storage=Blob Storage/File Storage/SQL Database,
  networking=VNet/Load Balancer/DNS,
  security=Azure AD/Security Center/Defender
)
```

##### 30.2.2.3 GCP 部署#

```
bash复制GCP Deployment(
  compute=GCE/GKE/Cloud Functions,
  storage=Cloud Storage/Persistent Disk/Cloud SQL,
  networking=VPC/Load Balancer/Cloud DNS,
  security=IAM/Security Command Center/Cloud Armor
)
```

```
GCP Deployment(
  compute=GCE/GKE/Cloud Functions,
  storage=Cloud Storage/Persistent Disk/Cloud SQL,
  networking=VPC/Load Balancer/Cloud DNS,
  security=IAM/Security Command Center/Cloud Armor
)
```

#### 30.2.3 公有云部署架构#

##### 30.2.3.1 三层架构#

```
bash复制Three-tier Architecture(
  presentation=Web Server,
  application=Application Server,
  data=Database Server
)
```

```
Three-tier Architecture(
  presentation=Web Server,
  application=Application Server,
  data=Database Server
)
```

##### 30.2.3.2 微服务架构#

```
bash复制Microservices Architecture(
  api_gateway=API Gateway,
  services=Microservices,
  database=Distributed Database
)
```

```
Microservices Architecture(
  api_gateway=API Gateway,
  services=Microservices,
  database=Distributed Database
)
```

##### 30.2.3.3 无服务器架构#

```
bash复制Serverless Architecture(
  functions=Serverless Functions,
  triggers=Event Triggers,
  storage=Cloud Storage
)
```

```
Serverless Architecture(
  functions=Serverless Functions,
  triggers=Event Triggers,
  storage=Cloud Storage
)
```

#### 30.2.4 公有云部署流程#

##### 30.2.4.1 账户准备#

```
bash复制# AWS 账户准备
aws configure

# Azure 账户准备
az login

# GCP 账户准备
gcloud init
```

```
# AWS 账户准备
aws configure

# Azure 账户准备
az login

# GCP 账户准备
gcloud init
```

##### 30.2.4.2 基础设施部署#

```
hcl复制# Terraform 配置
resource "aws_instance" "claude_code" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "Claude Code"
  }
}
```

```
# Terraform 配置
resource "aws_instance" "claude_code" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "Claude Code"
  }
}
```

##### 30.2.4.3 应用部署#

```
bash复制# Docker 部署
docker build -t claude-code .
docker run -d claude-code

# Kubernetes 部署
kubectl apply -f deployment.yaml
```

```
# Docker 部署
docker build -t claude-code .
docker run -d claude-code

# Kubernetes 部署
kubectl apply -f deployment.yaml
```

##### 30.2.4.4 配置管理#

```
yaml复制# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install dependencies
      apt:
        name: python3
        state: present
```

```
# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install dependencies
      apt:
        name: python3
        state: present
```

##### 30.2.4.5 测试验证#

```
bash复制# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code
```

```
# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code
```

#### 30.2.5 公有云安全#

##### 30.2.5.1 身份与访问管理#

```
bash复制# IAM 配置
aws iam create-user --user-name claude-code-user
aws iam attach-user-policy --user-name claude-code-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
```

```
# IAM 配置
aws iam create-user --user-name claude-code-user
aws iam attach-user-policy --user-name claude-code-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
```

##### 30.2.5.2 数据加密#

```
bash复制# S3 加密
aws s3api put-bucket-encryption --bucket claude-code-bucket --server-side-encryption-configuration '{
  "Rules": [{
    "ApplyServerSideEncryptionByDefault": {
      "SSEAlgorithm": "AES256"
    }
  }]
}'
```

```
# S3 加密
aws s3api put-bucket-encryption --bucket claude-code-bucket --server-side-encryption-configuration '{
  "Rules": [{
    "ApplyServerSideEncryptionByDefault": {
      "SSEAlgorithm": "AES256"
    }
  }]
}'
```

##### 30.2.5.3 网络安全#

```
bash复制# 安全组配置
aws ec2 create-security-group --group-name claude-code-sg --description "Claude Code Security Group"
aws ec2 authorize-security-group-ingress --group-name claude-code-sg --protocol tcp --port 80 --cidr 0.0.0.0/0
```

```
# 安全组配置
aws ec2 create-security-group --group-name claude-code-sg --description "Claude Code Security Group"
aws ec2 authorize-security-group-ingress --group-name claude-code-sg --protocol tcp --port 80 --cidr 0.0.0.0/0
```

#### 30.2.6 公有云成本优化#

##### 30.2.6.1 按需实例#

```
bash复制# 按需实例
aws ec2 run-instances --image-id ami-0c55b159cbfafe1f0 --instance-type t2.micro --count 1
```

```
# 按需实例
aws ec2 run-instances --image-id ami-0c55b159cbfafe1f0 --instance-type t2.micro --count 1
```

##### 30.2.6.2 预留实例#

```
bash复制# 预留实例
aws ec2 purchase-reserved-instances-offering --reserved-instances-offering-id ri-0123456789abcdef0 --instance-count 1
```

```
# 预留实例
aws ec2 purchase-reserved-instances-offering --reserved-instances-offering-id ri-0123456789abcdef0 --instance-count 1
```

##### 30.2.6.3 竞价实例#

```
bash复制# 竞价实例
aws ec2 run-instances --image-id ami-0c55b159cbfafe1f0 --instance-type t2.micro --count 1 --instance-market-options '{
  "MarketType": "spot"
}'
```

```
# 竞价实例
aws ec2 run-instances --image-id ami-0c55b159cbfafe1f0 --instance-type t2.micro --count 1 --instance-market-options '{
  "MarketType": "spot"
}'
```

#### 30.2.7 公有云监控#

##### 30.2.7.1 AWS CloudWatch#

```
bash复制# CloudWatch 监控
aws cloudwatch put-metric-alarm --alarm-name claude-code-high-cpu --metric-name CPUUtilization --namespace AWS/EC2 --statistic Average --period 300 --threshold 80 --comparison-operator GreaterThanThreshold --dimensions Name=InstanceId,Value=i-0123456789abcdef0 --evaluation-periods 2
```

```
# CloudWatch 监控
aws cloudwatch put-metric-alarm --alarm-name claude-code-high-cpu --metric-name CPUUtilization --namespace AWS/EC2 --statistic Average --period 300 --threshold 80 --comparison-operator GreaterThanThreshold --dimensions Name=InstanceId,Value=i-0123456789abcdef0 --evaluation-periods 2
```

##### 30.2.7.2 Azure Monitor#

```
bash复制# Azure Monitor
az monitor metrics alert create --name claude-code-high-cpu --resource-group claude-code-rg --scopes /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/claude-code-rg/providers/Microsoft.Compute/virtualMachines/claude-code-vm --condition "avg CPU percentage > 80"
```

```
# Azure Monitor
az monitor metrics alert create --name claude-code-high-cpu --resource-group claude-code-rg --scopes /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/claude-code-rg/providers/Microsoft.Compute/virtualMachines/claude-code-vm --condition "avg CPU percentage > 80"
```

##### 30.2.7.3 GCP Stackdriver#

```
bash复制# Stackdriver 监控
gcloud alpha monitoring policies create --policy-from-file policy.yaml
```

```
# Stackdriver 监控
gcloud alpha monitoring policies create --policy-from-file policy.yaml
```

#### 30.2.8 公有云部署案例#

##### 30.2.8.1 初创公司部署#

```
bash复制Startup Deployment(
  platform=AWS,
  architecture=Serverless,
  cost=Pay-as-you-go,
  scale=Elastic
)
```

```
Startup Deployment(
  platform=AWS,
  architecture=Serverless,
  cost=Pay-as-you-go,
  scale=Elastic
)
```

##### 30.2.8.2 中型企业部署#

```
bash复制Medium Enterprise Deployment(
  platform=Azure,
  architecture=Microservices,
  cost=Reserved Instances,
  scale=Auto Scaling
)
```

```
Medium Enterprise Deployment(
  platform=Azure,
  architecture=Microservices,
  cost=Reserved Instances,
  scale=Auto Scaling
)
```

##### 30.2.8.3 大型企业部署#

```
bash复制Large Enterprise Deployment(
  platform=GCP,
  architecture=Hybrid,
  cost=Enterprise Agreement,
  scale=Global
)
```

```
Large Enterprise Deployment(
  platform=GCP,
  architecture=Hybrid,
  cost=Enterprise Agreement,
  scale=Global
)
```

#### 30.2.9 公有云迁移#

##### 30.2.9.1 迁移策略#

```
bash复制Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

```
Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

##### 30.2.9.2 迁移工具#

```
bash复制Migration Tools(
  aws=AWS Migration Hub,
  azure=Azure Migrate,
  gcp=GCP Migration Center
)
```

```
Migration Tools(
  aws=AWS Migration Hub,
  azure=Azure Migrate,
  gcp=GCP Migration Center
)
```

##### 30.2.9.3 迁移流程#

```
bash复制Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

```
Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

#### 30.2.10 公有云最佳实践#

##### 30.2.10.1 架构设计#

```
bash复制Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

```
Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

##### 30.2.10.2 安全实践#

```
bash复制Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

```
Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

##### 30.2.10.3 成本实践#

```
bash复制Cost Best Practices(
  right_sizing=Right Sizing,
  reserved_instances=Reserved Instances,
  spot_instances=Spot Instances,
  cost_management=Cost Management
)
```

```
Cost Best Practices(
  right_sizing=Right Sizing,
  reserved_instances=Reserved Instances,
  spot_instances=Spot Instances,
  cost_management=Cost Management
)
```

#### 30.2.11 公有云未来发展#

##### 30.2.11.1 云原生应用#

```
bash复制Cloud-native Applications(
  containers=Docker/Kubernetes,
  microservices=Microservices,
  serverless=Serverless,
  devops=DevOps
)
```

```
Cloud-native Applications(
  containers=Docker/Kubernetes,
  microservices=Microservices,
  serverless=Serverless,
  devops=DevOps
)
```

##### 30.2.11.2 边缘计算#

```
bash复制Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

```
Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

##### 30.2.11.3 AI 集成#

```
bash复制AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

```
AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

#### 30.2.12 总结#

公有云部署是企业级 Claude Code 部署的重要选择，具有快速部署、弹性扩展、成本效益高等特点。通过选择合适的公有云平台、设计合理的部署架构、实施安全措施和优化成本，企业可以实现高效、安全、可靠的 Claude Code 部署。

随着云原生技术、边缘计算和 AI 集成的发展，公有云部署将变得更加灵活、高效和智能。企业应根据自身需求和情况，选择合适的公有云部署方案。

---

## 3 私有云部署

**URL**: https://claudecode.tangshuang.net/course/30.3%20%E7%A7%81%E6%9C%89%E4%BA%91%E9%83%A8%E7%BD%B2

#### 30.3.1 私有云部署概述#

私有云部署是将 Claude Code 部署在企业内部的数据中心，由企业自行管理和维护。私有云部署具有数据安全、合规性高、可控性强等特点。

##### 30.3.1.1 私有云优势#

- 数据安全：数据存储在企业内部
- 合规性高：符合行业法规要求
- 可控性强：企业完全掌控基础设施
- 性能稳定：不受外部网络影响
- 定制化：可根据需求定制部署

##### 30.3.1.2 私有云挑战#

- 初始投资高：需要购买硬件和软件
- 维护成本高：需要专业团队维护
- 部署周期长：需要搭建基础设施
- 扩展性有限：受硬件资源限制

#### 30.3.2 私有云架构设计#

##### 30.3.2.1 虚拟化架构#

```
bash复制Virtualization Architecture(
  hypervisor=VMware/KVM/Xen,
  virtual_machines=VMs,
  storage=SAN/NAS/DAS,
  networking=VLAN/Switch/Router
)
```

```
Virtualization Architecture(
  hypervisor=VMware/KVM/Xen,
  virtual_machines=VMs,
  storage=SAN/NAS/DAS,
  networking=VLAN/Switch/Router
)
```

##### 30.3.2.2 软件定义架构#

```
bash复制Software-defined Architecture(
  sdn=Software-defined Networking,
  sds=Software-defined Storage,
  sdc=Software-defined Compute
)
```

```
Software-defined Architecture(
  sdn=Software-defined Networking,
  sds=Software-defined Storage,
  sdc=Software-defined Compute
)
```

##### 30.3.2.3 混合架构#

```
bash复制Hybrid Architecture(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration
)
```

```
Hybrid Architecture(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration
)
```

#### 30.3.3 私有云平台选择#

##### 30.3.3.1 VMware 部署#

```
bash复制VMware Deployment(
  vsphere=VMware vSphere,
  vcenter=VMware vCenter,
  vsan=VMware vSAN,
  nsx=VMware NSX
)
```

```
VMware Deployment(
  vsphere=VMware vSphere,
  vcenter=VMware vCenter,
  vsan=VMware vSAN,
  nsx=VMware NSX
)
```

##### 30.3.3.2 OpenStack 部署#

```
bash复制OpenStack Deployment(
  compute=Nova,
  storage=Cinder/Glance/Swift,
  networking=Neutron,
  identity=Keystone
)
```

```
OpenStack Deployment(
  compute=Nova,
  storage=Cinder/Glance/Swift,
  networking=Neutron,
  identity=Keystone
)
```

##### 30.3.3.3 KVM 部署#

```
bash复制KVM Deployment(
  hypervisor=KVM,
  management=Proxmox/Virt-Manager,
  storage=LVM/Ceph,
  networking=Open vSwitch
)
```

```
KVM Deployment(
  hypervisor=KVM,
  management=Proxmox/Virt-Manager,
  storage=LVM/Ceph,
  networking=Open vSwitch
)
```

#### 30.3.4 私有云部署流程#

##### 30.3.4.1 基础设施规划#

```
markdown复制# 基础设施规划

## 硬件需求
- 服务器：2 台以上
- 存储：SAN/NAS
- 网络：交换机、路由器

## 软件需求
- 虚拟化软件：VMware/KVM
- 操作系统：Linux/Windows
- 管理软件：vCenter/OpenStack
```

```
# 基础设施规划

## 硬件需求
- 服务器：2 台以上
- 存储：SAN/NAS
- 网络：交换机、路由器

## 软件需求
- 虚拟化软件：VMware/KVM
- 操作系统：Linux/Windows
- 管理软件：vCenter/OpenStack
```

##### 30.3.4.2 硬件采购#

```
bash复制# 服务器采购
# CPU：Intel Xeon Gold
# 内存：128GB RAM
# 存储：1TB SSD
# 网络：10Gbps NIC
```

```
# 服务器采购
# CPU：Intel Xeon Gold
# 内存：128GB RAM
# 存储：1TB SSD
# 网络：10Gbps NIC
```

##### 30.3.4.3 虚拟化部署#

```
bash复制# VMware 部署
# 安装 ESXi
# 配置 vCenter
# 创建虚拟机

# OpenStack 部署
# 安装 OpenStack
# 配置服务
# 创建实例
```

```
# VMware 部署
# 安装 ESXi
# 配置 vCenter
# 创建虚拟机

# OpenStack 部署
# 安装 OpenStack
# 配置服务
# 创建实例
```

##### 30.3.4.4 应用部署#

```
bash复制# Docker 部署
docker build -t claude-code .
docker run -d claude-code

# Kubernetes 部署
kubectl apply -f deployment.yaml
```

```
# Docker 部署
docker build -t claude-code .
docker run -d claude-code

# Kubernetes 部署
kubectl apply -f deployment.yaml
```

##### 30.3.4.5 配置管理#

```
yaml复制# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install dependencies
      apt:
        name: python3
        state: present
```

```
# Ansible 配置
---
- name: Deploy Claude Code
  hosts: all
  tasks:
    - name: Install dependencies
      apt:
        name: python3
        state: present
```

##### 30.3.4.6 测试验证#

```
bash复制# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code
```

```
# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code
```

#### 30.3.5 私有云安全#

##### 30.3.5.1 物理安全#

```
bash复制Physical Security(
  access_control=Access Control System,
  surveillance=CCTV,
  fire_suppression=Fire Suppression System,
  environmental_control=HVAC
)
```

```
Physical Security(
  access_control=Access Control System,
  surveillance=CCTV,
  fire_suppression=Fire Suppression System,
  environmental_control=HVAC
)
```

##### 30.3.5.2 网络安全#

```
bash复制Network Security(
  firewall=Firewall,
  ids_ips=IDS/IPS,
  vpn=VPN,
  encryption=Encryption
)
```

```
Network Security(
  firewall=Firewall,
  ids_ips=IDS/IPS,
  vpn=VPN,
  encryption=Encryption
)
```

##### 30.3.5.3 数据安全#

```
bash复制Data Security(
  backup=Backup System,
  disaster_recovery=Disaster Recovery,
  encryption=Data Encryption,
  access_control=Data Access Control
)
```

```
Data Security(
  backup=Backup System,
  disaster_recovery=Disaster Recovery,
  encryption=Data Encryption,
  access_control=Data Access Control
)
```

#### 30.3.6 私有云性能优化#

##### 30.3.6.1 资源优化#

```
python复制class ResourceOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, infrastructure):
        # 优化资源分配
        infrastructure = self.optimize_cpu(infrastructure)
        infrastructure = self.optimize_memory(infrastructure)
        infrastructure = self.optimize_storage(infrastructure)
        return infrastructure
```

```
class ResourceOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, infrastructure):
        # 优化资源分配
        infrastructure = self.optimize_cpu(infrastructure)
        infrastructure = self.optimize_memory(infrastructure)
        infrastructure = self.optimize_storage(infrastructure)
        return infrastructure
```

##### 30.3.6.2 网络优化#

```
python复制class NetworkOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, network):
        # 优化网络性能
        network = self.optimize_bandwidth(network)
        network = self.optimize_latency(network)
        network = self.optimize_security(network)
        return network
```

```
class NetworkOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, network):
        # 优化网络性能
        network = self.optimize_bandwidth(network)
        network = self.optimize_latency(network)
        network = self.optimize_security(network)
        return network
```

#### 30.3.7 私有云监控#

##### 30.3.7.1 基础设施监控#

```
python复制class InfrastructureMonitor:
    def __init__(self):
        pass
    
    def monitor(self, infrastructure):
        # 监控基础设施
        metrics = {
            'cpu_usage': self.monitor_cpu(infrastructure),
            'memory_usage': self.monitor_memory(infrastructure),
            'storage_usage': self.monitor_storage(infrastructure)
        }
        return metrics
```

```
class InfrastructureMonitor:
    def __init__(self):
        pass
    
    def monitor(self, infrastructure):
        # 监控基础设施
        metrics = {
            'cpu_usage': self.monitor_cpu(infrastructure),
            'memory_usage': self.monitor_memory(infrastructure),
            'storage_usage': self.monitor_storage(infrastructure)
        }
        return metrics
```

##### 30.3.7.2 应用监控#

```
python复制class ApplicationMonitor:
    def __init__(self):
        pass
    
    def monitor(self, application):
        # 监控应用性能
        metrics = {
            'response_time': self.monitor_response_time(application),
            'throughput': self.monitor_throughput(application),
            'errors': self.monitor_errors(application)
        }
        return metrics
```

```
class ApplicationMonitor:
    def __init__(self):
        pass
    
    def monitor(self, application):
        # 监控应用性能
        metrics = {
            'response_time': self.monitor_response_time(application),
            'throughput': self.monitor_throughput(application),
            'errors': self.monitor_errors(application)
        }
        return metrics
```

#### 30.3.8 私有云部署案例#

##### 30.3.8.1 金融行业部署#

```
bash复制Financial Industry Deployment(
  security=High Security,
  compliance=PCI DSS,
  performance=High Performance,
  availability=99.99%
)
```

```
Financial Industry Deployment(
  security=High Security,
  compliance=PCI DSS,
  performance=High Performance,
  availability=99.99%
)
```

##### 30.3.8.2 医疗行业部署#

```
bash复制Healthcare Industry Deployment(
  compliance=HIPAA,
  security=Patient Data Security,
  performance=Fast Response,
  availability=99.99%
)
```

```
Healthcare Industry Deployment(
  compliance=HIPAA,
  security=Patient Data Security,
  performance=Fast Response,
  availability=99.99%
)
```

##### 30.3.8.3 政府行业部署#

```
bash复制Government Industry Deployment(
  security=Top Secret,
  compliance=Government Regulations,
  performance=High Performance,
  availability=99.99%
)
```

```
Government Industry Deployment(
  security=Top Secret,
  compliance=Government Regulations,
  performance=High Performance,
  availability=99.99%
)
```

#### 30.3.9 私有云迁移#

##### 30.3.9.1 迁移策略#

```
bash复制Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

```
Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

##### 30.3.9.2 迁移工具#

```
bash复制Migration Tools(
  vmware=VMware vMotion,
  openstack=OpenStack Migration Tool,
  third_party=Third-party Migration Tools
)
```

```
Migration Tools(
  vmware=VMware vMotion,
  openstack=OpenStack Migration Tool,
  third_party=Third-party Migration Tools
)
```

##### 30.3.9.3 迁移流程#

```
bash复制Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

```
Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

#### 30.3.10 私有云最佳实践#

##### 30.3.10.1 架构设计#

```
bash复制Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

```
Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

##### 30.3.10.2 安全实践#

```
bash复制Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

```
Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

##### 30.3.10.3 管理实践#

```
bash复制Management Best Practices(
  automation=Automation,
  orchestration=Orchestration,
  monitoring=Monitoring,
  optimization=Optimization
)
```

```
Management Best Practices(
  automation=Automation,
  orchestration=Orchestration,
  monitoring=Monitoring,
  optimization=Optimization
)
```

#### 30.3.11 私有云未来发展#

##### 30.3.11.1 边缘计算#

```
bash复制Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

```
Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

##### 30.3.11.2 AI 集成#

```
bash复制AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

```
AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

##### 30.3.11.3 混合云#

```
bash复制Hybrid Cloud(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration
)
```

```
Hybrid Cloud(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration
)
```

#### 30.3.12 总结#

私有云部署是企业级 Claude Code 部署的重要选择，具有数据安全、合规性高、可控性强等特点。通过合理的架构设计、安全措施和性能优化，企业可以实现高效、安全、可靠的 Claude Code 部署。

随着边缘计算、AI 集成和混合云技术的发展，私有云部署将变得更加灵活、高效和智能。企业应根据自身需求和情况，选择合适的私有云部署方案。

---

## 4 混合云部署

**URL**: https://claudecode.tangshuang.net/course/30.4%20%E6%B7%B7%E5%90%88%E4%BA%91%E9%83%A8%E7%BD%B2

#### 30.4.1 混合云部署概述#

混合云部署是将 Claude Code 同时部署在私有云和公有云中，结合两者的优势。混合云部署具有灵活性高、成本效益好、安全可靠等特点。

##### 30.4.1.1 混合云优势#

- 灵活性高：根据需求选择部署位置
- 成本效益：公有云处理非敏感负载，私有云处理敏感负载
- 安全可靠：敏感数据存储在私有云中
- 弹性扩展：利用公有云弹性扩展能力
- 业务连续性：确保业务持续运行

##### 30.4.1.2 混合云挑战#

- 集成复杂：需要集成私有云和公有云
- 网络延迟：跨云网络可能存在延迟
- 管理复杂：需要管理多个云环境
- 合规风险：需要符合行业法规要求

#### 30.4.2 混合云架构设计#

##### 30.4.2.1 核心架构#

```
bash复制Hybrid Cloud Architecture(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration,
  management=Hybrid Cloud Management
)
```

```
Hybrid Cloud Architecture(
  private_cloud=Private Cloud,
  public_cloud=Public Cloud,
  integration=Cloud Integration,
  management=Hybrid Cloud Management
)
```

##### 30.4.2.2 部署模型#

```
bash复制Deployment Models(
  cloudbursting=Cloud Bursting,
  data_archiving=Data Archiving,
  disaster_recovery=Disaster Recovery,
  workload_migration=Workload Migration
)
```

```
Deployment Models(
  cloudbursting=Cloud Bursting,
  data_archiving=Data Archiving,
  disaster_recovery=Disaster Recovery,
  workload_migration=Workload Migration
)
```

##### 30.4.2.3 集成架构#

```
bash复制Integration Architecture(
  api_gateway=API Gateway,
  message_bus=Message Bus,
  data_sync=Data Synchronization,
  identity_sync=Identity Synchronization
)
```

```
Integration Architecture(
  api_gateway=API Gateway,
  message_bus=Message Bus,
  data_sync=Data Synchronization,
  identity_sync=Identity Synchronization
)
```

#### 30.4.3 混合云平台选择#

##### 30.4.3.1 AWS 混合云#

```
bash复制AWS Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=AWS,
  integration=AWS Outposts/AWS Direct Connect
)
```

```
AWS Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=AWS,
  integration=AWS Outposts/AWS Direct Connect
)
```

##### 30.4.3.2 Azure 混合云#

```
bash复制Azure Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=Azure,
  integration=Azure Arc/Azure ExpressRoute
)
```

```
Azure Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=Azure,
  integration=Azure Arc/Azure ExpressRoute
)
```

##### 30.4.3.3 GCP 混合云#

```
bash复制GCP Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=GCP,
  integration=GCP Anthos/GCP Cloud Interconnect
)
```

```
GCP Hybrid Cloud(
  private_cloud=VMware/KVM,
  public_cloud=GCP,
  integration=GCP Anthos/GCP Cloud Interconnect
)
```

#### 30.4.4 混合云部署流程#

##### 30.4.4.1 需求分析#

```
markdown复制# 需求分析文档

## 业务需求
- 敏感数据处理
- 弹性扩展需求
- 成本优化需求

## 技术需求
- 私有云基础设施
- 公有云平台
- 集成方案

## 安全需求
- 数据安全
- 合规要求
- 访问控制
```

```
# 需求分析文档

## 业务需求
- 敏感数据处理
- 弹性扩展需求
- 成本优化需求

## 技术需求
- 私有云基础设施
- 公有云平台
- 集成方案

## 安全需求
- 数据安全
- 合规要求
- 访问控制
```

##### 30.4.4.2 架构设计#

```
markdown复制# 架构设计文档

## 系统架构
- 私有云部分
- 公有云部分
- 集成部分

## 网络架构
- 私有云网络
- 公有云网络
- 跨云连接

## 安全架构
- 私有云安全
- 公有云安全
- 集成安全
```

```
# 架构设计文档

## 系统架构
- 私有云部分
- 公有云部分
- 集成部分

## 网络架构
- 私有云网络
- 公有云网络
- 跨云连接

## 安全架构
- 私有云安全
- 公有云安全
- 集成安全
```

##### 30.4.4.3 基础设施部署#

```
bash复制# 私有云部署
# 安装虚拟化软件
# 配置存储和网络
# 部署管理平台

# 公有云部署
# 创建账户
# 配置网络
# 部署服务

# 集成部署
# 配置跨云连接
# 部署集成服务
# 配置管理平台
```

```
# 私有云部署
# 安装虚拟化软件
# 配置存储和网络
# 部署管理平台

# 公有云部署
# 创建账户
# 配置网络
# 部署服务

# 集成部署
# 配置跨云连接
# 部署集成服务
# 配置管理平台
```

##### 30.4.4.4 应用部署#

```
bash复制# 私有云应用部署
docker build -t claude-code .
docker run -d claude-code

# 公有云应用部署
kubectl apply -f deployment.yaml

# 集成配置
# 配置 API 网关
# 配置数据同步
# 配置身份同步
```

```
# 私有云应用部署
docker build -t claude-code .
docker run -d claude-code

# 公有云应用部署
kubectl apply -f deployment.yaml

# 集成配置
# 配置 API 网关
# 配置数据同步
# 配置身份同步
```

##### 30.4.4.5 测试验证#

```
bash复制# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code

# 集成测试
# 测试跨云数据同步
# 测试跨云身份验证
# 测试跨云负载均衡
```

```
# 功能测试
curl http://claude-code/api/v1/generate

# 性能测试
ab -n 1000 -c 100 http://claude-code/api/v1/generate

# 安全测试
zap-baseline.py -t http://claude-code

# 集成测试
# 测试跨云数据同步
# 测试跨云身份验证
# 测试跨云负载均衡
```

#### 30.4.5 混合云安全#

##### 30.4.5.1 数据安全#

```
bash复制Data Security(
  encryption=Data Encryption,
  tokenization=Data Tokenization,
  masking=Data Masking,
  access_control=Data Access Control
)
```

```
Data Security(
  encryption=Data Encryption,
  tokenization=Data Tokenization,
  masking=Data Masking,
  access_control=Data Access Control
)
```

##### 30.4.5.2 网络安全#

```
bash复制Network Security(
  vpn=VPN,
  direct_connect=Direct Connect,
  firewall=Firewall,
  ids_ips=IDS/IPS
)
```

```
Network Security(
  vpn=VPN,
  direct_connect=Direct Connect,
  firewall=Firewall,
  ids_ips=IDS/IPS
)
```

##### 30.4.5.3 身份安全#

```
bash复制Identity Security(
  single_sign_on=Single Sign-On,
  multi_factor_authentication=Multi-factor Authentication,
  identity_sync=Identity Synchronization,
  access_control=Access Control
)
```

```
Identity Security(
  single_sign_on=Single Sign-On,
  multi_factor_authentication=Multi-factor Authentication,
  identity_sync=Identity Synchronization,
  access_control=Access Control
)
```

#### 30.4.6 混合云成本优化#

##### 30.4.6.1 成本分析#

```
python复制class CostAnalyzer:
    def __init__(self):
        pass
    
    def analyze(self, hybrid_cloud):
        # 分析混合云成本
        costs = {
            'private_cloud_cost': self.analyze_private_cloud_cost(hybrid_cloud),
            'public_cloud_cost': self.analyze_public_cloud_cost(hybrid_cloud),
            'integration_cost': self.analyze_integration_cost(hybrid_cloud)
        }
        return costs
```

```
class CostAnalyzer:
    def __init__(self):
        pass
    
    def analyze(self, hybrid_cloud):
        # 分析混合云成本
        costs = {
            'private_cloud_cost': self.analyze_private_cloud_cost(hybrid_cloud),
            'public_cloud_cost': self.analyze_public_cloud_cost(hybrid_cloud),
            'integration_cost': self.analyze_integration_cost(hybrid_cloud)
        }
        return costs
```

##### 30.4.6.2 成本优化#

```
python复制class CostOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, hybrid_cloud):
        # 优化混合云成本
        hybrid_cloud = self.optimize_private_cloud_cost(hybrid_cloud)
        hybrid_cloud = self.optimize_public_cloud_cost(hybrid_cloud)
        hybrid_cloud = self.optimize_integration_cost(hybrid_cloud)
        return hybrid_cloud
```

```
class CostOptimizer:
    def __init__(self):
        pass
    
    def optimize(self, hybrid_cloud):
        # 优化混合云成本
        hybrid_cloud = self.optimize_private_cloud_cost(hybrid_cloud)
        hybrid_cloud = self.optimize_public_cloud_cost(hybrid_cloud)
        hybrid_cloud = self.optimize_integration_cost(hybrid_cloud)
        return hybrid_cloud
```

#### 30.4.7 混合云监控#

##### 30.4.7.1 基础设施监控#

```
python复制class InfrastructureMonitor:
    def __init__(self):
        pass
    
    def monitor(self, hybrid_cloud):
        # 监控混合云基础设施
        metrics = {
            'private_cloud_metrics': self.monitor_private_cloud(hybrid_cloud),
            'public_cloud_metrics': self.monitor_public_cloud(hybrid_cloud),
            'integration_metrics': self.monitor_integration(hybrid_cloud)
        }
        return metrics
```

```
class InfrastructureMonitor:
    def __init__(self):
        pass
    
    def monitor(self, hybrid_cloud):
        # 监控混合云基础设施
        metrics = {
            'private_cloud_metrics': self.monitor_private_cloud(hybrid_cloud),
            'public_cloud_metrics': self.monitor_public_cloud(hybrid_cloud),
            'integration_metrics': self.monitor_integration(hybrid_cloud)
        }
        return metrics
```

##### 30.4.7.2 应用监控#

```
python复制class ApplicationMonitor:
    def __init__(self):
        pass
    
    def monitor(self, hybrid_cloud):
        # 监控混合云应用
        metrics = {
            'response_time': self.monitor_response_time(hybrid_cloud),
            'throughput': self.monitor_throughput(hybrid_cloud),
            'errors': self.monitor_errors(hybrid_cloud)
        }
        return metrics
```

```
class ApplicationMonitor:
    def __init__(self):
        pass
    
    def monitor(self, hybrid_cloud):
        # 监控混合云应用
        metrics = {
            'response_time': self.monitor_response_time(hybrid_cloud),
            'throughput': self.monitor_throughput(hybrid_cloud),
            'errors': self.monitor_errors(hybrid_cloud)
        }
        return metrics
```

#### 30.4.8 混合云部署案例#

##### 30.4.8.1 金融行业部署#

```
bash复制Financial Industry Deployment(
  private_cloud=Core Banking,
  public_cloud=Customer Portal,
  integration=Secure Integration,
  compliance=PCI DSS
)
```

```
Financial Industry Deployment(
  private_cloud=Core Banking,
  public_cloud=Customer Portal,
  integration=Secure Integration,
  compliance=PCI DSS
)
```

##### 30.4.8.2 零售行业部署#

```
bash复制Retail Industry Deployment(
  private_cloud=Inventory Management,
  public_cloud=E-commerce,
  integration=Real-time Integration,
  compliance=GDPR
)
```

```
Retail Industry Deployment(
  private_cloud=Inventory Management,
  public_cloud=E-commerce,
  integration=Real-time Integration,
  compliance=GDPR
)
```

##### 30.4.8.3 医疗行业部署#

```
bash复制Healthcare Industry Deployment(
  private_cloud=Patient Records,
  public_cloud=Telemedicine,
  integration=Secure Integration,
  compliance=HIPAA
)
```

```
Healthcare Industry Deployment(
  private_cloud=Patient Records,
  public_cloud=Telemedicine,
  integration=Secure Integration,
  compliance=HIPAA
)
```

#### 30.4.9 混合云迁移#

##### 30.4.9.1 迁移策略#

```
bash复制Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

```
Migration Strategies(
  rehost=Lift-and-shift,
  replatform=Replatform,
  refactor=Refactor,
  retire=Retire,
  retain=Retain
)
```

##### 30.4.9.2 迁移工具#

```
bash复制Migration Tools(
  aws=AWS Migration Hub,
  azure=Azure Migrate,
  gcp=GCP Migration Center,
  third_party=Third-party Migration Tools
)
```

```
Migration Tools(
  aws=AWS Migration Hub,
  azure=Azure Migrate,
  gcp=GCP Migration Center,
  third_party=Third-party Migration Tools
)
```

##### 30.4.9.3 迁移流程#

```
bash复制Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

```
Migration Process(
  assessment=Assessment,
  planning=Planning,
  migration=Migration,
  validation=Validation,
  cutover=Cutover
)
```

#### 30.4.10 混合云最佳实践#

##### 30.4.10.1 架构设计#

```
bash复制Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

```
Architecture Best Practices(
  modularity=Modular Design,
  scalability=Elastic Scaling,
  availability=High Availability,
  security=Defense in Depth
)
```

##### 30.4.10.2 安全实践#

```
bash复制Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

```
Security Best Practices(
  least_privilege=Least Privilege,
  encryption=Encryption,
  monitoring=Continuous Monitoring,
  incident_response=Incident Response
)
```

##### 30.4.10.3 管理实践#

```
bash复制Management Best Practices(
  automation=Automation,
  orchestration=Orchestration,
  monitoring=Monitoring,
  optimization=Optimization
)
```

```
Management Best Practices(
  automation=Automation,
  orchestration=Orchestration,
  monitoring=Monitoring,
  optimization=Optimization
)
```

#### 30.4.11 混合云未来发展#

##### 30.4.11.1 多云管理#

```
bash复制Multi-cloud Management(
  unified_management=Unified Management,
  cost_optimization=Cost Optimization,
  security_management=Security Management,
  performance_management=Performance Management
)
```

```
Multi-cloud Management(
  unified_management=Unified Management,
  cost_optimization=Cost Optimization,
  security_management=Security Management,
  performance_management=Performance Management
)
```

##### 30.4.11.2 边缘计算#

```
bash复制Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

```
Edge Computing(
  edge_locations=Edge Locations,
  low_latency=Low Latency,
  real_time=Real-time Processing
)
```

##### 30.4.11.3 AI 集成#

```
bash复制AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

```
AI Integration(
  ml_services=ML Services,
  ai_platforms=AI Platforms,
  intelligent_applications=Intelligent Applications
)
```

#### 30.4.12 总结#

混合云部署是企业级 Claude Code 部署的重要选择，结合了私有云和公有云的优势。通过合理的架构设计、安全措施和成本优化，企业可以实现高效、安全、可靠的 Claude Code 部署。

随着多云管理、边缘计算和 AI 集成等技术的发展，混合云部署将变得更加灵活、高效和智能。企业应根据自身需求和情况，选择合适的混合云部署方案。

---

## 1 企业部署概述

**URL**: https://claudecode.tangshuang.net/course/30.1%20%E4%BC%81%E4%B8%9A%E9%83%A8%E7%BD%B2%E6%A6%82%E8%BF%B0

#### 30.1.1 为什么需要企业级部署#

随着 AI 编程工具在企业中的广泛应用，从个人使用转向团队协作和企业级部署成为必然趋势。企业级部署不仅仅是简单的工具安装，更涉及安全性、合规性、可管理性和成本控制等多个维度的考量。

##### 企业级部署的核心需求#

True. 安全性：保护企业代码和敏感数据不被泄露
True. 合规性：满足行业法规和企业内部安全政策
True. 可管理性：集中管理用户、权限和配置
True. 成本控制：监控和控制 AI 使用成本
True. 可扩展性：支持大规模团队使用
True. 可观测性：全面监控使用情况和性能指标

##### 个人使用与企业部署的区别#

#### 30.1.2 企业部署架构#

##### 整体架构图#

┌─────────────────────────────────────────────────────────┐
│                  企业用户层                             │
│  (开发者、项目经理、QA工程师等)                        │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                  访问层                               │
│  (企业代理、防火墙、负载均衡)                          │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                  应用层                               │
│  (Claude Code 客户端、IDE 插件、Web 界面)            │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                  服务层                               │
│  (LLM 网关、认证服务、配置管理)                       │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                  模型层                               │
│  (Anthropic API、Amazon Bedrock、Google Vertex AI)      │
└─────────────────────────────────────────────────────────┘

##### 部署模式#

###### 1. 直接提供商访问模式

```
bash复制bash

# 配置示例
export ANTHROPIC_API_KEY=sk-ant-xxx
export CLAUDE_CODE_MODEL=claude-sonnet-4-20250514

```> **适用场景**：
> - 小型团队
> - 快速原型开发
> - 无复杂网络限制

> **优势**：
> - 配置简单
> - 直接访问最新功能
> - 最少的中间层

> **劣势**：
> - 缺乏集中管理
> - 难以控制成本
> - 有限的审计能力

#### 2. 企业代理模式

# 配置示例
export ANTHROPIC_API_KEY=sk-ant-xxx
export HTTPS_PROXY=https://proxy.company.com:8080
export HTTP_PROXY=http://proxy.company.com:8080
```

```
bash

# 配置示例
export ANTHROPIC_API_KEY=sk-ant-xxx
export CLAUDE_CODE_MODEL=claude-sonnet-4-20250514

```> **适用场景**：
> - 小型团队
> - 快速原型开发
> - 无复杂网络限制

> **优势**：
> - 配置简单
> - 直接访问最新功能
> - 最少的中间层

> **劣势**：
> - 缺乏集中管理
> - 难以控制成本
> - 有限的审计能力

#### 2. 企业代理模式

# 配置示例
export ANTHROPIC_API_KEY=sk-ant-xxx
export HTTPS_PROXY=https://proxy.company.com:8080
export HTTP_PROXY=http://proxy.company.com:8080
```

- 有企业代理要求
- 需要流量监控
- 合规性要求高

- 符合企业网络策略
- 集中流量监控
- 易于审计

- 增加网络延迟
- 代理故障影响使用
- 配置复杂度增加

###### 3. LLM 网关模式

```
bash复制```bash

# 配置示例
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=company-token

```> **适用场景**：
> - 大型组织
> - 需要集中管理
> - 多团队使用

> **优势**：
> - 统一身份管理
> - 集中成本控制
> - 完整审计日志
> - 灵活的模型路由

> **劣势**：
> - 需要维护网关
> - 增加系统复杂度
> - 可能引入延迟

#### 4. 混合模式

# 配置示例
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=company-token
export HTTPS_PROXY=https://proxy.company.com:8080
```

```
```bash

# 配置示例
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=company-token

```> **适用场景**：
> - 大型组织
> - 需要集中管理
> - 多团队使用

> **优势**：
> - 统一身份管理
> - 集中成本控制
> - 完整审计日志
> - 灵活的模型路由

> **劣势**：
> - 需要维护网关
> - 增加系统复杂度
> - 可能引入延迟

#### 4. 混合模式

# 配置示例
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=company-token
export HTTPS_PROXY=https://proxy.company.com:8080
```

- 复杂的企业环境
- 需要多层安全控制
- 大规模部署

- 最大化的安全控制
- 灵活的配置选项
- 满足多种合规要求

- 最复杂的配置
- 最高的维护成本
- 可能的性能影响

#### 30.1.3 部署决策框架#

##### 决策因素#

###### 1. 组织规模

```
bash复制→ 直接提供商访问 或 企业代理模式

中型团队 (10-100 人)
→ 企业代理模式 或 LLM 网关模式

大型组织 (> 100 人)
→ LLM 网关模式 或 混合模式
```

```
→ 直接提供商访问 或 企业代理模式

中型团队 (10-100 人)
→ 企业代理模式 或 LLM 网关模式

大型组织 (> 100 人)
→ LLM 网关模式 或 混合模式
```

###### 2. 安全要求

低安全要求
→ 直接提供商访问
中等安全要求
→ 企业代理模式
高安全要求
→ LLM 网关模式
极高安全要求
→ 混合模式

```
bash复制#### 3. 合规需求
```

```
#### 3. 合规需求
```

无特殊合规要求
→ 直接提供商访问

基础合规要求
→ 企业代理模式

行业合规要求 (金融、医疗等)
→ LLM 网关模式

严格合规要求 (政府、国防等)
→ 混合模式

```
bash复制#### 4. 成本控制需求

个人或团队付费
→ 直接提供商访问
需要成本监控
→ 企业代理模式
需要预算控制
→ LLM 网关模式
需要精细成本管理
→ 混合模式
```

```
#### 4. 成本控制需求

个人或团队付费
→ 直接提供商访问
需要成本监控
→ 企业代理模式
需要预算控制
→ LLM 网关模式
需要精细成本管理
→ 混合模式
```

##### 决策矩阵#

#### 30.1.4 部署前准备#

##### 1. 需求评估#

```
python复制python

class DeploymentAssessment:
    """部署评估工具"""

    def __init__(self):
        self.requirements = {
            'team_size': 0,
            'security_level': 'low',
            'compliance_requirements': [],
            'cost_control': 'low',
            'network_restrictions': False,
            'existing_infrastructure': []
        }

    def assess(self, answers: Dict[str, Any]) -> DeploymentRecommendation:
        """评估部署需求"""
        self.requirements.update(answers)

        # 计算复杂度分数
        complexity_score = self._calculate_complexity()

        # 生成推荐
        recommendation = self._generate_recommendation(complexity_score)

        return recommendation

    def _calculate_complexity(self) -> int:
        """计算复杂度分数"""
        score = 0

        # 团队规模
        if self.requirements['team_size'] > 100:
            score += 3
        elif self.requirements['team_size'] > 10:
            score += 2
        else:
            score += 1

        # 安全级别
        security_levels = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
        score += security_levels.get(self.requirements['security_level'], 1)

        # 合规要求
        score += len(self.requirements['compliance_requirements'])

        # 成本控制
        cost_levels = {'low': 1, 'medium': 2, 'high': 3}
        score += cost_levels.get(self.requirements['cost_control'], 1)

        # 网络限制
        if self.requirements['network_restrictions']:
            score += 2

        return score

    def _generate_recommendation(self,
                               score: int) -> DeploymentRecommendation:
        """生成部署推荐"""
        if score <= 5:
            mode = 'direct'
            reason = "简单的部署方案适合您的需求"
        elif score <= 10:
            mode = 'proxy'
            reason = "企业代理模式可以满足您的安全和合规需求"
        elif score <= 15:
            mode = 'gateway'
            reason = "LLM 网关模式提供完整的企业级功能"
        else:
            mode = 'hybrid'
            reason = "混合模式可以满足您复杂的企业需求"

        return DeploymentRecommendation(
            mode=mode,
            reason=reason,
            complexity_score=score,
            next_steps=self._get_next_steps(mode)
        )

    def _get_next_steps(self, mode: str) -> List[str]:
        """获取下一步行动"""
        steps = {
            'direct': [
                "获取 Anthropic API 密钥",
                "安装 Claude Code",
                "配置基本设置"
            ],
            'proxy': [
                "配置企业代理",
                "获取 API 密钥",
                "配置代理环境变量",
                "测试连接"
            ],
            'gateway': [
                "评估 LLM 网关解决方案",
                "部署网关服务",
                "配置身份验证",
                "设置监控和日志"
            ],
            'hybrid': [
                "设计完整架构",
                "部署所有组件",
                "配置安全策略",
                "建立监控体系"
            ]
        }
        return steps.get(mode, [])

```### 2. 技术准备清单

#### 基础设施

> - [ ] 服务器资源（CPU、内存、存储）
> - [ ] 网络带宽评估
> - [ ] 负载均衡配置
> - [ ] 备份和恢复方案

#### 安全配置

> - [ ] 代理服务器配置
> - [ ] 防火墙规则设置
> - [ ] SSL/TLS 证书
> - [ ] mTLS 证书（如需要）
> - [ ] 自定义 CA 证书

#### 身份和访问管理

> - [ ] 用户目录集成 (LDAP/AD)
> - [ ] 单点登录 (SSO) 配置
> - [ ] 权限模型设计
> - [ ] 审计日志配置

#### 监控和日志

> - [ ] 监控系统部署
> - [ ] 日志聚合配置
> - [ ] 告警规则设置
> - [ ] 仪表板配置

#### 合规和审计

> - [ ] 数据分类策略
> - [ ] 审计日志保留策略
> - [ ] 合规报告生成
> - [ ] 定期安全审计

## 30.1.5 部署最佳实践

### 1. 渐进式部署

class ProgressiveDeployment:
"""渐进式部署策略"""
def __init__(self):
self.phases = [
'pilot',
'limited_rollout',
'full_rollout'
]
def deploy(self, config: DeploymentConfig) -> DeploymentResult:
"""执行渐进式部署"""
results = []
for phase in self.phases:
result = self._deploy_phase(phase, config)
results.append(result)
# 检查是否继续
if not result.success:
self._rollback(results)
return DeploymentResult(
success=False,
phase=phase,
error="Deployment failed, rolled back"
)
return DeploymentResult(
success=True,
phases=results
)
def _deploy_phase(self, phase: str,
config: DeploymentConfig) -> PhaseResult:
"""部署单个阶段"""
if phase == 'pilot':
return self._pilot_phase(config)
elif phase == 'limited_rollout':
return self._limited_rollout_phase(config)
elif phase == 'full_rollout':
return self._full_rollout_phase(config)
def _pilot_phase(self, config: DeploymentConfig) -> PhaseResult:
"""试点阶段"""
# 选择试点用户
pilot_users = self._select_pilot_users(config)
# 部署到试点用户
for user in pilot_users:
self._deploy_to_user(user, config)
# 收集反馈
feedback = self._collect_feedback(pilot_users)
# 评估结果
success = self._evaluate_feedback(feedback)
return PhaseResult(
phase='pilot',
users=pilot_users,
feedback=feedback,
success=success
)
def _limited_rollout_phase(self,
config: DeploymentConfig) -> PhaseResult:
"""有限推广阶段"""
# 扩大到部分团队
teams = self._select_teams(config)
# 部署到团队
for team in teams:
self._deploy_to_team(team, config)
# 监控性能
metrics = self._monitor_performance(teams)
# 评估结果
success = self._evaluate_metrics(metrics)
return PhaseResult(
phase='limited_rollout',
teams=teams,
metrics=metrics,
success=success
)
def _full_rollout_phase(self,
config: DeploymentConfig) -> PhaseResult:
"""全面推广阶段"""
# 部署到所有用户
all_users = self._get_all_users(config)
for user in all_users:
self._deploy_to_user(user, config)
# 全面监控
metrics = self._monitor_all(all_users)
return PhaseResult(
phase='full_rollout',
users=all_users,
metrics=metrics,
success=True
)
```

```
python

class DeploymentAssessment:
    """部署评估工具"""

    def __init__(self):
        self.requirements = {
            'team_size': 0,
            'security_level': 'low',
            'compliance_requirements': [],
            'cost_control': 'low',
            'network_restrictions': False,
            'existing_infrastructure': []
        }

    def assess(self, answers: Dict[str, Any]) -> DeploymentRecommendation:
        """评估部署需求"""
        self.requirements.update(answers)

        # 计算复杂度分数
        complexity_score = self._calculate_complexity()

        # 生成推荐
        recommendation = self._generate_recommendation(complexity_score)

        return recommendation

    def _calculate_complexity(self) -> int:
        """计算复杂度分数"""
        score = 0

        # 团队规模
        if self.requirements['team_size'] > 100:
            score += 3
        elif self.requirements['team_size'] > 10:
            score += 2
        else:
            score += 1

        # 安全级别
        security_levels = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
        score += security_levels.get(self.requirements['security_level'], 1)

        # 合规要求
        score += len(self.requirements['compliance_requirements'])

        # 成本控制
        cost_levels = {'low': 1, 'medium': 2, 'high': 3}
        score += cost_levels.get(self.requirements['cost_control'], 1)

        # 网络限制
        if self.requirements['network_restrictions']:
            score += 2

        return score

    def _generate_recommendation(self,
                               score: int) -> DeploymentRecommendation:
        """生成部署推荐"""
        if score <= 5:
            mode = 'direct'
            reason = "简单的部署方案适合您的需求"
        elif score <= 10:
            mode = 'proxy'
            reason = "企业代理模式可以满足您的安全和合规需求"
        elif score <= 15:
            mode = 'gateway'
            reason = "LLM 网关模式提供完整的企业级功能"
        else:
            mode = 'hybrid'
            reason = "混合模式可以满足您复杂的企业需求"

        return DeploymentRecommendation(
            mode=mode,
            reason=reason,
            complexity_score=score,
            next_steps=self._get_next_steps(mode)
        )

    def _get_next_steps(self, mode: str) -> List[str]:
        """获取下一步行动"""
        steps = {
            'direct': [
                "获取 Anthropic API 密钥",
                "安装 Claude Code",
                "配置基本设置"
            ],
            'proxy': [
                "配置企业代理",
                "获取 API 密钥",
                "配置代理环境变量",
                "测试连接"
            ],
            'gateway': [
                "评估 LLM 网关解决方案",
                "部署网关服务",
                "配置身份验证",
                "设置监控和日志"
            ],
            'hybrid': [
                "设计完整架构",
                "部署所有组件",
                "配置安全策略",
                "建立监控体系"
            ]
        }
        return steps.get(mode, [])

```### 2. 技术准备清单

#### 基础设施

> - [ ] 服务器资源（CPU、内存、存储）
> - [ ] 网络带宽评估
> - [ ] 负载均衡配置
> - [ ] 备份和恢复方案

#### 安全配置

> - [ ] 代理服务器配置
> - [ ] 防火墙规则设置
> - [ ] SSL/TLS 证书
> - [ ] mTLS 证书（如需要）
> - [ ] 自定义 CA 证书

#### 身份和访问管理

> - [ ] 用户目录集成 (LDAP/AD)
> - [ ] 单点登录 (SSO) 配置
> - [ ] 权限模型设计
> - [ ] 审计日志配置

#### 监控和日志

> - [ ] 监控系统部署
> - [ ] 日志聚合配置
> - [ ] 告警规则设置
> - [ ] 仪表板配置

#### 合规和审计

> - [ ] 数据分类策略
> - [ ] 审计日志保留策略
> - [ ] 合规报告生成
> - [ ] 定期安全审计

## 30.1.5 部署最佳实践

### 1. 渐进式部署

class ProgressiveDeployment:
"""渐进式部署策略"""
def __init__(self):
self.phases = [
'pilot',
'limited_rollout',
'full_rollout'
]
def deploy(self, config: DeploymentConfig) -> DeploymentResult:
"""执行渐进式部署"""
results = []
for phase in self.phases:
result = self._deploy_phase(phase, config)
results.append(result)
# 检查是否继续
if not result.success:
self._rollback(results)
return DeploymentResult(
success=False,
phase=phase,
error="Deployment failed, rolled back"
)
return DeploymentResult(
success=True,
phases=results
)
def _deploy_phase(self, phase: str,
config: DeploymentConfig) -> PhaseResult:
"""部署单个阶段"""
if phase == 'pilot':
return self._pilot_phase(config)
elif phase == 'limited_rollout':
return self._limited_rollout_phase(config)
elif phase == 'full_rollout':
return self._full_rollout_phase(config)
def _pilot_phase(self, config: DeploymentConfig) -> PhaseResult:
"""试点阶段"""
# 选择试点用户
pilot_users = self._select_pilot_users(config)
# 部署到试点用户
for user in pilot_users:
self._deploy_to_user(user, config)
# 收集反馈
feedback = self._collect_feedback(pilot_users)
# 评估结果
success = self._evaluate_feedback(feedback)
return PhaseResult(
phase='pilot',
users=pilot_users,
feedback=feedback,
success=success
)
def _limited_rollout_phase(self,
config: DeploymentConfig) -> PhaseResult:
"""有限推广阶段"""
# 扩大到部分团队
teams = self._select_teams(config)
# 部署到团队
for team in teams:
self._deploy_to_team(team, config)
# 监控性能
metrics = self._monitor_performance(teams)
# 评估结果
success = self._evaluate_metrics(metrics)
return PhaseResult(
phase='limited_rollout',
teams=teams,
metrics=metrics,
success=success
)
def _full_rollout_phase(self,
config: DeploymentConfig) -> PhaseResult:
"""全面推广阶段"""
# 部署到所有用户
all_users = self._get_all_users(config)
for user in all_users:
self._deploy_to_user(user, config)
# 全面监控
metrics = self._monitor_all(all_users)
return PhaseResult(
phase='full_rollout',
users=all_users,
metrics=metrics,
success=True
)
```

##### 2. 文档和培训#

###### 文档要求

True. 部署文档

- 安装步骤
- 配置说明
- 故障排除指南

True. 用户文档

- 快速入门指南
- 功能使用说明
- 最佳实践

True. 管理文档

- 管理员指南
- 监控和告警
- 维护流程

###### 培训计划

True. 管理员培训

- 系统架构
- 配置管理
- 故障处理

True. 用户培训

- 基础功能
- 高级特性
- 安全实践

True. 持续培训

- 新功能培训
- 最佳实践分享
- 问题解决工作坊

##### 3. 监控和维护#

###### 关键指标

```
python复制```python

class DeploymentMetrics:
    """部署指标"""

    def __init__(self):
        self.metrics = {
            'user_adoption': 0.0,
            'usage_frequency': 0.0,
            'error_rate': 0.0,
            'response_time': 0.0,
            'cost_per_user': 0.0,
            'satisfaction_score': 0.0
        }

    def collect(self) -> Dict[str, float]:
        """收集指标"""
        # 用户采用率
        self.metrics['user_adoption'] = self._calculate_adoption()

        # 使用频率
        self.metrics['usage_frequency'] = self._calculate_frequency()

        # 错误率
        self.metrics['error_rate'] = self._calculate_error_rate()

        # 响应时间
        self.metrics['response_time'] = self._calculate_response_time()

        # 每用户成本
        self.metrics['cost_per_user'] = self._calculate_cost_per_user()

        # 满意度评分
        self.metrics['satisfaction_score'] = self._calculate_satisfaction()

        return self.metrics

    def _calculate_adoption(self) -> float:
        """计算采用率"""
        total_users = self._get_total_users()
        active_users = self._get_active_users()
        return active_users / total_users if total_users > 0 else 0.0

    def _calculate_frequency(self) -> float:
        """计算使用频率"""
        total_requests = self._get_total_requests()
        active_users = self._get_active_users()
        return total_requests / active_users if active_users > 0 else 0.0

    def _calculate_error_rate(self) -> float:
        """计算错误率"""
        total_requests = self._get_total_requests()
        failed_requests = self._get_failed_requests()
        return failed_requests / total_requests if total_requests > 0 else 0.0

    def _calculate_response_time(self) -> float:
        """计算平均响应时间"""
        total_time = self._get_total_response_time()
        total_requests = self._get_total_requests()
        return total_time / total_requests if total_requests > 0 else 0.0

    def _calculate_cost_per_user(self) -> float:
        """计算每用户成本"""
        total_cost = self._get_total_cost()
        active_users = self._get_active_users()
        return total_cost / active_users if active_users > 0 else 0.0

    def _calculate_satisfaction(self) -> float:
        """计算满意度评分"""
        feedbacks = self._get_user_feedbacks()
        if not feedbacks:
            return 0.0
        return sum(f.score for f in feedbacks) / len(feedbacks)
```

```
```python

class DeploymentMetrics:
    """部署指标"""

    def __init__(self):
        self.metrics = {
            'user_adoption': 0.0,
            'usage_frequency': 0.0,
            'error_rate': 0.0,
            'response_time': 0.0,
            'cost_per_user': 0.0,
            'satisfaction_score': 0.0
        }

    def collect(self) -> Dict[str, float]:
        """收集指标"""
        # 用户采用率
        self.metrics['user_adoption'] = self._calculate_adoption()

        # 使用频率
        self.metrics['usage_frequency'] = self._calculate_frequency()

        # 错误率
        self.metrics['error_rate'] = self._calculate_error_rate()

        # 响应时间
        self.metrics['response_time'] = self._calculate_response_time()

        # 每用户成本
        self.metrics['cost_per_user'] = self._calculate_cost_per_user()

        # 满意度评分
        self.metrics['satisfaction_score'] = self._calculate_satisfaction()

        return self.metrics

    def _calculate_adoption(self) -> float:
        """计算采用率"""
        total_users = self._get_total_users()
        active_users = self._get_active_users()
        return active_users / total_users if total_users > 0 else 0.0

    def _calculate_frequency(self) -> float:
        """计算使用频率"""
        total_requests = self._get_total_requests()
        active_users = self._get_active_users()
        return total_requests / active_users if active_users > 0 else 0.0

    def _calculate_error_rate(self) -> float:
        """计算错误率"""
        total_requests = self._get_total_requests()
        failed_requests = self._get_failed_requests()
        return failed_requests / total_requests if total_requests > 0 else 0.0

    def _calculate_response_time(self) -> float:
        """计算平均响应时间"""
        total_time = self._get_total_response_time()
        total_requests = self._get_total_requests()
        return total_time / total_requests if total_requests > 0 else 0.0

    def _calculate_cost_per_user(self) -> float:
        """计算每用户成本"""
        total_cost = self._get_total_cost()
        active_users = self._get_active_users()
        return total_cost / active_users if active_users > 0 else 0.0

    def _calculate_satisfaction(self) -> float:
        """计算满意度评分"""
        feedbacks = self._get_user_feedbacks()
        if not feedbacks:
            return 0.0
        return sum(f.score for f in feedbacks) / len(feedbacks)
```

通过全面的部署前准备和遵循最佳实践，可以确保 Claude Code 在企业环境中的成功部署和长期稳定运行。

---

## 2 部署决策与规划

**URL**: https://claudecode.tangshuang.net/course/30.2%20%E9%83%A8%E7%BD%B2%E5%86%B3%E7%AD%96%E4%B8%8E%E8%A7%84%E5%88%92

#### 30.2.1 需求分析#

##### 业务需求评估#

###### 1. 使用场景分析

class UseCaseAnalyzer:
"""使用场景分析器"""

def init(self):
self.use_cases = {
'code_generation': {
'description': '生成新代码',
'frequency': 'high',
'complexity': 'medium',
'cost_impact': 'high'
},
'code_review': {
'description': '代码审查',
'frequency': 'medium',
'complexity': 'low',
'cost_impact': 'medium'
},
'debugging': {
'description': '调试和错误修复',
'frequency': 'high',
'complexity': 'high',
'cost_impact': 'medium'
},
'documentation': {
'description': '文档生成',
'frequency': 'low',
'complexity': 'low',
'cost_impact': 'low'
},
'refactoring': {
'description': '代码重构',
'frequency': 'medium',
'complexity': 'high',
'cost_impact': 'high'

def analyze(self, team_data: Dict[str, Any]) -> UseCaseAnalysis:
"""分析使用场景"""
analysis = UseCaseAnalysis()

### 分析每个使用场景

for use_case, metadata in self.use_cases.items():
relevance = self._calculate_relevance(use_case, team_data)
analysis.add_use_case(use_case, relevance, metadata)

### 识别主要使用场景

analysis.primary_use_cases = self._identify_primary_use_cases(analysis)

### 估算成本影响

analysis.estimated_cost = self._estimate_cost(analysis)

return analysis

def _calculate_relevance(self, use_case: str,
team_data: Dict) -> float:
"""计算使用场景相关性"""
relevance = 0.0

### 团队规模影响

team_size = team_data.get('team_size', 0)
if use_case in ['code_generation', 'debugging']:
relevance += min(team_size / 100, 1.0) * 0.4

### 项目类型影响

project_type = team_data.get('project_type', '')
if use_case == 'code_generation' and 'new' in project_type:
relevance += 0.3
elif use_case == 'refactoring' and 'legacy' in project_type:
relevance += 0.3

### 技术栈影响

tech_stack = team_data.get('tech_stack', [])
if use_case == 'debugging' and len(tech_stack) > 3:
relevance += 0.2

return min(relevance, 1.0)

def _identify_primary_use_cases(self,
analysis: UseCaseAnalysis) -> List[str]:
"""识别主要使用场景"""
sorted_cases = sorted(
analysis.use_cases.items(),
key=lambda x: x[1]['relevance'],
reverse=True
)
return [case[0] for case in sorted_cases[:3]]

def _estimate_cost(self,
analysis: UseCaseAnalysis) -> CostEstimate:
"""估算成本"""
total_cost = 0.0

for use_case, data in analysis.use_cases.items():
relevance = data['relevance']
cost_impact = self.use_cases[use_case]['cost_impact']

if cost_impact == 'high':
cost = relevance * 1000
elif cost_impact == 'medium':
cost = relevance * 500
else:
cost = relevance * 100

total_cost += cost

return CostEstimate(
monthly_cost=total_cost,
annual_cost=total_cost * 12,
cost_breakdown=analysis.use_cases
)

###### 2. 用户角色分析

```
bash复制python

class UserRoleAnalyzer:
    """用户角色分析器"""

    def __init__(self):
        self.roles = {
            'developer': {
                'usage_pattern': 'daily',
                'features': ['code_generation', 'debugging', 'refactoring'],
                'cost_multiplier': 1.0
            },
            'senior_developer': {
                'usage_pattern': 'daily',
                'features': ['code_generation', 'code_review', 'refactoring'],
                'cost_multiplier': 1.5
            },
            'tech_lead': {
                'usage_pattern': 'frequent',
                'features': ['code_review', 'documentation', 'architecture'],
                'cost_multiplier': 1.2
            },
            'qa_engineer': {
                'usage_pattern': 'moderate',
                'features': ['debugging', 'test_generation'],
                'cost_multiplier': 0.8
            },
            'project_manager': {
                'usage_pattern': 'occasional',
                'features': ['documentation', 'planning'],
                'cost_multiplier': 0.3
            }
        }

    def analyze(self, team_composition: Dict[str, int]) -> RoleAnalysis:
        """分析用户角色"""
        analysis = RoleAnalysis()

        total_users = sum(team_composition.values())

        for role, count in team_composition.items():
            if role in self.roles:
                role_data = self.roles[role]

                # 计算用户占比
                percentage = count / total_users if total_users > 0 else 0

                # 计算成本贡献
                cost_contribution = (
                    percentage *
                    role_data['cost_multiplier']
                )

                analysis.add_role(
                    role=role,
                    count=count,
                    percentage=percentage,
                    usage_pattern=role_data['usage_pattern'],
                    features=role_data['features'],
                    cost_contribution=cost_contribution
                )

        # 计算总体成本乘数
        analysis.total_cost_multiplier = sum(
            r['cost_contribution']
            for r in analysis.roles.values()
        )

        return analysis

### 技术需求评估

#### 1. 基础设施需求

class InfrastructureRequirements:
"""基础设施需求评估"""
def __init__(self):
self.requirements = {
'cpu': {'min': 2, 'recommended': 4},
'memory': {'min': 4, 'recommended': 8},
'storage': {'min': 20, 'recommended': 50},
'network': {'min': 10, 'recommended': 100}
}
def calculate(self, deployment_config: Dict) -> InfrastructureSpec:
"""计算基础设施需求"""
spec = InfrastructureSpec()
# 基础需求
base_users = deployment_config.get('base_users', 10)
spec.cpu = self._calculate_cpu(base_users)
spec.memory = self._calculate_memory(base_users)
spec.storage = self._calculate_storage(base_users)
spec.network = self._calculate_network(base_users)
# 考虑部署模式
mode = deployment_config.get('mode', 'direct')
if mode == 'gateway':
# 网关模式需要额外资源
spec.cpu *= 1.5
spec.memory *= 1.5
spec.storage *= 2.0
elif mode == 'hybrid':
# 混合模式需要更多资源
spec.cpu *= 2.0
spec.memory *= 2.0
spec.storage *= 3.0
# 高可用性需求
if deployment_config.get('high_availability', False):
spec.cpu *= 2.0
spec.memory *= 2.0
return spec
def _calculate_cpu(self, users: int) -> int:
"""计算 CPU 需求"""
base = self.requirements['cpu']['recommended']
return max(base, int(users / 10))
def _calculate_memory(self, users: int) -> int:
"""计算内存需求"""
base = self.requirements['memory']['recommended']
return max(base, int(users / 5))
def _calculate_storage(self, users: int) -> int:
"""计算存储需求"""
base = self.requirements['storage']['recommended']
return max(base, int(users * 2))
def _calculate_network(self, users: int) -> int:
"""计算网络带宽需求 (Mbps)"""
base = self.requirements['network']['recommended']
return max(base, int(users * 5))
```

```
python

class UserRoleAnalyzer:
    """用户角色分析器"""

    def __init__(self):
        self.roles = {
            'developer': {
                'usage_pattern': 'daily',
                'features': ['code_generation', 'debugging', 'refactoring'],
                'cost_multiplier': 1.0
            },
            'senior_developer': {
                'usage_pattern': 'daily',
                'features': ['code_generation', 'code_review', 'refactoring'],
                'cost_multiplier': 1.5
            },
            'tech_lead': {
                'usage_pattern': 'frequent',
                'features': ['code_review', 'documentation', 'architecture'],
                'cost_multiplier': 1.2
            },
            'qa_engineer': {
                'usage_pattern': 'moderate',
                'features': ['debugging', 'test_generation'],
                'cost_multiplier': 0.8
            },
            'project_manager': {
                'usage_pattern': 'occasional',
                'features': ['documentation', 'planning'],
                'cost_multiplier': 0.3
            }
        }

    def analyze(self, team_composition: Dict[str, int]) -> RoleAnalysis:
        """分析用户角色"""
        analysis = RoleAnalysis()

        total_users = sum(team_composition.values())

        for role, count in team_composition.items():
            if role in self.roles:
                role_data = self.roles[role]

                # 计算用户占比
                percentage = count / total_users if total_users > 0 else 0

                # 计算成本贡献
                cost_contribution = (
                    percentage *
                    role_data['cost_multiplier']
                )

                analysis.add_role(
                    role=role,
                    count=count,
                    percentage=percentage,
                    usage_pattern=role_data['usage_pattern'],
                    features=role_data['features'],
                    cost_contribution=cost_contribution
                )

        # 计算总体成本乘数
        analysis.total_cost_multiplier = sum(
            r['cost_contribution']
            for r in analysis.roles.values()
        )

        return analysis

### 技术需求评估

#### 1. 基础设施需求

class InfrastructureRequirements:
"""基础设施需求评估"""
def __init__(self):
self.requirements = {
'cpu': {'min': 2, 'recommended': 4},
'memory': {'min': 4, 'recommended': 8},
'storage': {'min': 20, 'recommended': 50},
'network': {'min': 10, 'recommended': 100}
}
def calculate(self, deployment_config: Dict) -> InfrastructureSpec:
"""计算基础设施需求"""
spec = InfrastructureSpec()
# 基础需求
base_users = deployment_config.get('base_users', 10)
spec.cpu = self._calculate_cpu(base_users)
spec.memory = self._calculate_memory(base_users)
spec.storage = self._calculate_storage(base_users)
spec.network = self._calculate_network(base_users)
# 考虑部署模式
mode = deployment_config.get('mode', 'direct')
if mode == 'gateway':
# 网关模式需要额外资源
spec.cpu *= 1.5
spec.memory *= 1.5
spec.storage *= 2.0
elif mode == 'hybrid':
# 混合模式需要更多资源
spec.cpu *= 2.0
spec.memory *= 2.0
spec.storage *= 3.0
# 高可用性需求
if deployment_config.get('high_availability', False):
spec.cpu *= 2.0
spec.memory *= 2.0
return spec
def _calculate_cpu(self, users: int) -> int:
"""计算 CPU 需求"""
base = self.requirements['cpu']['recommended']
return max(base, int(users / 10))
def _calculate_memory(self, users: int) -> int:
"""计算内存需求"""
base = self.requirements['memory']['recommended']
return max(base, int(users / 5))
def _calculate_storage(self, users: int) -> int:
"""计算存储需求"""
base = self.requirements['storage']['recommended']
return max(base, int(users * 2))
def _calculate_network(self, users: int) -> int:
"""计算网络带宽需求 (Mbps)"""
base = self.requirements['network']['recommended']
return max(base, int(users * 5))
```

###### 2. 网络需求评估

```
bash复制python

class NetworkRequirements:
    """网络需求评估"""

    def __init__(self):
        self.bandwidth_requirements = {
            'low_usage': 1,      # Mbps
            'medium_usage': 10,    # Mbps
            'high_usage': 50,      # Mbps
            'enterprise': 100       # Mbps
        }

    def assess(self, deployment_data: Dict) -> NetworkAssessment:
        """评估网络需求"""
        assessment = NetworkAssessment()

        # 评估带宽需求
        assessment.bandwidth = self._assess_bandwidth(deployment_data)

        # 评估延迟要求
        assessment.latency_requirement = self._assess_latency(deployment_data)

        # 评估可靠性要求
        assessment.reliability_requirement = self._assess_reliability(deployment_data)

        # 评估安全要求
        assessment.security_requirements = self._assess_security(deployment_data)

        return assessment

    def _assess_bandwidth(self, data: Dict) -> BandwidthRequirement:
        """评估带宽需求"""
        users = data.get('users', 10)
        usage_pattern = data.get('usage_pattern', 'medium')

        if users < 10:
            level = 'low_usage'
        elif users < 50:
            level = 'medium_usage'
        elif users < 200:
            level = 'high_usage'
        else:
            level = 'enterprise'

        base_bandwidth = self.bandwidth_requirements[level]

        # 根据使用模式调整
        if usage_pattern == 'high':
            base_bandwidth *= 2
        elif usage_pattern == 'low':
            base_bandwidth *= 0.5

        return BandwidthRequirement(
            level=level,
            required_bandwidth=base_bandwidth,
            recommended_bandwidth=base_bandwidth * 1.5
        )

    def _assess_latency(self, data: Dict) -> LatencyRequirement:
        """评估延迟要求"""
        use_cases = data.get('use_cases', [])

        if 'real_time' in use_cases:
            return LatencyRequirement(
                level='critical',
                max_latency=100,  # ms
                recommended_latency=50
            )
        elif 'interactive' in use_cases:
            return LatencyRequirement(
                level='high',
                max_latency=500,
                recommended_latency=200
            )
        else:
            return LatencyRequirement(
                level='normal',
                max_latency=2000,
                recommended_latency=1000
            )

    def _assess_reliability(self, data: Dict) -> ReliabilityRequirement:
        """评估可靠性要求"""
        criticality = data.get('criticality', 'normal')

        if criticality == 'critical':
            return ReliabilityRequirement(
                uptime_target=99.99,
                redundancy_required=True,
                failover_required=True
            )
        elif criticality == 'high':
            return ReliabilityRequirement(
                uptime_target=99.9,
                redundancy_required=True,
                failover_required=False
            )
        else:
            return ReliabilityRequirement(
                uptime_target=99.0,
                redundancy_required=False,
                failover_required=False
            )

    def _assess_security(self, data: Dict) -> SecurityRequirements:
        """评估安全要求"""
        security_level = data.get('security_level', 'medium')

        requirements = SecurityRequirements()

        if security_level == 'low':
            requirements.encryption = 'TLS 1.2'
            requirements.authentication = 'API Key'
            requirements.audit_logging = False
        elif security_level == 'medium':
            requirements.encryption = 'TLS 1.3'
            requirements.authentication = 'OAuth 2.0'
            requirements.audit_logging = True
        elif security_level == 'high':
            requirements.encryption = 'TLS 1.3 + mTLS'
            requirements.authentication = 'SSO + MFA'
            requirements.audit_logging = True
            requirements.data_loss_prevention = True
        else:  # critical
            requirements.encryption = 'TLS 1.3 + mTLS + End-to-End'
            requirements.authentication = 'SSO + MFA + Certificate'
            requirements.audit_logging = True
            requirements.data_loss_prevention = True
            requirements.network_isolation = True

        return requirements

## 30.2.2 成本分析

### 成本模型

class CostModel:
"""成本模型"""
def __init__(self):
self.pricing = {
'claude-sonnet-4': {
'input': 3.0,      # per 1M tokens
'output': 15.0      # per 1M tokens
},
'claude-opus-4': {
'input': 15.0,
'output': 75.0
}
}
def calculate(self, usage_data: Dict) -> CostBreakdown:
"""计算成本"""
breakdown = CostBreakdown()
# 计算每个使用场景的成本
for use_case, data in usage_data.items():
cost = self._calculate_use_case_cost(use_case, data)
breakdown.add_cost(use_case, cost)
# 计算总成本
breakdown.total_cost = sum(breakdown.costs.values())
# 计算每用户成本
total_users = usage_data.get('total_users', 1)
breakdown.cost_per_user = breakdown.total_cost / total_users
return breakdown
def _calculate_use_case_cost(self,
use_case: str,
data: Dict) -> UseCaseCost:
"""计算使用场景成本"""
model = data.get('model', 'claude-sonnet-4')
input_tokens = data.get('input_tokens', 0)
output_tokens = data.get('output_tokens', 0)
requests = data.get('requests', 0)
pricing = self.pricing.get(model, self.pricing['claude-sonnet-4'])
# 计算输入成本
input_cost = (input_tokens / 1_000_000) * pricing['input']
# 计算输出成本
output_cost = (output_tokens / 1_000_000) * pricing['output']
# 计算总成本
total_cost = input_cost + output_cost
# 计算每次请求成本
cost_per_request = total_cost / requests if requests > 0 else 0
return UseCaseCost(
model=model,
input_cost=input_cost,
output_cost=output_cost,
total_cost=total_cost,
cost_per_request=cost_per_request,
requests=requests
)
```

```
python

class NetworkRequirements:
    """网络需求评估"""

    def __init__(self):
        self.bandwidth_requirements = {
            'low_usage': 1,      # Mbps
            'medium_usage': 10,    # Mbps
            'high_usage': 50,      # Mbps
            'enterprise': 100       # Mbps
        }

    def assess(self, deployment_data: Dict) -> NetworkAssessment:
        """评估网络需求"""
        assessment = NetworkAssessment()

        # 评估带宽需求
        assessment.bandwidth = self._assess_bandwidth(deployment_data)

        # 评估延迟要求
        assessment.latency_requirement = self._assess_latency(deployment_data)

        # 评估可靠性要求
        assessment.reliability_requirement = self._assess_reliability(deployment_data)

        # 评估安全要求
        assessment.security_requirements = self._assess_security(deployment_data)

        return assessment

    def _assess_bandwidth(self, data: Dict) -> BandwidthRequirement:
        """评估带宽需求"""
        users = data.get('users', 10)
        usage_pattern = data.get('usage_pattern', 'medium')

        if users < 10:
            level = 'low_usage'
        elif users < 50:
            level = 'medium_usage'
        elif users < 200:
            level = 'high_usage'
        else:
            level = 'enterprise'

        base_bandwidth = self.bandwidth_requirements[level]

        # 根据使用模式调整
        if usage_pattern == 'high':
            base_bandwidth *= 2
        elif usage_pattern == 'low':
            base_bandwidth *= 0.5

        return BandwidthRequirement(
            level=level,
            required_bandwidth=base_bandwidth,
            recommended_bandwidth=base_bandwidth * 1.5
        )

    def _assess_latency(self, data: Dict) -> LatencyRequirement:
        """评估延迟要求"""
        use_cases = data.get('use_cases', [])

        if 'real_time' in use_cases:
            return LatencyRequirement(
                level='critical',
                max_latency=100,  # ms
                recommended_latency=50
            )
        elif 'interactive' in use_cases:
            return LatencyRequirement(
                level='high',
                max_latency=500,
                recommended_latency=200
            )
        else:
            return LatencyRequirement(
                level='normal',
                max_latency=2000,
                recommended_latency=1000
            )

    def _assess_reliability(self, data: Dict) -> ReliabilityRequirement:
        """评估可靠性要求"""
        criticality = data.get('criticality', 'normal')

        if criticality == 'critical':
            return ReliabilityRequirement(
                uptime_target=99.99,
                redundancy_required=True,
                failover_required=True
            )
        elif criticality == 'high':
            return ReliabilityRequirement(
                uptime_target=99.9,
                redundancy_required=True,
                failover_required=False
            )
        else:
            return ReliabilityRequirement(
                uptime_target=99.0,
                redundancy_required=False,
                failover_required=False
            )

    def _assess_security(self, data: Dict) -> SecurityRequirements:
        """评估安全要求"""
        security_level = data.get('security_level', 'medium')

        requirements = SecurityRequirements()

        if security_level == 'low':
            requirements.encryption = 'TLS 1.2'
            requirements.authentication = 'API Key'
            requirements.audit_logging = False
        elif security_level == 'medium':
            requirements.encryption = 'TLS 1.3'
            requirements.authentication = 'OAuth 2.0'
            requirements.audit_logging = True
        elif security_level == 'high':
            requirements.encryption = 'TLS 1.3 + mTLS'
            requirements.authentication = 'SSO + MFA'
            requirements.audit_logging = True
            requirements.data_loss_prevention = True
        else:  # critical
            requirements.encryption = 'TLS 1.3 + mTLS + End-to-End'
            requirements.authentication = 'SSO + MFA + Certificate'
            requirements.audit_logging = True
            requirements.data_loss_prevention = True
            requirements.network_isolation = True

        return requirements

## 30.2.2 成本分析

### 成本模型

class CostModel:
"""成本模型"""
def __init__(self):
self.pricing = {
'claude-sonnet-4': {
'input': 3.0,      # per 1M tokens
'output': 15.0      # per 1M tokens
},
'claude-opus-4': {
'input': 15.0,
'output': 75.0
}
}
def calculate(self, usage_data: Dict) -> CostBreakdown:
"""计算成本"""
breakdown = CostBreakdown()
# 计算每个使用场景的成本
for use_case, data in usage_data.items():
cost = self._calculate_use_case_cost(use_case, data)
breakdown.add_cost(use_case, cost)
# 计算总成本
breakdown.total_cost = sum(breakdown.costs.values())
# 计算每用户成本
total_users = usage_data.get('total_users', 1)
breakdown.cost_per_user = breakdown.total_cost / total_users
return breakdown
def _calculate_use_case_cost(self,
use_case: str,
data: Dict) -> UseCaseCost:
"""计算使用场景成本"""
model = data.get('model', 'claude-sonnet-4')
input_tokens = data.get('input_tokens', 0)
output_tokens = data.get('output_tokens', 0)
requests = data.get('requests', 0)
pricing = self.pricing.get(model, self.pricing['claude-sonnet-4'])
# 计算输入成本
input_cost = (input_tokens / 1_000_000) * pricing['input']
# 计算输出成本
output_cost = (output_tokens / 1_000_000) * pricing['output']
# 计算总成本
total_cost = input_cost + output_cost
# 计算每次请求成本
cost_per_request = total_cost / requests if requests > 0 else 0
return UseCaseCost(
model=model,
input_cost=input_cost,
output_cost=output_cost,
total_cost=total_cost,
cost_per_request=cost_per_request,
requests=requests
)
```

##### 成本优化策略#

```
bash复制python

class CostOptimizer:
    """成本优化器"""

    def __init__(self):
        self.optimization_strategies = [
            'model_selection',
            'prompt_optimization',
            'caching',
            'batching',
            'rate_limiting'
        ]

    def optimize(self, usage_data: Dict,
                budget: float) -> OptimizationPlan:
        """优化成本"""
        plan = OptimizationPlan()

        current_cost = self._calculate_current_cost(usage_data)

        if current_cost <= budget:
            plan.status = 'within_budget'
            return plan

        # 应用优化策略
        for strategy in self.optimization_strategies:
            strategy_result = self._apply_strategy(
                strategy,
                usage_data,
                budget
            )
            plan.add_strategy_result(strategy, strategy_result)

            # 检查是否达到预算
            if strategy_result.estimated_cost <= budget:
                plan.status = 'optimized'
                plan.selected_strategies = self.optimization_strategies[
                    :self.optimization_strategies.index(strategy) + 1
                ]
                break

        if plan.status == 'over_budget':
            plan.recommendations = self._generate_recommendations(
                usage_data,
                budget
            )

        return plan

    def _apply_strategy(self,
                      strategy: str,
                      usage_data: Dict,
                      budget: float) -> StrategyResult:
        """应用单个优化策略"""
        if strategy == 'model_selection':
            return self._optimize_model_selection(usage_data)
        elif strategy == 'prompt_optimization':
            return self._optimize_prompts(usage_data)
        elif strategy == 'caching':
            return self._implement_caching(usage_data)
        elif strategy == 'batching':
            return self._implement_batching(usage_data)
        elif strategy == 'rate_limiting':
            return self._implement_rate_limiting(usage_data, budget)

        return StrategyResult(success=False, estimated_cost=0)

    def _optimize_model_selection(self,
                                usage_data: Dict) -> StrategyResult:
        """优化模型选择"""
        # 分析使用场景
        simple_tasks = self._identify_simple_tasks(usage_data)
        complex_tasks = self._identify_complex_tasks(usage_data)

        # 为简单任务使用更便宜的模型
        savings = 0.0
        optimized_data = usage_data.copy()

        for task in simple_tasks:
            if task.get('model') == 'claude-opus-4':
                # 切换到 Sonnet
                original_cost = self._calculate_task_cost(task)
                task['model'] = 'claude-sonnet-4'
                new_cost = self._calculate_task_cost(task)
                savings += original_cost - new_cost
                optimized_data[task['id']] = task

        estimated_cost = self._calculate_current_cost(optimized_data)

        return StrategyResult(
            success=True,
            savings=savings,
            estimated_cost=estimated_cost,
            description=f"Switched {len(simple_tasks)} tasks to cheaper model"
        )

    def _implement_caching(self,
                         usage_data: Dict) -> StrategyResult:
        """实现缓存"""
        # 识别可缓存的使用场景
        cacheable_requests = self._identify_cacheable_requests(usage_data)

        # 估算缓存命中率
        cache_hit_rate = 0.3  # 30% 缓存命中率

        # 计算节省
        total_requests = sum(
            data.get('requests', 0)
            for data in usage_data.values()
        )
        cached_requests = int(total_requests * cache_hit_rate)

        # 计算节省的成本
        cost_per_request = self._calculate_avg_cost_per_request(usage_data)
        savings = cached_requests * cost_per_request

        estimated_cost = self._calculate_current_cost(usage_data) - savings

        return StrategyResult(
            success=True,
            savings=savings,
            estimated_cost=estimated_cost,
            description=f"Cache {cached_requests} requests ({cache_hit_rate*100}% hit rate)"
        )

## 30.2.3 风险评估

### 风险识别

class RiskAssessment:
"""风险评估"""
def __init__(self):
self.risk_categories = {
'security': {
'description': '安全风险',
'severity': 'critical'
},
'compliance': {
'description': '合规风险',
'severity': 'high'
},
'performance': {
'description': '性能风险',
'severity': 'medium'
},
'cost': {
'description': '成本风险',
'severity': 'medium'
},
'adoption': {
'description': '采用风险',
'severity': 'low'
}
}
def assess(self, deployment_config: Dict) -> RiskReport:
"""评估风险"""
report = RiskReport()
# 评估各类风险
for category, metadata in self.risk_categories.items():
risks = self._assess_category(category, deployment_config)
report.add_risks(category, risks)
# 计算总体风险等级
report.overall_risk_level = self._calculate_overall_risk(report)
# 生成缓解建议
report.mitigation_strategies = self._generate_mitigation_strategies(report)
return report
def _assess_category(self,
category: str,
config: Dict) -> List[Risk]:
"""评估单个风险类别"""
risks = []
if category == 'security':
risks.extend(self._assess_security_risks(config))
elif category == 'compliance':
risks.extend(self._assess_compliance_risks(config))
elif category == 'performance':
risks.extend(self._assess_performance_risks(config))
elif category == 'cost':
risks.extend(self._assess_cost_risks(config))
elif category == 'adoption':
risks.extend(self._assess_adoption_risks(config))
return risks
def _assess_security_risks(self, config: Dict) -> List[Risk]:
"""评估安全风险"""
risks = []
# API 密钥泄露风险
if config.get('api_key_management') == 'manual':
risks.append(Risk(
name='API Key Exposure',
description='API keys may be exposed in code or configuration',
likelihood='medium',
impact='high',
mitigation='Use centralized key management and rotate keys regularly'
))
# 数据泄露风险
if config.get('data_classification') == 'public':
risks.append(Risk(
name='Data Leakage',
description='Sensitive code may be sent to external APIs',
likelihood='low',
impact='critical',
mitigation='Implement data loss prevention and content filtering'
))
# 未经授权访问风险
if config.get('authentication') == 'api_key':
risks.append(Risk(
name='Unauthorized Access',
description='API keys may be shared or stolen',
likelihood='medium',
impact='high',
mitigation='Implement SSO and MFA for authentication'
))
return risks
def _assess_cost_risks(self, config: Dict) -> List[Risk]:
"""评估成本风险"""
risks = []
# 成本超支风险
if not config.get('budget_limits'):
risks.append(Risk(
name='Cost Overrun',
description='Usage may exceed budget without controls',
likelihood='high',
impact='medium',
mitigation='Implement budget limits and cost alerts'
))
# 使用效率低风险
if not config.get('usage_monitoring'):
risks.append(Risk(
name='Inefficient Usage',
description='Inefficient prompt usage may increase costs',
likelihood='medium',
impact='medium',
mitigation='Monitor usage patterns and provide optimization guidance'
))
return risks
```

```
python

class CostOptimizer:
    """成本优化器"""

    def __init__(self):
        self.optimization_strategies = [
            'model_selection',
            'prompt_optimization',
            'caching',
            'batching',
            'rate_limiting'
        ]

    def optimize(self, usage_data: Dict,
                budget: float) -> OptimizationPlan:
        """优化成本"""
        plan = OptimizationPlan()

        current_cost = self._calculate_current_cost(usage_data)

        if current_cost <= budget:
            plan.status = 'within_budget'
            return plan

        # 应用优化策略
        for strategy in self.optimization_strategies:
            strategy_result = self._apply_strategy(
                strategy,
                usage_data,
                budget
            )
            plan.add_strategy_result(strategy, strategy_result)

            # 检查是否达到预算
            if strategy_result.estimated_cost <= budget:
                plan.status = 'optimized'
                plan.selected_strategies = self.optimization_strategies[
                    :self.optimization_strategies.index(strategy) + 1
                ]
                break

        if plan.status == 'over_budget':
            plan.recommendations = self._generate_recommendations(
                usage_data,
                budget
            )

        return plan

    def _apply_strategy(self,
                      strategy: str,
                      usage_data: Dict,
                      budget: float) -> StrategyResult:
        """应用单个优化策略"""
        if strategy == 'model_selection':
            return self._optimize_model_selection(usage_data)
        elif strategy == 'prompt_optimization':
            return self._optimize_prompts(usage_data)
        elif strategy == 'caching':
            return self._implement_caching(usage_data)
        elif strategy == 'batching':
            return self._implement_batching(usage_data)
        elif strategy == 'rate_limiting':
            return self._implement_rate_limiting(usage_data, budget)

        return StrategyResult(success=False, estimated_cost=0)

    def _optimize_model_selection(self,
                                usage_data: Dict) -> StrategyResult:
        """优化模型选择"""
        # 分析使用场景
        simple_tasks = self._identify_simple_tasks(usage_data)
        complex_tasks = self._identify_complex_tasks(usage_data)

        # 为简单任务使用更便宜的模型
        savings = 0.0
        optimized_data = usage_data.copy()

        for task in simple_tasks:
            if task.get('model') == 'claude-opus-4':
                # 切换到 Sonnet
                original_cost = self._calculate_task_cost(task)
                task['model'] = 'claude-sonnet-4'
                new_cost = self._calculate_task_cost(task)
                savings += original_cost - new_cost
                optimized_data[task['id']] = task

        estimated_cost = self._calculate_current_cost(optimized_data)

        return StrategyResult(
            success=True,
            savings=savings,
            estimated_cost=estimated_cost,
            description=f"Switched {len(simple_tasks)} tasks to cheaper model"
        )

    def _implement_caching(self,
                         usage_data: Dict) -> StrategyResult:
        """实现缓存"""
        # 识别可缓存的使用场景
        cacheable_requests = self._identify_cacheable_requests(usage_data)

        # 估算缓存命中率
        cache_hit_rate = 0.3  # 30% 缓存命中率

        # 计算节省
        total_requests = sum(
            data.get('requests', 0)
            for data in usage_data.values()
        )
        cached_requests = int(total_requests * cache_hit_rate)

        # 计算节省的成本
        cost_per_request = self._calculate_avg_cost_per_request(usage_data)
        savings = cached_requests * cost_per_request

        estimated_cost = self._calculate_current_cost(usage_data) - savings

        return StrategyResult(
            success=True,
            savings=savings,
            estimated_cost=estimated_cost,
            description=f"Cache {cached_requests} requests ({cache_hit_rate*100}% hit rate)"
        )

## 30.2.3 风险评估

### 风险识别

class RiskAssessment:
"""风险评估"""
def __init__(self):
self.risk_categories = {
'security': {
'description': '安全风险',
'severity': 'critical'
},
'compliance': {
'description': '合规风险',
'severity': 'high'
},
'performance': {
'description': '性能风险',
'severity': 'medium'
},
'cost': {
'description': '成本风险',
'severity': 'medium'
},
'adoption': {
'description': '采用风险',
'severity': 'low'
}
}
def assess(self, deployment_config: Dict) -> RiskReport:
"""评估风险"""
report = RiskReport()
# 评估各类风险
for category, metadata in self.risk_categories.items():
risks = self._assess_category(category, deployment_config)
report.add_risks(category, risks)
# 计算总体风险等级
report.overall_risk_level = self._calculate_overall_risk(report)
# 生成缓解建议
report.mitigation_strategies = self._generate_mitigation_strategies(report)
return report
def _assess_category(self,
category: str,
config: Dict) -> List[Risk]:
"""评估单个风险类别"""
risks = []
if category == 'security':
risks.extend(self._assess_security_risks(config))
elif category == 'compliance':
risks.extend(self._assess_compliance_risks(config))
elif category == 'performance':
risks.extend(self._assess_performance_risks(config))
elif category == 'cost':
risks.extend(self._assess_cost_risks(config))
elif category == 'adoption':
risks.extend(self._assess_adoption_risks(config))
return risks
def _assess_security_risks(self, config: Dict) -> List[Risk]:
"""评估安全风险"""
risks = []
# API 密钥泄露风险
if config.get('api_key_management') == 'manual':
risks.append(Risk(
name='API Key Exposure',
description='API keys may be exposed in code or configuration',
likelihood='medium',
impact='high',
mitigation='Use centralized key management and rotate keys regularly'
))
# 数据泄露风险
if config.get('data_classification') == 'public':
risks.append(Risk(
name='Data Leakage',
description='Sensitive code may be sent to external APIs',
likelihood='low',
impact='critical',
mitigation='Implement data loss prevention and content filtering'
))
# 未经授权访问风险
if config.get('authentication') == 'api_key':
risks.append(Risk(
name='Unauthorized Access',
description='API keys may be shared or stolen',
likelihood='medium',
impact='high',
mitigation='Implement SSO and MFA for authentication'
))
return risks
def _assess_cost_risks(self, config: Dict) -> List[Risk]:
"""评估成本风险"""
risks = []
# 成本超支风险
if not config.get('budget_limits'):
risks.append(Risk(
name='Cost Overrun',
description='Usage may exceed budget without controls',
likelihood='high',
impact='medium',
mitigation='Implement budget limits and cost alerts'
))
# 使用效率低风险
if not config.get('usage_monitoring'):
risks.append(Risk(
name='Inefficient Usage',
description='Inefficient prompt usage may increase costs',
likelihood='medium',
impact='medium',
mitigation='Monitor usage patterns and provide optimization guidance'
))
return risks
```

##### 风险缓解策略#

```
bash复制python

class RiskMitigation:
    """风险缓解"""

    def __init__(self):
        self.mitigation_strategies = {
            'security': [
                'Implement SSO and MFA',
                'Use API key rotation',
                'Enable audit logging',
                'Implement data loss prevention',
                'Use network isolation'
            ],
            'compliance': [
                'Maintain audit logs',
                'Implement data classification',
                'Regular compliance audits',
                'Document data flows',
                'Implement retention policies'
            ],
            'performance': [
                'Implement caching',
                'Use load balancing',
                'Monitor performance metrics',
                'Implement rate limiting',
                'Optimize network configuration'
            ],
            'cost': [
                'Set budget limits',
                'Implement cost alerts',
                'Monitor usage patterns',
                'Optimize prompt efficiency',
                'Use caching strategies'
            ],
            'adoption': [
                'Provide training',
                'Create documentation',
                'Start with pilot program',
                'Gather user feedback',
                'Provide support'
            ]
        }

    def generate_plan(self, risk_report: RiskReport) -> MitigationPlan:
        """生成缓解计划"""
        plan = MitigationPlan()

        # 为每个风险类别生成缓解措施
        for category, risks in risk_report.risks.items():
            category_plan = self._generate_category_plan(category, risks)
            plan.add_category_plan(category, category_plan)

        # 优先级排序
        plan.prioritize_actions()

        return plan

    def _generate_category_plan(self,
                               category: str,
                               risks: List[Risk]) -> CategoryMitigationPlan:
        """生成类别缓解计划"""
        plan = CategoryMitigationPlan(category=category)

        # 为每个风险生成缓解措施
        for risk in risks:
            mitigations = self._get_mitigations_for_risk(risk)
            plan.add_risk_mitigation(risk, mitigations)

        return plan
```

```
python

class RiskMitigation:
    """风险缓解"""

    def __init__(self):
        self.mitigation_strategies = {
            'security': [
                'Implement SSO and MFA',
                'Use API key rotation',
                'Enable audit logging',
                'Implement data loss prevention',
                'Use network isolation'
            ],
            'compliance': [
                'Maintain audit logs',
                'Implement data classification',
                'Regular compliance audits',
                'Document data flows',
                'Implement retention policies'
            ],
            'performance': [
                'Implement caching',
                'Use load balancing',
                'Monitor performance metrics',
                'Implement rate limiting',
                'Optimize network configuration'
            ],
            'cost': [
                'Set budget limits',
                'Implement cost alerts',
                'Monitor usage patterns',
                'Optimize prompt efficiency',
                'Use caching strategies'
            ],
            'adoption': [
                'Provide training',
                'Create documentation',
                'Start with pilot program',
                'Gather user feedback',
                'Provide support'
            ]
        }

    def generate_plan(self, risk_report: RiskReport) -> MitigationPlan:
        """生成缓解计划"""
        plan = MitigationPlan()

        # 为每个风险类别生成缓解措施
        for category, risks in risk_report.risks.items():
            category_plan = self._generate_category_plan(category, risks)
            plan.add_category_plan(category, category_plan)

        # 优先级排序
        plan.prioritize_actions()

        return plan

    def _generate_category_plan(self,
                               category: str,
                               risks: List[Risk]) -> CategoryMitigationPlan:
        """生成类别缓解计划"""
        plan = CategoryMitigationPlan(category=category)

        # 为每个风险生成缓解措施
        for risk in risks:
            mitigations = self._get_mitigations_for_risk(risk)
            plan.add_risk_mitigation(risk, mitigations)

        return plan
```

通过全面的需求分析、成本评估和风险分析，企业可以做出明智的部署决策，确保 Claude Code 的成功部署和长期价值实现。

---

# 第 31 章

## 1 Amazon Bedrock 集成

**URL**: https://claudecode.tangshuang.net/course/31.1%20Amazon%20Bedrock%20%E9%9B%86%E6%88%90

#### 31.1.1 Bedrock 概述#

Amazon Bedrock 是 AWS 提供的完全托管服务，可以通过 API 访问基础模型，包括 Anthropic 的 Claude 模型。通过 Bedrock 使用 Claude Code 可以为企业带来以下优势：

##### Bedrock 的优势#

True. AWS 原生集成：与 AWS IAM、CloudTrail、CloudWatch 等服务无缝集成
True. 企业级安全：符合 AWS 安全标准和合规要求
True. 灵活的部署：支持多个 AWS 区域，满足数据驻留要求
True. 成本管理：通过 AWS Cost Explorer 和 Budgets 进行成本控制
True. 高可用性：利用 AWS 的全球基础设施和冗余机制

##### 适用场景#

- 已经使用 AWS 基础设施的企业
- 需要符合特定数据驻留法规的组织
- 要求使用 AWS IAM 进行身份验证的场景
- 需要集中监控和日志记录的环境

#### 31.1.2 Bedrock 配置步骤#

##### 1. 前置条件检查#

class BedrockPrerequisitesChecker:
"""Bedrock 前置条件检查器"""

def init(self):
self.checks = {
'aws_account': False,
'bedrock_enabled': False,
'model_access': False,
'iam_permissions': False,
'cli_configured': False
}

def check_all(self) -> PrerequisiteReport:
"""检查所有前置条件"""
report = PrerequisiteReport()

### 检查 AWS 账户

self.checks['aws_account'] = self._check_aws_account()

### 检查 Bedrock 是否启用

self.checks['bedrock_enabled'] = self._check_bedrock_enabled()

### 检查模型访问权限

self.checks['model_access'] = self._check_model_access()

### 检查 IAM 权限

self.checks['iam_permissions'] = self._check_iam_permissions()

### 检查 CLI 配置

self.checks['cli_configured'] = self._check_cli_configured()

### 生成报告

report.checks = self.checks
report.all_passed = all(self.checks.values())
report.missing = [
check for check, passed in self.checks.items()
if not passed
]

return report

def _check_aws_account(self) -> bool:
"""检查 AWS 账户"""
try:
result = subprocess.run(
['aws', 'sts', 'get-caller-identity'],
capture_output=True,
text=True
)
return result.returncode == 0
except Exception:
return False

def _check_bedrock_enabled(self) -> bool:
"""检查 Bedrock 是否启用"""
try:
result = subprocess.run(
['aws', 'bedrock', 'list-foundation-models'],
capture_output=True,
text=True
)
return result.returncode == 0
except Exception:
return False

def _check_model_access(self) -> bool:
"""检查模型访问权限"""
try:
result = subprocess.run(
['aws', 'bedrock', 'list-inference-profiles'],
capture_output=True,
text=True
)
return result.returncode == 0
except Exception:
return False

##### 2. 提交用例详情#

首次使用 Anthropic 模型需要提交用例详情：

```
bash复制bash

# 通过 AWS CLI 提交
aws bedrock create-model-customization-job \
  --job-name "claude-code-use-case" \
  --base-model-identifier "anthropic.claude-sonnet-4-5-20250929-v1:0" \
  --customization-type "FINE_TUNING" \
  --customization-config '{
    "useCase": "Code generation and assistance",
    "teamSize": "10-50",
    "industry": "Technology"
  }'

### 3. 配置 AWS 凭证

#### 选项 A：AWS CLI 配置

# 配置 AWS CLI
aws configure
# 输入您的 AWS 凭证
AWS Access Key ID: [您的访问密钥]
AWS Secret Access Key: [您的秘密密钥]
Default region name: us-east-1
Default output format: json
```

```
bash

# 通过 AWS CLI 提交
aws bedrock create-model-customization-job \
  --job-name "claude-code-use-case" \
  --base-model-identifier "anthropic.claude-sonnet-4-5-20250929-v1:0" \
  --customization-type "FINE_TUNING" \
  --customization-config '{
    "useCase": "Code generation and assistance",
    "teamSize": "10-50",
    "industry": "Technology"
  }'

### 3. 配置 AWS 凭证

#### 选项 A：AWS CLI 配置

# 配置 AWS CLI
aws configure
# 输入您的 AWS 凭证
AWS Access Key ID: [您的访问密钥]
AWS Secret Access Key: [您的秘密密钥]
Default region name: us-east-1
Default output format: json
```

###### 选项 B：环境变量

```
bash复制bash

# 设置环境变量
export AWS_ACCESS_KEY_ID=your-access-key-id
export AWS_SECRET_ACCESS_KEY=your-secret-access-key
export AWS_SESSION_TOKEN=your-session-token  # 如果使用临时凭证
export AWS_REGION=us-east-1

#### 选项 C：AWS SSO

# 配置 SSO 配置文件
aws configure sso
# 登录
aws sso login --profile claude-code
# 使用配置文件
export AWS_PROFILE=claude-code
```

```
bash

# 设置环境变量
export AWS_ACCESS_KEY_ID=your-access-key-id
export AWS_SECRET_ACCESS_KEY=your-secret-access-key
export AWS_SESSION_TOKEN=your-session-token  # 如果使用临时凭证
export AWS_REGION=us-east-1

#### 选项 C：AWS SSO

# 配置 SSO 配置文件
aws configure sso
# 登录
aws sso login --profile claude-code
# 使用配置文件
export AWS_PROFILE=claude-code
```

###### 选项 D：Bedrock API 密钥

```
bash复制bash

# 使用 Bedrock API 密钥（推荐用于简化部署）
export AWS_BEARER_TOKEN_BEDROCK=your-bedrock-api-key

### 4. 启用 Claude Code Bedrock 集成

# 启用 Bedrock
export CLAUDE_CODE_USE_BEDROCK=1
# 设置区域
export AWS_REGION=us-east-1
# 可选：为小型/快速模型设置不同区域
export ANTHROPIC_SMALL_FAST_MODEL_AWS_REGION=us-west-2
```

```
bash

# 使用 Bedrock API 密钥（推荐用于简化部署）
export AWS_BEARER_TOKEN_BEDROCK=your-bedrock-api-key

### 4. 启用 Claude Code Bedrock 集成

# 启用 Bedrock
export CLAUDE_CODE_USE_BEDROCK=1
# 设置区域
export AWS_REGION=us-east-1
# 可选：为小型/快速模型设置不同区域
export ANTHROPIC_SMALL_FAST_MODEL_AWS_REGION=us-west-2
```

##### 5. 配置模型#

```
bash复制bash

# 主模型
export ANTHROPIC_MODEL='global.anthropic.claude-sonnet-4-5-20250929-v1:0'

# 小型/快速模型
export ANTHROPIC_SMALL_FAST_MODEL='us.anthropic.claude-haiku-4-5-20251001-v1:0'

# 使用推理配置文件
export ANTHROPIC_MODEL='arn:aws:bedrock:us-east-2:your-account-id:application-inference-profile/your-model-id'

## 31.1.3 IAM 权限配置

### 基础 IAM 策略

{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AllowModelAccess",
"Effect": "Allow",
"Action": [
"bedrock:InvokeModel",
"bedrock:InvokeModelWithResponseStream",
"bedrock:ListInferenceProfiles"
],
"Resource": [
"arn:aws:bedrock:*:*:inference-profile/*",
"arn:aws:bedrock:*:*:application-inference-profile/*",
"arn:aws:bedrock:*:*:foundation-model/*"
]
},
{
"Sid": "AllowMarketplaceAccess",
"Effect": "Allow",
"Action": [
"aws-marketplace:ViewSubscriptions",
"aws-marketplace:Subscribe"
],
"Resource": "*",
"Condition": {
"StringEquals": {
"aws:CalledViaLast": "bedrock.amazonaws.com"
}
}
}
]
}
```

```
bash

# 主模型
export ANTHROPIC_MODEL='global.anthropic.claude-sonnet-4-5-20250929-v1:0'

# 小型/快速模型
export ANTHROPIC_SMALL_FAST_MODEL='us.anthropic.claude-haiku-4-5-20251001-v1:0'

# 使用推理配置文件
export ANTHROPIC_MODEL='arn:aws:bedrock:us-east-2:your-account-id:application-inference-profile/your-model-id'

## 31.1.3 IAM 权限配置

### 基础 IAM 策略

{
"Version": "2012-10-17",
"Statement": [
{
"Sid": "AllowModelAccess",
"Effect": "Allow",
"Action": [
"bedrock:InvokeModel",
"bedrock:InvokeModelWithResponseStream",
"bedrock:ListInferenceProfiles"
],
"Resource": [
"arn:aws:bedrock:*:*:inference-profile/*",
"arn:aws:bedrock:*:*:application-inference-profile/*",
"arn:aws:bedrock:*:*:foundation-model/*"
]
},
{
"Sid": "AllowMarketplaceAccess",
"Effect": "Allow",
"Action": [
"aws-marketplace:ViewSubscriptions",
"aws-marketplace:Subscribe"
],
"Resource": "*",
"Condition": {
"StringEquals": {
"aws:CalledViaLast": "bedrock.amazonaws.com"
}
}
}
]
}
```

##### 严格 IAM 策略#

```
bash复制json

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowSpecificModelAccess",
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel",
        "bedrock:InvokeModelWithResponseStream"
      ],
      "Resource": [
        "arn:aws:bedrock:us-east-1:123456789012:inference-profile/global.anthropic.claude-sonnet-4-5-20250929-v1:0",
        "arn:aws:bedrock:us-west-2:123456789012:inference-profile/us.anthropic.claude-haiku-4-5-20251001-v1:0"
      ]
    }
  ]
}

### IAM 角色创建

# 创建 IAM 角色
aws iam create-role \
--role-name ClaudeCodeBedrockRole \
--assume-role-policy-document '{
"Version": "2012-10-17",
"Statement": [{
"Effect": "Allow",
"Principal": {"Service": "bedrock.amazonaws.com"},
"Action": "sts:AssumeRole"
}]
}'
# 附加策略
aws iam put-role-policy \
--role-name ClaudeCodeBedrockRole \
--policy-name ClaudeCodeBedrockPolicy \
--policy-document file://bedrock-policy.json
```

```
json

{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowSpecificModelAccess",
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel",
        "bedrock:InvokeModelWithResponseStream"
      ],
      "Resource": [
        "arn:aws:bedrock:us-east-1:123456789012:inference-profile/global.anthropic.claude-sonnet-4-5-20250929-v1:0",
        "arn:aws:bedrock:us-west-2:123456789012:inference-profile/us.anthropic.claude-haiku-4-5-20251001-v1:0"
      ]
    }
  ]
}

### IAM 角色创建

# 创建 IAM 角色
aws iam create-role \
--role-name ClaudeCodeBedrockRole \
--assume-role-policy-document '{
"Version": "2012-10-17",
"Statement": [{
"Effect": "Allow",
"Principal": {"Service": "bedrock.amazonaws.com"},
"Action": "sts:AssumeRole"
}]
}'
# 附加策略
aws iam put-role-policy \
--role-name ClaudeCodeBedrockRole \
--policy-name ClaudeCodeBedrockPolicy \
--policy-document file://bedrock-policy.json
```

#### 31.1.4 高级配置#

##### 自动凭证刷新#

```
bash复制json

{
  "awsAuthRefresh": "aws sso login --profile myprofile",
  "env": {
    "AWS_PROFILE": "myprofile",
    "CLAUDE_CODE_USE_BEDROCK": "1",
    "AWS_REGION": "us-east-1"
  }
}

### 输出令牌优化

# Bedrock 推荐的令牌设置
export CLAUDE_CODE_MAX_OUTPUT_TOKENS=4096
export MAX_THINKING_TOKENS=1024
```

```
json

{
  "awsAuthRefresh": "aws sso login --profile myprofile",
  "env": {
    "AWS_PROFILE": "myprofile",
    "CLAUDE_CODE_USE_BEDROCK": "1",
    "AWS_REGION": "us-east-1"
  }
}

### 输出令牌优化

# Bedrock 推荐的令牌设置
export CLAUDE_CODE_MAX_OUTPUT_TOKENS=4096
export MAX_THINKING_TOKENS=1024
```

##### 提示缓存配置#

```
bash复制bash

# 启用提示缓存（默认启用）
# 如需禁用
export DISABLE_PROMPT_CACHING=1

## 31.1.5 监控和故障排除

### CloudWatch 监控

class BedrockMonitor:
"""Bedrock 监控器"""
def __init__(self):
self.cloudwatch = boto3.client('cloudwatch')
self.metrics = [
'InvokeModel',
'InvokeModelWithResponseStream',
'Latency',
'ErrorCount',
'5XXError',
'4XXError'
]
def setup_alarms(self, config: Dict):
"""设置告警"""
for metric in self.metrics:
alarm = self._create_alarm(metric, config)
self.cloudwatch.put_metric_alarm(**alarm)
def _create_alarm(self, metric: str, config: Dict) -> Dict:
"""创建告警"""
return {
'AlarmName': f'Bedrock{metric}Alarm',
'MetricName': metric,
'Namespace': 'AWS/Bedrock',
'Statistic': 'Sum',
'Period': 300,
'EvaluationPeriods': 1,
'Threshold': config.get('threshold', 100),
'ComparisonOperator': 'GreaterThanThreshold',
'AlarmActions': [config.get('sns_topic')],
'TreatMissingData': 'notBreaching'
}
```

```
bash

# 启用提示缓存（默认启用）
# 如需禁用
export DISABLE_PROMPT_CACHING=1

## 31.1.5 监控和故障排除

### CloudWatch 监控

class BedrockMonitor:
"""Bedrock 监控器"""
def __init__(self):
self.cloudwatch = boto3.client('cloudwatch')
self.metrics = [
'InvokeModel',
'InvokeModelWithResponseStream',
'Latency',
'ErrorCount',
'5XXError',
'4XXError'
]
def setup_alarms(self, config: Dict):
"""设置告警"""
for metric in self.metrics:
alarm = self._create_alarm(metric, config)
self.cloudwatch.put_metric_alarm(**alarm)
def _create_alarm(self, metric: str, config: Dict) -> Dict:
"""创建告警"""
return {
'AlarmName': f'Bedrock{metric}Alarm',
'MetricName': metric,
'Namespace': 'AWS/Bedrock',
'Statistic': 'Sum',
'Period': 300,
'EvaluationPeriods': 1,
'Threshold': config.get('threshold', 100),
'ComparisonOperator': 'GreaterThanThreshold',
'AlarmActions': [config.get('sns_topic')],
'TreatMissingData': 'notBreaching'
}
```

##### 常见问题解决#

```
bash复制python

class BedrockTroubleshooter:
    """Bedrock 故障排除器"""

    def diagnose(self, error: str) -> DiagnosisResult:
        """诊断问题"""
        if 'AccessDenied' in error:
            return self._diagnose_access_denied()
        elif 'ResourceNotFound' in error:
            return self._diagnose_resource_not_found()
        elif 'ThrottlingException' in error:
            return self._diagnose_throttling()
        elif 'ValidationException' in error:
            return self._diagnose_validation_error()
        else:
            return DiagnosisResult(
                issue='Unknown',
                solution='Check AWS CloudWatch logs for details'
            )

    def _diagnose_access_denied(self) -> DiagnosisResult:
        """诊断访问拒绝错误"""
        return DiagnosisResult(
            issue='IAM Permission Denied',
            solution='''1. Verify IAM user/role has bedrock:InvokeModel permission
2. Check if the model is accessible in the region
3. Verify the resource ARN in the IAM policy''',
            commands=[
                'aws iam get-role-policy --role-name <role-name> --policy-name <policy-name>',
                'aws bedrock list-inference-profiles --region us-east-1'
            ]
        )

    def _diagnose_throttling(self) -> DiagnosisResult:
        """诊断限流错误"""
        return DiagnosisResult(
            issue='Rate Limit Exceeded',
            solution='''1. Implement request queuing
2. Use inference profiles for higher throughput
3. Contact AWS support to increase quota''',
            commands=[
                'aws service-quotas list-service-quotas --service-code bedrock'
            ]
        )
```

```
python

class BedrockTroubleshooter:
    """Bedrock 故障排除器"""

    def diagnose(self, error: str) -> DiagnosisResult:
        """诊断问题"""
        if 'AccessDenied' in error:
            return self._diagnose_access_denied()
        elif 'ResourceNotFound' in error:
            return self._diagnose_resource_not_found()
        elif 'ThrottlingException' in error:
            return self._diagnose_throttling()
        elif 'ValidationException' in error:
            return self._diagnose_validation_error()
        else:
            return DiagnosisResult(
                issue='Unknown',
                solution='Check AWS CloudWatch logs for details'
            )

    def _diagnose_access_denied(self) -> DiagnosisResult:
        """诊断访问拒绝错误"""
        return DiagnosisResult(
            issue='IAM Permission Denied',
            solution='''1. Verify IAM user/role has bedrock:InvokeModel permission
2. Check if the model is accessible in the region
3. Verify the resource ARN in the IAM policy''',
            commands=[
                'aws iam get-role-policy --role-name <role-name> --policy-name <policy-name>',
                'aws bedrock list-inference-profiles --region us-east-1'
            ]
        )

    def _diagnose_throttling(self) -> DiagnosisResult:
        """诊断限流错误"""
        return DiagnosisResult(
            issue='Rate Limit Exceeded',
            solution='''1. Implement request queuing
2. Use inference profiles for higher throughput
3. Contact AWS support to increase quota''',
            commands=[
                'aws service-quotas list-service-quotas --service-code bedrock'
            ]
        )
```

通过正确配置 Amazon Bedrock，企业可以利用 AWS 的强大基础设施，安全、高效地部署 Claude Code。

---

## 2 Google Vertex AI 集成

**URL**: https://claudecode.tangshuang.net/course/31.2%20Google%20Vertex%20AI%20%E9%9B%86%E6%88%90

#### 31.2.1 Vertex AI 概述#

Google Vertex AI 是 Google Cloud 提供的统一机器学习平台，支持通过 API 访问多种基础模型，包括 Anthropic 的 Claude 模型。通过 Vertex AI 使用 Claude Code 可以为企业带来以下优势：

##### Vertex AI 的优势#

True. GCP 原生集成：与 Google Cloud IAM、Cloud Audit Logs、Cloud Monitoring 等服务无缝集成
True. 全球端点：支持全球访问，提供更好的延迟和可用性
True. 100 万令牌上下文窗口：支持超长上下文，适合大型代码库分析
True. 企业级安全：符合 Google Cloud 安全标准和合规要求
True. 灵活的部署：支持区域和全局端点，满足不同需求

##### 适用场景#

- 已经使用 Google Cloud Platform 的企业
- 需要超长上下文窗口的应用
- 要求使用 Google Cloud IAM 进行身份验证的场景
- 需要全球访问和低延迟的环境

#### 31.2.2 Vertex AI 配置步骤#

##### 1. 前置条件检查#

class VertexAIPrerequisitesChecker:
"""Vertex AI 前置条件检查器"""

def init(self):
self.checks = {
'gcp_project': False,
'vertex_enabled': False,
'model_access': False,
'iam_permissions': False,
'gcloud_configured': False
}

def check_all(self) -> PrerequisiteReport:
"""检查所有前置条件"""
report = PrerequisiteReport()

### 检查 GCP 项目

self.checks['gcp_project'] = self._check_gcp_project()

### 检查 Vertex AI 是否启用

self.checks['vertex_enabled'] = self._check_vertex_enabled()

### 检查模型访问权限

self.checks['model_access'] = self._check_model_access()

### 检查 IAM 权限

self.checks['iam_permissions'] = self._check_iam_permissions()

### 检查 gcloud 配置

self.checks['gcloud_configured'] = self._check_gcloud_configured()

### 生成报告

report.checks = self.checks
report.all_passed = all(self.checks.values())
report.missing = [
check for check, passed in self.checks.items()
if not passed
]

return report

def _check_gcp_project(self) -> bool:
"""检查 GCP 项目"""
try:
result = subprocess.run(
['gcloud', 'config', 'get-value', 'project'],
capture_output=True,
text=True
)
return result.returncode == 0 and result.stdout.strip()
except Exception:
return False

def _check_vertex_enabled(self) -> bool:
"""检查 Vertex AI 是否启用"""
try:
result = subprocess.run(
['gcloud', 'services', 'list', '--enabled'],
capture_output=True,
text=True
)
return 'aiplatform.googleapis.com' in result.stdout
except Exception:
return False

##### 2. 启用 Vertex AI API#

```
bash复制bash

# 设置项目 ID
gcloud config set project YOUR-PROJECT-ID

# 启用 Vertex AI API
gcloud services enable aiplatform.googleapis.com

# 验证启用
gcloud services list --enabled | grep aiplatform

### 3. 请求模型访问权限

# 通过 gcloud 请求访问
gcloud ai models list \
--region=global \
--filter="displayName~'Claude'"
# 或通过控制台访问
# https://console.cloud.google.com/vertex-ai/model-garden
```

```
bash

# 设置项目 ID
gcloud config set project YOUR-PROJECT-ID

# 启用 Vertex AI API
gcloud services enable aiplatform.googleapis.com

# 验证启用
gcloud services list --enabled | grep aiplatform

### 3. 请求模型访问权限

# 通过 gcloud 请求访问
gcloud ai models list \
--region=global \
--filter="displayName~'Claude'"
# 或通过控制台访问
# https://console.cloud.google.com/vertex-ai/model-garden
```

##### 4. 配置 GCP 凭证#

###### 选项 A：服务账户密钥

```
bash复制bash

# 创建服务账户
gcloud iam service-accounts create claude-code-sa \
  --display-name="Claude Code Service Account"

# 授予必要权限
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
  --member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
  --role="roles/aiplatform.user"

# 创建密钥
gcloud iam service-accounts keys create claude-code-key.json \
  --iam-account=claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com

# 设置环境变量
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/claude-code-key.json

#### 选项 B：ADC (Application Default Credentials)

# 使用用户凭证
gcloud auth application-default login
# 或使用服务账户
gcloud auth application-default login \
--impersonate-service-account=claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com
```

```
bash

# 创建服务账户
gcloud iam service-accounts create claude-code-sa \
  --display-name="Claude Code Service Account"

# 授予必要权限
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
  --member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
  --role="roles/aiplatform.user"

# 创建密钥
gcloud iam service-accounts keys create claude-code-key.json \
  --iam-account=claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com

# 设置环境变量
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/claude-code-key.json

#### 选项 B：ADC (Application Default Credentials)

# 使用用户凭证
gcloud auth application-default login
# 或使用服务账户
gcloud auth application-default login \
--impersonate-service-account=claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com
```

###### 选项 C：工作负载身份联邦

```
bash复制bash

# 配置工作负载身份联邦
gcloud iam workload-identity-pools create-cred-config \
  projects/YOUR-PROJECT-ID/locations/global/workloadIdentityPools/POOL-NAME/providers/PROVIDER-NAME \
  --credential-source-file=credential-config.json \
  --output-file=adc.json

export GOOGLE_APPLICATION_CREDENTIALS=/path/to/adc.json

### 5. 启用 Claude Code Vertex AI 集成

# 启用 Vertex AI
export CLAUDE_CODE_USE_VERTEX=1
# 设置项目 ID
export ANTHROPIC_VERTEX_PROJECT_ID=YOUR-PROJECT-ID
# 设置区域（全局或特定区域）
export CLOUD_ML_REGION=global
# 可选：为不同模型设置不同区域
export VERTEX_REGION_CLAUDE_3_5_HAIKU=us-east5
export VERTEX_REGION_CLAUDE_3_5_SONNET=us-east5
export VERTEX_REGION_CLAUDE_4_0_OPUS=europe-west1
export VERTEX_REGION_CLAUDE_4_0_SONNET=us-east5
export VERTEX_REGION_CLAUDE_4_1_OPUS=europe-west1
```

```
bash

# 配置工作负载身份联邦
gcloud iam workload-identity-pools create-cred-config \
  projects/YOUR-PROJECT-ID/locations/global/workloadIdentityPools/POOL-NAME/providers/PROVIDER-NAME \
  --credential-source-file=credential-config.json \
  --output-file=adc.json

export GOOGLE_APPLICATION_CREDENTIALS=/path/to/adc.json

### 5. 启用 Claude Code Vertex AI 集成

# 启用 Vertex AI
export CLAUDE_CODE_USE_VERTEX=1
# 设置项目 ID
export ANTHROPIC_VERTEX_PROJECT_ID=YOUR-PROJECT-ID
# 设置区域（全局或特定区域）
export CLOUD_ML_REGION=global
# 可选：为不同模型设置不同区域
export VERTEX_REGION_CLAUDE_3_5_HAIKU=us-east5
export VERTEX_REGION_CLAUDE_3_5_SONNET=us-east5
export VERTEX_REGION_CLAUDE_4_0_OPUS=europe-west1
export VERTEX_REGION_CLAUDE_4_0_SONNET=us-east5
export VERTEX_REGION_CLAUDE_4_1_OPUS=europe-west1
```

##### 6. 配置模型#

```
bash复制bash

# 主模型
export ANTHROPIC_MODEL='claude-sonnet-4-5@20250929'

# 小型/快速模型
export ANTHROPIC_SMALL_FAST_MODEL='claude-haiku-4-5@20251001'

# 使用 100 万令牌上下文窗口
export ANTHROPIC_MODEL='claude-sonnet-4-5@20250929'
export ANTHROPIC_VERTEX_ENABLE_1M_CONTEXT=1

## 31.2.3 IAM 权限配置

### 基础 IAM 角色

# 使用预定义角色
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
--member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
--role="roles/aiplatform.user"
```

```
bash

# 主模型
export ANTHROPIC_MODEL='claude-sonnet-4-5@20250929'

# 小型/快速模型
export ANTHROPIC_SMALL_FAST_MODEL='claude-haiku-4-5@20251001'

# 使用 100 万令牌上下文窗口
export ANTHROPIC_MODEL='claude-sonnet-4-5@20250929'
export ANTHROPIC_VERTEX_ENABLE_1M_CONTEXT=1

## 31.2.3 IAM 权限配置

### 基础 IAM 角色

# 使用预定义角色
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
--member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
--role="roles/aiplatform.user"
```

##### 自定义 IAM 角色#

```
bash复制yaml

# custom-role.yaml
title: "Claude Code Vertex AI Role"
description: "Custom role for Claude Code Vertex AI access"
stage: "GA"
includedPermissions:
  - aiplatform.endpoints.predict
  - aiplatform.endpoints.streamPredict
  - aiplatform.models.list
  - aiplatform.models.get

# 创建自定义角色
gcloud iam roles create claude-code-vertex-role \
--project=YOUR-PROJECT-ID \
--file=custom-role.yaml
# 授予自定义角色
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
--member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
--role="projects/YOUR-PROJECT-ID/roles/claude-code-vertex-role"
```

```
yaml

# custom-role.yaml
title: "Claude Code Vertex AI Role"
description: "Custom role for Claude Code Vertex AI access"
stage: "GA"
includedPermissions:
  - aiplatform.endpoints.predict
  - aiplatform.endpoints.streamPredict
  - aiplatform.models.list
  - aiplatform.models.get

# 创建自定义角色
gcloud iam roles create claude-code-vertex-role \
--project=YOUR-PROJECT-ID \
--file=custom-role.yaml
# 授予自定义角色
gcloud projects add-iam-policy-binding YOUR-PROJECT-ID \
--member="serviceAccount:claude-code-sa@YOUR-PROJECT-ID.iam.gserviceaccount.com" \
--role="projects/YOUR-PROJECT-ID/roles/claude-code-vertex-role"
```

##### 组织策略配置#

```
bash复制bash

# 创建组织策略以限制访问
gcloud resource-manager org-policies create \
  --organization=YOUR-ORG-ID \
  --name=restrict-vertex-ai-models \
  --policy-file=vertex-ai-policy.yaml

# vertex-ai-policy.yaml
name: organizations/YOUR-ORG-ID/policies/restrict-vertex-ai-models
spec:
  rules:
  - enforce: true
    values:
      allowedValues:
      - "claude-sonnet-4-5@20250929"
      - "claude-haiku-4-5@20251001"

## 31.2.4 高级配置

### 100 万令牌上下文窗口

class ContextWindowManager:
"""上下文窗口管理器"""
def __init__(self):
self.max_tokens = 1_000_000
self.context_headers = {
'context-1m-2025-08-07': 'true'
}
def enable_extended_context(self) -> Dict[str, str]:
"""启用扩展上下文窗口"""
return {
'model': 'claude-sonnet-4-5@20250929',
'headers': self.context_headers,
'env_vars': {
'ANTHROPIC_VERTEX_ENABLE_1M_CONTEXT': '1'
}
}
def estimate_token_count(self, text: str) -> int:
"""估算令牌数量"""
# 粗略估算：1 token ≈ 4 characters
return len(text) // 4
def check_context_fit(self, text: str) -> bool:
"""检查文本是否适合上下文窗口"""
token_count = self.estimate_token_count(text)
return token_count <= self.max_tokens
```

```
bash

# 创建组织策略以限制访问
gcloud resource-manager org-policies create \
  --organization=YOUR-ORG-ID \
  --name=restrict-vertex-ai-models \
  --policy-file=vertex-ai-policy.yaml

# vertex-ai-policy.yaml
name: organizations/YOUR-ORG-ID/policies/restrict-vertex-ai-models
spec:
  rules:
  - enforce: true
    values:
      allowedValues:
      - "claude-sonnet-4-5@20250929"
      - "claude-haiku-4-5@20251001"

## 31.2.4 高级配置

### 100 万令牌上下文窗口

class ContextWindowManager:
"""上下文窗口管理器"""
def __init__(self):
self.max_tokens = 1_000_000
self.context_headers = {
'context-1m-2025-08-07': 'true'
}
def enable_extended_context(self) -> Dict[str, str]:
"""启用扩展上下文窗口"""
return {
'model': 'claude-sonnet-4-5@20250929',
'headers': self.context_headers,
'env_vars': {
'ANTHROPIC_VERTEX_ENABLE_1M_CONTEXT': '1'
}
}
def estimate_token_count(self, text: str) -> int:
"""估算令牌数量"""
# 粗略估算：1 token ≈ 4 characters
return len(text) // 4
def check_context_fit(self, text: str) -> bool:
"""检查文本是否适合上下文窗口"""
token_count = self.estimate_token_count(text)
return token_count <= self.max_tokens
```

##### 区域配置优化#

```
bash复制python

class RegionOptimizer:
    """区域优化器"""

    def __init__(self):
        self.regions = {
            'us-east5': {
                'latency': 50,
                'cost_factor': 1.0,
                'availability': 0.999
            },
            'europe-west1': {
                'latency': 80,
                'cost_factor': 1.1,
                'availability': 0.999
            },
            'asia-southeast1': {
                'latency': 100,
                'cost_factor': 0.9,
                'availability': 0.998
            }
        }

    def select_optimal_region(self,
                             user_location: str,
                             requirements: Dict) -> str:
        """选择最优区域"""
        # 基于用户位置选择
        if 'US' in user_location:
            primary_region = 'us-east5'
        elif 'EU' in user_location:
            primary_region = 'europe-west1'
        else:
            primary_region = 'asia-southeast1'

        # 根据需求调整
        if requirements.get('low_latency', False):
            return primary_region
        elif requirements.get('low_cost', False):
            return min(
                self.regions.items(),
                key=lambda x: x[1]['cost_factor']
            )[0]
        else:
            return primary_region

### 提示缓存配置

# 启用提示缓存（默认启用）
# 在请求中包含 cache_control 标志
# 禁用提示缓存
export DISABLE_PROMPT_CACHING=1
```

```
python

class RegionOptimizer:
    """区域优化器"""

    def __init__(self):
        self.regions = {
            'us-east5': {
                'latency': 50,
                'cost_factor': 1.0,
                'availability': 0.999
            },
            'europe-west1': {
                'latency': 80,
                'cost_factor': 1.1,
                'availability': 0.999
            },
            'asia-southeast1': {
                'latency': 100,
                'cost_factor': 0.9,
                'availability': 0.998
            }
        }

    def select_optimal_region(self,
                             user_location: str,
                             requirements: Dict) -> str:
        """选择最优区域"""
        # 基于用户位置选择
        if 'US' in user_location:
            primary_region = 'us-east5'
        elif 'EU' in user_location:
            primary_region = 'europe-west1'
        else:
            primary_region = 'asia-southeast1'

        # 根据需求调整
        if requirements.get('low_latency', False):
            return primary_region
        elif requirements.get('low_cost', False):
            return min(
                self.regions.items(),
                key=lambda x: x[1]['cost_factor']
            )[0]
        else:
            return primary_region

### 提示缓存配置

# 启用提示缓存（默认启用）
# 在请求中包含 cache_control 标志
# 禁用提示缓存
export DISABLE_PROMPT_CACHING=1
```

#### 31.2.5 监控和故障排除#

##### Cloud Monitoring 配置#

```
bash复制python

class VertexAIMonitor:
    """Vertex AI 监控器"""

    def __init__(self):
        self.monitoring_client = monitoring_v3.MetricServiceClient()
        self.project_name = f"projects/{os.getenv('GOOGLE_CLOUD_PROJECT')}"

    def create_dashboard(self):
        """创建监控仪表板"""
        dashboard = {
            "displayName": "Claude Code Vertex AI Dashboard",
            "gridLayout": {
                "widgets": [
                    {
                        "title": "Request Count",
                        "xyChart": {
                            "dataSets": [{
                                "timeSeriesQuery": {
                                    "timeSeriesFilter": {
                                        "filter": "resource.type=\"aiplatform.googleapis.com/Endpoint\"",
                                        "aggregation": {
                                            "alignmentPeriod": "60s",
                                            "perSeriesAligner": "ALIGN_RATE"
                                        }
                                    }
                                }
                            }]
                        }
                    },
                    {
                        "title": "Latency",
                        "xyChart": {
                            "dataSets": [{
                                "timeSeriesQuery": {
                                    "timeSeriesFilter": {
                                        "filter": "metric.type=\"aiplatform.googleapis.com/prediction_latency\"",
                                        "aggregation": {
                                            "alignmentPeriod": "60s",
                                            "perSeriesAligner": "ALIGN_PERCENTILE_99"
                                        }
                                    }
                                }
                            }]
                        }
                    }
                ]
            }
        }

        self.monitoring_client.create_dashboard(
            name=f"{self.project_name}/dashboards/claude-code",
            body=dashboard
        )

### 常见问题解决

class VertexAITroubleshooter:
"""Vertex AI 故障排除器"""
def diagnose(self, error: str) -> DiagnosisResult:
"""诊断问题"""
if 'PermissionDenied' in error:
return self._diagnose_permission_denied()
elif 'ModelNotFound' in error:
return self._diagnose_model_not_found()
elif 'QuotaExceeded' in error:
return self._diagnose_quota_exceeded()
elif 'InvalidArgument' in error:
return self._diagnose_invalid_argument()
else:
return DiagnosisResult(
issue='Unknown',
solution='Check Cloud Logging for details'
)
def _diagnose_permission_denied(self) -> DiagnosisResult:
"""诊断权限拒绝错误"""
return DiagnosisResult(
issue='IAM Permission Denied',
solution='''1. Verify service account has aiplatform.user role

commands=[
'gcloud projects get-iam-policy YOUR-PROJECT-ID',
'gcloud ai models list --region=global'
]
)
def _diagnose_quota_exceeded(self) -> DiagnosisResult:
"""诊断配额超限错误"""
return DiagnosisResult(
issue='Quota Exceeded',
solution='''1. Check current quota in Cloud Console

commands=[
'gcloud compute project-info describe --project=YOUR-PROJECT-ID',
'gcloud ai models list --region=global --filter="displayName~\'Claude\'"'
]
)
```

```
python

class VertexAIMonitor:
    """Vertex AI 监控器"""

    def __init__(self):
        self.monitoring_client = monitoring_v3.MetricServiceClient()
        self.project_name = f"projects/{os.getenv('GOOGLE_CLOUD_PROJECT')}"

    def create_dashboard(self):
        """创建监控仪表板"""
        dashboard = {
            "displayName": "Claude Code Vertex AI Dashboard",
            "gridLayout": {
                "widgets": [
                    {
                        "title": "Request Count",
                        "xyChart": {
                            "dataSets": [{
                                "timeSeriesQuery": {
                                    "timeSeriesFilter": {
                                        "filter": "resource.type=\"aiplatform.googleapis.com/Endpoint\"",
                                        "aggregation": {
                                            "alignmentPeriod": "60s",
                                            "perSeriesAligner": "ALIGN_RATE"
                                        }
                                    }
                                }
                            }]
                        }
                    },
                    {
                        "title": "Latency",
                        "xyChart": {
                            "dataSets": [{
                                "timeSeriesQuery": {
                                    "timeSeriesFilter": {
                                        "filter": "metric.type=\"aiplatform.googleapis.com/prediction_latency\"",
                                        "aggregation": {
                                            "alignmentPeriod": "60s",
                                            "perSeriesAligner": "ALIGN_PERCENTILE_99"
                                        }
                                    }
                                }
                            }]
                        }
                    }
                ]
            }
        }

        self.monitoring_client.create_dashboard(
            name=f"{self.project_name}/dashboards/claude-code",
            body=dashboard
        )

### 常见问题解决

class VertexAITroubleshooter:
"""Vertex AI 故障排除器"""
def diagnose(self, error: str) -> DiagnosisResult:
"""诊断问题"""
if 'PermissionDenied' in error:
return self._diagnose_permission_denied()
elif 'ModelNotFound' in error:
return self._diagnose_model_not_found()
elif 'QuotaExceeded' in error:
return self._diagnose_quota_exceeded()
elif 'InvalidArgument' in error:
return self._diagnose_invalid_argument()
else:
return DiagnosisResult(
issue='Unknown',
solution='Check Cloud Logging for details'
)
def _diagnose_permission_denied(self) -> DiagnosisResult:
"""诊断权限拒绝错误"""
return DiagnosisResult(
issue='IAM Permission Denied',
solution='''1. Verify service account has aiplatform.user role

commands=[
'gcloud projects get-iam-policy YOUR-PROJECT-ID',
'gcloud ai models list --region=global'
]
)
def _diagnose_quota_exceeded(self) -> DiagnosisResult:
"""诊断配额超限错误"""
return DiagnosisResult(
issue='Quota Exceeded',
solution='''1. Check current quota in Cloud Console

commands=[
'gcloud compute project-info describe --project=YOUR-PROJECT-ID',
'gcloud ai models list --region=global --filter="displayName~\'Claude\'"'
]
)
```

##### 日志配置#

```
bash复制bash

# 启用详细日志
export GOOGLE_CLOUD_LOGGING_LEVEL=debug

# 查看日志
gcloud logging read "resource.type=aiplatform.googleapis.com/Endpoint" \
  --project=YOUR-PROJECT-ID \
  --limit=50 \
  --format="table(timestamp,protoPayload.requestId,protoPayload.error)"
```

```
bash

# 启用详细日志
export GOOGLE_CLOUD_LOGGING_LEVEL=debug

# 查看日志
gcloud logging read "resource.type=aiplatform.googleapis.com/Endpoint" \
  --project=YOUR-PROJECT-ID \
  --limit=50 \
  --format="table(timestamp,protoPayload.requestId,protoPayload.error)"
```

通过正确配置 Google Vertex AI，企业可以利用 Google Cloud 的强大基础设施，安全、高效地部署 Claude Code，并享受超长上下文窗口带来的优势。

---

# 第 32 章

## 1 企业网络配置

**URL**: https://claudecode.tangshuang.net/course/32.1%20%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE

#### 32.1.1 代理服务器配置#

##### HTTP/HTTPS 代理#

Claude Code 支持标准的环境变量来配置代理服务器：

### HTTPS 代理（推荐）

export HTTPS_PROXY=https://proxy.example.com:8080

### HTTP 代理（如果 HTTPS 不可用）

export HTTP_PROXY=http://proxy.example.com:8080

### 代理白名单（不通过代理的地址）

export NO_PROXY="localhost 127.0.0.1 192.168.1.1 example.com .example.com"

##### 代理配置管理器#

```
bash复制python

class ProxyConfigManager:
    """代理配置管理器"""

    def __init__(self):
        self.config = {
            'https_proxy': None,
            'http_proxy': None,
            'no_proxy': [],
            'proxy_auth': None
        }

    def configure(self, proxy_settings: Dict) -> ConfigResult:
        """配置代理"""
        result = ConfigResult()

        # 设置 HTTPS 代理
        if 'https_proxy' in proxy_settings:
            self.config['https_proxy'] = proxy_settings['https_proxy']
            os.environ['HTTPS_PROXY'] = self.config['https_proxy']
            result.add_setting('HTTPS_PROXY', self.config['https_proxy'])

        # 设置 HTTP 代理
        if 'http_proxy' in proxy_settings:
            self.config['http_proxy'] = proxy_settings['http_proxy']
            os.environ['HTTP_PROXY'] = self.config['http_proxy']
            result.add_setting('HTTP_PROXY', self.config['http_proxy'])

        # 设置白名单
        if 'no_proxy' in proxy_settings:
            no_proxy_list = ' '.join(proxy_settings['no_proxy'])
            self.config['no_proxy'] = proxy_settings['no_proxy']
            os.environ['NO_PROXY'] = no_proxy_list
            result.add_setting('NO_PROXY', no_proxy_list)

        # 验证配置
        validation = self._validate_config()
        result.validation = validation

        return result

    def _validate_config(self) -> ValidationResult:
        """验证配置"""
        validation = ValidationResult()

        # 检查代理 URL 格式
        for proxy_type in ['https_proxy', 'http_proxy']:
            proxy_url = self.config.get(proxy_type)
            if proxy_url:
                if not self._is_valid_url(proxy_url):
                    validation.add_error(
                        f"Invalid {proxy_type} URL: {proxy_url}"
                    )

        # 测试代理连接
        if self.config.get('https_proxy'):
            if not self._test_proxy_connection(self.config['https_proxy']):
                validation.add_error(
                    "Cannot connect to HTTPS proxy"
                )

        return validation

    def _is_valid_url(self, url: str) -> bool:
        """验证 URL 格式"""
        try:
            result = urllib.parse.urlparse(url)
            return all([result.scheme, result.netloc])
        except Exception:
            return False

    def _test_proxy_connection(self, proxy_url: str) -> bool:
        """测试代理连接"""
        try:
            parsed = urllib.parse.urlparse(proxy_url)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((parsed.hostname, parsed.port or 8080))
            sock.close()
            return result == 0
        except Exception:
            return False

### 代理身份验证

#### 基本身份验证

# 在代理 URL 中包含凭据
export HTTPS_PROXY=http://username:password@proxy.example.com:8080
export HTTP_PROXY=http://username:password@proxy.example.com:8080
```

```
python

class ProxyConfigManager:
    """代理配置管理器"""

    def __init__(self):
        self.config = {
            'https_proxy': None,
            'http_proxy': None,
            'no_proxy': [],
            'proxy_auth': None
        }

    def configure(self, proxy_settings: Dict) -> ConfigResult:
        """配置代理"""
        result = ConfigResult()

        # 设置 HTTPS 代理
        if 'https_proxy' in proxy_settings:
            self.config['https_proxy'] = proxy_settings['https_proxy']
            os.environ['HTTPS_PROXY'] = self.config['https_proxy']
            result.add_setting('HTTPS_PROXY', self.config['https_proxy'])

        # 设置 HTTP 代理
        if 'http_proxy' in proxy_settings:
            self.config['http_proxy'] = proxy_settings['http_proxy']
            os.environ['HTTP_PROXY'] = self.config['http_proxy']
            result.add_setting('HTTP_PROXY', self.config['http_proxy'])

        # 设置白名单
        if 'no_proxy' in proxy_settings:
            no_proxy_list = ' '.join(proxy_settings['no_proxy'])
            self.config['no_proxy'] = proxy_settings['no_proxy']
            os.environ['NO_PROXY'] = no_proxy_list
            result.add_setting('NO_PROXY', no_proxy_list)

        # 验证配置
        validation = self._validate_config()
        result.validation = validation

        return result

    def _validate_config(self) -> ValidationResult:
        """验证配置"""
        validation = ValidationResult()

        # 检查代理 URL 格式
        for proxy_type in ['https_proxy', 'http_proxy']:
            proxy_url = self.config.get(proxy_type)
            if proxy_url:
                if not self._is_valid_url(proxy_url):
                    validation.add_error(
                        f"Invalid {proxy_type} URL: {proxy_url}"
                    )

        # 测试代理连接
        if self.config.get('https_proxy'):
            if not self._test_proxy_connection(self.config['https_proxy']):
                validation.add_error(
                    "Cannot connect to HTTPS proxy"
                )

        return validation

    def _is_valid_url(self, url: str) -> bool:
        """验证 URL 格式"""
        try:
            result = urllib.parse.urlparse(url)
            return all([result.scheme, result.netloc])
        except Exception:
            return False

    def _test_proxy_connection(self, proxy_url: str) -> bool:
        """测试代理连接"""
        try:
            parsed = urllib.parse.urlparse(proxy_url)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((parsed.hostname, parsed.port or 8080))
            sock.close()
            return result == 0
        except Exception:
            return False

### 代理身份验证

#### 基本身份验证

# 在代理 URL 中包含凭据
export HTTPS_PROXY=http://username:password@proxy.example.com:8080
export HTTP_PROXY=http://username:password@proxy.example.com:8080
```

###### NTLM/Kerberos 认证

对于需要高级身份验证的代理，建议使用 LLM 网关：

```
bash复制bash

# 配置 LLM 网关处理代理认证
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=gateway-token

### 代理配置最佳实践

## 32.1.2 自定义 CA 证书

### 配置自定义 CA

企业环境通常使用自定义证书颁发机构（CA）来签发内部证书。Claude Code 需要配置以信任这些 CA：

# 配置自定义 CA 证书
export NODE_EXTRA_CA_CERTS=/path/to/ca-cert.pem
# 或使用多个证书
export NODE_EXTRA_CA_CERTS=/path/to/ca1.pem:/path/to/ca2.pem
```

```
bash

# 配置 LLM 网关处理代理认证
export ANTHROPIC_BASE_URL=https://llm-gateway.company.com
export ANTHROPIC_AUTH_TOKEN=gateway-token

### 代理配置最佳实践

## 32.1.2 自定义 CA 证书

### 配置自定义 CA

企业环境通常使用自定义证书颁发机构（CA）来签发内部证书。Claude Code 需要配置以信任这些 CA：

# 配置自定义 CA 证书
export NODE_EXTRA_CA_CERTS=/path/to/ca-cert.pem
# 或使用多个证书
export NODE_EXTRA_CA_CERTS=/path/to/ca1.pem:/path/to/ca2.pem
```

##### CA 证书管理器#

```
bash复制python

class CACertificateManager:
    """CA 证书管理器"""

    def __init__(self):
        self.certificates = []
        self.certificate_store = '/etc/ssl/certs'

    def add_certificate(self, cert_path: str) -> CertResult:
        """添加 CA 证书"""
        result = CertResult()

        # 验证证书
        if not self._validate_certificate(cert_path):
            result.success = False
            result.error = "Invalid certificate"
            return result

        # 复制证书到存储
        cert_name = os.path.basename(cert_path)
        dest_path = os.path.join(self.certificate_store, cert_name)

        shutil.copy(cert_path, dest_path)
        self.certificates.append(dest_path)

        # 更新环境变量
        self._update_ca_bundle()

        result.success = True
        result.certificate_path = dest_path

        return result

    def _validate_certificate(self, cert_path: str) -> bool:
        """验证证书"""
        try:
            with open(cert_path, 'rb') as f:
                cert_data = f.read()

            # 使用 OpenSSL 验证
            result = subprocess.run(
                ['openssl', 'x509', '-in', cert_path, '-noout'],
                capture_output=True
            )

            return result.returncode == 0
        except Exception:
            return False

    def _update_ca_bundle(self):
        """更新 CA 包"""
        cert_paths = ':'.join(self.certificates)
        os.environ['NODE_EXTRA_CA_CERTS'] = cert_paths

### 证书格式转换

# 将 DER 格式转换为 PEM 格式
openssl x509 -inform der -in certificate.cer -out certificate.pem
# 将 PKCS#12 格式转换为 PEM 格式
openssl pkcs12 -in certificate.p12 -out certificate.pem -nodes
# 提取证书链
openssl s_client -connect server:port -showcerts
```

```
python

class CACertificateManager:
    """CA 证书管理器"""

    def __init__(self):
        self.certificates = []
        self.certificate_store = '/etc/ssl/certs'

    def add_certificate(self, cert_path: str) -> CertResult:
        """添加 CA 证书"""
        result = CertResult()

        # 验证证书
        if not self._validate_certificate(cert_path):
            result.success = False
            result.error = "Invalid certificate"
            return result

        # 复制证书到存储
        cert_name = os.path.basename(cert_path)
        dest_path = os.path.join(self.certificate_store, cert_name)

        shutil.copy(cert_path, dest_path)
        self.certificates.append(dest_path)

        # 更新环境变量
        self._update_ca_bundle()

        result.success = True
        result.certificate_path = dest_path

        return result

    def _validate_certificate(self, cert_path: str) -> bool:
        """验证证书"""
        try:
            with open(cert_path, 'rb') as f:
                cert_data = f.read()

            # 使用 OpenSSL 验证
            result = subprocess.run(
                ['openssl', 'x509', '-in', cert_path, '-noout'],
                capture_output=True
            )

            return result.returncode == 0
        except Exception:
            return False

    def _update_ca_bundle(self):
        """更新 CA 包"""
        cert_paths = ':'.join(self.certificates)
        os.environ['NODE_EXTRA_CA_CERTS'] = cert_paths

### 证书格式转换

# 将 DER 格式转换为 PEM 格式
openssl x509 -inform der -in certificate.cer -out certificate.pem
# 将 PKCS#12 格式转换为 PEM 格式
openssl pkcs12 -in certificate.p12 -out certificate.pem -nodes
# 提取证书链
openssl s_client -connect server:port -showcerts
```

#### 32.1.3 mTLS 身份验证#

##### mTLS 配置#

对于需要客户端证书身份验证的企业环境：

```
bash复制bash

# 客户端证书
export CLAUDE_CODE_CLIENT_CERT=/path/to/client-cert.pem

# 客户端私钥
export CLAUDE_CODE_CLIENT_KEY=/path/to/client-key.pem

# 私钥密码短语（如果加密）
export CLAUDE_CODE_CLIENT_KEY_PASSPHRASE="your-passphrase"

### mTLS 配置管理器

class MTLSConfigManager:
"""mTLS 配置管理器"""
def __init__(self):
self.config = {
'client_cert': None,
'client_key': None,
'key_passphrase': None
}
def configure(self, mtls_settings: Dict) -> ConfigResult:
"""配置 mTLS"""
result = ConfigResult()
# 设置客户端证书
if 'client_cert' in mtls_settings:
cert_path = mtls_settings['client_cert']
if self._validate_certificate(cert_path):
self.config['client_cert'] = cert_path
os.environ['CLAUDE_CODE_CLIENT_CERT'] = cert_path
result.add_setting('CLAUDE_CODE_CLIENT_CERT', cert_path)
else:
result.add_error("Invalid client certificate")
# 设置客户端密钥
if 'client_key' in mtls_settings:
key_path = mtls_settings['client_key']
if self._validate_key(key_path):
self.config['client_key'] = key_path
os.environ['CLAUDE_CODE_CLIENT_KEY'] = key_path
result.add_setting('CLAUDE_CODE_CLIENT_KEY', key_path)
else:
result.add_error("Invalid client key")
# 设置密钥密码短语
if 'key_passphrase' in mtls_settings:
self.config['key_passphrase'] = mtls_settings['key_passphrase']
os.environ['CLAUDE_CODE_CLIENT_KEY_PASSPHRASE'] = \
mtls_settings['key_passphrase']
result.add_setting('CLAUDE_CODE_CLIENT_KEY_PASSPHRASE', '***')
# 验证配置
validation = self._validate_mtls_config()
result.validation = validation
return result
def _validate_key(self, key_path: str) -> bool:
"""验证私钥"""
try:
result = subprocess.run(
['openssl', 'rsa', '-in', key_path, '-check', '-noout'],
capture_output=True
)
return result.returncode == 0
except Exception:
return False
def _validate_mtls_config(self) -> ValidationResult:
"""验证 mTLS 配置"""
validation = ValidationResult()
# 检查证书和密钥是否匹配
if (self.config['client_cert'] and
self.config['client_key']):
if not self._check_cert_key_match():
validation.add_error(
"Certificate and key do not match"
)
return validation
def _check_cert_key_match(self) -> bool:
"""检查证书和密钥是否匹配"""
try:
# 提取证书的公钥模数
cert_result = subprocess.run(
['openssl', 'x509', '-noout', '-modulus', '-in',
self.config['client_cert']],
capture_output=True,
text=True
)
# 提取密钥的公钥模数
key_result = subprocess.run(
['openssl', 'rsa', '-noout', '-modulus', '-in',
self.config['client_key']],
capture_output=True,
text=True
)
return cert_result.stdout == key_result.stdout
except Exception:
return False
```

```
bash

# 客户端证书
export CLAUDE_CODE_CLIENT_CERT=/path/to/client-cert.pem

# 客户端私钥
export CLAUDE_CODE_CLIENT_KEY=/path/to/client-key.pem

# 私钥密码短语（如果加密）
export CLAUDE_CODE_CLIENT_KEY_PASSPHRASE="your-passphrase"

### mTLS 配置管理器

class MTLSConfigManager:
"""mTLS 配置管理器"""
def __init__(self):
self.config = {
'client_cert': None,
'client_key': None,
'key_passphrase': None
}
def configure(self, mtls_settings: Dict) -> ConfigResult:
"""配置 mTLS"""
result = ConfigResult()
# 设置客户端证书
if 'client_cert' in mtls_settings:
cert_path = mtls_settings['client_cert']
if self._validate_certificate(cert_path):
self.config['client_cert'] = cert_path
os.environ['CLAUDE_CODE_CLIENT_CERT'] = cert_path
result.add_setting('CLAUDE_CODE_CLIENT_CERT', cert_path)
else:
result.add_error("Invalid client certificate")
# 设置客户端密钥
if 'client_key' in mtls_settings:
key_path = mtls_settings['client_key']
if self._validate_key(key_path):
self.config['client_key'] = key_path
os.environ['CLAUDE_CODE_CLIENT_KEY'] = key_path
result.add_setting('CLAUDE_CODE_CLIENT_KEY', key_path)
else:
result.add_error("Invalid client key")
# 设置密钥密码短语
if 'key_passphrase' in mtls_settings:
self.config['key_passphrase'] = mtls_settings['key_passphrase']
os.environ['CLAUDE_CODE_CLIENT_KEY_PASSPHRASE'] = \
mtls_settings['key_passphrase']
result.add_setting('CLAUDE_CODE_CLIENT_KEY_PASSPHRASE', '***')
# 验证配置
validation = self._validate_mtls_config()
result.validation = validation
return result
def _validate_key(self, key_path: str) -> bool:
"""验证私钥"""
try:
result = subprocess.run(
['openssl', 'rsa', '-in', key_path, '-check', '-noout'],
capture_output=True
)
return result.returncode == 0
except Exception:
return False
def _validate_mtls_config(self) -> ValidationResult:
"""验证 mTLS 配置"""
validation = ValidationResult()
# 检查证书和密钥是否匹配
if (self.config['client_cert'] and
self.config['client_key']):
if not self._check_cert_key_match():
validation.add_error(
"Certificate and key do not match"
)
return validation
def _check_cert_key_match(self) -> bool:
"""检查证书和密钥是否匹配"""
try:
# 提取证书的公钥模数
cert_result = subprocess.run(
['openssl', 'x509', '-noout', '-modulus', '-in',
self.config['client_cert']],
capture_output=True,
text=True
)
# 提取密钥的公钥模数
key_result = subprocess.run(
['openssl', 'rsa', '-noout', '-modulus', '-in',
self.config['client_key']],
capture_output=True,
text=True
)
return cert_result.stdout == key_result.stdout
except Exception:
return False
```

#### 32.1.4 网络访问要求#

##### 必需的 URL#

Claude Code 需要访问以下 URL：

```
api.anthropic.com
```

```
claude.ai
```

```
statsig.anthropic.com
```

```
sentry.io
```

##### 防火墙配置#

```
bash复制python

class FirewallConfigurator:
    """防火墙配置器"""

    def __init__(self):
        self.required_urls = [
            'api.anthropic.com',
            'claude.ai',
            'statsig.anthropic.com',
            'sentry.io'
        ]

    def generate_rules(self,
                       firewall_type: str = 'iptables') -> List[str]:
        """生成防火墙规则"""
        rules = []

        if firewall_type == 'iptables':
            rules = self._generate_iptables_rules()
        elif firewall_type == 'aws':
            rules = self._generate_aws_rules()
        elif firewall_type == 'gcp':
            rules = self._generate_gcp_rules()

        return rules

    def _generate_iptables_rules(self) -> List[str]:
        """生成 iptables 规则"""
        rules = []

        for url in self.required_urls:
            # 解析域名获取 IP
            try:
                ips = socket.gethostbyname_ex(url)[2]
                for ip in ips:
                    rule = f"iptables -A OUTPUT -d {ip} -p tcp --dport 443 -j ACCEPT"
                    rules.append(rule)
            except socket.gaierror:
                pass

        return rules

    def _generate_aws_rules(self) -> List[str]:
        """生成 AWS 安全组规则"""
        rules = []

        for url in self.required_urls:
            # AWS 需要使用 IP 范围
            # 这里简化处理，实际需要查询 IP 范围
            rule = {
                'type': 'egress',
                'protocol': 'tcp',
                'port': 443,
                'destination': url,
                'action': 'allow'
            }
            rules.append(rule)

        return rules

    def _generate_gcp_rules(self) -> List[str]:
        """生成 GCP 防火墙规则"""
        rules = []

        for url in self.required_urls:
            rule = {
                'direction': 'EGRESS',
                'action': 'ALLOW',
                'rules': [{
                    'protocol': 'tcp',
                    'ports': ['443'],
                    'destinationRanges': [self._resolve_ip_range(url)]
                }]
            }
            rules.append(rule)

        return rules

    def _resolve_ip_range(self, url: str) -> str:
        """解析 IP 范围"""
        # 简化实现，实际需要查询 DNS 或 IP 范围
        try:
            ip = socket.gethostbyname(url)
            return f"{ip}/32"
        except socket.gaierror:
            return "0.0.0.0/0"

### 网络连接测试

class NetworkTester:
"""网络测试器"""
def __init__(self):
self.required_urls = [
'https://api.anthropic.com',
'https://claude.ai',
'https://statsig.anthropic.com'
]
def test_all(self) -> NetworkTestResult:
"""测试所有网络连接"""
result = NetworkTestResult()
for url in self.required_urls:
test_result = self._test_url(url)
result.add_result(url, test_result)
# 生成报告
result.summary = self._generate_summary(result.results)
return result
def _test_url(self, url: str) -> URLTestResult:
"""测试单个 URL"""
result = URLTestResult(url=url)
try:
start_time = time.time()
response = requests.get(url, timeout=10)
end_time = time.time()
result.success = response.status_code == 200
result.latency = (end_time - start_time) * 1000  # ms
result.status_code = response.status_code
except requests.exceptions.Timeout:
result.success = False
result.error = "Timeout"
except requests.exceptions.ConnectionError:
result.success = False
result.error = "Connection error"
except Exception as e:
result.success = False
result.error = str(e)
return result
def _generate_summary(self,
results: Dict[str, URLTestResult]) -> str:
"""生成测试摘要"""
total = len(results)
successful = sum(1 for r in results.values() if r.success)
summary = f"Network Test Summary:\n"
summary += f"Total: {total}, Successful: {successful}, Failed: {total - successful}\n\n"
for url, result in results.items():
status = "✓" if result.success else "✗"
summary += f"{status} {url}: "
if result.success:
summary += f"OK ({result.latency:.0f}ms)\n"
else:
summary += f"FAILED ({result.error})\n"
return summary
```

```
python

class FirewallConfigurator:
    """防火墙配置器"""

    def __init__(self):
        self.required_urls = [
            'api.anthropic.com',
            'claude.ai',
            'statsig.anthropic.com',
            'sentry.io'
        ]

    def generate_rules(self,
                       firewall_type: str = 'iptables') -> List[str]:
        """生成防火墙规则"""
        rules = []

        if firewall_type == 'iptables':
            rules = self._generate_iptables_rules()
        elif firewall_type == 'aws':
            rules = self._generate_aws_rules()
        elif firewall_type == 'gcp':
            rules = self._generate_gcp_rules()

        return rules

    def _generate_iptables_rules(self) -> List[str]:
        """生成 iptables 规则"""
        rules = []

        for url in self.required_urls:
            # 解析域名获取 IP
            try:
                ips = socket.gethostbyname_ex(url)[2]
                for ip in ips:
                    rule = f"iptables -A OUTPUT -d {ip} -p tcp --dport 443 -j ACCEPT"
                    rules.append(rule)
            except socket.gaierror:
                pass

        return rules

    def _generate_aws_rules(self) -> List[str]:
        """生成 AWS 安全组规则"""
        rules = []

        for url in self.required_urls:
            # AWS 需要使用 IP 范围
            # 这里简化处理，实际需要查询 IP 范围
            rule = {
                'type': 'egress',
                'protocol': 'tcp',
                'port': 443,
                'destination': url,
                'action': 'allow'
            }
            rules.append(rule)

        return rules

    def _generate_gcp_rules(self) -> List[str]:
        """生成 GCP 防火墙规则"""
        rules = []

        for url in self.required_urls:
            rule = {
                'direction': 'EGRESS',
                'action': 'ALLOW',
                'rules': [{
                    'protocol': 'tcp',
                    'ports': ['443'],
                    'destinationRanges': [self._resolve_ip_range(url)]
                }]
            }
            rules.append(rule)

        return rules

    def _resolve_ip_range(self, url: str) -> str:
        """解析 IP 范围"""
        # 简化实现，实际需要查询 DNS 或 IP 范围
        try:
            ip = socket.gethostbyname(url)
            return f"{ip}/32"
        except socket.gaierror:
            return "0.0.0.0/0"

### 网络连接测试

class NetworkTester:
"""网络测试器"""
def __init__(self):
self.required_urls = [
'https://api.anthropic.com',
'https://claude.ai',
'https://statsig.anthropic.com'
]
def test_all(self) -> NetworkTestResult:
"""测试所有网络连接"""
result = NetworkTestResult()
for url in self.required_urls:
test_result = self._test_url(url)
result.add_result(url, test_result)
# 生成报告
result.summary = self._generate_summary(result.results)
return result
def _test_url(self, url: str) -> URLTestResult:
"""测试单个 URL"""
result = URLTestResult(url=url)
try:
start_time = time.time()
response = requests.get(url, timeout=10)
end_time = time.time()
result.success = response.status_code == 200
result.latency = (end_time - start_time) * 1000  # ms
result.status_code = response.status_code
except requests.exceptions.Timeout:
result.success = False
result.error = "Timeout"
except requests.exceptions.ConnectionError:
result.success = False
result.error = "Connection error"
except Exception as e:
result.success = False
result.error = str(e)
return result
def _generate_summary(self,
results: Dict[str, URLTestResult]) -> str:
"""生成测试摘要"""
total = len(results)
successful = sum(1 for r in results.values() if r.success)
summary = f"Network Test Summary:\n"
summary += f"Total: {total}, Successful: {successful}, Failed: {total - successful}\n\n"
for url, result in results.items():
status = "✓" if result.success else "✗"
summary += f"{status} {url}: "
if result.success:
summary += f"OK ({result.latency:.0f}ms)\n"
else:
summary += f"FAILED ({result.error})\n"
return summary
```

---

## 2 企业安全配置

**URL**: https://claudecode.tangshuang.net/course/32.2%20%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE

#### 32.2.1 身份验证与授权#

##### API 密钥管理#

###### 集中式密钥管理

class APIKeyManager:
"""API 密钥管理器"""

def init(self):
self.vault_url = os.getenv('VAULT_ADDR')
self.vault_token = os.getenv('VAULT_TOKEN')
self.key_cache = {}
self.cache_ttl = 3600  # 1 hour

def get_key(self, key_name: str) -> str:
"""获取 API 密钥"""

### 检查缓存

if key_name in self.key_cache:

cached = self.key_cache[key_name]
if time.time() - cached['timestamp'] < self.cache_ttl:
return cached['key']

### 从 Vault 获取

key = self._fetch_from_vault(key_name)

### 缓存密钥

self.key_cache[key_name] = {
'key': key,
'timestamp': time.time()
}

return key

def _fetch_from_vault(self, key_name: str) -> str:
"""从 Vault 获取密钥"""
try:
response = requests.get(
f"{self.vault_url}/v1/secret/data/{key_name}",
headers={'X-Vault-Token': self.vault_token}
)

if response.status_code == 200:
data = response.json()
return data['data']['data']['value']
else:
raise Exception(f"Failed to fetch key: {response.status_code}")
except Exception as e:
logger.error(f"Error fetching key from vault: {e}")
raise

###### 密钥轮换策略

```
bash复制python

class KeyRotationManager:
    """密钥轮换管理器"""

    def __init__(self):
        self.rotation_schedule = {}
        self.rotation_history = []

    def schedule_rotation(self, key_name: str,
                        interval_days: int = 90):
        """安排密钥轮换"""
        next_rotation = datetime.now() + timedelta(days=interval_days)
        self.rotation_schedule[key_name] = {
            'interval_days': interval_days,
            'next_rotation': next_rotation,
            'last_rotation': None
        }

        logger.info(f"Scheduled rotation for {key_name} in {interval_days} days")

    def check_rotations(self) -> List[str]:
        """检查需要轮换的密钥"""
        now = datetime.now()
        keys_to_rotate = []

        for key_name, schedule in self.rotation_schedule.items():
            if schedule['next_rotation'] <= now:
                keys_to_rotate.append(key_name)

        return keys_to_rotate

    def rotate_key(self, key_name: str) -> RotationResult:
        """轮换密钥"""
        result = RotationResult(key_name=key_name)

        try:
            # 生成新密钥
            new_key = self._generate_new_key()

            # 更新配置
            self._update_key_configuration(key_name, new_key)

            # 记录轮换
            self.rotation_history.append({
                'key_name': key_name,
                'rotated_at': datetime.now(),
                'old_key_hash': self._hash_key(self._get_old_key(key_name)),
                'new_key_hash': self._hash_key(new_key)
            })

            # 更新轮换计划
            self.rotation_schedule[key_name]['last_rotation'] = datetime.now()
            self.rotation_schedule[key_name]['next_rotation'] = \
                datetime.now() + timedelta(
                    days=self.rotation_schedule[key_name]['interval_days']
                )

            result.success = True
            result.new_key = new_key

        except Exception as e:
            result.success = False
            result.error = str(e)

        return result

### SSO 集成

#### OAuth 2.0 配置

class SSOAuthenticator:
"""SSO 认证器"""
def __init__(self, config: Dict):
self.client_id = config['client_id']
self.client_secret = config['client_secret']
self.redirect_uri = config['redirect_uri']
self.auth_url = config['auth_url']
self.token_url = config['token_url']
self.scopes = config.get('scopes', ['openid', 'profile'])
def get_auth_url(self, state: str = None) -> str:
"""获取认证 URL"""
params = {
'response_type': 'code',
'client_id': self.client_id,
'redirect_uri': self.redirect_uri,
'scope': ' '.join(self.scopes),
'state': state or self._generate_state()
}
return f"{self.auth_url}?{urllib.parse.urlencode(params)}"
def exchange_code_for_token(self,
auth_code: str) -> TokenResponse:
"""用授权码交换访问令牌"""
data = {
'grant_type': 'authorization_code',
'code': auth_code,
'client_id': self.client_id,
'client_secret': self.client_secret,
'redirect_uri': self.redirect_uri
}
response = requests.post(self.token_url, data=data)
if response.status_code == 200:
token_data = response.json()
return TokenResponse(
access_token=token_data['access_token'],
refresh_token=token_data.get('refresh_token'),
expires_in=token_data.get('expires_in', 3600),
token_type=token_data.get('token_type', 'Bearer')
)
else:
raise Exception(f"Token exchange failed: {response.status_code}")
def refresh_access_token(self,
refresh_token: str) -> TokenResponse:
"""刷新访问令牌"""
data = {
'grant_type': 'refresh_token',
'refresh_token': refresh_token,
'client_id': self.client_id,
'client_secret': self.client_secret
}
response = requests.post(self.token_url, data=data)
if response.status_code == 200:
token_data = response.json()
return TokenResponse(
access_token=token_data['access_token'],
refresh_token=token_data.get('refresh_token', refresh_token),
expires_in=token_data.get('expires_in', 3600),
token_type=token_data.get('token_type', 'Bearer')
)
else:
raise Exception(f"Token refresh failed: {response.status_code}")
def _generate_state(self) -> str:
"""生成状态参数"""
return secrets.token_urlsafe(16)
```

```
python

class KeyRotationManager:
    """密钥轮换管理器"""

    def __init__(self):
        self.rotation_schedule = {}
        self.rotation_history = []

    def schedule_rotation(self, key_name: str,
                        interval_days: int = 90):
        """安排密钥轮换"""
        next_rotation = datetime.now() + timedelta(days=interval_days)
        self.rotation_schedule[key_name] = {
            'interval_days': interval_days,
            'next_rotation': next_rotation,
            'last_rotation': None
        }

        logger.info(f"Scheduled rotation for {key_name} in {interval_days} days")

    def check_rotations(self) -> List[str]:
        """检查需要轮换的密钥"""
        now = datetime.now()
        keys_to_rotate = []

        for key_name, schedule in self.rotation_schedule.items():
            if schedule['next_rotation'] <= now:
                keys_to_rotate.append(key_name)

        return keys_to_rotate

    def rotate_key(self, key_name: str) -> RotationResult:
        """轮换密钥"""
        result = RotationResult(key_name=key_name)

        try:
            # 生成新密钥
            new_key = self._generate_new_key()

            # 更新配置
            self._update_key_configuration(key_name, new_key)

            # 记录轮换
            self.rotation_history.append({
                'key_name': key_name,
                'rotated_at': datetime.now(),
                'old_key_hash': self._hash_key(self._get_old_key(key_name)),
                'new_key_hash': self._hash_key(new_key)
            })

            # 更新轮换计划
            self.rotation_schedule[key_name]['last_rotation'] = datetime.now()
            self.rotation_schedule[key_name]['next_rotation'] = \
                datetime.now() + timedelta(
                    days=self.rotation_schedule[key_name]['interval_days']
                )

            result.success = True
            result.new_key = new_key

        except Exception as e:
            result.success = False
            result.error = str(e)

        return result

### SSO 集成

#### OAuth 2.0 配置

class SSOAuthenticator:
"""SSO 认证器"""
def __init__(self, config: Dict):
self.client_id = config['client_id']
self.client_secret = config['client_secret']
self.redirect_uri = config['redirect_uri']
self.auth_url = config['auth_url']
self.token_url = config['token_url']
self.scopes = config.get('scopes', ['openid', 'profile'])
def get_auth_url(self, state: str = None) -> str:
"""获取认证 URL"""
params = {
'response_type': 'code',
'client_id': self.client_id,
'redirect_uri': self.redirect_uri,
'scope': ' '.join(self.scopes),
'state': state or self._generate_state()
}
return f"{self.auth_url}?{urllib.parse.urlencode(params)}"
def exchange_code_for_token(self,
auth_code: str) -> TokenResponse:
"""用授权码交换访问令牌"""
data = {
'grant_type': 'authorization_code',
'code': auth_code,
'client_id': self.client_id,
'client_secret': self.client_secret,
'redirect_uri': self.redirect_uri
}
response = requests.post(self.token_url, data=data)
if response.status_code == 200:
token_data = response.json()
return TokenResponse(
access_token=token_data['access_token'],
refresh_token=token_data.get('refresh_token'),
expires_in=token_data.get('expires_in', 3600),
token_type=token_data.get('token_type', 'Bearer')
)
else:
raise Exception(f"Token exchange failed: {response.status_code}")
def refresh_access_token(self,
refresh_token: str) -> TokenResponse:
"""刷新访问令牌"""
data = {
'grant_type': 'refresh_token',
'refresh_token': refresh_token,
'client_id': self.client_id,
'client_secret': self.client_secret
}
response = requests.post(self.token_url, data=data)
if response.status_code == 200:
token_data = response.json()
return TokenResponse(
access_token=token_data['access_token'],
refresh_token=token_data.get('refresh_token', refresh_token),
expires_in=token_data.get('expires_in', 3600),
token_type=token_data.get('token_type', 'Bearer')
)
else:
raise Exception(f"Token refresh failed: {response.status_code}")
def _generate_state(self) -> str:
"""生成状态参数"""
return secrets.token_urlsafe(16)
```

##### 多因素认证 (MFA)#

```
bash复制python

class MFAAuthenticator:
    """MFA 认证器"""

    def __init__(self):
        self.mfa_methods = {
            'totp': self._verify_totp,
            'sms': self._verify_sms,
            'email': self._verify_email
        }

    def verify_mfa(self, method: str,
                   code: str,
                   user_id: str) -> bool:
        """验证 MFA 代码"""
        verifier = self.mfa_methods.get(method)

        if not verifier:
            raise ValueError(f"Unsupported MFA method: {method}")

        return verifier(code, user_id)

    def _verify_totp(self, code: str, user_id: str) -> bool:
        """验证 TOTP 代码"""
        # 获取用户的 TOTP 密钥
        secret = self._get_totp_secret(user_id)

        # 生成预期的代码
        totp = pyotp.TOTP(secret)
        expected_code = totp.now()

        # 验证代码（允许时间窗口）
        return totp.verify(code, valid_window=1)

    def _verify_sms(self, code: str, user_id: str) -> bool:
        """验证 SMS 代码"""
        # 从数据库获取发送的代码
        stored_code = self._get_stored_sms_code(user_id)

        # 验证代码
        return stored_code == code and not self._is_code_expired(user_id)

    def _verify_email(self, code: str, user_id: str) -> bool:
        """验证邮件代码"""
        # 从数据库获取发送的代码
        stored_code = self._get_stored_email_code(user_id)

        # 验证代码
        return stored_code == code and not self._is_code_expired(user_id)

## 32.2.2 权限控制

### 基于角色的访问控制 (RBAC)

class RBACManager:
"""RBAC 管理器"""
def __init__(self):
self.roles = {}
self.permissions = {}
self.user_roles = {}
def define_role(self, role_name: str,
permissions: List[str]):
"""定义角色"""
self.roles[role_name] = permissions
logger.info(f"Role {role_name} defined with {len(permissions)} permissions")
def assign_role(self, user_id: str, role_name: str):
"""为用户分配角色"""
if role_name not in self.roles:
raise ValueError(f"Role {role_name} not defined")
if user_id not in self.user_roles:
self.user_roles[user_id] = []
if role_name not in self.user_roles[user_id]:
self.user_roles[user_id].append(role_name)
logger.info(f"Role {role_name} assigned to user {user_id}")
def check_permission(self, user_id: str,
permission: str) -> bool:
"""检查用户权限"""
user_roles = self.user_roles.get(user_id, [])
for role in user_roles:
role_permissions = self.roles.get(role, [])
if permission in role_permissions:
return True
return False
def get_user_permissions(self, user_id: str) -> List[str]:
"""获取用户的所有权限"""
user_roles = self.user_roles.get(user_id, [])
all_permissions = set()
for role in user_roles:
role_permissions = self.roles.get(role, [])
all_permissions.update(role_permissions)
return list(all_permissions)
```

```
python

class MFAAuthenticator:
    """MFA 认证器"""

    def __init__(self):
        self.mfa_methods = {
            'totp': self._verify_totp,
            'sms': self._verify_sms,
            'email': self._verify_email
        }

    def verify_mfa(self, method: str,
                   code: str,
                   user_id: str) -> bool:
        """验证 MFA 代码"""
        verifier = self.mfa_methods.get(method)

        if not verifier:
            raise ValueError(f"Unsupported MFA method: {method}")

        return verifier(code, user_id)

    def _verify_totp(self, code: str, user_id: str) -> bool:
        """验证 TOTP 代码"""
        # 获取用户的 TOTP 密钥
        secret = self._get_totp_secret(user_id)

        # 生成预期的代码
        totp = pyotp.TOTP(secret)
        expected_code = totp.now()

        # 验证代码（允许时间窗口）
        return totp.verify(code, valid_window=1)

    def _verify_sms(self, code: str, user_id: str) -> bool:
        """验证 SMS 代码"""
        # 从数据库获取发送的代码
        stored_code = self._get_stored_sms_code(user_id)

        # 验证代码
        return stored_code == code and not self._is_code_expired(user_id)

    def _verify_email(self, code: str, user_id: str) -> bool:
        """验证邮件代码"""
        # 从数据库获取发送的代码
        stored_code = self._get_stored_email_code(user_id)

        # 验证代码
        return stored_code == code and not self._is_code_expired(user_id)

## 32.2.2 权限控制

### 基于角色的访问控制 (RBAC)

class RBACManager:
"""RBAC 管理器"""
def __init__(self):
self.roles = {}
self.permissions = {}
self.user_roles = {}
def define_role(self, role_name: str,
permissions: List[str]):
"""定义角色"""
self.roles[role_name] = permissions
logger.info(f"Role {role_name} defined with {len(permissions)} permissions")
def assign_role(self, user_id: str, role_name: str):
"""为用户分配角色"""
if role_name not in self.roles:
raise ValueError(f"Role {role_name} not defined")
if user_id not in self.user_roles:
self.user_roles[user_id] = []
if role_name not in self.user_roles[user_id]:
self.user_roles[user_id].append(role_name)
logger.info(f"Role {role_name} assigned to user {user_id}")
def check_permission(self, user_id: str,
permission: str) -> bool:
"""检查用户权限"""
user_roles = self.user_roles.get(user_id, [])
for role in user_roles:
role_permissions = self.roles.get(role, [])
if permission in role_permissions:
return True
return False
def get_user_permissions(self, user_id: str) -> List[str]:
"""获取用户的所有权限"""
user_roles = self.user_roles.get(user_id, [])
all_permissions = set()
for role in user_roles:
role_permissions = self.roles.get(role, [])
all_permissions.update(role_permissions)
return list(all_permissions)
```

##### 权限策略定义#

```
bash复制python

class PermissionPolicy:
    """权限策略"""

    # 定义权限
    PERMISSIONS = {
        'code:generate': 'Generate code',
        'code:read': 'Read code',
        'code:write': 'Write code',
        'code:delete': 'Delete code',
        'file:read': 'Read files',
        'file:write': 'Write files',
        'file:delete': 'Delete files',
        'tool:execute': 'Execute tools',
        'config:manage': 'Manage configuration',
        'user:manage': 'Manage users'
    }

    # 定义角色
    ROLES = {
        'viewer': [
            'code:read',
            'file:read'
        ],
        'developer': [
            'code:read',
            'code:write',
            'code:generate',
            'file:read',
            'file:write',
            'tool:execute'
        ],
        'senior_developer': [
            'code:read',
            'code:write',
            'code:generate',
            'code:delete',
            'file:read',
            'file:write',
            'file:delete',
            'tool:execute'
        ],
        'admin': [
            'code:read',
            'code:write',
            'code:generate',
            'code:delete',
            'file:read',
            'file:write',
            'file:delete',
            'tool:execute',
            'config:manage',
            'user:manage'
        ]
    }

### 权限检查中间件

class PermissionMiddleware:
"""权限检查中间件"""
def __init__(self, rbac_manager: RBACManager):
self.rbac_manager = rbac_manager
def check_permission(self,
user_id: str,
required_permission: str) -> bool:
"""检查权限"""
has_permission = self.rbac_manager.check_permission(
user_id,
required_permission
)
if not has_permission:
logger.warning(
f"Permission denied: user={user_id}, "
f"permission={required_permission}"
)
return has_permission
def require_permission(self, permission: str):
"""权限装饰器"""
def decorator(func):
def wrapper(*args, **kwargs):
# 获取用户 ID
user_id = self._get_user_id()
# 检查权限
if not self.check_permission(user_id, permission):
raise PermissionError(
f"Permission denied: {permission}"
)
# 执行函数
return func(*args, **kwargs)
return wrapper
return decorator
def _get_user_id(self) -> str:
"""获取当前用户 ID"""
# 从上下文或会话中获取
return os.getenv('USER_ID', 'anonymous')
```

```
python

class PermissionPolicy:
    """权限策略"""

    # 定义权限
    PERMISSIONS = {
        'code:generate': 'Generate code',
        'code:read': 'Read code',
        'code:write': 'Write code',
        'code:delete': 'Delete code',
        'file:read': 'Read files',
        'file:write': 'Write files',
        'file:delete': 'Delete files',
        'tool:execute': 'Execute tools',
        'config:manage': 'Manage configuration',
        'user:manage': 'Manage users'
    }

    # 定义角色
    ROLES = {
        'viewer': [
            'code:read',
            'file:read'
        ],
        'developer': [
            'code:read',
            'code:write',
            'code:generate',
            'file:read',
            'file:write',
            'tool:execute'
        ],
        'senior_developer': [
            'code:read',
            'code:write',
            'code:generate',
            'code:delete',
            'file:read',
            'file:write',
            'file:delete',
            'tool:execute'
        ],
        'admin': [
            'code:read',
            'code:write',
            'code:generate',
            'code:delete',
            'file:read',
            'file:write',
            'file:delete',
            'tool:execute',
            'config:manage',
            'user:manage'
        ]
    }

### 权限检查中间件

class PermissionMiddleware:
"""权限检查中间件"""
def __init__(self, rbac_manager: RBACManager):
self.rbac_manager = rbac_manager
def check_permission(self,
user_id: str,
required_permission: str) -> bool:
"""检查权限"""
has_permission = self.rbac_manager.check_permission(
user_id,
required_permission
)
if not has_permission:
logger.warning(
f"Permission denied: user={user_id}, "
f"permission={required_permission}"
)
return has_permission
def require_permission(self, permission: str):
"""权限装饰器"""
def decorator(func):
def wrapper(*args, **kwargs):
# 获取用户 ID
user_id = self._get_user_id()
# 检查权限
if not self.check_permission(user_id, permission):
raise PermissionError(
f"Permission denied: {permission}"
)
# 执行函数
return func(*args, **kwargs)
return wrapper
return decorator
def _get_user_id(self) -> str:
"""获取当前用户 ID"""
# 从上下文或会话中获取
return os.getenv('USER_ID', 'anonymous')
```

#### 32.2.3 审计日志#

##### 审计日志记录器#

```
bash复制python

class AuditLogger:
    """审计日志记录器"""

    def __init__(self, config: Dict):
        self.log_file = config.get('log_file', 'audit.log')
        self.log_level = config.get('log_level', 'INFO')
        self.retention_days = config.get('retention_days', 90)

        # 配置日志
        self.logger = logging.getLogger('audit')
        self.logger.setLevel(getattr(logging, self.log_level))

        # 文件处理器
        handler = logging.FileHandler(self.log_file)
        handler.setFormatter(
            logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
        )
        self.logger.addHandler(handler)

    def log_event(self, event: AuditEvent):
        """记录审计事件"""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'user_id': event.user_id,
            'action': event.action,
            'resource': event.resource,
            'result': event.result,
            'ip_address': event.ip_address,
            'user_agent': event.user_agent,
            'metadata': event.metadata
        }

        self.logger.info(json.dumps(log_entry))

    def log_api_call(self, user_id: str,
                    endpoint: str,
                    method: str,
                    status_code: int,
                    duration_ms: float):
        """记录 API 调用"""
        event = AuditEvent(
            user_id=user_id,
            action='API_CALL',
            resource=endpoint,
            result=str(status_code),
            metadata={
                'method': method,
                'duration_ms': duration_ms
            }
        )
        self.log_event(event)

    def log_file_access(self, user_id: str,
                      file_path: str,
                      action: str,
                      result: str):
        """记录文件访问"""
        event = AuditEvent(
            user_id=user_id,
            action=f'FILE_{action.upper()}',
            resource=file_path,
            result=result
        )
        self.log_event(event)

    def log_permission_check(self, user_id: str,
                           permission: str,
                           granted: bool):
        """记录权限检查"""
        event = AuditEvent(
            user_id=user_id,
            action='PERMISSION_CHECK',
            resource=permission,
            result='GRANTED' if granted else 'DENIED'
        )
        self.log_event(event)

    def cleanup_old_logs(self):
        """清理旧日志"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)

        # 读取日志文件
        with open(self.log_file, 'r') as f:
            lines = f.readlines()

        # 过滤旧日志
        filtered_lines = []
        for line in lines:
            try:
                log_entry = json.loads(line)
                log_date = datetime.fromisoformat(log_entry['timestamp'])
                if log_date > cutoff_date:
                    filtered_lines.append(line)
            except (json.JSONDecodeError, ValueError):
                # 保留无法解析的行
                filtered_lines.append(line)

        # 写回文件
        with open(self.log_file, 'w') as f:
            f.writelines(filtered_lines)

        logger.info(f"Cleaned up audit logs, removed {len(lines) - len(filtered_lines)} entries")

### 审计事件类型

class AuditEvent:
"""审计事件"""
def __init__(self,
user_id: str,
action: str,
resource: str = None,
result: str = None,
ip_address: str = None,
user_agent: str = None,
metadata: Dict = None):
self.user_id = user_id
self.action = action
self.resource = resource
self.result = result
self.ip_address = ip_address or self._get_client_ip()
self.user_agent = user_agent or self._get_user_agent()
self.metadata = metadata or {}
def _get_client_ip(self) -> str:
"""获取客户端 IP"""
# 从请求上下文中获取
return os.getenv('REMOTE_ADDR', 'unknown')
def _get_user_agent(self) -> str:
"""获取用户代理"""
# 从请求头中获取
return os.getenv('HTTP_USER_AGENT', 'unknown')
```

```
python

class AuditLogger:
    """审计日志记录器"""

    def __init__(self, config: Dict):
        self.log_file = config.get('log_file', 'audit.log')
        self.log_level = config.get('log_level', 'INFO')
        self.retention_days = config.get('retention_days', 90)

        # 配置日志
        self.logger = logging.getLogger('audit')
        self.logger.setLevel(getattr(logging, self.log_level))

        # 文件处理器
        handler = logging.FileHandler(self.log_file)
        handler.setFormatter(
            logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
        )
        self.logger.addHandler(handler)

    def log_event(self, event: AuditEvent):
        """记录审计事件"""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'user_id': event.user_id,
            'action': event.action,
            'resource': event.resource,
            'result': event.result,
            'ip_address': event.ip_address,
            'user_agent': event.user_agent,
            'metadata': event.metadata
        }

        self.logger.info(json.dumps(log_entry))

    def log_api_call(self, user_id: str,
                    endpoint: str,
                    method: str,
                    status_code: int,
                    duration_ms: float):
        """记录 API 调用"""
        event = AuditEvent(
            user_id=user_id,
            action='API_CALL',
            resource=endpoint,
            result=str(status_code),
            metadata={
                'method': method,
                'duration_ms': duration_ms
            }
        )
        self.log_event(event)

    def log_file_access(self, user_id: str,
                      file_path: str,
                      action: str,
                      result: str):
        """记录文件访问"""
        event = AuditEvent(
            user_id=user_id,
            action=f'FILE_{action.upper()}',
            resource=file_path,
            result=result
        )
        self.log_event(event)

    def log_permission_check(self, user_id: str,
                           permission: str,
                           granted: bool):
        """记录权限检查"""
        event = AuditEvent(
            user_id=user_id,
            action='PERMISSION_CHECK',
            resource=permission,
            result='GRANTED' if granted else 'DENIED'
        )
        self.log_event(event)

    def cleanup_old_logs(self):
        """清理旧日志"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)

        # 读取日志文件
        with open(self.log_file, 'r') as f:
            lines = f.readlines()

        # 过滤旧日志
        filtered_lines = []
        for line in lines:
            try:
                log_entry = json.loads(line)
                log_date = datetime.fromisoformat(log_entry['timestamp'])
                if log_date > cutoff_date:
                    filtered_lines.append(line)
            except (json.JSONDecodeError, ValueError):
                # 保留无法解析的行
                filtered_lines.append(line)

        # 写回文件
        with open(self.log_file, 'w') as f:
            f.writelines(filtered_lines)

        logger.info(f"Cleaned up audit logs, removed {len(lines) - len(filtered_lines)} entries")

### 审计事件类型

class AuditEvent:
"""审计事件"""
def __init__(self,
user_id: str,
action: str,
resource: str = None,
result: str = None,
ip_address: str = None,
user_agent: str = None,
metadata: Dict = None):
self.user_id = user_id
self.action = action
self.resource = resource
self.result = result
self.ip_address = ip_address or self._get_client_ip()
self.user_agent = user_agent or self._get_user_agent()
self.metadata = metadata or {}
def _get_client_ip(self) -> str:
"""获取客户端 IP"""
# 从请求上下文中获取
return os.getenv('REMOTE_ADDR', 'unknown')
def _get_user_agent(self) -> str:
"""获取用户代理"""
# 从请求头中获取
return os.getenv('HTTP_USER_AGENT', 'unknown')
```

#### 32.2.4 数据保护#

##### 数据分类#

```
bash复制python

class DataClassifier:
    """数据分类器"""

    def __init__(self):
        self.classification_rules = {
            'public': {
                'description': '可以公开访问的数据',
                'examples': ['public documentation', 'open source code']
            },
            'internal': {
                'description': '仅限内部访问的数据',
                'examples': ['internal documentation', 'proprietary code']
            },
            'confidential': {
                'description': '需要特殊保护的数据',
                'examples': ['customer data', 'financial information']
            },
            'restricted': {
                'description': '最高级别的保护',
                'examples': ['PII', 'trade secrets']
            }
        }

    def classify(self, data: str,
                context: Dict = None) -> str:
        """分类数据"""
        # 检查敏感关键词
        if self._contains_pii(data):
            return 'restricted'

        # 检查上下文
        if context:
            if context.get('source') == 'customer':
                return 'confidential'
            elif context.get('access_level') == 'internal':
                return 'internal'

        # 默认分类
        return 'public'

    def _contains_pii(self, data: str) -> bool:
        """检查是否包含 PII"""
        pii_patterns = [
            r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
            r'\b\d{16}\b',  # Credit card
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'  # Email
        ]

        for pattern in pii_patterns:
            if re.search(pattern, data):
                return True

        return False

### 数据脱敏

class DataMasker:
"""数据脱敏器"""
def __init__(self):
self.masking_rules = {
'email': self._mask_email,
'phone': self._mask_phone,
'ssn': self._mask_ssn,
'credit_card': self._mask_credit_card,
'ip_address': self._mask_ip_address
}
def mask_data(self, data: str,
data_type: str = 'auto') -> str:
"""脱敏数据"""
if data_type == 'auto':
data_type = self._detect_data_type(data)
masker = self.masking_rules.get(data_type)
if masker:
return masker(data)
else:
return data
def _mask_email(self, email: str) -> str:
"""脱敏邮箱"""
if '@' not in email:
return email
local, domain = email.split('@', 1)
masked_local = local[0] + '***' + local[-1:] if len(local) > 3 else '***'
return f"{masked_local}@{domain}"
def _mask_phone(self, phone: str) -> str:
"""脱敏电话号码"""
digits = re.sub(r'\D', '', phone)
if len(digits) >= 10:
return f"***-***-{digits[-4:]}"
else:
return '***-***'
def _mask_ssn(self, ssn: str) -> str:
"""脱敏 SSN"""
digits = re.sub(r'\D', '', ssn)
if len(digits) == 9:
return f"***-**-{digits[-4:]}"
else:
return '***-**-****'
def _mask_credit_card(self, card: str) -> str:
"""脱敏信用卡号"""
digits = re.sub(r'\D', '', card)
if len(digits) >= 13:
return f"****-****-****-{digits[-4:]}"
else:
return '****-****-****-****'
def _detect_data_type(self, data: str) -> str:
"""检测数据类型"""
if '@' in data and '.' in data.split('@')[1]:
return 'email'
elif re.match(r'^\d{3}-\d{2}-\d{4}$', data):
return 'ssn'
elif re.match(r'^\d{16}$', re.sub(r'\D', '', data)):
return 'credit_card'
elif re.match(r'^\d{10}$', re.sub(r'\D', '', data)):
return 'phone'
else:
return 'unknown'
```

```
python

class DataClassifier:
    """数据分类器"""

    def __init__(self):
        self.classification_rules = {
            'public': {
                'description': '可以公开访问的数据',
                'examples': ['public documentation', 'open source code']
            },
            'internal': {
                'description': '仅限内部访问的数据',
                'examples': ['internal documentation', 'proprietary code']
            },
            'confidential': {
                'description': '需要特殊保护的数据',
                'examples': ['customer data', 'financial information']
            },
            'restricted': {
                'description': '最高级别的保护',
                'examples': ['PII', 'trade secrets']
            }
        }

    def classify(self, data: str,
                context: Dict = None) -> str:
        """分类数据"""
        # 检查敏感关键词
        if self._contains_pii(data):
            return 'restricted'

        # 检查上下文
        if context:
            if context.get('source') == 'customer':
                return 'confidential'
            elif context.get('access_level') == 'internal':
                return 'internal'

        # 默认分类
        return 'public'

    def _contains_pii(self, data: str) -> bool:
        """检查是否包含 PII"""
        pii_patterns = [
            r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
            r'\b\d{16}\b',  # Credit card
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'  # Email
        ]

        for pattern in pii_patterns:
            if re.search(pattern, data):
                return True

        return False

### 数据脱敏

class DataMasker:
"""数据脱敏器"""
def __init__(self):
self.masking_rules = {
'email': self._mask_email,
'phone': self._mask_phone,
'ssn': self._mask_ssn,
'credit_card': self._mask_credit_card,
'ip_address': self._mask_ip_address
}
def mask_data(self, data: str,
data_type: str = 'auto') -> str:
"""脱敏数据"""
if data_type == 'auto':
data_type = self._detect_data_type(data)
masker = self.masking_rules.get(data_type)
if masker:
return masker(data)
else:
return data
def _mask_email(self, email: str) -> str:
"""脱敏邮箱"""
if '@' not in email:
return email
local, domain = email.split('@', 1)
masked_local = local[0] + '***' + local[-1:] if len(local) > 3 else '***'
return f"{masked_local}@{domain}"
def _mask_phone(self, phone: str) -> str:
"""脱敏电话号码"""
digits = re.sub(r'\D', '', phone)
if len(digits) >= 10:
return f"***-***-{digits[-4:]}"
else:
return '***-***'
def _mask_ssn(self, ssn: str) -> str:
"""脱敏 SSN"""
digits = re.sub(r'\D', '', ssn)
if len(digits) == 9:
return f"***-**-{digits[-4:]}"
else:
return '***-**-****'
def _mask_credit_card(self, card: str) -> str:
"""脱敏信用卡号"""
digits = re.sub(r'\D', '', card)
if len(digits) >= 13:
return f"****-****-****-{digits[-4:]}"
else:
return '****-****-****-****'
def _detect_data_type(self, data: str) -> str:
"""检测数据类型"""
if '@' in data and '.' in data.split('@')[1]:
return 'email'
elif re.match(r'^\d{3}-\d{2}-\d{4}$', data):
return 'ssn'
elif re.match(r'^\d{16}$', re.sub(r'\D', '', data)):
return 'credit_card'
elif re.match(r'^\d{10}$', re.sub(r'\D', '', data)):
return 'phone'
else:
return 'unknown'
```

---

# 第 33 章

## 1 LLM 网关概述

**URL**: https://claudecode.tangshuang.net/course/33.1%20LLM%20%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0

#### 33.1.1 什么是 LLM 网关#

LLM 网关是位于 Claude Code 和模型提供商之间的中间层，提供集中式的模型访问管理。它充当代理，处理所有与 LLM API 的交互，为企业提供额外的控制和管理能力。

##### LLM 网关的核心功能#

True. 集中身份验证：统一管理所有用户的 API 密钥和凭证
True. 使用情况跟踪：监控跨团队和项目的使用情况
True. 成本控制：实施预算限制和速率限制
True. 审计日志：记录所有模型交互以满足合规要求
True. 模型路由：在不同提供商和模型之间动态切换
True. 负载均衡：在多个 API 端点之间分配请求
True. 缓存优化：缓存常见查询以减少成本和延迟

##### LLM 网关架构#

┌─────────────────────────────────────────┐
│        Claude Code 客户端            │
│  (多个用户、多个会话)              │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│           LLM 网关                │
│  (身份验证、路由、缓存、监控)        │
│  ┌──────────────────────────────┐   │
│  │  认证层                  │   │
│  │  (API 密钥、SSO、MFA)     │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  路由层                  │   │
│  │  (模型选择、负载均衡)       │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  缓存层                  │   │
│  │  (查询缓存、响应缓存)       │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  监控层                  │   │
│  │  (日志、指标、告警)         │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│         模型提供商                 │
│  (Anthropic、Bedrock、Vertex AI)    │
└─────────────────────────────────────────┘

#### 33.1.2 LLM 网关的优势#

##### 与直接访问对比#

##### 企业级优势#

True. 成本优化

- 集中计费和预算控制
- 智能缓存减少重复查询
- 按使用模式优化模型选择

True. 安全增强

- 统一身份验证和授权
- 完整的审计追踪
- 数据脱敏和过滤

True. 运营效率

- 集中配置管理
- 统一监控和告警
- 简化的用户管理

True. 合规支持

- 详细的审计日志
- 数据驻留控制
- 访问控制策略

#### 33.1.3 LLM 网关类型#

##### 1. 开源网关#

###### LiteLLM

LiteLLM 是一个流行的开源 LLM 网关，支持多个提供商：
特点：

- 支持 100+ LLM 提供商
- 统一的 API 接口
- 内置缓存和速率限制
- 成本跟踪和预算控制
- 易于部署和配置
适用场景：
- 需要多提供商支持
- 希望快速部署
- 预算有限

###### LangServe

LangServe 是 LangChain 的服务器组件：
特点：

- 与 LangChain 深度集成
- 支持自定义链和代理
- 实时流式响应
- 灵活的部署选项
适用场景：
- 使用 LangChain 生态
- 需要自定义处理逻辑
- 构建复杂的应用

##### 2. 商业网关#

###### Azure AI Gateway

微软提供的托管网关服务：
特点：

- 完全托管
- 企业级 SLA
- 集成 Azure 生态
- 高级安全功能
适用场景：
- 使用 Azure 基础设施
- 需要托管服务
- 要求高可用性

###### AWS Bedrock Gateway

AWS 提供的网关服务：
特点：

- 与 AWS 服务集成
- 原生 IAM 支持
- CloudWatch 监控
- 自动扩展
适用场景：
- 使用 AWS 基础设施
- 需要与 AWS 集成
- 要求企业级功能

##### 3. 自建网关#

企业可以构建自己的 LLM 网关：
优势：

- 完全控制
- 自定义功能
- 无供应商锁定
挑战：
- 需要开发和维护
- 需要专业知识
- 持续更新成本

#### 33.1.4 网关选择决策#

##### 决策因素#

```
python复制python

class GatewaySelector:
    """网关选择器"""

    def __init__(self):
        self.gateways = {
            'litellm': {
                'type': 'open_source',
                'cost': 'low',
                'complexity': 'low',
                'features': ['caching', 'rate_limiting', 'cost_tracking'],
                'providers': ['anthropic', 'bedrock', 'vertex', 'openai', 'cohere']
            },
            'langserve': {
                'type': 'open_source',
                'cost': 'low',
                'complexity': 'medium',
                'features': ['streaming', 'custom_chains', 'langchain_integration'],
                'providers': ['anthropic', 'openai', 'cohere']
            },
            'azure_gateway': {
                'type': 'commercial',
                'cost': 'high',
                'complexity': 'low',
                'features': ['managed', 'sla', 'azure_integration'],
                'providers': ['anthropic', 'openai', 'azure_openai']
            },
            'aws_gateway': {
                'type': 'commercial',
                'cost': 'high',
                'complexity': 'low',
                'features': ['managed', 'iam_integration', 'cloudwatch'],
                'providers': ['anthropic', 'bedrock', 'ai21']
            },
            'custom': {
                'type': 'custom',
                'cost': 'medium',
                'complexity': 'high',
                'features': ['full_control', 'custom_features'],
                'providers': ['all']
            }
        }

    def select(self, requirements: Dict) -> GatewayRecommendation:
        """选择网关"""
        scores = {}

        # 评估每个网关
        for gateway, metadata in self.gateways.items():
            score = self._evaluate_gateway(gateway, metadata, requirements)
            scores[gateway] = score

        # 选择最佳网关
        best_gateway = max(scores, key=scores.get)

        return GatewayRecommendation(
            gateway=best_gateway,
            score=scores[best_gateway],
            reasoning=self._generate_reasoning(best_gateway, requirements),
            alternatives=self._get_alternatives(scores, best_gateway)
        )

    def _evaluate_gateway(self,
                        gateway: str,
                        metadata: Dict,
                        requirements: Dict) -> float:
        """评估网关"""
        score = 0.0

        # 成本因素
        cost_preference = requirements.get('cost_preference', 'medium')
        cost_scores = {'low': 3, 'medium': 2, 'high': 1}
        score += cost_scores.get(metadata['cost'], 2)

        # 复杂度因素
        complexity_preference = requirements.get('complexity_preference', 'medium')
        complexity_scores = {'low': 3, 'medium': 2, 'high': 1}
        score += complexity_scores.get(metadata['complexity'], 2)

        # 功能匹配
        required_features = requirements.get('required_features', [])
        feature_match = len(
            set(required_features) & set(metadata['features'])
        ) / len(required_features) if required_features else 1.0
        score += feature_match * 2

        # 提供商支持
        required_providers = requirements.get('required_providers', [])
        if required_providers:
            provider_match = len(
                set(required_providers) & set(metadata['providers'])
            ) / len(required_providers)
            score += provider_match * 2

        return score

    def _generate_reasoning(self,
                           gateway: str,
                           requirements: Dict) -> str:
        """生成选择理由"""
        metadata = self.gateways[gateway]

        reasons = []

        if metadata['cost'] == requirements.get('cost_preference'):
            reasons.append(f"Matches cost preference ({metadata['cost']})")

        if metadata['complexity'] == requirements.get('complexity_preference'):
            reasons.append(f"Matches complexity preference ({metadata['complexity']})")

        if 'full_control' in metadata['features']:
            reasons.append("Provides full control over functionality")

        if 'managed' in metadata['features']:
            reasons.append("Fully managed service with SLA")

        return '; '.join(reasons) if reasons else "Best overall match"

```### 选择矩阵

| 需求 | LiteLLM | LangServe | Azure Gateway | AWS Gateway | 自建 |
|-------|----------|-----------|---------------|--------------|-------|
| 低成本 | ✓ | ✓ | ✗ | ✗ | ✓ |
| 快速部署 | ✓ | ✓ | ✓ | ✓ | ✗ |
| 多提供商 | ✓ | ✓ | ✗ | ✗ | ✓ |
| 完全托管 | ✗ | ✗ | ✓ | ✓ | ✗ |
| 自定义功能 | ✗ | ✓ | ✗ | ✗ | ✓ |
| 低维护 | ✓ | ✓ | ✓ | ✓ | ✗ |
| 企业 SLA | ✗ | ✗ | ✓ | ✓ | ✗ |

## 33.1.5 部署前准备

### 需求评估

class GatewayRequirements:
"""网关需求评估"""
def __init__(self):
self.requirements = {
'users': 0,
'requests_per_day': 0,
'providers': [],
'features': [],
'budget': 0.0,
'sla_requirement': None
}
def assess(self, deployment_data: Dict) -> RequirementsReport:
"""评估需求"""
report = RequirementsReport()
# 评估用户数量
report.users = deployment_data.get('users', 10)
# 评估请求量
report.requests_per_day = deployment_data.get('requests_per_day', 1000)
# 评估提供商需求
report.providers = deployment_data.get('providers', ['anthropic'])
# 评估功能需求
report.features = deployment_data.get('features', [])
# 评估预算
report.budget = deployment_data.get('budget', 1000.0)
# 评估 SLA 需求
report.sla_requirement = deployment_data.get('sla_requirement', '99.9%')
# 生成基础设施需求
report.infrastructure = self._calculate_infrastructure_needs(report)
# 生成成本估算
report.estimated_cost = self._estimate_cost(report)
return report
def _calculate_infrastructure_needs(self,
report: RequirementsReport) -> InfrastructureNeeds:
"""计算基础设施需求"""
needs = InfrastructureNeeds()
# CPU 需求
needs.cpu = max(2, report.users // 50)
# 内存需求
needs.memory = max(4, report.users // 25)
# 存储需求
needs.storage = max(20, report.requests_per_day // 100)
# 网络带宽
needs.bandwidth = max(10, report.requests_per_day // 100)
return needs
def _estimate_cost(self,
report: RequirementsReport) -> CostEstimate:
"""估算成本"""
estimate = CostEstimate()
# 基础设施成本
estimate.infrastructure_cost = (
needs.cpu * 20 +  # $20 per CPU core per month
needs.memory * 5 +  # $5 per GB RAM per month
needs.storage * 0.1 +  # $0.1 per GB per month
needs.bandwidth * 10  # $10 per Mbps per month
)
# API 成本
estimate.api_cost = report.requests_per_day * 30 * 0.001  # $0.001 per request
# 网关许可成本（如适用）
estimate.license_cost = 0.0
# 总成本
estimate.total_cost = (
estimate.infrastructure_cost +
estimate.api_cost +
estimate.license_cost
)
return estimate
```

```
python

class GatewaySelector:
    """网关选择器"""

    def __init__(self):
        self.gateways = {
            'litellm': {
                'type': 'open_source',
                'cost': 'low',
                'complexity': 'low',
                'features': ['caching', 'rate_limiting', 'cost_tracking'],
                'providers': ['anthropic', 'bedrock', 'vertex', 'openai', 'cohere']
            },
            'langserve': {
                'type': 'open_source',
                'cost': 'low',
                'complexity': 'medium',
                'features': ['streaming', 'custom_chains', 'langchain_integration'],
                'providers': ['anthropic', 'openai', 'cohere']
            },
            'azure_gateway': {
                'type': 'commercial',
                'cost': 'high',
                'complexity': 'low',
                'features': ['managed', 'sla', 'azure_integration'],
                'providers': ['anthropic', 'openai', 'azure_openai']
            },
            'aws_gateway': {
                'type': 'commercial',
                'cost': 'high',
                'complexity': 'low',
                'features': ['managed', 'iam_integration', 'cloudwatch'],
                'providers': ['anthropic', 'bedrock', 'ai21']
            },
            'custom': {
                'type': 'custom',
                'cost': 'medium',
                'complexity': 'high',
                'features': ['full_control', 'custom_features'],
                'providers': ['all']
            }
        }

    def select(self, requirements: Dict) -> GatewayRecommendation:
        """选择网关"""
        scores = {}

        # 评估每个网关
        for gateway, metadata in self.gateways.items():
            score = self._evaluate_gateway(gateway, metadata, requirements)
            scores[gateway] = score

        # 选择最佳网关
        best_gateway = max(scores, key=scores.get)

        return GatewayRecommendation(
            gateway=best_gateway,
            score=scores[best_gateway],
            reasoning=self._generate_reasoning(best_gateway, requirements),
            alternatives=self._get_alternatives(scores, best_gateway)
        )

    def _evaluate_gateway(self,
                        gateway: str,
                        metadata: Dict,
                        requirements: Dict) -> float:
        """评估网关"""
        score = 0.0

        # 成本因素
        cost_preference = requirements.get('cost_preference', 'medium')
        cost_scores = {'low': 3, 'medium': 2, 'high': 1}
        score += cost_scores.get(metadata['cost'], 2)

        # 复杂度因素
        complexity_preference = requirements.get('complexity_preference', 'medium')
        complexity_scores = {'low': 3, 'medium': 2, 'high': 1}
        score += complexity_scores.get(metadata['complexity'], 2)

        # 功能匹配
        required_features = requirements.get('required_features', [])
        feature_match = len(
            set(required_features) & set(metadata['features'])
        ) / len(required_features) if required_features else 1.0
        score += feature_match * 2

        # 提供商支持
        required_providers = requirements.get('required_providers', [])
        if required_providers:
            provider_match = len(
                set(required_providers) & set(metadata['providers'])
            ) / len(required_providers)
            score += provider_match * 2

        return score

    def _generate_reasoning(self,
                           gateway: str,
                           requirements: Dict) -> str:
        """生成选择理由"""
        metadata = self.gateways[gateway]

        reasons = []

        if metadata['cost'] == requirements.get('cost_preference'):
            reasons.append(f"Matches cost preference ({metadata['cost']})")

        if metadata['complexity'] == requirements.get('complexity_preference'):
            reasons.append(f"Matches complexity preference ({metadata['complexity']})")

        if 'full_control' in metadata['features']:
            reasons.append("Provides full control over functionality")

        if 'managed' in metadata['features']:
            reasons.append("Fully managed service with SLA")

        return '; '.join(reasons) if reasons else "Best overall match"

```### 选择矩阵

| 需求 | LiteLLM | LangServe | Azure Gateway | AWS Gateway | 自建 |
|-------|----------|-----------|---------------|--------------|-------|
| 低成本 | ✓ | ✓ | ✗ | ✗ | ✓ |
| 快速部署 | ✓ | ✓ | ✓ | ✓ | ✗ |
| 多提供商 | ✓ | ✓ | ✗ | ✗ | ✓ |
| 完全托管 | ✗ | ✗ | ✓ | ✓ | ✗ |
| 自定义功能 | ✗ | ✓ | ✗ | ✗ | ✓ |
| 低维护 | ✓ | ✓ | ✓ | ✓ | ✗ |
| 企业 SLA | ✗ | ✗ | ✓ | ✓ | ✗ |

## 33.1.5 部署前准备

### 需求评估

class GatewayRequirements:
"""网关需求评估"""
def __init__(self):
self.requirements = {
'users': 0,
'requests_per_day': 0,
'providers': [],
'features': [],
'budget': 0.0,
'sla_requirement': None
}
def assess(self, deployment_data: Dict) -> RequirementsReport:
"""评估需求"""
report = RequirementsReport()
# 评估用户数量
report.users = deployment_data.get('users', 10)
# 评估请求量
report.requests_per_day = deployment_data.get('requests_per_day', 1000)
# 评估提供商需求
report.providers = deployment_data.get('providers', ['anthropic'])
# 评估功能需求
report.features = deployment_data.get('features', [])
# 评估预算
report.budget = deployment_data.get('budget', 1000.0)
# 评估 SLA 需求
report.sla_requirement = deployment_data.get('sla_requirement', '99.9%')
# 生成基础设施需求
report.infrastructure = self._calculate_infrastructure_needs(report)
# 生成成本估算
report.estimated_cost = self._estimate_cost(report)
return report
def _calculate_infrastructure_needs(self,
report: RequirementsReport) -> InfrastructureNeeds:
"""计算基础设施需求"""
needs = InfrastructureNeeds()
# CPU 需求
needs.cpu = max(2, report.users // 50)
# 内存需求
needs.memory = max(4, report.users // 25)
# 存储需求
needs.storage = max(20, report.requests_per_day // 100)
# 网络带宽
needs.bandwidth = max(10, report.requests_per_day // 100)
return needs
def _estimate_cost(self,
report: RequirementsReport) -> CostEstimate:
"""估算成本"""
estimate = CostEstimate()
# 基础设施成本
estimate.infrastructure_cost = (
needs.cpu * 20 +  # $20 per CPU core per month
needs.memory * 5 +  # $5 per GB RAM per month
needs.storage * 0.1 +  # $0.1 per GB per month
needs.bandwidth * 10  # $10 per Mbps per month
)
# API 成本
estimate.api_cost = report.requests_per_day * 30 * 0.001  # $0.001 per request
# 网关许可成本（如适用）
estimate.license_cost = 0.0
# 总成本
estimate.total_cost = (
estimate.infrastructure_cost +
estimate.api_cost +
estimate.license_cost
)
return estimate
```

---

## 2 LiteLLM 网关部署

**URL**: https://claudecode.tangshuang.net/course/33.2%20LiteLLM%20%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2

#### 33.2.1 LiteLLM 简介#

LiteLLM 是一个开源的 LLM 网关，支持 100+ 个 LLM 提供商，包括 Anthropic、OpenAI、Cohere 等。它提供了统一的 API 接口，简化了多提供商的使用和管理。

##### LiteLLM 的核心特性#

True. 多提供商支持：支持 100+ LLM 提供商
True. 统一 API：一致的 API 接口，简化集成
True. 智能缓存：内置缓存机制，减少成本和延迟
True. 速率限制：可配置的速率限制，控制使用
True. 成本跟踪：详细的使用情况和成本分析
True. 负载均衡：在多个 API 密钥之间分配请求
True. 失败重试：自动重试失败的请求
True. 流式响应：支持流式输出

##### LiteLLM 架构#

┌─────────────────────────────────────────┐
│      Claude Code 客户端              │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│         LiteLLM Proxy               │
│  ┌──────────────────────────────┐   │
│  │  API 层                    │   │
│  │  (Anthropic、OpenAI 等)      │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  缓存层                    │   │
│  │  (Redis、Memcached)          │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  监控层                    │   │
│  │  (Prometheus、Grafana)       │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────────┘
↓
┌─────────────────────────────────────────┐
│        LLM 提供商                  │
│  (Anthropic、OpenAI、Cohere 等)    │
└─────────────────────────────────────────┘

#### 33.2.2 安装和配置#

##### 1. 安装 LiteLLM#

###### 使用 Docker 安装（推荐）

```
bash复制bash

# 拉取 LiteLLM 镜像
docker pull litellm/litellm:latest

# 创建配置目录
mkdir -p ~/litellm/config
cd ~/litellm

# 创建配置文件
cat > config.yaml << EOF
model_list:
  - model_name: claude-sonnet-4
    litellm_params:
      model: claude-sonnet-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

  - model_name: claude-opus-4
    litellm_params:
      model: claude-opus-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

  - model_name: claude-haiku-4
    litellm_params:
      model: claude-haiku-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

litellm_settings:
  drop_params: true
  set_verbose: true

general_settings:
  master_key: sk-litellm-master-key-123456
  database_url: postgresql://user:password@localhost:5432/litellm

security_settings:
  valid_api_keys:
    - sk-team-a-key-123
    - sk-team-b-key-456
EOF

# 启动 LiteLLM
docker run -d \
  --name litellm \
  -p 4000:4000 \
  -v $(pwd)/config.yaml:/app/config.yaml \
  -e ANTHROPIC_API_KEY=sk-ant-xxx \
  litellm/litellm:latest

```#### 使用 Python 安装

# 安装 LiteLLM
pip install litellm[proxy]
# 初始化配置
litellm init
# 编辑配置文件
nano litellm_config.yaml
# 启动代理服务器
litellm proxy --config litellm_config.yaml --port 4000
```

```
bash

# 拉取 LiteLLM 镜像
docker pull litellm/litellm:latest

# 创建配置目录
mkdir -p ~/litellm/config
cd ~/litellm

# 创建配置文件
cat > config.yaml << EOF
model_list:
  - model_name: claude-sonnet-4
    litellm_params:
      model: claude-sonnet-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

  - model_name: claude-opus-4
    litellm_params:
      model: claude-opus-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

  - model_name: claude-haiku-4
    litellm_params:
      model: claude-haiku-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY

litellm_settings:
  drop_params: true
  set_verbose: true

general_settings:
  master_key: sk-litellm-master-key-123456
  database_url: postgresql://user:password@localhost:5432/litellm

security_settings:
  valid_api_keys:
    - sk-team-a-key-123
    - sk-team-b-key-456
EOF

# 启动 LiteLLM
docker run -d \
  --name litellm \
  -p 4000:4000 \
  -v $(pwd)/config.yaml:/app/config.yaml \
  -e ANTHROPIC_API_KEY=sk-ant-xxx \
  litellm/litellm:latest

```#### 使用 Python 安装

# 安装 LiteLLM
pip install litellm[proxy]
# 初始化配置
litellm init
# 编辑配置文件
nano litellm_config.yaml
# 启动代理服务器
litellm proxy --config litellm_config.yaml --port 4000
```

##### 2. 配置文件详解#

```
yaml复制```yaml

# litellm_config.yaml

# 模型列表
model_list:
  # Anthropic Claude 模型
  - model_name: claude-sonnet-4
    litellm_params:
      model: claude-sonnet-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      api_base: https://api.anthropic.com
      max_tokens: 4096
      temperature: 0.7

  - model_name: claude-opus-4
    litellm_params:
      model: claude-opus-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      max_tokens: 4096

  - model_name: claude-haiku-4
    litellm_params:
      model: claude-haiku-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      max_tokens: 4096

  # Amazon Bedrock 模型
  - model_name: bedrock-claude-sonnet
    litellm_params:
      model: anthropic.claude-sonnet-4-5-20250929-v1:0
      api_base: https://bedrock-runtime.us-east-1.amazonaws.com
      api_key: os.environ/AWS_ACCESS_KEY_ID
      aws_secret_access_key: os.environ/AWS_SECRET_ACCESS_KEY
      aws_region_name: us-east-1

  # Google Vertex AI 模型
  - model_name: vertex-claude-sonnet
    litellm_params:
      model: claude-sonnet-4-5@20250929
      api_base: https://us-central1-aiplatform.googleapis.com
      api_key: os.environ/GOOGLE_APPLICATION_CREDENTIALS
      vertex_project: os.environ/VERTEX_PROJECT_ID
      vertex_location: us-central1

# LiteLLM 设置
```

```
```yaml

# litellm_config.yaml

# 模型列表
model_list:
  # Anthropic Claude 模型
  - model_name: claude-sonnet-4
    litellm_params:
      model: claude-sonnet-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      api_base: https://api.anthropic.com
      max_tokens: 4096
      temperature: 0.7

  - model_name: claude-opus-4
    litellm_params:
      model: claude-opus-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      max_tokens: 4096

  - model_name: claude-haiku-4
    litellm_params:
      model: claude-haiku-4-20250514
      api_key: os.environ/ANTHROPIC_API_KEY
      max_tokens: 4096

  # Amazon Bedrock 模型
  - model_name: bedrock-claude-sonnet
    litellm_params:
      model: anthropic.claude-sonnet-4-5-20250929-v1:0
      api_base: https://bedrock-runtime.us-east-1.amazonaws.com
      api_key: os.environ/AWS_ACCESS_KEY_ID
      aws_secret_access_key: os.environ/AWS_SECRET_ACCESS_KEY
      aws_region_name: us-east-1

  # Google Vertex AI 模型
  - model_name: vertex-claude-sonnet
    litellm_params:
      model: claude-sonnet-4-5@20250929
      api_base: https://us-central1-aiplatform.googleapis.com
      api_key: os.environ/GOOGLE_APPLICATION_CREDENTIALS
      vertex_project: os.environ/VERTEX_PROJECT_ID
      vertex_location: us-central1

# LiteLLM 设置
```

litellm_settings:
drop_params: true              # 删除未使用的参数
set_verbose: true              # 启用详细日志
json_logs: true               # JSON 格式日志
success_callback: http://localhost:5000/callback  # 成功回调
failure_callback: http://localhost:5000/failure  # 失败回调

### 通用设置

general_settings:
master_key: sk-litellm-master-key-123456  # 主密钥
database_url: postgresql://user:password@localhost:5432/litellm  # 数据库 URL
cache: redis://localhost:6379  # Redis 缓存
cache_seconds: 3600  # 缓存时间（秒）

### 安全设置

security_settings:
valid_api_keys:  # 有效的 API 密钥
- sk-team-a-key-123
- sk-team-b-key-456
- sk-team-c-key-789
max_budget: 1000.0  # 最大预算（美元）
budget_duration: monthly  # 预算周期
rpm_limit: 100  # 每分钟请求数限制
tpm_limit: 10000  # 每分钟令牌数限制

### 负载均衡设置

load_balancing_settings:
routing_strategy: usage-based  # 路由策略：usage-based, round-robin, least-latency
health_check: true  # 启用健康检查
health_check_interval: 60  # 健康检查间隔（秒）

### 监控设置

monitoring_settings:
enable_prometheus: true  # 启用 Prometheus
prometheus_port: 9090  # Prometheus 端口
enable_slack_alerts: true  # 启用 Slack 告警
slack_webhook_url: https://hooks.slack.com/services/xxx/yyy/zzz
alert_thresholds:
error_rate: 0.05  # 错误率阈值
latency_p99: 5000  # P99 延迟阈值（毫秒）

```
bash复制
### 1. 缓存配置

# 缓存设置
cache_settings:
type: redis  # 缓存类型：redis, memory, none
redis_url: redis://localhost:6379/0
cache_ttl: 3600  # 缓存生存时间（秒）
cache_key_prefix: litellm  # 缓存键前缀
enable_cache_for_stream: false  # 是否为流式响应启用缓存
cache_control_headers: true  # 是否使用缓存控制头
```

```
### 1. 缓存配置

# 缓存设置
cache_settings:
type: redis  # 缓存类型：redis, memory, none
redis_url: redis://localhost:6379/0
cache_ttl: 3600  # 缓存生存时间（秒）
cache_key_prefix: litellm  # 缓存键前缀
enable_cache_for_stream: false  # 是否为流式响应启用缓存
cache_control_headers: true  # 是否使用缓存控制头
```

##### 2. 速率限制配置#

```
yaml复制```yaml

# 速率限制设置
rate_limit_settings:
  enabled: true
  strategy: sliding_window  # 策略：sliding_window, token_bucket, fixed_window
  limits:
    - api_key: sk-team-a-key-123
      rpm: 100  # 每分钟请求数
      tpm: 10000  # 每分钟令牌数
      rpd: 10000  # 每天请求数
    - api_key: sk-team-b-key-456
      rpm: 50
      tpm: 5000
      rpd: 5000
  default_limits:
    rpm: 10
    tpm: 1000
    rpd: 100
  burst_size: 20  # 突发大小

```### 3. 预算控制配置

# 预算设置
budget_settings:
enabled: true
currency: USD
budgets:
- name: team-a-budget
api_keys:
- sk-team-a-key-123
limit: 1000.0
period: monthly
alert_threshold: 0.8  # 在 80% 时告警
hard_limit: true  # 达到限制时阻止请求
- name: team-b-budget
api_keys:
- sk-team-b-key-456
limit: 500.0
period: monthly
alert_threshold: 0.9
hard_limit: false
cost_tracking:
enabled: true
update_interval: 60  # 更新间隔（秒）
storage: database  # 存储方式：database, file
```

```
```yaml

# 速率限制设置
rate_limit_settings:
  enabled: true
  strategy: sliding_window  # 策略：sliding_window, token_bucket, fixed_window
  limits:
    - api_key: sk-team-a-key-123
      rpm: 100  # 每分钟请求数
      tpm: 10000  # 每分钟令牌数
      rpd: 10000  # 每天请求数
    - api_key: sk-team-b-key-456
      rpm: 50
      tpm: 5000
      rpd: 5000
  default_limits:
    rpm: 10
    tpm: 1000
    rpd: 100
  burst_size: 20  # 突发大小

```### 3. 预算控制配置

# 预算设置
budget_settings:
enabled: true
currency: USD
budgets:
- name: team-a-budget
api_keys:
- sk-team-a-key-123
limit: 1000.0
period: monthly
alert_threshold: 0.8  # 在 80% 时告警
hard_limit: true  # 达到限制时阻止请求
- name: team-b-budget
api_keys:
- sk-team-b-key-456
limit: 500.0
period: monthly
alert_threshold: 0.9
hard_limit: false
cost_tracking:
enabled: true
update_interval: 60  # 更新间隔（秒）
storage: database  # 存储方式：database, file
```

##### 4. 监控和告警配置#

```
yaml复制```yaml

# 监控设置
monitoring_settings:
  prometheus:
    enabled: true
    port: 9090
    metrics:
      - request_count
      - request_duration
      - error_count
      - cache_hit_rate
      - token_usage
      - cost

  grafana:
    enabled: true
    dashboard_url: http://localhost:3000/d/litellm

  alerts:
    slack:
      enabled: true
      webhook_url: https://hooks.slack.com/services/xxx/yyy/zzz
      channels:
        - litellm-alerts
        - devops-notifications
      alert_rules:
        - name: high_error_rate
          condition: error_rate > 0.05
          duration: 5m
          severity: warning
        - name: high_latency
          condition: p99_latency > 5000
          duration: 2m
          severity: critical
        - name: budget_exceeded
          condition: budget_usage > 1.0
          severity: critical

    email:
      enabled: true
      smtp_server: smtp.gmail.com
      smtp_port: 587
      smtp_username: alerts@company.com
      smtp_password: ${SMTP_PASSWORD}
      from_address: litellm-alerts@company.com
      to_addresses:
        - devops@company.com
        - finance@company.com

```## 33.2.4 集成 Claude Code

### 1. 配置 Claude Code 使用 LiteLLM

# 方法 1：使用统一端点（推荐）
export ANTHROPIC_BASE_URL=https://litellm-server:4000
export ANTHROPIC_AUTH_TOKEN=sk-litellm-static-key
# 方法 2：使用 Anthropic 格式端点
export ANTHROPIC_BASE_URL=https://litellm-server:4000/anthropic
export ANTHROPIC_AUTH_TOKEN=sk-litellm-static-key
```

```
```yaml

# 监控设置
monitoring_settings:
  prometheus:
    enabled: true
    port: 9090
    metrics:
      - request_count
      - request_duration
      - error_count
      - cache_hit_rate
      - token_usage
      - cost

  grafana:
    enabled: true
    dashboard_url: http://localhost:3000/d/litellm

  alerts:
    slack:
      enabled: true
      webhook_url: https://hooks.slack.com/services/xxx/yyy/zzz
      channels:
        - litellm-alerts
        - devops-notifications
      alert_rules:
        - name: high_error_rate
          condition: error_rate > 0.05
          duration: 5m
          severity: warning
        - name: high_latency
          condition: p99_latency > 5000
          duration: 2m
          severity: critical
        - name: budget_exceeded
          condition: budget_usage > 1.0
          severity: critical

    email:
      enabled: true
      smtp_server: smtp.gmail.com
      smtp_port: 587
      smtp_username: alerts@company.com
      smtp_password: ${SMTP_PASSWORD}
      from_address: litellm-alerts@company.com
      to_addresses:
        - devops@company.com
        - finance@company.com

```## 33.2.4 集成 Claude Code

### 1. 配置 Claude Code 使用 LiteLLM

# 方法 1：使用统一端点（推荐）
export ANTHROPIC_BASE_URL=https://litellm-server:4000
export ANTHROPIC_AUTH_TOKEN=sk-litellm-static-key
# 方法 2：使用 Anthropic 格式端点
export ANTHROPIC_BASE_URL=https://litellm-server:4000/anthropic
export ANTHROPIC_AUTH_TOKEN=sk-litellm-static-key
```

### 方法 3：使用 API 密钥辅助程序

### 创建辅助程序脚本

cat > ~/bin/get-litellm-key.sh << 'EOF'
#!/bin/bash

### 从 Vault 获取密钥

vault kv get -field=api_key secret/litellm/claude-code
EOF
chmod +x ~/bin/get-litellm-key.sh

### 配置 Claude Code 使用辅助程序

cat > /.claude-code/settings.json << EOF
{
"apiKeyHelper": "/bin/get-litellm-key.sh",
"env": {
"ANTHROPIC_BASE_URL": "https://litellm-server:4000"
}
}
EOF

```
bash复制### 2. 验证配置

```python
```python

class LiteLLMValidator:
    """LiteLLM 验证器"""

    def __init__(self, gateway_url: str, auth_token: str):
        self.gateway_url = gateway_url
        self.auth_token = auth_token

    def validate_connection(self) -> ValidationResult:
        """验证连接"""
        result = ValidationResult()

        try:
            # 测试健康检查端点
            response = requests.get(
                f"{self.gateway_url}/health",
                headers={'Authorization': f'Bearer {self.auth_token}'},
                timeout=10
            )

            if response.status_code == 200:
                result.success = True
                result.message = "Connection successful"
            else:
                result.success = False
                result.message = f"Health check failed: {response.status_code}"

        except requests.exceptions.Timeout:
            result.success = False
            result.message = "Connection timeout"
        except requests.exceptions.ConnectionError:
            result.success = False
            result.message = "Connection error"
        except Exception as e:
            result.success = False
            result.message = f"Unexpected error: {str(e)}"

        return result

    def validate_model_access(self, model: str) -> ValidationResult:
        """验证模型访问"""
        result = ValidationResult()

        try:
            # 测试模型访问
            response = requests.post(
                f"{self.gateway_url}/v1/completions",
                headers={
                    'Authorization': f'Bearer {self.auth_token}',
                    'Content-Type': 'application/json'
                },
                json={
                    'model': model,
                    'prompt': 'Hello',
                    'max_tokens': 10
                },
                timeout=30
            )

            if response.status_code == 200:
                result.success = True
                result.message = f"Model {model} accessible"
            else:
                result.success = False
                result.message = f"Model access failed: {response.status_code}"
                result.error = response.text

        except Exception as e:
            result.success = False
            result.message = f"Model access error: {str(e)}"

        return result

    def validate_all(self) -> ValidationReport:
        """验证所有配置"""
        report = ValidationReport()

        # 验证连接
        report.connection = self.validate_connection()

        # 验证模型访问
        models = ['claude-sonnet-4', 'claude-opus-4', 'claude-haiku-4']
        report.models = {}

        for model in models:
            report.models[model] = self.validate_model_access(model)

        # 生成摘要
        report.summary = self._generate_summary(report)

        return report

    def _generate_summary(self, report: ValidationReport) -> str:
        """生成验证摘要"""
        summary = "LiteLLM Validation Summary:\n\n"

        summary += f"Connection: {'✓' if report.connection.success else '✗'} "
        summary += f"{report.connection.message}\n\n"

        summary += "Model Access:\n"
        for model, result in report.models.items():
            status = '✓' if result.success else '✗'
            summary += f"  {status} {model}: {result.message}\n"

        return summary

```## 33.2.5 监控和维护

### 1. Prometheus 监控

# prometheus.yml
global:
scrape_interval: 15s
evaluation_interval: 15s
scrape_configs:
- job_name: 'litellm'
static_configs:
- targets: ['litellm-server:9090']
metrics_path: '/metrics'
```

```
### 2. 验证配置

```python
```python

class LiteLLMValidator:
    """LiteLLM 验证器"""

    def __init__(self, gateway_url: str, auth_token: str):
        self.gateway_url = gateway_url
        self.auth_token = auth_token

    def validate_connection(self) -> ValidationResult:
        """验证连接"""
        result = ValidationResult()

        try:
            # 测试健康检查端点
            response = requests.get(
                f"{self.gateway_url}/health",
                headers={'Authorization': f'Bearer {self.auth_token}'},
                timeout=10
            )

            if response.status_code == 200:
                result.success = True
                result.message = "Connection successful"
            else:
                result.success = False
                result.message = f"Health check failed: {response.status_code}"

        except requests.exceptions.Timeout:
            result.success = False
            result.message = "Connection timeout"
        except requests.exceptions.ConnectionError:
            result.success = False
            result.message = "Connection error"
        except Exception as e:
            result.success = False
            result.message = f"Unexpected error: {str(e)}"

        return result

    def validate_model_access(self, model: str) -> ValidationResult:
        """验证模型访问"""
        result = ValidationResult()

        try:
            # 测试模型访问
            response = requests.post(
                f"{self.gateway_url}/v1/completions",
                headers={
                    'Authorization': f'Bearer {self.auth_token}',
                    'Content-Type': 'application/json'
                },
                json={
                    'model': model,
                    'prompt': 'Hello',
                    'max_tokens': 10
                },
                timeout=30
            )

            if response.status_code == 200:
                result.success = True
                result.message = f"Model {model} accessible"
            else:
                result.success = False
                result.message = f"Model access failed: {response.status_code}"
                result.error = response.text

        except Exception as e:
            result.success = False
            result.message = f"Model access error: {str(e)}"

        return result

    def validate_all(self) -> ValidationReport:
        """验证所有配置"""
        report = ValidationReport()

        # 验证连接
        report.connection = self.validate_connection()

        # 验证模型访问
        models = ['claude-sonnet-4', 'claude-opus-4', 'claude-haiku-4']
        report.models = {}

        for model in models:
            report.models[model] = self.validate_model_access(model)

        # 生成摘要
        report.summary = self._generate_summary(report)

        return report

    def _generate_summary(self, report: ValidationReport) -> str:
        """生成验证摘要"""
        summary = "LiteLLM Validation Summary:\n\n"

        summary += f"Connection: {'✓' if report.connection.success else '✗'} "
        summary += f"{report.connection.message}\n\n"

        summary += "Model Access:\n"
        for model, result in report.models.items():
            status = '✓' if result.success else '✗'
            summary += f"  {status} {model}: {result.message}\n"

        return summary

```## 33.2.5 监控和维护

### 1. Prometheus 监控

# prometheus.yml
global:
scrape_interval: 15s
evaluation_interval: 15s
scrape_configs:
- job_name: 'litellm'
static_configs:
- targets: ['litellm-server:9090']
metrics_path: '/metrics'
```

##### 2. Grafana 仪表板#

```
json复制```json

{
  "dashboard": {
    "title": "LiteLLM Dashboard",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(litellm_request_count[1m])"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(litellm_error_count[1m]) / rate(litellm_request_count[1m])"
          }
        ]
      },
      {
        "title": "P99 Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.99, rate(litellm_request_duration_bucket[1m]))"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "targets": [
          {
            "expr": "rate(litellm_cache_hits[1m]) / rate(litellm_cache_requests[1m])"
          }
        ]
      },
      {
        "title": "Token Usage",
        "targets": [
          {
            "expr": "rate(litellm_token_usage[1m])"
          }
        ]
      },
      {
        "title": "Cost",
        "targets": [
          {
            "expr": "litellm_cost_total"
          }
        ]
      }
    ]
  }
}

```### 3. 日志管理

class LiteLLMLogManager:
"""LiteLLM 日志管理器"""
def __init__(self, log_file: str):
self.log_file = log_file
self.log_parser = LiteLLMLogParser()
def analyze_logs(self,
start_time: datetime = None,
end_time: datetime = None) -> LogAnalysis:
"""分析日志"""
analysis = LogAnalysis()
# 读取日志文件
with open(self.log_file, 'r') as f:
logs = f.readlines()
# 解析日志
parsed_logs = []
for log in logs:
try:
parsed = self.log_parser.parse(log)
parsed_logs.append(parsed)
except Exception as e:
logger.warning(f"Failed to parse log: {e}")
# 过滤时间范围
if start_time or end_time:
parsed_logs = [
log for log in parsed_logs
if (not start_time or log.timestamp >= start_time) and
(not end_time or log.timestamp <= end_time)
]
# 分析日志
analysis.total_requests = len(parsed_logs)
analysis.successful_requests = sum(
1 for log in parsed_logs if log.status == 'success'
)
analysis.failed_requests = sum(
1 for log in parsed_logs if log.status == 'error'
)
analysis.error_rate = (
analysis.failed_requests / analysis.total_requests
if analysis.total_requests > 0 else 0
)
# 分析延迟
latencies = [log.duration for log in parsed_logs if log.duration]
if latencies:
analysis.avg_latency = sum(latencies) / len(latencies)
analysis.p50_latency = np.percentile(latencies, 50)
analysis.p95_latency = np.percentile(latencies, 95)
analysis.p99_latency = np.percentile(latencies, 99)
# 分析令牌使用
analysis.total_tokens = sum(
log.input_tokens + log.output_tokens
for log in parsed_logs
)
# 分析成本
analysis.total_cost = sum(log.cost for log in parsed_logs)
return analysis
def generate_report(self, analysis: LogAnalysis) -> str:
"""生成报告"""
report = "LiteLLM Log Analysis Report\n"
report += "=" * 50 + "\n\n"
report += "Request Summary:\n"
report += f"  Total: {analysis.total_requests}\n"
report += f"  Successful: {analysis.successful_requests}\n"
report += f"  Failed: {analysis.failed_requests}\n"
report += f"  Error Rate: {analysis.error_rate:.2%}\n\n"
report += "Latency (ms):\n"
report += f"  Average: {analysis.avg_latency:.0f}\n"
report += f"  P50: {analysis.p50_latency:.0f}\n"
report += f"  P95: {analysis.p95_latency:.0f}\n"
report += f"  P99: {analysis.p99_latency:.0f}\n\n"
report += "Token Usage:\n"
report += f"  Total: {analysis.total_tokens:,}\n\n"
report += "Cost:\n"
report += f"  Total: ${analysis.total_cost:.2f}\n"
return report
```

```
```json

{
  "dashboard": {
    "title": "LiteLLM Dashboard",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(litellm_request_count[1m])"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(litellm_error_count[1m]) / rate(litellm_request_count[1m])"
          }
        ]
      },
      {
        "title": "P99 Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.99, rate(litellm_request_duration_bucket[1m]))"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "targets": [
          {
            "expr": "rate(litellm_cache_hits[1m]) / rate(litellm_cache_requests[1m])"
          }
        ]
      },
      {
        "title": "Token Usage",
        "targets": [
          {
            "expr": "rate(litellm_token_usage[1m])"
          }
        ]
      },
      {
        "title": "Cost",
        "targets": [
          {
            "expr": "litellm_cost_total"
          }
        ]
      }
    ]
  }
}

```### 3. 日志管理

class LiteLLMLogManager:
"""LiteLLM 日志管理器"""
def __init__(self, log_file: str):
self.log_file = log_file
self.log_parser = LiteLLMLogParser()
def analyze_logs(self,
start_time: datetime = None,
end_time: datetime = None) -> LogAnalysis:
"""分析日志"""
analysis = LogAnalysis()
# 读取日志文件
with open(self.log_file, 'r') as f:
logs = f.readlines()
# 解析日志
parsed_logs = []
for log in logs:
try:
parsed = self.log_parser.parse(log)
parsed_logs.append(parsed)
except Exception as e:
logger.warning(f"Failed to parse log: {e}")
# 过滤时间范围
if start_time or end_time:
parsed_logs = [
log for log in parsed_logs
if (not start_time or log.timestamp >= start_time) and
(not end_time or log.timestamp <= end_time)
]
# 分析日志
analysis.total_requests = len(parsed_logs)
analysis.successful_requests = sum(
1 for log in parsed_logs if log.status == 'success'
)
analysis.failed_requests = sum(
1 for log in parsed_logs if log.status == 'error'
)
analysis.error_rate = (
analysis.failed_requests / analysis.total_requests
if analysis.total_requests > 0 else 0
)
# 分析延迟
latencies = [log.duration for log in parsed_logs if log.duration]
if latencies:
analysis.avg_latency = sum(latencies) / len(latencies)
analysis.p50_latency = np.percentile(latencies, 50)
analysis.p95_latency = np.percentile(latencies, 95)
analysis.p99_latency = np.percentile(latencies, 99)
# 分析令牌使用
analysis.total_tokens = sum(
log.input_tokens + log.output_tokens
for log in parsed_logs
)
# 分析成本
analysis.total_cost = sum(log.cost for log in parsed_logs)
return analysis
def generate_report(self, analysis: LogAnalysis) -> str:
"""生成报告"""
report = "LiteLLM Log Analysis Report\n"
report += "=" * 50 + "\n\n"
report += "Request Summary:\n"
report += f"  Total: {analysis.total_requests}\n"
report += f"  Successful: {analysis.successful_requests}\n"
report += f"  Failed: {analysis.failed_requests}\n"
report += f"  Error Rate: {analysis.error_rate:.2%}\n\n"
report += "Latency (ms):\n"
report += f"  Average: {analysis.avg_latency:.0f}\n"
report += f"  P50: {analysis.p50_latency:.0f}\n"
report += f"  P95: {analysis.p95_latency:.0f}\n"
report += f"  P99: {analysis.p99_latency:.0f}\n\n"
report += "Token Usage:\n"
report += f"  Total: {analysis.total_tokens:,}\n\n"
report += "Cost:\n"
report += f"  Total: ${analysis.total_cost:.2f}\n"
return report
```

---

# 第 34 章

## 1 开发容器配置

**URL**: https://claudecode.tangshuang.net/course/34.1%20%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE

学习如何在企业环境中配置和使用 Claude Code 开发容器，为团队提供一致、安全的开发环境。

#### 34.1.1 开发容器概述#

##### 什么是开发容器#

开发容器（Dev Containers）是一种使用 Docker 容器作为完整开发环境的解决方案。它为团队提供：

- 一致性：所有开发者使用相同的工具和配置
- 可移植性：在不同操作系统上获得相同的开发体验
- 隔离性：开发环境与主机系统分离
- 安全性：增强的安全措施保护开发环境

##### Claude Code 开发容器特性#

Claude Code 提供的官方开发容器包含：

- 生产就绪的 Node.js：基于 Node.js 20 构建
- 安全设计：自定义防火墙限制网络访问
- 开发者工具：git、ZSH、fzf 等生产力工具
- VS Code 集成：预配置的扩展和优化设置
- 会话持久性：保留命令历史和配置

#### 34.1.2 快速入门#

##### 前置要求#

确保您的系统已安装以下组件：

### 检查 Docker 安装

docker --version

### 检查 VS Code 安装

code --version

### 检查 Remote - Containers 扩展

code --list-extensions | grep ms-vscode-remote.remote-containers

##### 安装步骤#

True. 安装 Docker Desktop

```
bash复制bash

# macOS
brew install --cask docker

# 启动 Docker Desktop
open /Applications/Docker.app

# 安装 VS Code（如果尚未安装）
brew install --cask visual-studio-code
# 安装 Remote - Containers 扩展
code --install-extension ms-vscode-remote.remote-containers
```

```
bash

# macOS
brew install --cask docker

# 启动 Docker Desktop
open /Applications/Docker.app

# 安装 VS Code（如果尚未安装）
brew install --cask visual-studio-code
# 安装 Remote - Containers 扩展
code --install-extension ms-vscode-remote.remote-containers
```

True. 克隆 Claude Code 参考实现

```
bash复制bash

git clone https://github.com/anthropics/claude-code.git
cd claude-code

在 VS Code 中：
> - 打开命令面板：`Cmd+Shift+P`
> - 输入并选择：`Remote-Containers: Reopen in Container`
> - 等待容器构建和启动

## 34.1.3 开发容器配置详解

### devcontainer.json 配置

{
"name": "Claude Code Dev Container",
"dockerFile": "Dockerfile",
"context": "..",
"customizations": {
"vscode": {
"extensions": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"github.copilot"
],
"settings": {
"editor.formatOnSave": true,
"editor.defaultFormatter": "esbenp.prettier-vscode",
"terminal.integrated.defaultProfile.linux": "zsh"
}
}
},
"features": {
"ghcr.io/devcontainers/features/node:1": {
"version": "20"
},
"ghcr.io/devcontainers/features/git:1": {}
},
"mounts": [
"source=${localWorkspaceFolder},target=/workspace,type=bind",
"source=claude-code-history,target=/home/vscode/.claude-history,type=volume"
],
"postCreateCommand": "bash .devcontainer/init-firewall.sh",
"remoteUser": "vscode"
}
```

```
bash

git clone https://github.com/anthropics/claude-code.git
cd claude-code

在 VS Code 中：
> - 打开命令面板：`Cmd+Shift+P`
> - 输入并选择：`Remote-Containers: Reopen in Container`
> - 等待容器构建和启动

## 34.1.3 开发容器配置详解

### devcontainer.json 配置

{
"name": "Claude Code Dev Container",
"dockerFile": "Dockerfile",
"context": "..",
"customizations": {
"vscode": {
"extensions": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"github.copilot"
],
"settings": {
"editor.formatOnSave": true,
"editor.defaultFormatter": "esbenp.prettier-vscode",
"terminal.integrated.defaultProfile.linux": "zsh"
}
}
},
"features": {
"ghcr.io/devcontainers/features/node:1": {
"version": "20"
},
"ghcr.io/devcontainers/features/git:1": {}
},
"mounts": [
"source=${localWorkspaceFolder},target=/workspace,type=bind",
"source=claude-code-history,target=/home/vscode/.claude-history,type=volume"
],
"postCreateCommand": "bash .devcontainer/init-firewall.sh",
"remoteUser": "vscode"
}
```

##### Dockerfile 配置#

```
bash复制dockerfile

FROM mcr.microsoft.com/devcontainers/base:ubuntu-22.04

# 安装 Node.js 20
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# 安装开发工具
RUN apt-get update && apt-get install -y \
    git \
    zsh \
    fzf \
    ripgrep \
    jq \
    curl \
    wget \
    vim \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# 安装 Oh My Zsh
RUN sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# 配置 ZSH
RUN echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc && \
    echo 'export EDITOR="vim"' >> ~/.zshrc

# 创建非 root 用户
RUN useradd -m -s /bin/zsh vscode && \
    echo "vscode ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# 设置工作目录
WORKDIR /workspace

USER vscode

### 防火墙脚本 (init-firewall.sh)

#!/bin/bash
set -e
echo "配置开发容器防火墙..."
# 安装 iptables
sudo apt-get update
sudo apt-get install -y iptables
# 清除现有规则
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X
# 默认策略：拒绝所有出站连接
sudo iptables -P OUTPUT DROP
# 允许本地回环
sudo iptables -A OUTPUT -o lo -j ACCEPT
# 允许已建立的连接
sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
# 允许 DNS
sudo iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
# 允许 SSH
sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
# 允许 HTTPS（白名单域名）
ALLOWED_DOMAINS=(
"api.anthropic.com"
"code.claude.com"
"github.com"
"npmjs.org"
"registry.npmjs.org"
"cdn.npmjs.org"
)
for domain in "${ALLOWED_DOMAINS[@]}"; do
ip=$(dig +short $domain | head -n 1)
if [ -n "$ip" ]; then
sudo iptables -A OUTPUT -d $ip -p tcp --dport 443 -j ACCEPT
echo "允许访问: $domain ($ip)"
fi
done
# 保存规则
sudo iptables-save > /etc/iptables/rules.v4
echo "防火墙配置完成"
```

```
dockerfile

FROM mcr.microsoft.com/devcontainers/base:ubuntu-22.04

# 安装 Node.js 20
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# 安装开发工具
RUN apt-get update && apt-get install -y \
    git \
    zsh \
    fzf \
    ripgrep \
    jq \
    curl \
    wget \
    vim \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# 安装 Oh My Zsh
RUN sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# 配置 ZSH
RUN echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc && \
    echo 'export EDITOR="vim"' >> ~/.zshrc

# 创建非 root 用户
RUN useradd -m -s /bin/zsh vscode && \
    echo "vscode ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# 设置工作目录
WORKDIR /workspace

USER vscode

### 防火墙脚本 (init-firewall.sh)

#!/bin/bash
set -e
echo "配置开发容器防火墙..."
# 安装 iptables
sudo apt-get update
sudo apt-get install -y iptables
# 清除现有规则
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X
# 默认策略：拒绝所有出站连接
sudo iptables -P OUTPUT DROP
# 允许本地回环
sudo iptables -A OUTPUT -o lo -j ACCEPT
# 允许已建立的连接
sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
# 允许 DNS
sudo iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
# 允许 SSH
sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
# 允许 HTTPS（白名单域名）
ALLOWED_DOMAINS=(
"api.anthropic.com"
"code.claude.com"
"github.com"
"npmjs.org"
"registry.npmjs.org"
"cdn.npmjs.org"
)
for domain in "${ALLOWED_DOMAINS[@]}"; do
ip=$(dig +short $domain | head -n 1)
if [ -n "$ip" ]; then
sudo iptables -A OUTPUT -d $ip -p tcp --dport 443 -j ACCEPT
echo "允许访问: $domain ($ip)"
fi
done
# 保存规则
sudo iptables-save > /etc/iptables/rules.v4
echo "防火墙配置完成"
```

#### 34.1.4 企业级自定义配置#

##### 多环境配置#

为不同的开发环境创建不同的配置文件：

```
bash复制bash

.devcontainer/
├── devcontainer.json
├── Dockerfile
├── Dockerfile.dev
├── Dockerfile.staging
├── Dockerfile.prod
├── devcontainer.dev.json
├── devcontainer.staging.json
└── devcontainer.prod.json

{
"name": "Claude Code Dev Environment",
"dockerFile": "Dockerfile.dev",
"customizations": {
"vscode": {
"extensions": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"github.copilot",
"eamodio.gitlens",
"ms-python.python"
]
}
},
"mounts": [
"source=${localWorkspaceFolder},target=/workspace,type=bind",
"source=dev-node-modules,target=/workspace/node_modules,type=volume"
],
"postCreateCommand": "npm install && npm run setup:dev"
}
```

```
bash

.devcontainer/
├── devcontainer.json
├── Dockerfile
├── Dockerfile.dev
├── Dockerfile.staging
├── Dockerfile.prod
├── devcontainer.dev.json
├── devcontainer.staging.json
└── devcontainer.prod.json

{
"name": "Claude Code Dev Environment",
"dockerFile": "Dockerfile.dev",
"customizations": {
"vscode": {
"extensions": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"github.copilot",
"eamodio.gitlens",
"ms-python.python"
]
}
},
"mounts": [
"source=${localWorkspaceFolder},target=/workspace,type=bind",
"source=dev-node-modules,target=/workspace/node_modules,type=volume"
],
"postCreateCommand": "npm install && npm run setup:dev"
}
```

生产环境配置 (devcontainer.prod.json):

```
bash复制json

{
  "name": "Claude Code Prod Environment",
  "dockerFile": "Dockerfile.prod",
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "ms-vscode.vscode-typescript-next"
      ]
    }
  },
  "mounts": [
    "source=${localWorkspaceFolder},target=/workspace,type=bind"
  ],
  "postCreateCommand": "npm ci && npm run build"
}

### 企业级 Dockerfile

FROM mcr.microsoft.com/devcontainers/base:ubuntu-22.04
# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone
# 安装企业级工具
RUN apt-get update && apt-get install -y \
# 基础工具
git \
curl \
wget \
vim \
jq \
# 开发工具
build-essential \
python3 \
python3-pip \
# 安全工具
openssl \
gnupg \
# 网络工具
net-tools \
iputils-ping \
# 版本控制
subversion \
mercurial \
&& apt-get clean && rm -rf /var/lib/apt/lists/*
# 安装 Node.js 20
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
apt-get install -y nodejs && \
apt-get clean && rm -rf /var/lib/apt/lists/*
# 配置 npm 企业镜像
RUN npm config set registry https://npm.company.com && \
npm config set @company:registry https://npm.company.com
# 安装企业证书
COPY company-ca.crt /usr/local/share/ca-certificates/
RUN update-ca-certificates
# 安装企业 CLI 工具
RUN npm install -g @company/cli-tools
# 配置 Git
RUN git config --global user.name "Company Developer" && \
git config --global user.email "dev@company.com" && \
git config --global core.autocrlf input
# 安装 Oh My Zsh 和企业主题
RUN sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended && \
git clone https://github.com/company/zsh-theme.git ~/.oh-my-zsh/custom/themes/company
# 配置企业代理
ENV HTTP_PROXY=http://proxy.company.com:8080
ENV HTTPS_PROXY=http://proxy.company.com:8080
ENV NO_PROXY=localhost,127.0.0.1,.company.com
# 创建用户
RUN useradd -m -s /bin/zsh vscode && \
echo "vscode ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
WORKDIR /workspace
USER vscode
# 配置企业环境变量
RUN echo 'export COMPANY_ENV=production' >> ~/.zshrc && \
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc
```

```
json

{
  "name": "Claude Code Prod Environment",
  "dockerFile": "Dockerfile.prod",
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "ms-vscode.vscode-typescript-next"
      ]
    }
  },
  "mounts": [
    "source=${localWorkspaceFolder},target=/workspace,type=bind"
  ],
  "postCreateCommand": "npm ci && npm run build"
}

### 企业级 Dockerfile

FROM mcr.microsoft.com/devcontainers/base:ubuntu-22.04
# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone
# 安装企业级工具
RUN apt-get update && apt-get install -y \
# 基础工具
git \
curl \
wget \
vim \
jq \
# 开发工具
build-essential \
python3 \
python3-pip \
# 安全工具
openssl \
gnupg \
# 网络工具
net-tools \
iputils-ping \
# 版本控制
subversion \
mercurial \
&& apt-get clean && rm -rf /var/lib/apt/lists/*
# 安装 Node.js 20
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
apt-get install -y nodejs && \
apt-get clean && rm -rf /var/lib/apt/lists/*
# 配置 npm 企业镜像
RUN npm config set registry https://npm.company.com && \
npm config set @company:registry https://npm.company.com
# 安装企业证书
COPY company-ca.crt /usr/local/share/ca-certificates/
RUN update-ca-certificates
# 安装企业 CLI 工具
RUN npm install -g @company/cli-tools
# 配置 Git
RUN git config --global user.name "Company Developer" && \
git config --global user.email "dev@company.com" && \
git config --global core.autocrlf input
# 安装 Oh My Zsh 和企业主题
RUN sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended && \
git clone https://github.com/company/zsh-theme.git ~/.oh-my-zsh/custom/themes/company
# 配置企业代理
ENV HTTP_PROXY=http://proxy.company.com:8080
ENV HTTPS_PROXY=http://proxy.company.com:8080
ENV NO_PROXY=localhost,127.0.0.1,.company.com
# 创建用户
RUN useradd -m -s /bin/zsh vscode && \
echo "vscode ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
WORKDIR /workspace
USER vscode
# 配置企业环境变量
RUN echo 'export COMPANY_ENV=production' >> ~/.zshrc && \
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc
```

##### 团队协作配置#

共享配置文件 (.devcontainer/shared-settings.json):

```
bash复制json

{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.tabSize": 2,
  "editor.insertSpaces": true,
  "files.trimTrailingWhitespace": true,
  "files.insertFinalNewline": true,
  "files.exclude": {
    "**/.git": true,
    "**/.DS_Store": true,
    "**/node_modules": true,
    "**/dist": true
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/dist": true,
    "**/.git": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "eslint.workingDirectories": ["./"]
}

{
"recommendations": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"eamodio.gitlens",
"ms-python.python",
"github.copilot",
"github.vscode-pull-request-github",
"redhat.vscode-yaml",
"ms-azuretools.vscode-docker"
]
}
```

```
json

{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.tabSize": 2,
  "editor.insertSpaces": true,
  "files.trimTrailingWhitespace": true,
  "files.insertFinalNewline": true,
  "files.exclude": {
    "**/.git": true,
    "**/.DS_Store": true,
    "**/node_modules": true,
    "**/dist": true
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/dist": true,
    "**/.git": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "eslint.workingDirectories": ["./"]
}

{
"recommendations": [
"dbaeumer.vscode-eslint",
"esbenp.prettier-vscode",
"ms-vscode.vscode-typescript-next",
"eamodio.gitlens",
"ms-python.python",
"github.copilot",
"github.vscode-pull-request-github",
"redhat.vscode-yaml",
"ms-azuretools.vscode-docker"
]
}
```

#### 34.1.5 安全增强配置#

##### 强化防火墙规则#

```
bash复制bash

#!/bin/bash
# .devcontainer/init-security.sh

set -e

echo "配置企业级安全防火墙..."

# 安装安全工具
sudo apt-get update
sudo apt-get install -y iptables fail2ban

# 配置 iptables
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X

# 默认拒绝策略
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT DROP

# 允许本地回环
sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A OUTPUT -o lo -j ACCEPT

# 允许已建立的连接
sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# 允许 DNS
sudo iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT

# 允许 SSH（仅从特定网络）
sudo iptables -A INPUT -p tcp -s 10.0.0.0/8 --dport 22 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT

# 企业白名单域名
declare -A ALLOWED_DOMAINS=(
    ["api.anthropic.com"]="443"
    ["code.claude.com"]="443"
    ["github.com"]="443"
    ["npm.company.com"]="443"
    ["git.company.com"]="443"
    ["artifacts.company.com"]="443"
)

for domain in "${!ALLOWED_DOMAINS[@]}"; do
    port=${ALLOWED_DOMAINS[$domain]}
    ips=$(dig +short $domain)
    for ip in $ips; do
        sudo iptables -A OUTPUT -d $ip -p tcp --dport $port -j ACCEPT
        echo "允许: $domain -> $ip:$port"
    done
done

# 阻止常见攻击端口
BLOCKED_PORTS=(23 135 137 138 139 445 1433 3389)
for port in "${BLOCKED_PORTS[@]}"; do
    sudo iptables -A OUTPUT -p tcp --dport $port -j DROP
    sudo iptables -A OUTPUT -p udp --dport $port -j DROP
done

# 保存规则
sudo iptables-save > /etc/iptables/rules.v4

# 配置 fail2ban
sudo cat > /etc/fail2ban/jail.local << 'EOF'
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
EOF

sudo systemctl enable fail2ban
sudo systemctl start fail2ban

echo "安全配置完成"

### 文件系统权限配置

#!/bin/bash
# .devcontainer/init-permissions.sh
set -e
echo "配置文件系统权限..."
# 创建受限目录结构
sudo mkdir -p /workspace/{src,tests,docs,scripts}
sudo mkdir -p /workspace/.secrets
# 设置权限
sudo chown -R vscode:vscode /workspace
sudo chmod 755 /workspace/{src,tests,docs,scripts}
sudo chmod 700 /workspace/.secrets
# 配置 .gitignore
cat > /workspace/.gitignore << 'EOF'
# Secrets
.secrets/
*.key
*.pem
.env.local
# IDE
.vscode/
.idea/
# OS
.DS_Store
Thumbs.db
# Dependencies
node_modules/
EOF
# 配置敏感文件保护
sudo touch /workspace/.secrets/.gitkeep
sudo chmod 600 /workspace/.secrets/.gitkeep
echo "文件系统权限配置完成"
```

```
bash

#!/bin/bash
# .devcontainer/init-security.sh

set -e

echo "配置企业级安全防火墙..."

# 安装安全工具
sudo apt-get update
sudo apt-get install -y iptables fail2ban

# 配置 iptables
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X

# 默认拒绝策略
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT DROP

# 允许本地回环
sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A OUTPUT -o lo -j ACCEPT

# 允许已建立的连接
sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# 允许 DNS
sudo iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT

# 允许 SSH（仅从特定网络）
sudo iptables -A INPUT -p tcp -s 10.0.0.0/8 --dport 22 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT

# 企业白名单域名
declare -A ALLOWED_DOMAINS=(
    ["api.anthropic.com"]="443"
    ["code.claude.com"]="443"
    ["github.com"]="443"
    ["npm.company.com"]="443"
    ["git.company.com"]="443"
    ["artifacts.company.com"]="443"
)

for domain in "${!ALLOWED_DOMAINS[@]}"; do
    port=${ALLOWED_DOMAINS[$domain]}
    ips=$(dig +short $domain)
    for ip in $ips; do
        sudo iptables -A OUTPUT -d $ip -p tcp --dport $port -j ACCEPT
        echo "允许: $domain -> $ip:$port"
    done
done

# 阻止常见攻击端口
BLOCKED_PORTS=(23 135 137 138 139 445 1433 3389)
for port in "${BLOCKED_PORTS[@]}"; do
    sudo iptables -A OUTPUT -p tcp --dport $port -j DROP
    sudo iptables -A OUTPUT -p udp --dport $port -j DROP
done

# 保存规则
sudo iptables-save > /etc/iptables/rules.v4

# 配置 fail2ban
sudo cat > /etc/fail2ban/jail.local << 'EOF'
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
EOF

sudo systemctl enable fail2ban
sudo systemctl start fail2ban

echo "安全配置完成"

### 文件系统权限配置

#!/bin/bash
# .devcontainer/init-permissions.sh
set -e
echo "配置文件系统权限..."
# 创建受限目录结构
sudo mkdir -p /workspace/{src,tests,docs,scripts}
sudo mkdir -p /workspace/.secrets
# 设置权限
sudo chown -R vscode:vscode /workspace
sudo chmod 755 /workspace/{src,tests,docs,scripts}
sudo chmod 700 /workspace/.secrets
# 配置 .gitignore
cat > /workspace/.gitignore << 'EOF'
# Secrets
.secrets/
*.key
*.pem
.env.local
# IDE
.vscode/
.idea/
# OS
.DS_Store
Thumbs.db
# Dependencies
node_modules/
EOF
# 配置敏感文件保护
sudo touch /workspace/.secrets/.gitkeep
sudo chmod 600 /workspace/.secrets/.gitkeep
echo "文件系统权限配置完成"
```

#### 34.1.6 CI/CD 集成#

##### GitHub Actions 配置#

```
bash复制yaml

name: Dev Container CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build dev container
      uses: devcontainers/ci@v0.3
      with:
        push: never
        imageName: ghcr.io/${{ github.repository }}/devcontainer
        cacheFrom: ghcr.io/${{ github.repository }}/devcontainer:latest

    - name: Run tests in dev container
      uses: devcontainers/ci@v0.3
      with:
        push: never
        imageName: ghcr.io/${{ github.repository }}/devcontainer
        runCmd: npm test

### GitLab CI 配置

stages:
- build
- test
variables:
DEV_CONTAINER_IMAGE: $CI_REGISTRY_IMAGE/devcontainer:$CI_COMMIT_SHORT_SHA
build:
stage: build
image: docker:24
services:
- docker:24-dind
script:
- docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
- docker build -f .devcontainer/Dockerfile -t $DEV_CONTAINER_IMAGE .
- docker push $DEV_CONTAINER_IMAGE
test:
stage: test
image: $DEV_CONTAINER_IMAGE
script:
- npm install
- npm test
- npm run lint
```

```
yaml

name: Dev Container CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build dev container
      uses: devcontainers/ci@v0.3
      with:
        push: never
        imageName: ghcr.io/${{ github.repository }}/devcontainer
        cacheFrom: ghcr.io/${{ github.repository }}/devcontainer:latest

    - name: Run tests in dev container
      uses: devcontainers/ci@v0.3
      with:
        push: never
        imageName: ghcr.io/${{ github.repository }}/devcontainer
        runCmd: npm test

### GitLab CI 配置

stages:
- build
- test
variables:
DEV_CONTAINER_IMAGE: $CI_REGISTRY_IMAGE/devcontainer:$CI_COMMIT_SHORT_SHA
build:
stage: build
image: docker:24
services:
- docker:24-dind
script:
- docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
- docker build -f .devcontainer/Dockerfile -t $DEV_CONTAINER_IMAGE .
- docker push $DEV_CONTAINER_IMAGE
test:
stage: test
image: $DEV_CONTAINER_IMAGE
script:
- npm install
- npm test
- npm run lint
```

#### 34.1.7 监控和日志#

##### 容器健康检查#

```
bash复制json

{
  "name": "Claude Code Dev Container",
  "dockerFile": "Dockerfile",
  "healthCheck": {
    "test": ["CMD", "curl", "-f", "http://localhost:3000/health"],
    "interval": "30s",
    "timeout": "10s",
    "retries": 3,
    "startPeriod": "40s"
  }
}

### 日志配置

#!/bin/bash
# .devcontainer/init-logging.sh
# 创建日志目录
mkdir -p /workspace/logs
# 配置日志轮转
sudo cat > /etc/logrotate.d/devcontainer << 'EOF'
/workspace/logs/*.log {
daily
rotate 7
compress
delaycompress
missingok
notifempty
create 0644 vscode vscode
}
EOF
# 配置应用日志
cat > /workspace/.env << 'EOF'
LOG_LEVEL=info
LOG_FILE=/workspace/logs/app.log
LOG_MAX_SIZE=10m
LOG_MAX_FILES=5
EOF
echo "日志配置完成"
```

```
json

{
  "name": "Claude Code Dev Container",
  "dockerFile": "Dockerfile",
  "healthCheck": {
    "test": ["CMD", "curl", "-f", "http://localhost:3000/health"],
    "interval": "30s",
    "timeout": "10s",
    "retries": 3,
    "startPeriod": "40s"
  }
}

### 日志配置

#!/bin/bash
# .devcontainer/init-logging.sh
# 创建日志目录
mkdir -p /workspace/logs
# 配置日志轮转
sudo cat > /etc/logrotate.d/devcontainer << 'EOF'
/workspace/logs/*.log {
daily
rotate 7
compress
delaycompress
missingok
notifempty
create 0644 vscode vscode
}
EOF
# 配置应用日志
cat > /workspace/.env << 'EOF'
LOG_LEVEL=info
LOG_FILE=/workspace/logs/app.log
LOG_MAX_SIZE=10m
LOG_MAX_FILES=5
EOF
echo "日志配置完成"
```

#### 34.1.8 最佳实践#

##### 1. 版本控制#

- 将所有配置文件纳入版本控制
- 使用 .gitignore 排除敏感信息
- 使用环境变量管理配置差异

```
.gitignore
```

##### 2. 文档化#

- 为每个配置文件添加注释
- 创建 README 说明如何使用开发容器
- 记录常见问题和解决方案

##### 3. 安全性#

- 定期更新基础镜像
- 使用最小权限原则
- 定期审计防火墙规则

##### 4. 性能优化#

- 使用多阶段构建减小镜像大小
- 利用 Docker 缓存层
- 合理配置资源限制

##### 5. 团队协作#

- 标准化配置文件
- 共享常用扩展和设置
- 建立配置审查流程

#### 34.1.9 故障排查#

##### 常见问题#

问题 1：容器无法启动

```
bash复制bash

# 检查 Docker 状态
docker ps -a

# 查看容器日志
docker logs <container-id>
```

```
bash

# 检查 Docker 状态
docker ps -a

# 查看容器日志
docker logs <container-id>
```

### 重新构建容器

### 在 VS Code 中: Remote-Containers: Rebuild Container

### 检查防火墙规则

sudo iptables -L -n -v

### 测试 DNS 解析

dig api.anthropic.com

### 检查代理配置

echo $HTTP_PROXY
echo $HTTPS_PROXY

```
bash复制**问题 3：权限问题**
```

```
**问题 3：权限问题**
```

### 检查文件权限

ls -la /workspace

### 修复权限

sudo chown -R vscode:vscode /workspace

问题 4：扩展安装失败

### 手动安装扩展

code --install-extension <extension-id>

### 检查扩展市场连接

curl -I https://marketplace.visualstudio.com

---

## 2 沙箱隔离配置

**URL**: https://claudecode.tangshuang.net/course/34.2%20%E6%B2%99%E7%AE%B1%E9%9A%94%E7%A6%BB%E9%85%8D%E7%BD%AE

学习如何配置和使用 Claude Code 的沙箱隔离功能，为企业环境提供更安全的代理执行环境。

#### 34.2.1 沙箱隔离概述#

##### 什么是沙箱隔离#

沙箱隔离是 Claude Code 提供的一种安全机制，通过操作系统级原语强制执行文件系统和网络隔离。它允许 Claude Code 在预定义的安全边界内自主运行，减少对持续权限提示的依赖。

##### 沙箱隔离的优势#

- 减少批准疲劳：安全命令无需逐个批准
- 提高生产力：减少工作流中断
- 增强安全性：定义清晰的访问边界
- 启用自主性：Claude Code 可以更独立地工作
- 全面保护：文件系统和网络双重隔离

##### 沙箱隔离的适用场景#

- 企业开发环境
- 处理敏感数据的项目
- 需要高安全性的生产环境
- 自动化 CI/CD 流程
- 多租户开发环境

#### 34.2.2 沙箱隔离工作原理#

##### 文件系统隔离#

沙箱化 bash 工具通过以下方式限制文件系统访问：

### 沙箱文件系统访问规则示例

SANDBOX_FILESYSTEM_RULES = {
"allowed_write_paths": [
"/workspace",           # 当前工作目录
"/tmp",                 # 临时目录
"/home/developer/.cache" # 缓存目录
],
"allowed_read_paths": [
"/",                    # 整个系统（默认）
"/usr/local/bin",       # 系统工具
"/opt/tools"            # 企业工具
],
"denied_paths": [
"/etc",                 # 系统配置
"/root",                # root 用户目录
"/home/developer/.ssh", # SSH 密钥
"/home/developer/.aws", # AWS 凭证
"~/.config/claude-code" # Claude Code 配置
]
}

##### 网络隔离#

网络访问通过代理服务器控制：

```
bash复制python

# 沙箱网络访问规则示例
SANDBOX_NETWORK_RULES = {
    "allowed_domains": [
        "api.anthropic.com",
        "code.claude.com",
        "github.com",
        "npmjs.org",
        "*.company.com"
    ],
    "denied_domains": [
        "*",
        "malicious-site.com"
    ],
    "proxy_settings": {
        "http_proxy": "http://proxy.company.com:8080",
        "https_proxy": "http://proxy.comany.com:8080",
        "no_proxy": "localhost,127.0.0.1,.company.com"
    }
}

### 操作系统级强制执行

不同平台的实现方式：

# Linux: 使用 bubblewrap
bwrap \
--ro-bind /usr /usr \
--ro-bind /lib /lib \
--bind /workspace /workspace \
--bind /tmp /tmp \
--dev /dev \
--proc /proc \
--unshare-net \
--setenv PATH /usr/bin:/bin \
/bin/bash
# macOS: 使用 Seatbelt
sandbox-exec \
-f /path/to/sandbox.profile \
/bin/bash
```

```
python

# 沙箱网络访问规则示例
SANDBOX_NETWORK_RULES = {
    "allowed_domains": [
        "api.anthropic.com",
        "code.claude.com",
        "github.com",
        "npmjs.org",
        "*.company.com"
    ],
    "denied_domains": [
        "*",
        "malicious-site.com"
    ],
    "proxy_settings": {
        "http_proxy": "http://proxy.company.com:8080",
        "https_proxy": "http://proxy.comany.com:8080",
        "no_proxy": "localhost,127.0.0.1,.company.com"
    }
}

### 操作系统级强制执行

不同平台的实现方式：

# Linux: 使用 bubblewrap
bwrap \
--ro-bind /usr /usr \
--ro-bind /lib /lib \
--bind /workspace /workspace \
--bind /tmp /tmp \
--dev /dev \
--proc /proc \
--unshare-net \
--setenv PATH /usr/bin:/bin \
/bin/bash
# macOS: 使用 Seatbelt
sandbox-exec \
-f /path/to/sandbox.profile \
/bin/bash
```

#### 34.2.3 快速入门#

##### 启用沙箱隔离#

在 Claude Code 中运行斜杠命令：

```
bash复制/sandbox
```

```
/sandbox
```

```
bash复制这将使用默认设置激活沙箱化 bash 工具。

### 验证沙箱状态

# 检查沙箱是否启用
```

```
这将使用默认设置激活沙箱化 bash 工具。

### 验证沙箱状态

# 检查沙箱是否启用
```

/sandbox status

### 查看当前沙箱配置

/sandbox config

```
bash复制### 测试沙箱隔离

```bash
```bash

# 测试文件系统隔离 - 应该成功
echo "test" > /workspace/test.txt

# 测试文件系统隔离 - 应该失败
echo "test" > /etc/test.txt

# 测试网络隔离 - 应该成功
curl https://api.anthropic.com

# 测试网络隔离 - 应该失败
curl https://example.com

```## 34.2.4 基础配置

### settings.json 配置

{
"sandbox": {
"enabled": true,
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org"
],
"httpProxy": "http://proxy.company.com:8080",
"httpsProxy": "http://proxy.company.com:8080"
},
"excludedCommands": [
"docker",
"systemctl"
],
"allowUnsandboxedCommands": false
}
}
```

```
### 测试沙箱隔离

```bash
```bash

# 测试文件系统隔离 - 应该成功
echo "test" > /workspace/test.txt

# 测试文件系统隔离 - 应该失败
echo "test" > /etc/test.txt

# 测试网络隔离 - 应该成功
curl https://api.anthropic.com

# 测试网络隔离 - 应该失败
curl https://example.com

```## 34.2.4 基础配置

### settings.json 配置

{
"sandbox": {
"enabled": true,
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org"
],
"httpProxy": "http://proxy.company.com:8080",
"httpsProxy": "http://proxy.company.com:8080"
},
"excludedCommands": [
"docker",
"systemctl"
],
"allowUnsandboxedCommands": false
}
}
```

##### 环境变量配置#

```
bash复制```bash

# 启用沙箱
export CLAUDE_SANDBOX_ENABLED=true

# 配置文件系统路径
export CLAUDE_SANDBOX_WRITE_PATHS="/workspace,/tmp"
export CLAUDE_SANDBOX_DENY_PATHS="/etc,/root,~/.ssh"

# 配置网络
export CLAUDE_SANDBOX_ALLOWED_DOMAINS="api.anthropic.com,code.claude.com,github.com"
export CLAUDE_SANDBOX_HTTP_PROXY="http://proxy.company.com:8080"
export CLAUDE_SANDBOX_HTTPS_PROXY="http://proxy.company.com:8080"

```## 34.2.5 企业级配置

### 多环境沙箱配置

> **开发环境配置:**

{
"sandbox": {
"enabled": true,
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp",
"/home/developer/.cache"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws",
"~/.config/claude-code"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"*.dev.company.com"
],
"httpProxy": "http://proxy-dev.company.com:8080",
"httpsProxy": "http://proxy-dev.company.com:8080"
},
"excludedCommands": [
"docker",
"kubectl"
],
"allowUnsandboxedCommands": true
}
}
```

```
```bash

# 启用沙箱
export CLAUDE_SANDBOX_ENABLED=true

# 配置文件系统路径
export CLAUDE_SANDBOX_WRITE_PATHS="/workspace,/tmp"
export CLAUDE_SANDBOX_DENY_PATHS="/etc,/root,~/.ssh"

# 配置网络
export CLAUDE_SANDBOX_ALLOWED_DOMAINS="api.anthropic.com,code.claude.com,github.com"
export CLAUDE_SANDBOX_HTTP_PROXY="http://proxy.company.com:8080"
export CLAUDE_SANDBOX_HTTPS_PROXY="http://proxy.company.com:8080"

```## 34.2.5 企业级配置

### 多环境沙箱配置

> **开发环境配置:**

{
"sandbox": {
"enabled": true,
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp",
"/home/developer/.cache"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws",
"~/.config/claude-code"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"*.dev.company.com"
],
"httpProxy": "http://proxy-dev.company.com:8080",
"httpsProxy": "http://proxy-dev.company.com:8080"
},
"excludedCommands": [
"docker",
"kubectl"
],
"allowUnsandboxedCommands": true
}
}
```

生产环境配置:

```
json复制```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": [
        "${workspaceFolder}/build",
        "${workspaceFolder}/dist",
        "/tmp"
      ],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "~/.config",
        "${workspaceFolder}/src"
      ]
    },
    "network": {
      "allowedDomains": [
        "api.anthropic.com",
        "code.claude.com",
        "*.prod.company.com"
      ],
      "httpProxy": "http://proxy-prod.company.com:8080",
      "httpsProxy": "http://proxy-prod.company.com:8080"
    },
    "excludedCommands": [],
    "allowUnsandboxedCommands": false,
    "enableWeakerNestedSandbox": false
  }
}

```### 项目级配置

为不同类型的项目创建专门的沙箱配置：

> **前端项目配置 (frontend-sandbox.json):**

{
"name": "Frontend Sandbox",
"sandbox": {
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp",
"/home/developer/.npm"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"registry.npmjs.org",
"*.api.company.com"
]
},
"excludedCommands": [
"docker"
]
}
}
```

```
```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": [
        "${workspaceFolder}/build",
        "${workspaceFolder}/dist",
        "/tmp"
      ],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "~/.config",
        "${workspaceFolder}/src"
      ]
    },
    "network": {
      "allowedDomains": [
        "api.anthropic.com",
        "code.claude.com",
        "*.prod.company.com"
      ],
      "httpProxy": "http://proxy-prod.company.com:8080",
      "httpsProxy": "http://proxy-prod.company.com:8080"
    },
    "excludedCommands": [],
    "allowUnsandboxedCommands": false,
    "enableWeakerNestedSandbox": false
  }
}

```### 项目级配置

为不同类型的项目创建专门的沙箱配置：

> **前端项目配置 (frontend-sandbox.json):**

{
"name": "Frontend Sandbox",
"sandbox": {
"filesystem": {
"allowedWritePaths": [
"${workspaceFolder}",
"/tmp",
"/home/developer/.npm"
],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"registry.npmjs.org",
"*.api.company.com"
]
},
"excludedCommands": [
"docker"
]
}
}
```

后端项目配置 (backend-sandbox.json):

```
json复制```json

{
  "name": "Backend Sandbox",
  "sandbox": {
    "filesystem": {
      "allowedWritePaths": [
        "${workspaceFolder}",
        "/tmp",
        "/var/log/app"
      ],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "/var/lib"
      ]
    },
    "network": {
      "allowedDomains": [
        "api.anthropic.com",
        "code.claude.com",
        "github.com",
        "*.api.company.com",
        "*.db.company.com"
      ]
    },
    "excludedCommands": [
      "docker",
      "systemctl",
      "service"
    ]
  }
}

```## 34.2.6 高级配置

### 自定义代理配置

# 自定义代理服务器实现
import asyncio
from aiohttp import web
class SandboxProxy:
def __init__(self, allowed_domains, audit_log_path):
self.allowed_domains = set(allowed_domains)
self.audit_log_path = audit_log_path
async def proxy_handler(self, request):
target_url = request.headers.get('X-Target-URL')
# 检查域名是否在白名单中
from urllib.parse import urlparse
parsed = urlparse(target_url)
domain = parsed.netloc
if domain not in self.allowed_domains:
# 记录拒绝的访问
self.log_access(request, target_url, allowed=False)
return web.Response(status=403, text="Domain not allowed")
# 转发请求
async with aiohttp.ClientSession() as session:
async with session.request(
request.method,
target_url,
headers=request.headers,
data=await request.read()
) as response:
# 记录允许的访问
self.log_access(request, target_url, allowed=True)
return web.Response(
status=response.status,
body=await response.read()
)
def log_access(self, request, url, allowed):
import json
from datetime import datetime
log_entry = {
"timestamp": datetime.now().isoformat(),
"client_ip": request.remote,
"url": url,
"allowed": allowed,
"method": request.method
}
with open(self.audit_log_path, 'a') as f:
f.write(json.dumps(log_entry) + '\n')
def start(self, host='0.0.0.0', port=8080):
app = web.Application()
app.router.add_route('*', '/{path:.*}', self.proxy_handler)
web.run_app(app, host=host, port=port)
# 使用示例
if __name__ == '__main__':
proxy = SandboxProxy(
allowed_domains=[
'api.anthropic.com',
'code.claude.com',
'github.com'
],
audit_log_path='/var/log/sandbox-proxy.log'
)
proxy.start()
```

```
```json

{
  "name": "Backend Sandbox",
  "sandbox": {
    "filesystem": {
      "allowedWritePaths": [
        "${workspaceFolder}",
        "/tmp",
        "/var/log/app"
      ],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "/var/lib"
      ]
    },
    "network": {
      "allowedDomains": [
        "api.anthropic.com",
        "code.claude.com",
        "github.com",
        "*.api.company.com",
        "*.db.company.com"
      ]
    },
    "excludedCommands": [
      "docker",
      "systemctl",
      "service"
    ]
  }
}

```## 34.2.6 高级配置

### 自定义代理配置

# 自定义代理服务器实现
import asyncio
from aiohttp import web
class SandboxProxy:
def __init__(self, allowed_domains, audit_log_path):
self.allowed_domains = set(allowed_domains)
self.audit_log_path = audit_log_path
async def proxy_handler(self, request):
target_url = request.headers.get('X-Target-URL')
# 检查域名是否在白名单中
from urllib.parse import urlparse
parsed = urlparse(target_url)
domain = parsed.netloc
if domain not in self.allowed_domains:
# 记录拒绝的访问
self.log_access(request, target_url, allowed=False)
return web.Response(status=403, text="Domain not allowed")
# 转发请求
async with aiohttp.ClientSession() as session:
async with session.request(
request.method,
target_url,
headers=request.headers,
data=await request.read()
) as response:
# 记录允许的访问
self.log_access(request, target_url, allowed=True)
return web.Response(
status=response.status,
body=await response.read()
)
def log_access(self, request, url, allowed):
import json
from datetime import datetime
log_entry = {
"timestamp": datetime.now().isoformat(),
"client_ip": request.remote,
"url": url,
"allowed": allowed,
"method": request.method
}
with open(self.audit_log_path, 'a') as f:
f.write(json.dumps(log_entry) + '\n')
def start(self, host='0.0.0.0', port=8080):
app = web.Application()
app.router.add_route('*', '/{path:.*}', self.proxy_handler)
web.run_app(app, host=host, port=port)
# 使用示例
if __name__ == '__main__':
proxy = SandboxProxy(
allowed_domains=[
'api.anthropic.com',
'code.claude.com',
'github.com'
],
audit_log_path='/var/log/sandbox-proxy.log'
)
proxy.start()
```

##### Unix Socket 配置#

```
json复制```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "allowedUnixSockets": [
        "/var/run/docker.sock",  # 警告：这可能授予主机访问权限
        "/tmp/vscode-git.sock"
      ]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  }
}

```### 嵌套沙箱配置

{
"sandbox": {
"enabled": true,
"enableWeakerNestedSandbox": true,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}"]
},
"network": {
"allowedDomains": ["api.anthropic.com", "code.claude.com"]
}
}
}
```

```
```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "allowedUnixSockets": [
        "/var/run/docker.sock",  # 警告：这可能授予主机访问权限
        "/tmp/vscode-git.sock"
      ]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  }
}

```### 嵌套沙箱配置

{
"sandbox": {
"enabled": true,
"enableWeakerNestedSandbox": true,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}"]
},
"network": {
"allowedDomains": ["api.anthropic.com", "code.claude.com"]
}
}
}
```

#### 34.2.7 安全最佳实践#

##### 1. 最小权限原则#

从最严格的配置开始，根据需要逐步放宽：

```
json复制```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "~/.config",
        "/usr/local/bin",
        "/opt"
      ]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    },
    "excludedCommands": [],
    "allowUnsandboxedCommands": false
  }
}

```### 2. 审计和监控

实现全面的审计日志记录：

import json
from datetime import datetime
from pathlib import Path
class SandboxAuditor:
def __init__(self, log_dir='/var/log/claude-sandbox'):
self.log_dir = Path(log_dir)
self.log_dir.mkdir(parents=True, exist_ok=True)
def log_filesystem_access(self, operation, path, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "filesystem",
"operation": operation,
"path": path,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def log_network_access(self, url, domain, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "network",
"url": url,
"domain": domain,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def log_command_execution(self, command, sandboxed, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "command",
"command": command,
"sandboxed": sandboxed,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def _write_log(self, log_entry):
log_file = self.log_dir / f"sandbox-{datetime.now().strftime('%Y-%m-%d')}.log"
with open(log_file, 'a') as f:
f.write(json.dumps(log_entry) + '\n')
def analyze_violations(self, days=7):
violations = []
for i in range(days):
date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
log_file = self.log_dir / f"sandbox-{date}.log"
if log_file.exists():
with open(log_file, 'r') as f:
for line in f:
entry = json.loads(line)
if not entry.get('allowed', True):
violations.append(entry)
return violations
# 使用示例
auditor = SandboxAuditor()
# 记录文件系统访问
auditor.log_filesystem_access('write', '/etc/config', False, 'developer')
# 记录网络访问
auditor.log_network_access('https://malicious.com', 'malicious.com', False, 'developer')
# 分析违规
violations = auditor.analyze_violations(days=7)
print(f"发现 {len(violations)} 个违规")
```

```
```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "deniedPaths": [
        "/etc",
        "/root",
        "~/.ssh",
        "~/.aws",
        "~/.config",
        "/usr/local/bin",
        "/opt"
      ]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    },
    "excludedCommands": [],
    "allowUnsandboxedCommands": false
  }
}

```### 2. 审计和监控

实现全面的审计日志记录：

import json
from datetime import datetime
from pathlib import Path
class SandboxAuditor:
def __init__(self, log_dir='/var/log/claude-sandbox'):
self.log_dir = Path(log_dir)
self.log_dir.mkdir(parents=True, exist_ok=True)
def log_filesystem_access(self, operation, path, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "filesystem",
"operation": operation,
"path": path,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def log_network_access(self, url, domain, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "network",
"url": url,
"domain": domain,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def log_command_execution(self, command, sandboxed, allowed, user):
log_entry = {
"timestamp": datetime.now().isoformat(),
"type": "command",
"command": command,
"sandboxed": sandboxed,
"allowed": allowed,
"user": user
}
self._write_log(log_entry)
def _write_log(self, log_entry):
log_file = self.log_dir / f"sandbox-{datetime.now().strftime('%Y-%m-%d')}.log"
with open(log_file, 'a') as f:
f.write(json.dumps(log_entry) + '\n')
def analyze_violations(self, days=7):
violations = []
for i in range(days):
date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
log_file = self.log_dir / f"sandbox-{date}.log"
if log_file.exists():
with open(log_file, 'r') as f:
for line in f:
entry = json.loads(line)
if not entry.get('allowed', True):
violations.append(entry)
return violations
# 使用示例
auditor = SandboxAuditor()
# 记录文件系统访问
auditor.log_filesystem_access('write', '/etc/config', False, 'developer')
# 记录网络访问
auditor.log_network_access('https://malicious.com', 'malicious.com', False, 'developer')
# 分析违规
violations = auditor.analyze_violations(days=7)
print(f"发现 {len(violations)} 个违规")
```

##### 3. 定期审查#

建立定期审查流程：

```
bash复制```bash

#!/bin/bash
# sandbox-audit.sh

LOG_DIR="/var/log/claude-sandbox"
REPORT_DIR="/var/reports/sandbox"
DATE=$(date +%Y-%m-%d)

# 创建报告目录
mkdir -p "$REPORT_DIR"

# 生成每日报告
echo "=== 沙箱审计报告 - $DATE ===" > "$REPORT_DIR/daily-$DATE.txt"

# 统计违规次数
VIOLATIONS=$(grep -r '"allowed": false' "$LOG_DIR" | wc -l)
echo "总违规次数: $VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 统计文件系统违规
FS_VIOLATIONS=$(grep -r '"type": "filesystem"' "$LOG_DIR" | grep '"allowed": false' | wc -l)
echo "文件系统违规: $FS_VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 统计网络违规
NET_VIOLATIONS=$(grep -r '"type": "network"' "$LOG_DIR" | grep '"allowed": false' | wc -l)
echo "网络违规: $NET_VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 列出最活跃的用户
echo -e "\n最活跃的用户:" >> "$REPORT_DIR/daily-$DATE.txt"
grep -r '"user"' "$LOG_DIR" | jq -r '.user' | sort | uniq -c | sort -rn | head -10 >> "$REPORT_DIR/daily-$DATE.txt"

# 列出最常见的违规
echo -e "\n最常见的违规:" >> "$REPORT_DIR/daily-$DATE.txt"
grep -r '"allowed": false' "$LOG_DIR" | jq -r '.path // .domain // .command' | sort | uniq -c | sort -rn | head -10 >> "$REPORT_DIR/daily-$DATE.txt"

echo "报告已生成: $REPORT_DIR/daily-$DATE.txt"

```### 4. 环境隔离

为不同的环境使用不同的沙箱配置：

import json
from pathlib import Path
class SandboxConfigManager:
def __init__(self, config_dir='/etc/claude-sandbox'):
self.config_dir = Path(config_dir)
self.config_dir.mkdir(parents=True, exist_ok=True)
def create_config(self, environment, config):
config_file = self.config_dir / f"{environment}.json"
with open(config_file, 'w') as f:
json.dump(config, f, indent=2)
def get_config(self, environment):
config_file = self.config_dir / f"{environment}.json"
if config_file.exists():
with open(config_file, 'r') as f:
return json.load(f)
return None
def create_development_config(self):
return {
"sandbox": {
"enabled": True,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}", "/tmp"],
"deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"*.dev.company.com"
]
},
"allowUnsandboxedCommands": True
}
}
def create_production_config(self):
return {
"sandbox": {
"enabled": True,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}/build", "/tmp"],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws",
"~/.config",
"${workspaceFolder}/src"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"*.prod.company.com"
]
},
"allowUnsandboxedCommands": False,
"enableWeakerNestedSandbox": False
}
}
# 使用示例
manager = SandboxConfigManager()
# 创建开发环境配置
manager.create_config('development', manager.create_development_config())
# 创建生产环境配置
manager.create_config('production', manager.create_production_config())
```

```
```bash

#!/bin/bash
# sandbox-audit.sh

LOG_DIR="/var/log/claude-sandbox"
REPORT_DIR="/var/reports/sandbox"
DATE=$(date +%Y-%m-%d)

# 创建报告目录
mkdir -p "$REPORT_DIR"

# 生成每日报告
echo "=== 沙箱审计报告 - $DATE ===" > "$REPORT_DIR/daily-$DATE.txt"

# 统计违规次数
VIOLATIONS=$(grep -r '"allowed": false' "$LOG_DIR" | wc -l)
echo "总违规次数: $VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 统计文件系统违规
FS_VIOLATIONS=$(grep -r '"type": "filesystem"' "$LOG_DIR" | grep '"allowed": false' | wc -l)
echo "文件系统违规: $FS_VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 统计网络违规
NET_VIOLATIONS=$(grep -r '"type": "network"' "$LOG_DIR" | grep '"allowed": false' | wc -l)
echo "网络违规: $NET_VIOLATIONS" >> "$REPORT_DIR/daily-$DATE.txt"

# 列出最活跃的用户
echo -e "\n最活跃的用户:" >> "$REPORT_DIR/daily-$DATE.txt"
grep -r '"user"' "$LOG_DIR" | jq -r '.user' | sort | uniq -c | sort -rn | head -10 >> "$REPORT_DIR/daily-$DATE.txt"

# 列出最常见的违规
echo -e "\n最常见的违规:" >> "$REPORT_DIR/daily-$DATE.txt"
grep -r '"allowed": false' "$LOG_DIR" | jq -r '.path // .domain // .command' | sort | uniq -c | sort -rn | head -10 >> "$REPORT_DIR/daily-$DATE.txt"

echo "报告已生成: $REPORT_DIR/daily-$DATE.txt"

```### 4. 环境隔离

为不同的环境使用不同的沙箱配置：

import json
from pathlib import Path
class SandboxConfigManager:
def __init__(self, config_dir='/etc/claude-sandbox'):
self.config_dir = Path(config_dir)
self.config_dir.mkdir(parents=True, exist_ok=True)
def create_config(self, environment, config):
config_file = self.config_dir / f"{environment}.json"
with open(config_file, 'w') as f:
json.dump(config, f, indent=2)
def get_config(self, environment):
config_file = self.config_dir / f"{environment}.json"
if config_file.exists():
with open(config_file, 'r') as f:
return json.load(f)
return None
def create_development_config(self):
return {
"sandbox": {
"enabled": True,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}", "/tmp"],
"deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com",
"npmjs.org",
"*.dev.company.com"
]
},
"allowUnsandboxedCommands": True
}
}
def create_production_config(self):
return {
"sandbox": {
"enabled": True,
"filesystem": {
"allowedWritePaths": ["${workspaceFolder}/build", "/tmp"],
"deniedPaths": [
"/etc",
"/root",
"~/.ssh",
"~/.aws",
"~/.config",
"${workspaceFolder}/src"
]
},
"network": {
"allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"*.prod.company.com"
]
},
"allowUnsandboxedCommands": False,
"enableWeakerNestedSandbox": False
}
}
# 使用示例
manager = SandboxConfigManager()
# 创建开发环境配置
manager.create_config('development', manager.create_development_config())
# 创建生产环境配置
manager.create_config('production', manager.create_production_config())
```

#### 34.2.8 故障排查#

##### 常见问题#

问题 1：沙箱阻止了合法操作

```
bash复制```bash

# 查看沙箱日志
tail -f /var/log/claude-sandbox/sandbox-$(date +%Y-%m-%d).log

# 临时禁用沙箱
```

```
```bash

# 查看沙箱日志
tail -f /var/log/claude-sandbox/sandbox-$(date +%Y-%m-%d).log

# 临时禁用沙箱
```

/sandbox disable

### 添加允许的路径或域名

### 在 settings.json 中更新配置

```
bash复制
# 检查命令是否在排除列表中
```

```
# 检查命令是否在排除列表中
```

/sandbox config

### 将命令添加到排除列表

### 在 settings.json 中添加到 "excludedCommands"

```
bash复制> **问题 3：网络连接问题**

```bash
```bash

# 测试 DNS 解析
dig api.anthropic.com

# 检查代理配置
echo $HTTP_PROXY
echo $HTTPS_PROXY

# 测试网络连接
curl -v https://api.anthropic.com

```> **问题 4：文件权限问题**

# 检查文件权限
ls -la /workspace
# 修复权限
chmod 755 /workspace
chown developer:developer /workspace
```

```
> **问题 3：网络连接问题**

```bash
```bash

# 测试 DNS 解析
dig api.anthropic.com

# 检查代理配置
echo $HTTP_PROXY
echo $HTTPS_PROXY

# 测试网络连接
curl -v https://api.anthropic.com

```> **问题 4：文件权限问题**

# 检查文件权限
ls -la /workspace
# 修复权限
chmod 755 /workspace
chown developer:developer /workspace
```

#### 34.2.9 与其他安全功能集成#

##### 与 IAM 策略集成#

```
json复制```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  },
  "permissions": {
    "fileAccess": {
      "allowedPaths": ["${workspaceFolder}"],
      "deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
    },
    "networkAccess": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  }
}

```### 与开发容器集成

{
"name": "Claude Code Enterprise Dev Container",
"dockerFile": "Dockerfile",
"customizations": {
"vscode": {
"settings": {
"claude-code.sandbox.enabled": true,
"claude-code.sandbox.filesystem.allowedWritePaths": [
"${workspaceFolder}",
"/tmp"
],
"claude-code.sandbox.network.allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com"
]
}
}
},
"postCreateCommand": "bash .devcontainer/init-sandbox.sh"
}
```

```
```json

{
  "sandbox": {
    "enabled": true,
    "filesystem": {
      "allowedWritePaths": ["${workspaceFolder}"],
      "deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
    },
    "network": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  },
  "permissions": {
    "fileAccess": {
      "allowedPaths": ["${workspaceFolder}"],
      "deniedPaths": ["/etc", "/root", "~/.ssh", "~/.aws"]
    },
    "networkAccess": {
      "allowedDomains": ["api.anthropic.com", "code.claude.com"]
    }
  }
}

```### 与开发容器集成

{
"name": "Claude Code Enterprise Dev Container",
"dockerFile": "Dockerfile",
"customizations": {
"vscode": {
"settings": {
"claude-code.sandbox.enabled": true,
"claude-code.sandbox.filesystem.allowedWritePaths": [
"${workspaceFolder}",
"/tmp"
],
"claude-code.sandbox.network.allowedDomains": [
"api.anthropic.com",
"code.claude.com",
"github.com"
]
}
}
},
"postCreateCommand": "bash .devcontainer/init-sandbox.sh"
}
```

---

## 3 企业级监控与维护

**URL**: https://claudecode.tangshuang.net/course/34.3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%BB%B4%E6%8A%A4

学习如何建立企业级监控和维护体系，确保 Claude Code 在生产环境中的稳定运行和持续优化。

#### 34.3.1 监控体系概述#

##### 监控的重要性#

企业级监控对于 Claude Code 部署至关重要，它可以帮助：

- 确保可用性：及时发现和解决服务中断
- 优化性能：识别性能瓶颈并优化资源使用
- 安全防护：检测异常行为和安全威胁
- 成本控制：监控使用情况和资源消耗
- 合规审计：满足企业合规要求

##### 监控维度#

### 企业级监控维度

MONITORING_DIMENSIONS = {
"可用性监控": {
"指标": ["服务状态", "响应时间", "错误率"],
"目标": "99.9% 可用性"
},
"性能监控": {
"指标": ["API 延迟", "令牌使用", "并发连接"],
"目标": "P95 延迟 < 2s"
},
"资源监控": {
"指标": ["CPU 使用率", "内存使用", "磁盘 I/O", "网络带宽"],
"目标": "资源利用率 < 80%"
},
"安全监控": {
"指标": ["异常访问", "权限违规", "数据泄露"],
"目标": "零安全事件"
},
"成本监控": {
"指标": ["API 调用成本", "令牌成本", "基础设施成本"],
"目标": "成本控制在预算内"
}
}

#### 34.3.2 指标收集#

##### Prometheus 配置#

```
bash复制yaml

# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # Claude Code API 监控
  - job_name: 'claude-code-api'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s

  # LLM 网关监控
  - job_name: 'llm-gateway'
    static_configs:
      - targets: ['localhost:4000']
    metrics_path: '/metrics'
    scrape_interval: 10s

  # 开发容器监控
  - job_name: 'dev-containers'
    static_configs:
      - targets: ['localhost:9323']
    metrics_path: '/metrics'
    scrape_interval: 30s

  # 沙箱监控
  - job_name: 'sandbox'
    static_configs:
      - targets: ['localhost:9100']
    metrics_path: '/metrics'
    scrape_interval: 15s

alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']

### 自定义指标导出器

# claude_code_exporter.py
from prometheus_client import start_http_server, Gauge, Counter, Histogram
import time
import json
import requests
from datetime import datetime
# 定义指标
api_requests_total = Counter(
'claude_code_api_requests_total',
'Total API requests',
['endpoint', 'status']
)
api_latency = Histogram(
'claude_code_api_latency_seconds',
'API request latency',
['endpoint']
)
active_sessions = Gauge(
'claude_code_active_sessions',
'Number of active sessions'
)
tokens_used = Counter(
'claude_code_tokens_used_total',
'Total tokens used',
['model', 'type']
)
cost_incurred = Gauge(
'claude_code_cost_usd',
'Total cost incurred in USD'
)
class ClaudeCodeMetricsCollector:
def __init__(self, api_base_url='http://localhost:8080'):
self.api_base_url = api_base_url
self.start_time = datetime.now()
def collect_api_metrics(self):
"""收集 API 指标"""
try:
# 获取 API 状态
response = requests.get(f'{self.api_base_url}/health')
if response.status_code == 200:
data = response.json()
# 更新活跃会话数
```

```
yaml

# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # Claude Code API 监控
  - job_name: 'claude-code-api'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s

  # LLM 网关监控
  - job_name: 'llm-gateway'
    static_configs:
      - targets: ['localhost:4000']
    metrics_path: '/metrics'
    scrape_interval: 10s

  # 开发容器监控
  - job_name: 'dev-containers'
    static_configs:
      - targets: ['localhost:9323']
    metrics_path: '/metrics'
    scrape_interval: 30s

  # 沙箱监控
  - job_name: 'sandbox'
    static_configs:
      - targets: ['localhost:9100']
    metrics_path: '/metrics'
    scrape_interval: 15s

alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']

### 自定义指标导出器

# claude_code_exporter.py
from prometheus_client import start_http_server, Gauge, Counter, Histogram
import time
import json
import requests
from datetime import datetime
# 定义指标
api_requests_total = Counter(
'claude_code_api_requests_total',
'Total API requests',
['endpoint', 'status']
)
api_latency = Histogram(
'claude_code_api_latency_seconds',
'API request latency',
['endpoint']
)
active_sessions = Gauge(
'claude_code_active_sessions',
'Number of active sessions'
)
tokens_used = Counter(
'claude_code_tokens_used_total',
'Total tokens used',
['model', 'type']
)
cost_incurred = Gauge(
'claude_code_cost_usd',
'Total cost incurred in USD'
)
class ClaudeCodeMetricsCollector:
def __init__(self, api_base_url='http://localhost:8080'):
self.api_base_url = api_base_url
self.start_time = datetime.now()
def collect_api_metrics(self):
"""收集 API 指标"""
try:
# 获取 API 状态
response = requests.get(f'{self.api_base_url}/health')
if response.status_code == 200:
data = response.json()
# 更新活跃会话数
```

active_sessions.set(data.get('active_sessions', 0))

### 更新令牌使用

tokens = data.get('tokens_used', {})
for model, count in tokens.items():
tokens_used.labels(model=model, type='input').inc(count.get('input', 0))
tokens_used.labels(model=model, type='output').inc(count.get('output', 0))

### 更新成本

cost_incurred.set(data.get('total_cost', 0.0))
except Exception as e:
print(f"Error collecting API metrics: {e}")
def collect_performance_metrics(self):
"""收集性能指标"""
try:

### 测试 API 延迟

start_time = time.time()
response = requests.get(f'{self.api_base0_url}/health')
latency = time.time() - start_time

### 记录延迟

api_latency.labels(endpoint='/health').observe(latency)

### 记录请求

api_requests_total.labels(
endpoint='/health',
status=response.status_code
).inc()
except Exception as e:
print(f"Error collecting performance metrics: {e}")
def collect_sandbox_metrics(self):
"""收集沙箱指标"""
try:
response = requests.get(f'{self.api_base_url}/sandbox/status')
if response.status_code == 200:
data = response.json()

### 沙箱违规计数

violations = data.get('violations', 0)

### 可以添加更多沙箱相关指标

except Exception as e:
print(f"Error collecting sandbox metrics: {e}")
def run(self, interval=10):
"""运行指标收集器"""
start_http_server(9100)
print("Metrics server started on port 9100")
while True:
self.collect_api_metrics()
self.collect_performance_metrics()
self.collect_sandbox_metrics()
time.sleep(interval)
if name == 'main':
collector = ClaudeCodeMetricsCollector()
collector.run()

```
bash复制### 日志收集配置
```

```
### 日志收集配置
```

### filebeat.yml

filebeat.inputs:

- type: log
enabled: true
paths:

/var/log/claude-code/*.log
fields:
service: claude-code
environment: production
fields_under_root: true
- /var/log/claude-code/*.log
fields:
service: claude-code
environment: production
fields_under_root: true
- type: log
enabled: true
paths:

/var/log/llm-gateway/*.log
fields:
service: llm-gateway
environment: production
fields_under_root: true
- /var/log/llm-gateway/*.log
fields:
service: llm-gateway
environment: production
fields_under_root: true
- type: log
enabled: true
paths:

/var/log/claude-sandbox/*.log
fields:
service: claude-sandbox
environment: production
fields_under_root: true
- /var/log/claude-sandbox/*.log
fields:
service: claude-sandbox
environment: production
fields_under_root: true

type: log
enabled: true
paths:

- /var/log/claude-code/*.log
fields:
service: claude-code
environment: production
fields_under_root: true

type: log
enabled: true
paths:

- /var/log/llm-gateway/*.log
fields:
service: llm-gateway
environment: production
fields_under_root: true

type: log
enabled: true
paths:

- /var/log/claude-sandbox/*.log
fields:
service: claude-sandbox
environment: production
fields_under_root: true

output.elasticsearch:
hosts: ["elasticsearch:9200"]
index: "claude-code-%{+yyyy.MM.dd}"

setup.kibana:
host: "kibana:5601"

processors:

- add_host_metadata: ~
- add_cloud_metadata: ~

#### 34.3.3 告警配置#

##### Prometheus 告警规则#

### alert_rules.yml

groups:

- name: claude_code_alerts
interval: 30s
rules:

### 服务可用性告警

- alert: ClaudeCodeServiceDown
expr: up{job="claude-code-api"} == 0
for: 1m
labels:
severity: critical
annotations:
summary: "Claude Code 服务不可用"
description: "Claude Code API 服务已宕机超过 1 分钟"

### API 错误率告警

- alert: HighAPIErrorRate
expr: |
rate(claude_code_api_requests_total{status=~"5.."}[5m]) /
rate(claude_code_api_requests_total[5m]) > 0.05
for: 5m
labels:
severity: warning
annotations:
summary: "API 错误率过高"
description: "API 错误率超过 5% (当前: {{ $value }})"

### API 延迟告警

- alert: HighAPILatency
expr: |
histogram_quantile(0.95,
rate(claude_code_api_latency_seconds_bucket[5m])
) > 2
for: 5m
labels:
severity: warning
annotations:
summary: "API 延迟过高"
description: "API P95 延迟超过 2 秒 (当前: {{ $value }}s)"

### 令牌使用告警

- alert: HighTokenUsage
expr: |
rate(claude_code_tokens_used_total[1h]) > 100000
for: 10m
labels:
severity: warning
annotations:
summary: "令牌使用率过高"
description: "令牌使用率超过 100,000/小时 (当前: {{ $value }})"

### 成本告警

- alert: HighCostIncurred
expr: claude_code_cost_usd > 1000
for: 1h
labels:
severity: warning
annotations:
summary: "成本超过阈值"
description: "累计成本超过 $1000 (当前: ${{ $value }})"

### 沙箱违规告警

- alert: SandboxViolations
expr: |
rate(claude_sandbox_violations_total[5m]) > 10
for: 5m
labels:
severity: critical
annotations:
summary: "沙箱违规频繁"
description: "沙箱违规率超过 10/分钟 (当前: {{ $value }})"

### 资源使用告警

- alert: HighCPUUsage
expr: |
rate(process_cpu_seconds_total{job="claude-code-api"}[5m]) > 0.8
for: 10m
labels:
severity: warning
annotations:
summary: "CPU 使用率过高"
description: "CPU 使用率超过 80% (当前: {{ $value }})"
- alert: HighMemoryUsage
expr: |
process_resident_memory_bytes{job="claude-code-api"} /
node_memory_MemTotal_bytes > 0.8
for: 10m
labels:
severity: warning
annotations:
summary: "内存使用率过高"
description: "内存使用率超过 80% (当前: {{ $value }})"

```
bash复制### Alertmanager 配置
```

```
### Alertmanager 配置
```

### alertmanager.yml

global:
resolve_timeout: 5m

route:
group_by: ['alertname', 'severity']
group_wait: 10s
group_interval: 10s
repeat_interval: 12h
receiver: 'default'
routes:
- match:
severity: critical
receiver: 'critical-alerts'
continue: false

```
bash复制- match:
    severity: warning
  receiver: 'warning-alerts'
  continue: false
```

```
- match:
    severity: warning
  receiver: 'warning-alerts'
  continue: false
```

receivers:

- name: 'default'
email_configs:

to: 'team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
- to: 'team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
- name: 'critical-alerts'
email_configs:

to: 'oncall@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#critical-alerts'
title: 'Claude Code Critical Alert'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
- to: 'oncall@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
- api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#critical-alerts'
title: 'Claude Code Critical Alert'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
- name: 'warning-alerts'
email_configs:

to: 'dev-team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#warnings'
title: 'Claude Code Warning'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
- to: 'dev-team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
- api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#warnings'
title: 'Claude Code Warning'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

name: 'default'
email_configs:

- to: 'team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'

name: 'critical-alerts'
email_configs:

- to: 'oncall@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
- api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#critical-alerts'
title: 'Claude Code Critical Alert'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

name: 'warning-alerts'
email_configs:

- to: 'dev-team@company.com'
from: 'alerts@company.com'
smarthost: 'smtp.company.com:587'
auth_username: 'alerts@company.com'
auth_password: 'password'
slack_configs:
- api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
channel: '#warnings'
title: 'Claude Code Warning'
text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

inhibit_rules:

- source_match:
severity: 'critical'
target_match:
severity: 'warning'
equal: ['alertname']

#### 34.3.4 可视化仪表板#

##### Grafana 仪表板配置#

{
"dashboard": {
"title": "Claude Code Enterprise Dashboard",
"panels": [
{
"title": "API 请求速率",
"targets": [
{
"expr": "rate(claude_code_api_requests_total[5m])",
"legendFormat": "{{ endpoint }}"
}
],
"type": "graph"
},
{
"title": "API 延迟 (P95)",
"targets": [
{
"expr": "histogram_quantile(0.95, rate(claude_code_api_latency_seconds_bucket[5m]))",
"legendFormat": "P95"
}
],
"type": "graph"
},
{
"title": "活跃会话数",
"targets": [
{
"expr": "claude_code_active_sessions",
"legendFormat": "Sessions"
}
],
"type": "stat"
},
{
"title": "令牌使用率",
"targets": [
{
"expr": "rate(claude_code_tokens_used_total[1h])",
"legendFormat": "{{ model }} - {{ type }}"
}
],
"type": "graph"
},
{
"title": "累计成本",
"targets": [
{
"expr": "claude_code_cost_usd",
"legendFormat": "Cost (USD)"
}
],
"type": "stat"
},
{
"title": "API 错误率",
"targets": [
{
"expr": "rate(claude_code_api_requests_total{status=~"5.."}[5m]) / rate(claude_code_api_requests_total[5m])",
"legendFormat": "Error Rate"
}
],
"type": "graph"
},
{
"title": "沙箱违规",
"targets": [
{
"expr": "rate(claude_sandbox_violations_total[5m])",
"legendFormat": "Violations/min"
}
],
"type": "graph"
},
{
"title": "资源使用",
"targets": [
{
"expr": "rate(process_cpu_seconds_total{job="claude-code-api"}[5m])",
"legendFormat": "CPU"
},
{
"expr": "process_resident_memory_bytes{job="claude-code-api"} / 1024 / 1024 / 1024",
"legendFormat": "Memory (GB)"
}
],
"type": "graph"
}
]
}
}

```
bash复制## 34.3.5 日志分析
### ELK Stack 配置
```

```
## 34.3.5 日志分析
### ELK Stack 配置
```

python

### log_analyzer.py

import elasticsearch
from elasticsearch import Elasticsearch
from datetime import datetime, timedelta
import json

class ClaudeCodeLogAnalyzer:
def init(self, es_host='http://localhost:9200'):
self.es = Elasticsearch([es_host])
self.index_pattern = 'claude-code-*'

```
bash复制def search_errors(self, hours=24):
    """搜索错误日志"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"match": {"level": "ERROR"}},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                        }
                    }}
                ]
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response['hits']['hits']

def search_slow_requests(self, threshold_seconds=2, hours=24):
    """搜索慢请求"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"range": {
                        "latency": {
                            "gte": threshold_seconds
                        }
                    }},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                        }
                    }}
                ]
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response['hits']['hits']

def analyze_user_activity(self, user_id, days=7):
    """分析用户活动"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"match": {"user_id": user_id}},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(days=days)).isoformat()
                        }
                    }}
                ]
            }
        },
        "aggs": {
            "daily_requests": {
                "date_histogram": {
                    "field": "@timestamp",
                    "calendar_interval": "day"
                },
                "aggs": {
                    "total_tokens": {
                        "sum": {
                            "field": "tokens_used"
                        }
                    }
                }
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response

def detect_anomalies(self, hours=1):
    """检测异常"""
    # 计算平均请求速率
    avg_query = {
        "query": {
            "range": {
                "@timestamp": {
                    "gte": (datetime.now() - timedelta(hours=hours*2)).isoformat(),
                    "lt": (datetime.now() - timedelta(hours=hours)).isoformat()
                }
            }
        },
        "aggs": {
            "avg_rate": {
                "avg": {
                    "script": {
                        "source": "doc['request_count'].value"
                    }
                }
            }
        }
    }

    avg_response = self.es.search(index=self.index_pattern, body=avg_query)
    avg_rate = avg_response['aggregations']['avg_rate']['value']

    # 检查当前速率是否异常
    current_query = {
        "query": {
            "range": {
                "@timestamp": {
                    "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                }
            }
        },
        "aggs": {
            "current_rate": {
                "avg": {
                    "script": {
                        "source": "doc['request_count'].value"
                    }
                }
            }
        }
    }

    current_response = self.es.search(index=self.index_pattern, body=current_query)
    current_rate = current_response['aggregations']['current_rate']['value']

    # 如果当前速率超过平均值的 2 倍，视为异常
    if current_rate > avg_rate * 2:
        return {
            "anomaly": True,
            "avg_rate": avg_rate,
            "current_rate": current_rate,
            "threshold": avg_rate * 2
        }

    return {"anomaly": False}
```

```
def search_errors(self, hours=24):
    """搜索错误日志"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"match": {"level": "ERROR"}},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                        }
                    }}
                ]
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response['hits']['hits']

def search_slow_requests(self, threshold_seconds=2, hours=24):
    """搜索慢请求"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"range": {
                        "latency": {
                            "gte": threshold_seconds
                        }
                    }},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                        }
                    }}
                ]
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response['hits']['hits']

def analyze_user_activity(self, user_id, days=7):
    """分析用户活动"""
    query = {
        "query": {
            "bool": {
                "must": [
                    {"match": {"user_id": user_id}},
                    {"range": {
                        "@timestamp": {
                            "gte": (datetime.now() - timedelta(days=days)).isoformat()
                        }
                    }}
                ]
            }
        },
        "aggs": {
            "daily_requests": {
                "date_histogram": {
                    "field": "@timestamp",
                    "calendar_interval": "day"
                },
                "aggs": {
                    "total_tokens": {
                        "sum": {
                            "field": "tokens_used"
                        }
                    }
                }
            }
        }
    }

    response = self.es.search(index=self.index_pattern, body=query)
    return response

def detect_anomalies(self, hours=1):
    """检测异常"""
    # 计算平均请求速率
    avg_query = {
        "query": {
            "range": {
                "@timestamp": {
                    "gte": (datetime.now() - timedelta(hours=hours*2)).isoformat(),
                    "lt": (datetime.now() - timedelta(hours=hours)).isoformat()
                }
            }
        },
        "aggs": {
            "avg_rate": {
                "avg": {
                    "script": {
                        "source": "doc['request_count'].value"
                    }
                }
            }
        }
    }

    avg_response = self.es.search(index=self.index_pattern, body=avg_query)
    avg_rate = avg_response['aggregations']['avg_rate']['value']

    # 检查当前速率是否异常
    current_query = {
        "query": {
            "range": {
                "@timestamp": {
                    "gte": (datetime.now() - timedelta(hours=hours)).isoformat()
                }
            }
        },
        "aggs": {
            "current_rate": {
                "avg": {
                    "script": {
                        "source": "doc['request_count'].value"
                    }
                }
            }
        }
    }

    current_response = self.es.search(index=self.index_pattern, body=current_query)
    current_rate = current_response['aggregations']['current_rate']['value']

    # 如果当前速率超过平均值的 2 倍，视为异常
    if current_rate > avg_rate * 2:
        return {
            "anomaly": True,
            "avg_rate": avg_rate,
            "current_rate": current_rate,
            "threshold": avg_rate * 2
        }

    return {"anomaly": False}
```

### 使用示例

analyzer = ClaudeCodeLogAnalyzer()

### 搜索错误

errors = analyzer.search_errors(hours=24)
print(f"发现 {len(errors)} 个错误")

### 搜索慢请求

slow_requests = analyzer.search_slow_requests(threshold_seconds=2, hours=24)
print(f"发现 {len(slow_requests)} 个慢请求")

### 分析用户活动

user_activity = analyzer.analyze_user_activity(user_id="user123", days=7)

### 检测异常

anomalies = analyzer.detect_anomalies(hours=1)
if anomalies['anomaly']:
print(f"检测到异常！当前速率: {anomalies['current_rate']}, 阈值: {anomalies['threshold']}")

#### 34.3.6 维护策略#

##### 定期维护任务#

#!/bin/bash

### maintenance.sh

set -e
LOG_DIR="/var/log/claude-code"
BACKUP_DIR="/backup/claude-code"
DATE=$(date +%Y-%m-%d)
echo "=== Claude Code 维护脚本 - $DATE ==="

### 1. 日志轮转

echo "执行日志轮转..."
logrotate -f /etc/logrotate.d/claude-code

### 2. 清理旧日志

echo "清理 30 天前的日志..."
find $LOG_DIR -name "*.log" -mtime +30 -delete

### 3. 备份配置

echo "备份配置文件..."
mkdir -p $BACKUP_DIR/$DATE
cp -r /etc/claude-code $BACKUP_DIR/$DATE/

### 4. 清理缓存

echo "清理缓存..."
rm -rf /tmp/claude-code-cache/*

### 5. 数据库维护（如果使用）

echo "执行数据库维护..."

```
bash复制# psql -U claude -d claude_code -c "VACUUM ANALYZE;"
# 6. 生成维护报告
echo "生成维护报告..."
cat > $BACKUP_DIR/$DATE/maintenance-report.txt << EOF
Claude Code 维护报告
日期: $DATE
日志轮转: 完成
旧日志清理: 完成
配置备份: 完成
缓存清理: 完成
数据库维护: 完成
磁盘使用情况:
$(df -h /var/log/claude-code)
服务状态:
$(systemctl status claude-code --no-pager)
EOF
echo "维护完成！报告已保存到 $BACKUP_DIR/$DATE/maintenance-report.txt"
```

```
# psql -U claude -d claude_code -c "VACUUM ANALYZE;"
# 6. 生成维护报告
echo "生成维护报告..."
cat > $BACKUP_DIR/$DATE/maintenance-report.txt << EOF
Claude Code 维护报告
日期: $DATE
日志轮转: 完成
旧日志清理: 完成
配置备份: 完成
缓存清理: 完成
数据库维护: 完成
磁盘使用情况:
$(df -h /var/log/claude-code)
服务状态:
$(systemctl status claude-code --no-pager)
EOF
echo "维护完成！报告已保存到 $BACKUP_DIR/$DATE/maintenance-report.txt"
```

##### 健康检查脚本#

```
bash复制python

# health_check.py
import requests
import json
import sys
from datetime import datetime

class ClaudeCodeHealthChecker:
    def __init__(self, api_base_url='http://localhost:8080'):
        self.api_base_url = api_base_url
        self.checks = []

    def check_api_health(self):
        """检查 API 健康状态"""
        try:
            response = requests.get(f'{self.api_base_url}/health', timeout=5)
            if response.status_code == 200:
                data = response.json()
                self.checks.append({
                    "name": "API Health",
                    "status": "healthy",
                    "details": data
                })
                return True
            else:
                self.checks.append({
                    "name": "API Health",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "API Health",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_llm_gateway(self):
        """检查 LLM 网关"""
        try:
            response = requests.get('http://localhost:4000/health', timeout=5)
            if response.status_code == 200:
                self.checks.append({
                    "name": "LLM Gateway",
                    "status": "healthy",
                    "details": response.json()
                })
                return True
            else:
                self.checks.append({
                    "name": "LLM Gateway",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "LLM Gateway",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_sandbox(self):
        """检查沙箱状态"""
        try:
            response = requests.get(f'{self.api_base_url}/sandbox/status', timeout=5)
            if response.status_code == 200:
                data = response.json()
                self.checks.append({
                    "name": "Sandbox",
                    "status": "healthy",
                    "details": data
                })
                return True
            else:
                self.checks.append({
                    "name": "Sandbox",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "Sandbox",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_disk_space(self, threshold=90):
        """检查磁盘空间"""
        import shutil
        usage = shutil.disk_usage('/')
        percent = (usage.used / usage.total) * 100

        if percent < threshold:
            self.checks.append({
                "name": "Disk Space",
                "status": "healthy",
                "details": f"Usage: {percent:.1f}%"
            })
            return True
        else:
            self.checks.append({
                "name": "Disk Space",
                "status": "unhealthy",
                "details": f"Usage: {percent:.1f}% (Threshold: {threshold}%)"
            })
            return False

    def check_memory(self, threshold=90):
        """检查内存使用"""
        import psutil
        percent = psutil.virtual_memory().percent

        if percent < threshold:
            self.checks.append({
                "name": "Memory",
                "status": "healthy",
                "details": f"Usage: {percent:.1f}%"
            })
            return True
        else:
            self.checks.append({
                "name": "Memory",
                "status": "unhealthy",
                "details": f"Usage: {percent:.1f}% (Threshold: {threshold}%)"
            })
            return False

    def run_all_checks(self):
        """运行所有检查"""
        self.check_api_health()
        self.check_llm_gateway()
        self.check_sandbox()
        self.check_disk_space()
        self.check_memory()

        return self.checks

    def generate_report(self):
        """生成健康检查报告"""
        report = {
            "timestamp": datetime.now().isoformat(),
            "overall_status": "healthy",
            "checks": self.checks
        }

        # 确定整体状态
        for check in self.checks:
            if check['status'] == 'unhealthy':
                report['overall_status'] = 'unhealthy'
                break

        return report

    def print_report(self):
        """打印报告"""
        report = self.generate_report()

        print("=" * 50)
        print(f"Claude Code 健康检查报告")
        print(f"时间: {report['timestamp']}")
        print(f"整体状态: {report['overall_status'].upper()}")
        print("=" * 50)

        for check in report['checks']:
            status_icon = "✓" if check['status'] == 'healthy' else "✗"
            print(f"{status_icon} {check['name']}: {check['status']}")
            print(f"  详情: {check['details']}")
            print()

        return report['overall_status'] == 'healthy'

if __name__ == '__main__':
    checker = ClaudeCodeHealthChecker()
    checker.run_all_checks()
    is_healthy = checker.print_report()

    sys.exit(0 if is_healthy else 1)

## 34.3.7 灾难恢复

### 备份策略

#!/bin/bash
# backup.sh
set -e
BACKUP_DIR="/backup/claude-code"
DATE=$(date +%Y-%m-%d_%H-%M-%S)
BACKUP_PATH="$BACKUP_DIR/$DATE"
echo "=== Claude Code 备份脚本 - $DATE ==="
# 创建备份目录
mkdir -p $BACKUP_PATH
# 1. 备份配置文件
echo "备份配置文件..."
tar -czf $BACKUP_PATH/config.tar.gz /etc/claude-code
# 2. 备份数据库
echo "备份数据库..."
```

```
python

# health_check.py
import requests
import json
import sys
from datetime import datetime

class ClaudeCodeHealthChecker:
    def __init__(self, api_base_url='http://localhost:8080'):
        self.api_base_url = api_base_url
        self.checks = []

    def check_api_health(self):
        """检查 API 健康状态"""
        try:
            response = requests.get(f'{self.api_base_url}/health', timeout=5)
            if response.status_code == 200:
                data = response.json()
                self.checks.append({
                    "name": "API Health",
                    "status": "healthy",
                    "details": data
                })
                return True
            else:
                self.checks.append({
                    "name": "API Health",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "API Health",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_llm_gateway(self):
        """检查 LLM 网关"""
        try:
            response = requests.get('http://localhost:4000/health', timeout=5)
            if response.status_code == 200:
                self.checks.append({
                    "name": "LLM Gateway",
                    "status": "healthy",
                    "details": response.json()
                })
                return True
            else:
                self.checks.append({
                    "name": "LLM Gateway",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "LLM Gateway",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_sandbox(self):
        """检查沙箱状态"""
        try:
            response = requests.get(f'{self.api_base_url}/sandbox/status', timeout=5)
            if response.status_code == 200:
                data = response.json()
                self.checks.append({
                    "name": "Sandbox",
                    "status": "healthy",
                    "details": data
                })
                return True
            else:
                self.checks.append({
                    "name": "Sandbox",
                    "status": "unhealthy",
                    "details": f"Status code: {response.status_code}"
                })
                return False
        except Exception as e:
            self.checks.append({
                "name": "Sandbox",
                "status": "unhealthy",
                "details": str(e)
            })
            return False

    def check_disk_space(self, threshold=90):
        """检查磁盘空间"""
        import shutil
        usage = shutil.disk_usage('/')
        percent = (usage.used / usage.total) * 100

        if percent < threshold:
            self.checks.append({
                "name": "Disk Space",
                "status": "healthy",
                "details": f"Usage: {percent:.1f}%"
            })
            return True
        else:
            self.checks.append({
                "name": "Disk Space",
                "status": "unhealthy",
                "details": f"Usage: {percent:.1f}% (Threshold: {threshold}%)"
            })
            return False

    def check_memory(self, threshold=90):
        """检查内存使用"""
        import psutil
        percent = psutil.virtual_memory().percent

        if percent < threshold:
            self.checks.append({
                "name": "Memory",
                "status": "healthy",
                "details": f"Usage: {percent:.1f}%"
            })
            return True
        else:
            self.checks.append({
                "name": "Memory",
                "status": "unhealthy",
                "details": f"Usage: {percent:.1f}% (Threshold: {threshold}%)"
            })
            return False

    def run_all_checks(self):
        """运行所有检查"""
        self.check_api_health()
        self.check_llm_gateway()
        self.check_sandbox()
        self.check_disk_space()
        self.check_memory()

        return self.checks

    def generate_report(self):
        """生成健康检查报告"""
        report = {
            "timestamp": datetime.now().isoformat(),
            "overall_status": "healthy",
            "checks": self.checks
        }

        # 确定整体状态
        for check in self.checks:
            if check['status'] == 'unhealthy':
                report['overall_status'] = 'unhealthy'
                break

        return report

    def print_report(self):
        """打印报告"""
        report = self.generate_report()

        print("=" * 50)
        print(f"Claude Code 健康检查报告")
        print(f"时间: {report['timestamp']}")
        print(f"整体状态: {report['overall_status'].upper()}")
        print("=" * 50)

        for check in report['checks']:
            status_icon = "✓" if check['status'] == 'healthy' else "✗"
            print(f"{status_icon} {check['name']}: {check['status']}")
            print(f"  详情: {check['details']}")
            print()

        return report['overall_status'] == 'healthy'

if __name__ == '__main__':
    checker = ClaudeCodeHealthChecker()
    checker.run_all_checks()
    is_healthy = checker.print_report()

    sys.exit(0 if is_healthy else 1)

## 34.3.7 灾难恢复

### 备份策略

#!/bin/bash
# backup.sh
set -e
BACKUP_DIR="/backup/claude-code"
DATE=$(date +%Y-%m-%d_%H-%M-%S)
BACKUP_PATH="$BACKUP_DIR/$DATE"
echo "=== Claude Code 备份脚本 - $DATE ==="
# 创建备份目录
mkdir -p $BACKUP_PATH
# 1. 备份配置文件
echo "备份配置文件..."
tar -czf $BACKUP_PATH/config.tar.gz /etc/claude-code
# 2. 备份数据库
echo "备份数据库..."
```

### pg_dump -U claude claude_code > $BACKUP_PATH/database.sql

### 3. 备份日志

echo "备份日志..."
tar -czf $BACKUP_PATH/logs.tar.gz /var/log/claude-code

### 4. 备份用户数据

echo "备份用户数据..."
tar -czf $BACKUP_PATH/user-data.tar.gz /var/lib/claude-code

### 5. 生成备份清单

echo "生成备份清单..."
cat > $BACKUP_PATH/manifest.txt << EOF
备份清单
日期: $DATE
配置文件: config.tar.gz
数据库: database.sql
日志: logs.tar.gz
用户数据: user-data.tar.gz
文件大小:
$(du -sh $BACKUP_PATH/*)
EOF

### 6. 上传到远程存储（可选）

echo "上传到远程存储..."

### aws s3 cp $BACKUP_PATH s3://company-backups/claude-code/$DATE --recursive

### 7. 清理旧备份（保留最近 30 天）

echo "清理旧备份..."
find $BACKUP_DIR -type d -mtime +30 -exec rm -rf {} ;
echo "备份完成！备份位置: $BACKUP_PATH"

```
bash复制### 恢复脚本
```

```
### 恢复脚本
```

#!/bin/bash

### restore.sh

set -e

if [ -z "$1" ]; then
echo "用法: $0 <备份目录>"
exit 1
fi

BACKUP_PATH="$1"

echo "=== Claude Code 恢复脚本 ==="
echo "备份目录: $BACKUP_PATH"

### 1. 停止服务

echo "停止服务..."
systemctl stop claude-code

### 2. 恢复配置文件

echo "恢复配置文件..."
tar -xzf $BACKUP_PATH/config.tar.gz -C /

### 3. 恢复数据库

echo "恢复数据库..."

### psql -U claude -d claude_code < $BACKUP_PATH/database.sql

### 4. 恢复用户数据

echo "恢复用户数据..."
tar -xzf $BACKUP_PATH/user-data.tar.gz -C /

### 5. 启动服务

echo "启动服务..."
systemctl start claude-code

### 6. 验证恢复

echo "验证恢复..."
sleep 5
if systemctl is-active --quiet claude-code; then
echo "服务启动成功！"
else
echo "服务启动失败！"
exit 1
fi

echo "恢复完成！"

#### 34.3.8 性能优化#

##### 缓存策略#

### cache_manager.py

import redis
import json
from datetime import timedelta
class CacheManager:
def init(self, redis_host='localhost', redis_port=6379):
self.redis = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
def cache_api_response(self, key, response, ttl=3600):
"""缓存 API 响应"""
self.redis.setex(key, ttl, json.dumps(response))
def get_cached_response(self, key):
"""获取缓存的响应"""
cached = self.redis.get(key)
if cached:
return json.loads(cached)
return None
def cache_token_count(self, user_id, count, ttl=86400):
"""缓存令牌计数"""
key = f"tokens:{user_id}:{datetime.now().strftime('%Y-%m-%d')}"
self.redis.incrby(key, count)
self.redis.expire(key, ttl)
def get_token_count(self, user_id):
"""获取令牌计数"""
key = f"tokens:{user_id}:{datetime.now().strftime('%Y-%m-%d')}"
count = self.redis.get(key)
return int(count) if count else 0
def cache_model_response(self, model, prompt_hash, response, ttl=7200):
"""缓存模型响应"""
key = f"model:{model}:{prompt_hash}"
self.redis.setex(key, ttl, json.dumps(response))
def get_cached_model_response(self, model, prompt_hash):
"""获取缓存的模型响应"""
key = f"model:{model}:{prompt_hash}"
cached = self.redis.get(key)
if cached:
return json.loads(cached)
return None

### 使用示例

cache = CacheManager()

### 缓存 API 响应

cache.cache_api_response("api:user:123:profile", {"name": "John"}, ttl=3600)

### 获取缓存的响应

cached = cache.get_cached_response("api:user:123:profile")

```
bash复制### 负载均衡配置
```

```
### 负载均衡配置
```

### nginx.conf

upstream claude_code_backend {
least_conn;
server claude-code-1:8080 weight=3;
server claude-code-2:8080 weight=2;
server claude-code-3:8080 weight=1;

```
bash复制keepalive 32;
```

```
keepalive 32;
```

server {
listen 80;
server_name claude-code.company.com;

```
bash复制# 重定向到 HTTPS
return 301 https://$server_name$request_uri;
```

```
# 重定向到 HTTPS
return 301 https://$server_name$request_uri;
```

server {
listen 443 ssl http2;
server_name claude-code.company.com;

```
bash复制ssl_certificate /etc/nginx/ssl/claude-code.crt;
ssl_certificate_key /etc/nginx/ssl/claude-code.key;

# SSL 配置
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers HIGH:!aNULL:!MD5;
ssl_prefer_server_ciphers on;

# 日志
access_log /var/log/nginx/claude-code-access.log;
error_log /var/log/nginx/claude-code-error.log;

# 代理配置
location / {
    proxy_pass http://claude_code_backend;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # 超时配置
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;

    # 缓冲配置
    proxy_buffering on;
    proxy_buffer_size 4k;
    proxy_buffers 8 4k;
    proxy_busy_buffers_size 8k;

    # 健康检查
    health_check interval=10s fails=3 passes=2;
}

# 健康检查端点
location /health {
    proxy_pass http://claude_code_backend/health;
    access_log off;
}
```

```
ssl_certificate /etc/nginx/ssl/claude-code.crt;
ssl_certificate_key /etc/nginx/ssl/claude-code.key;

# SSL 配置
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers HIGH:!aNULL:!MD5;
ssl_prefer_server_ciphers on;

# 日志
access_log /var/log/nginx/claude-code-access.log;
error_log /var/log/nginx/claude-code-error.log;

# 代理配置
location / {
    proxy_pass http://claude_code_backend;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # 超时配置
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;

    # 缓冲配置
    proxy_buffering on;
    proxy_buffer_size 4k;
    proxy_buffers 8 4k;
    proxy_busy_buffers_size 8k;

    # 健康检查
    health_check interval=10s fails=3 passes=2;
}

# 健康检查端点
location /health {
    proxy_pass http://claude_code_backend/health;
    access_log off;
}
```

```
bash复制
## 34.3.9 小结

本节介绍了企业级监控和维护的各个方面，包括：

- 监控体系概述和监控维度
- 指标收集（Prometheus、自定义导出器）
- 告警配置（Prometheus、Alertmanager）
- 可视化仪表板（Grafana）
- 日志分析（ELK Stack）
- 维护策略（定期维护、健康检查）
- 灾难恢复（备份和恢复）
- 性能优化（缓存、负载均衡）

通过建立完善的监控和维护体系，企业可以确保 Claude Code 在生产环境中的稳定运行，及时发现和解决问题，优化性能和成本控制。
```

```
## 34.3.9 小结

本节介绍了企业级监控和维护的各个方面，包括：

- 监控体系概述和监控维度
- 指标收集（Prometheus、自定义导出器）
- 告警配置（Prometheus、Alertmanager）
- 可视化仪表板（Grafana）
- 日志分析（ELK Stack）
- 维护策略（定期维护、健康检查）
- 灾难恢复（备份和恢复）
- 性能优化（缓存、负载均衡）

通过建立完善的监控和维护体系，企业可以确保 Claude Code 在生产环境中的稳定运行，及时发现和解决问题，优化性能和成本控制。
```

---

